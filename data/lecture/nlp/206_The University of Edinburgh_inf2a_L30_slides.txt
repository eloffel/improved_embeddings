the id154: summary
turing machines
linear bounded automata
the limits of computability: church-turing thesis

turing machines and linear bounded automata

informatics 2a: lecture 30

john longley

school of informatics
university of edinburgh

jrl@inf.ed.ac.uk

24 november 2017

1 / 18

the id154: summary
turing machines
linear bounded automata
the limits of computability: church-turing thesis

the id154: summary

level
3

regular

context-free

language type

grammars
x      , x     y ,
x     ay
(regular)
x       
2
(context-free)
1 context-sensitive          
with |  |     |  |
(noncontracting)
         
(unrestricted)

recursively
enumerable

0

the material in red will be introduced today.

accepting machines

nfas (or dfas)

npdas

nondeterministic
linear bounded

automata

turing machines

2 / 18

the id154: summary
turing machines
linear bounded automata
the limits of computability: church-turing thesis

the length restriction in noncontracting grammars
what   s the e   ect of the restriction |  |     |  | in noncontracting
grammar rules?
idea: in a noncontracting derivation s                           s of a
nonempty string s, all the sentential forms are of length at most |s|.
this means that if l is context-sensitive, and we   re trying to decide
whether s     l, we only need to consider possible sentential forms
of length     |s| . . . and there are just    nitely many of these. so in
principle, we have the problem under control.

by contrast, without the length restriction, there   s no upper limit
on the length of intermediate forms that might appear in a
derivation of s. so if we   re searching for a derivation for s, how do
we know when to stop looking? intuitively, the problem here is wild
and out of control. (this will be made more precise next lecture.)

3 / 18

the id154: summary
turing machines
linear bounded automata
the limits of computability: church-turing thesis

alan turing (1912   1954)

4 / 18

the id154: summary
turing machines
linear bounded automata
the limits of computability: church-turing thesis

turing machines

recall that nfas are    essentially memoryless   , whilst npdas are
equipped with memory in the form of a stack.

to    nd the right kinds of machines for the top two chomsky
levels, we need to allow more general manipulation of memory.

a turing machine consists of a    nite-state control unit, equipped
with a memory tape, in   nite in both directions. each cell on the
tape contains a symbol drawn from a    nite alphabet   .

5 / 18

finitecontrol..........ab5$   3ca:read, write,move l/rthe id154: summary
turing machines
linear bounded automata
the limits of computability: church-turing thesis

turing machines, continued

at each step, the behaviour of the machine can depend on

the current state of the control unit,
the tape symbol at the current read position.
depending on these things, the machine may then

overwrite the current tape symbol with a new symbol,
shift the tape left or right by one cell,
jump to a new control state.

this happens repeatedly until (if ever) the control unit enters some
identi   ed    nal state.

6 / 18

finitecontrol..........ab5$   3ca:read, write,move l/rthe id154: summary
turing machines
linear bounded automata
the limits of computability: church-turing thesis

turing machines, formally

a turing machine t consists of:

a set q of control states
an initial state i     q
a    nal (accepting) state f     q
a    nite tape alphabet   
an input alphabet          
a blank symbol                  
a transition function    : q           q          {l, r}.

a nondeterministic turing machine replaces the transition function
   with a transition relation         (q      )    (q          {l, r}).

(numerous variant de   nitions of turing machine are possible. all
lead to notions of tm of equivalent power.)

7 / 18

the id154: summary
turing machines
linear bounded automata
the limits of computability: church-turing thesis

turing machines as acceptors

to use a turing machine t as an acceptor for a language over   ,
assume          , and set up the tape with the test string s          
written left-to-right starting at the read position, and with blank
symbols everywhere else.

then let the machine run (maybe overwriting s), and if it enters
the    nal state, declare that the original string s is accepted.
the language accepted by t (written l(t )) consists of all strings
s that are accepted in this way.
theorem: a set l           is generated by some unrestricted (type 0)
grammar if and only if l = l(t ) for some turing machine t .
so both type 0 grammars and turing machines lead to the same
class of recursively enumerable languages.

8 / 18

the id154: summary
turing machines
linear bounded automata
the limits of computability: church-turing thesis

questions

q1. which is the most powerful class of language acceptors (i.e.
provides acceptors for the widest class of languages)?

1 dfas

2 npdas

3 turing machines

4 your laptop (with suitable programming)

9 / 18

the id154: summary
turing machines
linear bounded automata
the limits of computability: church-turing thesis

questions

q1. which is the most powerful class of language acceptors (i.e.
provides acceptors for the widest class of languages)?

q2. which is the least powerful (i.e. provides acceptors for the
narrowest class of languages)?

1 dfas

2 npdas

3 turing machines

4 your laptop (with suitable programming)

9 / 18

the id154: summary
turing machines
linear bounded automata
the limits of computability: church-turing thesis

linear bounded automata

suppose we modify our model to allow just a    nite tape, initially
containing just the test string s with endmarkers on either side:

the machine therefore has just a    nite amount of memory,
determined by the length of the input string. we call this a linear
bounded automaton.

(lbas are sometimes de   ned as having tape length bounded by a
constant multiple of length of input. no essential di   erence.)

10 / 18

he manythe id154: summary
turing machines
linear bounded automata
the limits of computability: church-turing thesis

example: an lba for {anbnc n | n     1}

the tape alphabet for an lba, though    nite, might be considerably
bigger than the input alphabet. so we can store more information
on a tape than just an input string or related sentential form.
e.g. let    = {a, b, c, a, b, c}, and    = {a, b, c}. occurrences of
green letters can serve as markers for positions of interest.
to test whether an input string has the form anbnc n:

1 scan string to ensure it has form ak bmc n for k, m, n     1.

along the way, mark leftmost a, b, c. e.g. aaabbbccc.

2 scan string again to see if it   s the rightmost a, b, c that are marked.

if yes for all three, accept.
if yes for some but not all of a, b, c, reject.

3 scan string again moving the    markers    one position to the right.

e.g. aaabbbccc becomes aaabbbccc. then go to 2.

all this can be done by a (deterministic) lba.

11 / 18

the id154: summary
turing machines
linear bounded automata
the limits of computability: church-turing thesis

recommended exercise . . .

in a similar spirit, outline how the language
{ss | s     {a, b}   }

could be recognized by a deterministic lba.

12 / 18

the id154: summary
turing machines
linear bounded automata
the limits of computability: church-turing thesis

lbas and context-sensitive languages

theorem: a language l           is context-sensitive if and only if
l = l(t ) for some non-deterministic linear bounded automaton t .
rough idea: we can guess at a derivation for s. we can check each
step since each sentential form    ts onto the tape.

to implement this by an lba, expand the tape alphabet so that
the tape can simultaneously store:

the input string

two successive sentential forms in a derivation

a few    markers    used to check the validity of the derivation step.

the context-sensitive grammar rules themselves will be hardwired
into the design of the lba.

13 / 18

the id154: summary
turing machines
linear bounded automata
the limits of computability: church-turing thesis

a non-context-sensitive language

sentences of    rst-order predicate logic can be regarded as strings
over a certain alphabet, with symbols like    ,   , x, =, (, ) etc.
let p be the language consisting of all such sentences that are
provable using the rules of fopl. e.g. the sentence

(   x. a(x))     (   x. b(x))     (   x. a(x)     b(x))

is in p. but the sentence

(   x. a(x))     (   x. b(x))     (   x. a(x)     b(x))

is not in p, even though it   s syntactically well-formed.

theorem: p is recursively enumerable, but not context-sensitive.
intuition: to show s     p, we   d in e   ect have to construct a proof
of s. but in general, a proof of s might involve formulae much,
much longer than s itself, which wouldn   t    t on the lba tape.
put another way, mathematics itself is wild and out of control!

14 / 18

the id154: summary
turing machines
linear bounded automata
the limits of computability: church-turing thesis

determinism vs. non-determinism: a curiosity

at the bottom level of the id154, it makes no
di   erence: every nfa can be simulated by a dfa.

at the top level, the same happens. any nondeterministic
turing machine can be simulated by a deterministic one.

at the context-free level, there is a di   erence: we need
npdas to account for all context-free languages.
(reason: context-free languages aren   t closed under
complementation, see last lecture. however, if l is accepted
by a dpda then so is its complement.)

what about the context-sensitive level? are nlbas strictly
more powerful than dlbas? asked in 1964, and still open!!
can   t use the above argument here because csls are closed
under complementation (shown in 1988).

15 / 18

the id154: summary
turing machines
linear bounded automata
the limits of computability: church-turing thesis

detecting non-acceptance: lbas versus tms

suppose t is an lba. how might we detect that s is not in l(t )?
clearly, if there   s an accepting computation for s, there   s one that
doesn   t pass through exactly the same machine con   guration twice
(if it did, we could shorten it).

since the tape is    nite, the total number of machine con   gurations
is    nite (though ridiculously large). so in theory, if t runs for long
enough without reaching the    nal state, it will enter the same
con   guration twice, and we may as well abort.

note that on this view, repeated con   gurations would be spotted
not by t itself, but by    us looking on   , or perhaps by some
super-machine spying on t .

for turing machines with unlimited tape space, this reasoning
doesn   t work. is there some general way of spotting that a
computation isn   t going to terminate ?? see next lecture . . .

16 / 18

the id154: summary
turing machines
linear bounded automata
the limits of computability: church-turing thesis

wider signi   cance of turing machines

turing machines are important because (it   s generally believed
that) any symbolic computation that can be done by any
mechanical procedure or algorithm can in principle be done by a
turing machine. this is called the church-turing thesis.

e.g.:

any language l           that can be    recognized    by some
mechanical procedure can be recognized by a tm.
any mathematical function f : n     n that can be computed
by a mechanical procedure can be computed by a tm (e.g.
representing integers in binary, and requiring the tm to write
the result onto the tape.)

17 / 18

the id154: summary
turing machines
linear bounded automata
the limits of computability: church-turing thesis

status of church-turing thesis

the ct thesis is a somewhat informal statement insofar as the
general notion of a mechanical procedure isn   t formally de   ned
(although we have a pretty good idea of what we mean by it).

although a certain amount of philosophical hair-splitting is
possible, the broad idea behind ctt is generally accepted.

at any rate, anything that can be done on any present-day
computer (even disregarding time/memory limitations) can in
principle be done on a tm.

so if we buy into ctt, theorems about what tms can/can   t do
can be interpreted as fundamental statements about what
can/can   t be accomplished by mechanical computation in general.

we   ll see some examples of such theorems next time.

18 / 18

