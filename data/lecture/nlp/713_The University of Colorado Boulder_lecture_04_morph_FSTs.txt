finite state morphology and 

phonology

natural language processing

ling/csci 5832

mans hulden

dept. of linguistics

mans.hulden@colorado.edu

jan 22 2014

composition

in+possible+ity

0

d

 

s
 

a
 

2

5

1

u

 
i
 

e
 

u

 

3

6

<
+
:
0
>

 

e
 

m

 

t
 

1
0

4

7

n

 

<
n
:
m
>

 

i
 

o

 

2
2

<
+
:
0
>

 

1
1

8

<
+
:
0
>

 

<
+
:
0
>

 

2
3

9

1
2

s
 

u

 

l
 

s
 

u

 

l
 

p

 

p

 

2
7

3
3

2
4

1
3

t
 

i
 

o

 

r
 

2
8

2
5

1
7

1
4

r
 

g

 

k

 

s
 

e
 

2
9

2
6

1
8

1
5

a
 

e
 

s
 

t
 

3
0

3
4

1
9

1
6

n

 

i
 

l
 

t
 

2
0

3
5

3
1

b

 

g

 

2
1

l
 

y
 

3
2

e
 

3
6

a
 

n
 

i
 

3
7

4
0

e
 

4
1

3
8

t
 

l
 

s
 

4
2

c
 

3
9

y
 

s
 

4
3

impossibility

23

o 

r 

29

i 

t 

18

15

12

24

s 

e 

g 

k 

r 

19

16

13

25

s 

t 

e 

a 

20

17

30

10

+ 

s 
p 
u 

l 

14

11

27

b 

g 

22

26

i 

t 
l 

n 

21

31

l 

y 

28

e 

n 
a 

32

33

i 

e 

36

34

37

s 

l 

t 

35

c 

38

s 

y 

39

0

u i 

s 
a 

8

e 

u 

d 

2

5

3

6

+ 

n 

1

m 

t 

9

i 
o 

e 

4

7

in+possible+ity

@ + m p 

0

@ m p 

n 

<n:m> 

n 
+ 

@ + m 

n 

1

4

<n:m> 

<n:m> 

p 

2

+ 

3

im+possible+ity

@ + i l t y 

@ + e i l t y 

0

@ + e i t y 

b 

b 

1

@ e i l t y 

l 

b 

<l:i> 

@ + e l t y 

7

b 

2

e 

b 
<e:l> 

@ + e i l y 

8

b 

3

+ 

b 

9

i 

10

t 

<+:i> 

4

<i:t> 

5

<t:y> 

@ + e i l t 

<y:0> 

11

6

im+possibility

@ <+:0> 

0

impossibility

composition

neg+possible+ity+noun+plural

23

o 

r 

29

i 

t 

18

15

12

24

s 

e 

g 

k 

r 

19

16

13

25

s 

t 

e 

a 

20

17

30

10

+ 

s 
p 
u 

l 

14

11

27

b 

g 

22

26

i 

t 
l 

n 

21

31

l 

y 

28

e 

n 
a 

32

33

i 

e 

36

34

37

s 

l 

t 

35

c 

38

s 

y 

39

0

u i 

s 
a 

8

e 

u 

d 

2

5

3

6

+ 

n 

1

m 

t 

9

i 
o 

e 

4

7

in+possible+ity+s

@ + m p 

0

@ m p 

n 

<n:m> 

n 
+ 

@ + m 

n 

1

4

<n:m> 

<n:m> 

p 

2

+ 

3

im+possible+ity+s

@ + i l t y 

@ + e i l t y 

0

@ + e i t y 

b 

b 

1

@ e i l t y 

l 

b 

<l:i> 

@ + e l t y 

7

b 

2

e 

b 
<e:l> 

@ + e i l y 

8

b 

3

+ 

b 

9

i 

10

t 

<+:i> 

4

<i:t> 

5

<t:y> 

@ + e i l t 

<y:0> 

11

6

im+possibility+s

@ <+:0> 

0

impossibilities

neg+possible+ity+noun+plural

0

d

 

s
 

a
 

2

5

1

u

 
i
 

e
 

u

 

3

6

<
+
:
0
>

 

e
 

m

 

t
 

1
0

4

7

n

 

<
n
:
m
>

 

i
 

o

 

2
2

<
+
:
0
>

 

1
1

8

<
+
:
0
>

 

<
+
:
0
>

 

2
3

9

1
2

s
 

u

 

l
 

s
 

u

 

l
 

p

 

p

 

2
7

3
3

2
4

1
3

t
 

i
 

o

 

r
 

2
8

2
5

1
7

1
4

r
 

g

 

k

 

s
 

e
 

2
9

2
6

1
8

1
5

a
 

e
 

s
 

t
 

3
0

3
4

1
9

1
6

n

 

i
 

l
 

t
 

2
0

3
5

3
1

b
 

g
 

2
1

l
 

y
 

3
2

e
 

3
6

a
 

n
 

i
 

3
7

4
0

e
 

4
1

3
8

t
 

l
 

s
 

4
2

c
 

3
9

y

 

s
 

4
3

impossibility

compilers

several    nite-state compilers available to do the 
hard work 

 - xerox xfst (http://www.id122book.com)
 - sfst (https://code.google.com/p/cistern/wiki/
sfst)
 - hfst (http://hfst.sf.net)
 - openfst (http://www.openfst.org)
 - foma (http://foma.googlecode.com) 

demo with foma

toy grammar of english

toy lexicon: kiss, hire, spy
possible suf   xes: ed, ing, s 
generate kiss+s/kisses, spy+ed/spied, hire+ing/
hiring, hire+ed/hired, etc.

more advanced version of this in tutorial form on:

https://code.google.com/p/foma/wiki/

morphologicalanalysistutorial

some derivations

hire+ing

edelete

hir+ing

einsert

hir+ing

hire+ed

edelete

hir+ed

kiss+s

edelete

kiss+s

einsert

einsert

hir+ed

kisses

delete +

delete +

delete +

hiring

delete +

hired

kisses

code

analyzer1.foma

def stems      s p y | k i s s | h i r e ; 
def suf   xes   "+" [ 0 | s | e d | i n g ]; 

def lexicon   stems  suf   xes ; 

def yrule1       y -> i e || _ "+" s ;    # spy+s > spie+s 
def yrule2       y -> i || _ "+" e d ;    # spy+ed > spi+ed 
def einsert     "+" -> e || s _ s ;         #kiss+s > kisses 
def edelete      e -> 0 || _ "+" [e|i];  #hire+ed > hir+ed, hire+ing > hir+ing 
def cleanup     "+" -> 0 ;                      #hir+ing >hiring, etc. 

def grammar         lexicon .o. yrule1 .o. yrule2 .o. einsert .o. edelete .o. cleanup; 
regex grammar;

code

analyzer2.foma

def stems    s p y | k i s s | h i r e ; 
def suf   xes 0:"+" [ "[inf]":0 | "[noun][singular]":0 | "[pres]":s |  
                      "[noun][plural]":s | "[pastpart]":[e d] | "[prespart]":[i n g] ]; 

def lexicon     stems  suf   xes ; 

def yrule1      y -> i e || _ "+" s ; 
def yrule2      y -> i || _ "+" e d ; 
def einsert  "+" -> "+" e || s _ s ; 
def edelete       e -> 0 || _ "+" [e|i]; 
def cleanup     "+" -> 0; 

def grammar  lexicon .o. yrule1 .o. yrule2 .o. einsert .o. edelete .o. cleanup; 
regex grammar; 

the 2 second spell checker

neg+possible+ity+noun+plural

(1) extract the possible 
outputs of the 
   grammar    transducer, 
and convert to 
automaton (output-side 
projection)

(2) test a word against 
automaton

0

d

 

s
 

a
 

2

5

1

u

 
i
 

e
 

u

 

3

6

<
+
:
0
>

 

e
 

m

 

t
 

1
0

4

7

n

 

<
n
:
m
>

 

i
 

o

 

2
2

<
+
:
0
>

 

1
1

8

<
+
:
0
>

 

<
+
:
0
>

 

2
3

9

1
2

s
 

u

 

l
 

s
 

u

 

l
 

p

 

p

 

2
7

3
3

2
4

1
3

t
 

i
 

o

 

r
 

2
8

2
5

1
7

1
4

r
 

g

 

k

 

s
 

e
 

2
9

2
6

1
8

1
5

a
 

e
 

s
 

t
 

3
0

3
4

1
9

1
6

n

 

i
 

l
 

t
 

2
0

3
5

3
1

b
 

g
 

2
1

l
 

y
 

3
2

e
 

3
6

a
 

n
 

i
 

3
7

4
0

e
 

4
1

3
8

t
 

l
 

s
 

4
2

c
 

3
9

y

 

s
 

4
3

impossibility

the 5 second spelling corrector [med]

assume we have a list of words as a 
repeating fst as before

hired

w

hired

the 5 second spelling corrector

assume we have a list of words as a 
repeating fst as before

now, create a transducer c1 that makes one 
change in a word (one deletion, one change, 
one insertion)

abc

@ 

0

<?:0> <0:?> <?:?>

@ 

1

ab,bc,ac,aba,aac,abca,...

the 5 second spelling corrector

compose

hired

w

hired

c1

xire, hird, hird, hiredx, ired, hied,...

the 5 second spelling corrector

compose

hired

w o c1

xire, hird, hird, hiredx, ired, hied,...

code

analyzer3.foma

def stems    s p y | k i s s | h i r e ; 
def suf   xes 0:"+" [ "[inf]":0 | "[noun][singular]":0 | "[pres]":s | "[noun]
[plural]":s | "[pastpart]":[e d] | "[prespart]":[i n g] ]; 

def lexicon     stems suf   xes ; 

def yrule1      y -> i e || _ "+" s ; 
def yrule2      y -> i || _ "+" e d ; 
def epenthesis  "+" -> "+" e || s _ s ; 
def erule       e -> 0 || _ "+" [e|i]; 
def cleanup     "+" -> 0; 

def grammar  lexicon .o. yrule1 .o. yrule2 .o. epenthesis .o. erule .o. cleanup; 
def c1  ?* [?:0|0:?|?:?-?] ?* ; 

regex grammar.2 .o. c1;

entirely non-orthographic grammar

def stems    s p      | k    s | h      r ; 
def suf   xes 0:"+" [ "[inf]":0 | "[pres]":z | "[pastpart]":[d] | "[prespart]":[   
  ] ]; 

def sib [s|z];             # sibilants 
  
def unvoiced [h|s]; # unvoiced phonemes 

de   ne obsassimilation d -> t || unvoiced "+" _ ; 
de   ne epenthesis [..] ->    || sib "+" _ sib ; 
de   ne cleanup "+" -> 0; 

def lexicon     stems suf   xes ; 

def grammar     lexicon .o. obsassimilation .o. epenthesis .o. cleanup; 

regex grammar;

applications

id121
id52
id66 (chunking)
syntactic parsing
information extraction
text-to-speech
spell checking/correction
electronic dictionaries
machine translation
   

example: syntactic parsing

syntactic parsing

   generally consults a separate morphological analyzer

 

 

wrapup

    the above are standard techniques - morphological/
phonological grammars have been written for hundreds 
of languages in this way

    the calculus is crucial - thinking about states and 
transitions is counterproductive

    a well-designed grammar should be very accurate, 
barring misspellings (easily >99% recall)

    there are also probabilistic extensions to all of the 
above (to combine with language models, to handle 
noisy data, etc.)

    these grammars are also used to improve pos-
taggers, parsers, chunkers, id39, etc.

