1
1
0
2

 
t
c
o
4
1

 

 
 
]
s
d
.
s
c
[
 
 

1
v
5
2
2
3

.

0
1
1
1
:
v
i
x
r
a

mining patterns in networks using homomorphism   

anton dries   

siegfried nijssen   

abstract

in recent years many algorithms have been developed for    nding pat-
terns in graphs and networks. a disadvantage of these algorithms is that
they use subgraph isomorphism to determine the support of a graph pat-
tern; subgraph isomorphism is a well-known np complete problem.
in
this paper, we propose an alternative approach which mines tree patterns
in networks by using subgraph homomorphism. the advantage of homo-
morphism is that it can be computed in polynomial time, which allows us
to develop an algorithm that mines tree patterns in arbitrary graphs in
incremental polynomial time. homomorphism however entails two prob-
lems not found when using isomorphism: (1) two patterns of di   erent size
can be equivalent; (2) patterns of unbounded size can be frequent.
in
this paper we formalize these problems and study solutions that easily    t
within our algorithm.

1 introduction

frequent pattern mining is arguably one of the most popular problems in the
data mining literature. it involves enumerating all substructures satisfying a
frequency constraint in data. although initially studied on binary databases [1],
such as market basket data, the task has been extended to many other types of
data in recent years, including network and graph data [20, 13], motivated by
the availability of large amounts of network data. patterns were found to be
particularly useful in such structured data as they can be used to build classi   ers,
track changes in network structure or cluster data [3, 2].

a key choice that has to be made in pattern mining algorithms is the def-
inition of pattern support. whether operating on sets of graphs [20, 16] or
on networks [13, 2], the most common solutions in the literature are based on
the use of graph isomorphism. we will illustrate this on the following example
database.

   this work was partially supported by the ministry of science and innovation of spain
(micinn) under grant number tin2009-14560-c03-01 and by a postdoc and a project grant
from the research foundation   flanders, project    principles of patternset mining   .

   universitat pompeu fabra, barcelona, spain
   katholieke universiteit leuven, belgium

1

example 1. we assume given a database in which nodes correspond to authors,
papers and keywords of papers. directed edges indicate the authors and keywords
of a paper.

author

paper

data mining

databases

paper

data mining

author

arti   cial intelligence

paper

databases

in the traditional transactional setting, each connected component of the
graph above would be a di   erent transaction; assuming a minimum support
threshold of 2, the largest patterns found under subgraph isomorphism are:

    author     paper     data mining

    author     paper     databases

both graphs are subgraph isomorphic to two transactions in the data and are
hence frequent. when considering the graph as one large network, support
measures based on overlap can be used [13]. also in this case, however, these
would be the largest patterns that can be found.

one pattern that is not found using subgraph isomorphism is hence the

following:

author

paper

data mining

paper

databases

the reason is that the two paper nodes in the pattern may not be mapped to
the same node in the data at the same time, i.e. an isomorphism is an injective
mapping. consequently, the pattern that both authors have a paper in data
mining and in databases can not be found when using subgraph isomorphism.
the technique that we propose in this paper addresses this speci   c injectiv-
ity requirement in existing graph mining algorithms. the key idea is to develop
a pattern mining algorithm in which support is based on subgraph homomor-
phism, in which the mapping from a pattern to the data no longer needs to be
injective.

graph homomorphism is a well-studied topic in id207 [7]. it is closely
related to the way queries are usually evaluated in id208 and to
the   -subsumption procedure commonly used in inductive logic programming
[5].
indeed, the common use of homomorphisms in many areas in computer
science can be seen as evidence that the use of homomorphism is intuitive to
many people.

another reason for the popularity of homomorphism is the fact that homo-
morphisms can be calculated more e   ciently than isomorphisms. for instance,

2

homomorphisms of a rooted tree in a graph can be calculated in polynomial time,
while the corresponding problem for isomorphisms is np complete [7]. in par-
ticular when dealing with large data, this is a crucial advantage well-recognized
by the database community [6].

nevertheless, in pattern mining the setting has rarely been studied, despite
its potential computational advantages. there may be several reasons for this,
which we will discuss in more detail in section 2. essentially, most of these
problems are of a technical nature:

    trees of a di   erent size can be homomorphic with each other, making the

development of level-wise algorithms di   cult;

    in   nite numbers of patterns can be frequent when using homomorphisms

on cyclic data without further constraints;

indeed, the few existing pattern mining algorithms that support the graph ho-
momorphism setting, do not    nd all frequent patterns even if this number is
   nite [5], cannot be applied on networks, or are not known to achieve incremen-
tal polynomial time enumeration even if restricted to rooted trees [8, 9].

in this paper, we develop a new algorithm that overcomes these problems.
we will prove that this algorithm is able to    nd all frequent rooted trees under
homomorphism and that it    nds them in incremental polynomial time. novel
contributions of this paper are hence:

    we present the    rst algorithm that    nds frequent rooted trees under ho-
momorphism in incremental polynomial time, both in a transactional and
in a network setting;

    we present novel measures of support, allowing the discovery of patterns

in cyclic network data without transactions;

    we present the    rst algorithm for    nding closed and maximal patterns

under these settings;

    we present an extension of this algorithm which allows for pattern mining

under syntactical constraints.

syntactical constraints will turn out to be useful in an application of our algo-
rithm on bibliographic data.

the remainder of the paper is organized as follows. in section 2 we will in-
troduce the basic graph principles that we need in this paper and provide more
details on the technical challenges of pattern mining under homomorphism. in
section 3 we will introduce our algorithm for enumerating trees under homo-
morphism, as well as the basic algorithm for evaluating support. in section 4
we introduce constraints that aim at avoiding unbounded patterns. section 5
discusses the extension towards closed and maximal pattern mining. section 7
discusses important related work in detail. section 8 provides experiments while
section 9 concludes.

3

2 preliminaries

2.1 graphs, trees and homomorphisms

a labeled directed graph g = (vg, eg,   g) (or graph for short in this paper)
consists of a set of nodes vg, a set of edges eg     vg    vg and a labeling
function   g : vg     eg        that maps each node or edge of the graph to an
element of the alphabet   . by gd
   we denote the set of all graphs over the
alphabet   . in case the graph is unlabeled, we drop   g.

a graph g1 is subgraph homomorphic with another graph g2, denoted by
g2 (cid:23) g1, if there exists a function    from nodes in vg1 to nodes in vg2, such
that:

       v     vg1 :   g1 (v) =   g2 (  (v));

       (v1, v2)     eg1 : (  (v1),   (v2))     eg2;

       (v1, v2)     eg1 :   g1 ((v1, v2)) =   g2 ((  (v1),   (v2))).

we also denote this as g2 (cid:23)   g1, for a given    that is a homomorphism. a
graph g1 is subgraph isomorphic with another graph g2, denoted by g2 (cid:23)i
   g1,
if g2 (cid:23)   g1, and    is injective, i.e., if v1 6= v2, then   (v1) 6=   (v2).

given two graphs g1 and g2, if g1 (cid:23) g2 and g2 (cid:23) g1, we denote this
by g1     g2; similarly we also de   ne g1    i g2. the equivalence class under
homomorphism of a graph is de   ned as follows:

[g] = {g        gd

   | g        g}.

a labeled rooted unordered tree t = (vt , et ,   t ) is a graph which ful   lls

the additional requirement that there is exactly one node v     vt such that:

    there is no edge (v   , v)     et ;

    for all other nodes v        vt there is exactly one node v           vt such that

(v      , v   )     et .

node v is called the root of the tree; node v       is the parent of node v    while node
v    is a child of node v      . subgraph isomorphism and homomorphism carry over
from graphs.

without loss of generality, we will assume from now on that node vt

0 is the
root of a tree. a root preserving subtree homomorphism of tree t1 into t2 is
a subtree homomorphism in which   (vt1
0 ; it is denoted by t2 (cid:23)r t1.
similarly, a root preserving isomorphism is denoted by t2 (cid:23)r,i t1. we say that
t2 is a specialization of t1, while t1 is a generalization of t2, if t2 (cid:23)r t1.

0 ) = vt2

for a given (in   nite) set of nodes v = {v0, v1, . . .} and a    nite set of labels
v,   the set of all (   nite) rooted unordered trees over these

   we denote by gt
nodes and labels.

4

2.2 di   erences between homomorphism and isomorphism

graph isomorphism and homomorphism behave di   erently. these di   erences
lead to two important problems.

problem 1. an in   nite number of graphs, each pair of which is not isomorphic,
can all be homomorphic with each other.

consider for instance this in   nite set of directed graphs:

v

v

{

v ,

v

v

,

v

v

v

v ,

. . . }

each trees in this set is homomorphic to all other trees and hence conveys
the same information. finding one of these trees is su   cient. the conse-
quence is that we cannot straightforwardly reuse the enumeration process of
an isomorphism-based graph mining algorithm: an existing graph mining algo-
rithm would try to enumerate all these patterns and produces redundant results.

problem 2. an in   nite number of graphs, each pair of which is not homomor-
phic with each other, can be subgraph homomorphic with a    nite graph.

as an example consider this in   nite set of graphs:

v

{ v ,

v ,

v

v

v

,

. . . },

then each of these graphs is subgraph homomorphic with this graph:

v

v

the cause of this problem is the presence of a cycle in the data. if the data is
not cyclic, this problem does not occur.

these problems motivate our problem de   nition in the next section.

2.3 high-level problem description

in this section we will introduce the basic problem of frequent rooted tree min-
ing under homomorphism; in a later section we will de   ne extended problem
settings, such as closed and maximal pattern mining. let us de   ne the support
of a tree t in a graph g as follows.

de   nition 1 (image). given a tree t and a graph g, the image of a node
v     vt is:

img t    g(v) = {v        vg |       :   (v) = v   , g (cid:23)   t }

de   nition 2 (support). the support of a tree can now be de   ned as the size
of the image set of the root:

freq(t, g) = (cid:12)(cid:12)img t    g(vt

0 )(cid:12)(cid:12) .

5

using this support we can de   ne a support constraint:

  (t, g) = (freq(t, g)       )

for some threshold   .

note that this de   nition assumes that the data is one large network. it can

easily be modi   ed to a transactional setting.

intuitively one could now be interested in    nding the set of frequent trees

f = {t     gt

   |   (t, g) is true }.

note that this support de   nition is anti-monotonic under root-preserving
subtree homomorphism, i.e. if t1 (cid:23)r t2 and   (t1, g) is true, then also   (t2, g)
is true. furthermore, any pattern that would be frequent when using isomor-
phism would also be frequent when using homomorphism.

due to problem 1 the set f is in   nite. hence, we need to re   ne this problem
statement. essentially, we wish to    nd only one representative for each equiva-
lence class of trees. let us assume we have a function r(t ) that computes one
representative for a set of equivalent trees [t ], i.e. for all t         [t ]: r(t    ) = r(t ).
then we de   ne a reduced space of trees

r(gt

   ) = {r(t ) | t     gt
   }

and look for subtrees in

f = {t     r(gt

   ) | freq(t, g)       }.

in section 3 we propose to use core trees as representatives, and we show how
to enumerate such core trees.

due to problem 1 even the reduced space of trees can contain an in   nite
number of frequent patterns. to avoid this problem, we propose to impose
additional constraints that patterns need to ful   ll in order to be part of the result
set. these constraints have to ful   ll the following property and are introduced
in detail in section 4.

de   nition 3 (finiteness). an anti-monotonic constraint    ensures    niteness
i    for any graph g there is a maximum on the size of the tree t for which
  (t, g) is true.

we are initially only interested in    nding core patterns under an anti-

monotonic constraint that ensures    niteness.

3 enumerating patterns

3.1 re   ned problem de   nition

essentially, we propose to enumerate core trees as representative patterns. a
tree is a core if no subtree can be identi   ed that is equivalent with it.

6

de   nition 4 (core tree). a tree t is a core i    there is no tree t     with: (1)
t (cid:23)i t    ; (2) t 6   i t    ; (3) t     t    .

of the below two trees, tree t1 is a core; tree t2 is not a core, as it contains

the equivalent tree t1 (labels are indicated in black, node identi   ers in gray).

a v1

b v2

c v3

d v4

t1

a v1

b v2

b v5

c v3

d v4

t2

we will restrict our enumeration to core trees as much as possible. if a tree is
not core, we will say that it is reducible to a core tree.

for any given tree t = (v, e,   ) and given node v     v , we will denote by
subtree(v, t ) the complete subtree below v in t , i.e. the tree consisting of all
nodes that are a descendant of v in t and all edges connecting these nodes, as
well as the path leading from the root of t to node v.

in our example, subtree(v2, t2) = t1.
an interesting feature of core trees is the following.

lemma 1. a tree t is a core i    for every pair of siblings v1 and v2 in t ,
neither subtree(v1, t ) (cid:23)i subtree(v2, t ) nor subtree(v2, t ) (cid:23)i subtree(v1, t ). if
two trees are a core t1     t2 implies t1    i t2.

proof. first we prove that if a tree is a core, then for every pair of siblings
v1 and v2 in t , neither subtree(v1, t ) (cid:23)i subtree(v2, t ) nor subtree(v2, t ) (cid:23)i
subtree(v1, t ).

assume that we would have subtree(v1, t ) (cid:23)i subtree(v2, t ). then consider
the tree t     without subtree(v2, t ) (except for the path to node v2). clearly
we would have t (cid:23)r t    ; however also t     (cid:23)r t is the case, as the nodes in
subtree(v2, t ) in t could be mapped to the nodes in subtree(v1, t    ). as we
have identi   ed a tree for which t (cid:23)r t    , the assumption that subtree(v1, t ) (cid:23)i
subtree(v2, t ) was incorrect.

the other way around, if the tree is not a core, we can assume equivalence
with a root-preserving subgraph isomorphic subtree t    . the only possibility for
such equivalence with a smaller tree is that we map at least two sibling nodes of
t to the same node v    in tree t    . as the subtree subtree(v   , t    ) is also a subtree
of t , this must mean that the subtree subtree(v1, t ) for one node v1 of t is
mapped into a subtree subtree(v2, t ) for some node v2     vt .

note that as we only enumerate core trees, certain tree structures will
not be found under homomorphism-based mining that could be found using
isomorphism-based algorithms. according to this lemma, the patterns that will
not be found in our algorithm will always contain a subtree that is subgraph
isomorphic to another subtree within the pattern. indeed, when using subgraph
isomorphism in practice [2] one often    nds patterns that indirectly encode degree
constraints. such patterns are avoided by using homomorphisms.

when enumerating trees in today   s sequential computers, we need to develop
a representation of trees in which the nodes are ordered. the second problem

7

that we need to deal with is that di   erent ordered trees can represent the same
unordered tree. here we reuse ideas from earlier tree mining algorithms [16, 4].
for simplicity, we assume that a tree is ordered if the nodes are numbered

as v1, . . . , vn in a depth-   rst order. the following are two ordered trees:

t1 = ({v1, v2, v3, v4}, {(v1, v2), (v2, v3), (v1, v4)})

and

t2 = ({v1, v2, v3, v4}, {(v1, v2), (v1, v3), (v3, v4)}).

these trees are equivalent to each other under isomorphism, but represent dif-
ferent orders in which the children of v1 are enumerated. the right-most path
of an ordered tree is the path from the root to the last node in the tree.

to ensure that only one of these two orders is enumerated, we will use a
canonical code. canonical codes are common in graph and tree mining; here we
will use the canonical code of [16], which works as follows.

the code of an ordered tree is computed by traversing the tree in depth-   rst
order, and printing for every node its depth and its label. for our example trees
we obtain the following codes:

   (t1) = 0a1a2a1a and    (t2) = 0a1a1a2a.

among all codes that can be obtained for a tree, the canonical code is the
one which is lexicographically the highest1. in our example, as    (t1)        (t2),
where     denotes lexicographical comparison,    (t1) is canonical;    (t2) is not. a
characteristic of this canonical code is that trees look    left-heavy   : if there were
no labels, the longest path would always be the left-most path in the tree.

the re   ned enumeration problem is now the following.

de   nition 5 (enumeration under homomorphism). given a constraint    that
ensures    niteness,    nd the set:

{t     gt

   |   (t, g) is true, t is canonical and a core}.

3.2 algorithm

in our algorithm we exploit several properties of the above canonical code. we
repeat these properties here; proofs for the    rst three claims can be found in
[14, 15].

property 1. every pre   x of a canonical code representation of a tree also is
the canonical representation of the corresponding tree.

for instance, the pre   xes 0a, 0a1a, 0a1a2a of    (t1) = 0a1a2a1a are also

canonical codes.

property 2. a tree t is canonical i    for any pair of siblings vi and vj (i < j):
   (subtree(vi, t ))        (subtree(vj, t )).

1here some order on the labels is assumed

8

0a

1a

2a

2b

2a

1a

2a

2a

1a

2a

2b

2a

1a

2a

2a

2b

2a

tree code

1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
...

1a

2a

1a

0a
0a 1a
0a 1a 1a
0a 1a 2a
0a 1a 2a 1a
0a 1a 2a 1a 2a
0a 1a 2a 2a
0a 1a 2a 2a 1a
0a 1a 2a 2a 1a 2a
0a 1a 2a 2a 1a 2a 2a
0a 1a 2b
0a 1a 2b 1a
0a 1a 2b 1a 2a
0a 1a 2b 1a 2b
0a 1a 2b 2a
0a 1a 2b 2a 1a
0a 1a 2b 2a 1a 2a
0a 1a 2b 2a 1a 2a 2a
0a 1a 2b 2a 1a 2b
0a 1a 2b 2a 1a 2b 2a
...

figure 1: the    rst 20 canonical codes for trees upto depth 2, degree 2, and
labels {a,b} (left); a visualization of the trie data structure storing these trees,
not taking into account homomorphism (right); nodes that are stored also under
homomorphism are underlined.

property 3. if t1 (cid:23)r,i t2, then    (t1)        (t2).

this property is especially important, as it states that for any tree t1 all
subtrees must have been enumerated before this tree, including the core trees
when using homomorphism, if we enumerate the patterns in the order of their
codes.

we enumerate trees depth-   rst, from smallest to largest according to the
lexicographical order of canonical codes, by using algorithm 1 based on the
algorithm of [15]. this algorithm was developed for enumerating trees under
an isomorphism relationship. ignoring the problem of homomorphisms for the
moment, the    rst trees enumerated up to depth 2, degree 2 and for labels {a,b}
are given in figure 1. trees are grown by extending the codes of trees, where
the essential observation is that in a canonical code we can only add edges to
the rightmost path of a tree.

to calculate whether a given new code is canonical [14, 15] proposed an o(1)

algorithm which we do not elaborate on here as we will not use it later on.

an important observation when applying this algorithm in a homomorphism
context is that it is sometimes necessary to enumerate trees which are reducible

9

algorithm 1 tree enumeration(code)
if code is not canonical or does not satisfy constraint    then

return

output code
let d   be the last (depth,label) pair in code
for i := 1 to d do

for           in increasing order do
tree enumeration(code   i      )

in order to reach a tree which is a core. an example is tree number 12, which
is not a core, but needed to reach tree 13 in figure 1.

the issue that we need to address is how to avoid as much as possible
that algorithm 1 enumerates trees that are reducible to a core tree, but that
are considered in the hope of reaching a tree which is a core and satis   es the
constraints later on. in the following we will show such a method for which we
can prove a good theoretical performance.

the    rst idea is to exploit the fact that certain trees can never be extended

into a core tree.

property 4 (unavoidably reducible). given a canonical tree t , if we can
identify two siblings v1 and v2 such that subtree(v1, t )    r subtree(v2, t ), while
both v1 and v2 are not on the right-most path of the tree, then no canonical code
   (t    ) which has    (t ) as a pre   x is a core.

proof. this follows from the fact that we grow trees by connecting nodes to the
right-most path and from lemma 1.

the second idea is that we store all tree-patterns that are found in the
enumeration in a trie data structure (see figure 1); each node in this data
structure corresponds to a tree pattern represented by its canonical code. the
children of a node in the data structure essentially represent those trees that
are canonical children in the enumeration tree.

when dealing with homomorphism, we will maintain this data structure such
that any given node is only stored if one of its descendants is a core tree. in our
example, tree number 7 is for instance not stored, as none of its descendants is
a core tree.

we use this data structure to guide the traversal of the search space. while
growing trees in algorithm 1, we traverse the already constructed part of the
trie to eliminate extensions that are not known to lead to trees that are frequent
or a core; essentially, hence, we here exploit the fact that frequency is an anti-
monotonic property.

we perform this traversal of the trie as follows. the node on the right-
most path of the pattern with the lowest level and more than one child will
be referred to as the split node. if we now remove the    rst subtree below this
node, we obtain an ordered tree which is also a canonical tree (by application

10

a

a*

a

c

b

b

a

a

c

0a 1a 2b 3a 2a 3c 3b 2a 3c

figure 2: example of a canonical tree pattern, its rightmost path (bold) and its
split node (*)

of property 2), and which    if it is satis   es the anti-monotonic constraint    we
must have entered in the trie earlier according to property 3.

this is illustrated in figure 2. if we remove the nodes which are marked
in gray, we obtain a code which is also canonical. we can search for this code
in the data structure; only the children of this code in the data structure are
promising extensions of the current code.

a special case is a pattern in which we cannot identify a split node, as it is
consists of one path. in this case we treat every node on the path iteratively as
a split node, starting from the shallowest node.

note that due to the order in which we are enumerating trees, and the fact
that we only allow extensions which are part of the data structure, we do not
need to perform explicit checks whether a code is canonical.

this leads us to the algorithm given in algorithm 2. this algorithm is called
in principle for each          , where    is the set of labels occurring in the data,
in increasing order.

in this algorithm we need to calculate whether a tree is a core, and whether
reducibility is avoidable. in principle, we could determine this for each pattern
tree from scratch using a polynomial algorithm. however, by reusing infor-
mation we can do this more e   ciently; we calculate incrementally whether a
pattern tree is a core and whether a pattern tree is unavoidably reducible.

first, we observe that a path-like tree is always a core; we only need to
consider trees which have a split node. if we remove the left-most subtree of the
split node, we obtain a tree which was stored earlier in the trie data structure,
and for which we have already stored whether it is a core; if this earlier tree was
not a core, the current tree, which includes this tree, is not a core either. if the
earlier stored tree was a core, reducibility can only be caused by the presence
of the left-most subtree, where there are two possible reasons:

    the left-most subtree is not a core itself;

    one of the other subtrees of the split-node is a subtree of the left-most

subtree (lemma 1).

11

algorithm 2 tree enumeration(code)
if code does not satisfy constraint    or
code is unavoidably reducible then

return

if code is a core then

insert code into trie data structure
output pattern

if code represents a path then

split nodes     { all nodes on the path }

else

split nodes     { node on right-most path

with lowest depth and more than one child }

for all split nodes in increasing depth do

let code    be the code of the tree obtained when removing

the left-most subtree of split node

for all children (d  ) of code    in trie data structure do

tree enumeration(code   d      )

if code represents a path then

let d be the depth of the deepest node +1
for           in increasing order do
tree enumeration(code   d      )

we can also exclude many of these possibilities, as we ensure during the enu-
meration process that only trees with avoidable reducibility are considered (note
that we check reducibility only after we have checked unavoidable reducibility).
if any subtree which is not the right-most subtree of the split node could be
mapped to the left-most subtree, or the left-most subtree would not be a core,
the tree would be unavoidably reducible, and the tree would have been pruned
earlier.

hence, we only need to check whether the right-most subtree of the split node
can be mapped to the left-most subtree. to calculate this e   ciently we use an
incremental algorithm similar to the algorithm used to evaluate the support of
a tree pattern. this algorithm is discussed in section 3.4.

similarly, we can also calculate incrementally whether reducibility is avoid-
able. first, we observe that we can assume that the parent pattern in the
enumeration is already avoidably reducible. whether this is still the case for
the current pattern is easily determined:

    if the new node was inserted above the split node of the parent tree, or
was connected to the split node, and this parent tree was not a core, this
creates an unavoidable reducibility;

    if the new node was inserted below the split node, any unavoidable re-
ducibility would have to be below this split node. the subtree below this

12

split node corresponds to a tree that has been stored earlier, however, and
we can assume that no tree with unavoidable reducibility is stored.

3.3 complexity analysis

we provide an analysis of the complexity of the above algorithm here, assum-
ing that both the support constraint and the reducibility of a pattern can be
evaluated in polynomial time (we will see in the next section that this is the
case).

given that the potential number of patterns is exponential, our analysis is
based on the amount of computation needed per pattern enumerated. we show
that the algorithm achieves incremental polynomial time complexity.

de   nition 6 (incremental polynomial time [12]). an algorithm to enumerate
items a1, a2, . . . , ap runs in incremental polynomial time if

    it iterates the following procedure for i = 1, 2, . . . , p: output the ith item
ai from the knowledge of its input and items a1, a2, . . . , ai   1 generated so
far;

    the time required for the ith iteration is polynomial in the input length and

the sizes of a1, a2, . . ., ai   1.

the main argument is that our algorithm only considers extensions of a path
that can be obtained by copying earlier trees below the path. hence, to reach a
next pattern, a number of possibilities bounded by the number of trees stored
is considered, which in its turn is polynomial in the number of patterns listed
earlier.

more formally, given a certain (core) pattern tree, the next (core) pattern
tree satisfying the given constraint   (t, g) can be of two kinds. (1) the next
pattern tree is a descendant of the current pattern in the enumeration tree.
descendants can be reached in two ways: by adding trees found earlier (and
stored in the trie) to the right-most path, or by adding nodes below the left-
most node in case the tree only has one path. in the    rst case the number of
trees that can be added to the right-most path is bounded by the number of
trees found earlier; in the second case, the number of labels we can add below
the path is bounded by the number of labels in the data. overall, the number of
attempted re   nements before a frequent re   nement is reached is hence bounded
polynomially. (2) the next pattern tree is a descendant of an ancestor of the
current pattern. the number of such ancestors is bounded by the number of
nodes in the pattern. for each such ancestor, we can apply the argument above.
please note that a more desirable time complexity would be polynomial
delay,
in which case the time needed to enumerate the next pattern would
be bounded by a polynomial that is independent of the number of patterns
enumerated till that moment. it is still an open question whether enumeration
with this type of complexity can be achieved.

13

3.4 evaluating support

e   ciently evaluating support is critical for pattern mining algorithms; indeed
an important motivation for our work is that we can evaluate support e   ciently
for the case of homomorphism. in this section we show how we can evaluate the
support of a pattern.

in principle we could evaluate the support of a rooted tree from scratch
by means of known algorithms for graph homomorphism [6], or by means of
sql database queries [9]. however, a more e   cient approach is obtained by
evaluating support incrementally. the main idea is that for every node v on the
right-most path, we maintain its image img t    g(v) in the data. if we extend
a pattern by adding a node to the right-most path (yielding a pattern t    ), the
image of each node on the right-most path of t     is obtained as follows:

    the image for the new node vnew with label    is created by traversing the
image of its parent vparent ; for each v        img t    g(vparent ) those nodes v      
with (v   , v      )     eg and   g(v      ) =    are inserted into img t       g(vnew ).

    the image of the other nodes is update sequentially in a bottom-up fashion,
starting from the node vparent . essentially, any node in img t    g(vparent )
which is not connected (in g) to at least one node in img t       g(vnew ) is
removed.

the size of the image of the root, |img t       g(v0)|, corresponds to the support of
the new pattern.

note that each image list is no larger than the number of nodes in the data;
updating each list proceeds in polynomial time. overall, this provides us with
polynomial time support evaluation.

4 constraints for cyclic data

the above algorithm can safely be applied to graphs which are directed and
acyclic; in this case our algorithm is the    rst algorithm for enumerating rooted
trees in incremental polynomial time. however, when applied to cyclic graphs,
such as most information networks, we are faced with problem 2. in this section
we will introduce a general class of path-based constraints that can be used
in addition to support constraints to avoid this problem, while being easy to
evaluate in our algorithm.

de   nition 7. a constraint   (t, g) is path-based if it can be expressed as a
constraint over all root-paths in the tree:

  (t, g) = ^

v   vt

     (path(v, t ), g),

where path(v, t ) denotes the tree which consists only of the path leading from the
root of t to the node v, and       is a path constraint that can only be evaluated
on path patterns.

14

if a path constraint ensures    niteness of paths (see de   nition 3), the above

path-based constraint ensures    niteness of trees.

note that a path-based constraint is anti-monotonic: any supertree of a tree

which does not satisfy a path-based constraint will not satisfy it either.

a path-based constraint is easily integrated in our algorithm: essentially,
when we are growing paths, we need to check whether the paths satisfy the path
constraint. other paths are only added in a tree if they have been enumerated
earlier, and hence have been found to satisfy the path constraint earlier. hence,
as soon as a pattern has a split node, checking the path-based constraint is no
longer needed.

below we provide an overview of possible path constraints on which tree

constraints can be based.

depth constraint the depth constraint is de   ned by:

where n is the number of nodes in path p .

     (p, g)     n       ,

additional cover constraint this constraint determines if the last node
of the path adds information with respect to the union of earlier nodes in the
path:

     (p, g)        

   img p    g(vn) 6    [

0   i<n

img p    g(vi)   
    ,

where vp = {v0, . . . , vn}.

intuitively, this constraint avoids that many nodes of a pattern are mapped
to the same set of nodes in the data. this is the default constraint that we will
be using in our experiments.

label constraint the label constraint states that no two nodes on a path
may have the same label:

   v, v        vp : v 6= v    =      p (v) 6=   p (v   ).

note that this constraint is su   cient to    nd the patterns in the introduction
(section 1). even if this constraint is applied, subgraph isomorphism remains
np-complete, and hence the use of homomorphism is bene   cial. we can prove
this by showing that we can reduce the np-complete independent set problem
to a problem of subgraph isomorphism under the label constraint.

de   nition 8. (independent sets) given a graph g = (v, e) an independent
set is a subset of nodes v         v such that for no v1, v2     v    : (v1, v2)     e. the
problem of    nding a k-independent set is the problem of    nding an independent
set of size k.

the independent set problem is a well-known np complete problem.

15

theorem 1. subgraph isomorphism under the label constraint is np complete.

proof. we can encode the independent set problem in terms of the subgraph
isomorphism problem as follows. the data graph is a directed acyclic graph d
of three levels. the levels are the following:

    level 1 in d contains one node (the root), having label    r   ;

    level 2 in d contains one node for each node in the graph g, each node

being connected to the root; these nodes are labeled with label    n   

    level 3 in d contains nodes labeled with label    n2   , in the following con-

   guration:

    one node for each node in the graph g; each such node is connected
to all nodes in level 2 to which it is connected in g, as well as the node
itself; the idea is that these are the nodes that would be covered if
the node in the original node is selected, which includes all neighbors
and the node itself;

    let m be the maximum degree of the nodes in g. for each node with
degree d < m, m     d additional nodes are added in level 3, which are
only connected to the corresponding node in level 2.

the query graph consists of three levels as well:

    level 1 with one root with label    r   ;

    level 2 with k nodes labeled with label    n   , each connected to the root;

    level 3 with km nodes labeled with label    n2   , such that each node in

level 2 has m children.

this transformation is clearly polynomial; furthermore, on each path in the
query tree all labels are unique.

if we    nd a subgraph isomorphism for this query graph in the data graph,
we have selected k nodes in level 2 of the data graph, such that no two nodes
in level 3 of the query graph are mapped to the same node in the data graph;
this is only possible if we selected nodes that do not share an edge, and hence
we have solved the independent set problem.

5 maximality

as most other frequent pattern mining algorithms, the above algorithm may
generate many frequent patterns. one means to reduce the number of patterns
is by restricting the output to patterns that are either maximal or closed. a
maximal frequent pattern is a pattern for which no specialization satis   es the
given constraints; a closed frequent pattern is a pattern for which no specializa-
tion has the same support.

16

we can    lter the output of the above algorithm to obtain such patterns.
compared to tree mining algorithms in the literature [4], a complicating issue
is that we can also specialize by merging nodes in a tree:

a

a

b

a

c

a

a

b

c

=   

note that merging does not a   ect the set of paths present in the tree, and hence
can never in   uence the evaluation of a path-based constraint.

we now discuss how we    nd maximal patterns by post-processing the set of
patterns found above; subsequently, we discuss how to make the search more
e   cient by using additional pruning criteria.

5.1 post-processing

to obtain a set of maximal patterns in a na    ve way, we do the following in
post-processing:

    for every pattern, we determine which generalizations can be obtained by

removing a leaf; we mark such generalizations as not maximal;

    for every pattern, we determine which specializations can be obtained
by considering a merge of every pair of siblings. merging proceeds as
follows: (1) two siblings are replaced by one node, below which we copy
the subtrees of the two original trees; (2) we reduce a tree to its core to
remove redundant subtrees; (3) we compute its canonical form; (4) if the
resulting code is a frequent pattern, the pattern is marked as non-maximal.

the reason for merging is that generating specializations by splitting a tree
is a more costly procedure, as there are many possible ways to split a certain
node in a tree.

5.2 pruning during the search

several optimizations can be applied to avoid the enumeration of patterns during
the search that cannot be maximal.

the main idea is illustrated by the following example. assume we are enu-
merating the following tree t , where we have added superscripts to give di   erent
names to nodes labeled with a:

a0

a1

b

a2

a3

then we can prune this tree in the following cases.

17

test 1 let t     be the last ancestor in the enumeration of t in which node a1
was on the right-most path, i.e. the trees with a2 and a3 missing. then we
can assume that we still know the image of a1 of this earlier pattern due to the
depth-   rst enumeration. we prune the pattern t if:

img t    g(a2)     img t       g(a1)

the reason is that any subtree that is inserted below node a2 (yielding a tree
t       ), can additionally be attached below node a1; any such pattern will be more
speci   c and can not have a support lower than t       .

test 2 similarly, we can also prune if

img t    g(a2)     img t       g(a1);

however in this case an additional condition is required; after all, adding nodes
below a2 may remove some of the images of a2, yielding situations in which
a2   s image is no longer a superset of a1   s. the solution to this is to apply such
pruning only once a new node is connected to a0; due to our enumeration process
we know at this point that the tree below a2 will not grow any more.

in general we can describe these tests formally as follows. assume given a
pattern tree t . let v = {v0, . . . , vn} be its set of nodes, in the order of the
canonical form. furthermore, let rt (i) be the index of node at depth i on
the rightmost path of t . let t [i] denote the tree which contains only nodes
{v0, . . . , vi} of tree t , i.e. t [i] is an ancestor of t in the search space, which is
also canonical due to our de   nition of the canonical form.

then, according to test 1, we prune a pattern t if there are nodes u, u        vt

for which:

    u = vrt (i) for a certain i, i.e. u is a node on the rightmost path;

    u    is the left-hand sibling of u, if there is any such node;

      t (u) =   t (u   ), i.e. u and u    have the same label;

    img t    g(u)     img t [rt (i)   1]   g(u   ); here t [rt (i)     1] is the last ancestor

of t in which u    was on the rightmost path.

the main argument for this test is that if we now consider any tree t     which
contains additional nodes below node u in the pattern, we will still have the
following property:

img t       g(u)     img t       g(u   ).

the reason for this is that the only cause for losing a node x in img t       g(u   )
is that we lost a node in the image of the parent of u   . however, then we must
have also lost the node x in img t       g(u), as u and u    have the same parent, and
hence the subset relation still holds.

18

as img t       g(u)     img t       g(u   ) for every tree t    , we can put the subtrees
below node u in tree pattern t     always below node u   ; the resulting pattern will
also be frequent, while being more speci   c.

similarly, according to test 2, we prune a pattern t if there are nodes u, u       

vt for which:

    u = vrt     (i) for a certain i     d, where d is the depth of the last node in t ;

    u    is the left-hand sibling of u, if there is any such node;

      t (u) =   t (u   ), i.e. u and u    have the same label;

    img t       g(u)     img t [rt     (i)   1]   g(u   ).

here, t     = t [n     1], the tree obtained from t by removing the last node. the
correctness for this test follows from similar arguments as the previous test,
while also borrowing ideas from unavoidable redundancy pruning.

note that as a consequence of this pruning, certain trees are not entered in
the trie data structure. we perform the    nal maximality checking still on this
trie data structure, which means that we need to make sure that we search over
missing patterns in the post-processing step.

6 label constraints

in several of the datasets we will be using in the experiments we can distinguish
two types of nodes. on the one hand we have nodes of a general label type,
such as    page   , which represent entities in the data; on the other hand, we have
nodes that indicate properties of nodes, such as being in the    history    category.
the following is a small example of such a database.

people

history geography

history

page

page

page

in practice many patterns can be found in such data which contain the
   page    label. from a user   s perspective such patterns may not be very useful.
therefore, we propose to impose an additional constraint on patterns.

de   nition 9. let p be the set of property-labels in a graph. a tree t satis   es
the property label constraint i    every internal node has a child labeled with a
label in p.

the obvious way to process this constraint is by means of post-processing. a
better approach is based on exploiting unavoidable violations of the constraint.

de   nition 10. tree t violates the label constraint unavoidably if it has a node
that (1) is not on the right-most path and (2) does not have a child labeled with
a label in p.

19

the processing of this constraint is similar to that of the unavoidable re-
ducibility property (property 4); any tree which unavoidably violates the prop-
erty label constraint cannot be extended into a tree which satis   es this con-
straint. ordering the labels such that property labels are the right-most children
of their parent is bene   cial for this pruning.

note that with this type of pruning, we do not achieve incremental polyno-
mial time enumeration of all patterns satisfying the property label constraint:
we may be considering many paths before    nding a valid pattern. in theory,
our algorithm can be modi   ed to also ensure incremental polynomial enumera-
tion in this case; we omit the details of this rather complex modi   cation here.
experiments will be performed for the simpler algorithm.

7 related work

there is a very large literature on frequent pattern mining, ranging from itemsets
[1] to tree and graph data [4, 20, 16]. most work in the graph mining literature
focuses on the subgraph isomorphism setting, extending this from molecules to
networks [20, 13]. although in most cases exponential algorithms are used, it
was found that certain types of graphs can be mined more e   ciently: graphs of
bounded treewidth and bounded degree can be mined in incremental polynomial
time [10], while outerplanar graphs can be mined with polynomial delay [11],
both under isomorphism and homomorphism. the key observation in these
papers is to limit the class of graphs that are mined. in our work we do not
limit the class of graphs that can be mined; we only limit the class of patterns
to trees. in the tree mining literature, additional relationships between data
and patterns have been studied, such as embedded subtrees [4]. these methods
exploit the ancestor-descendant relationships between nodes in the data, and
hence are not applicable when the data is replaced by an arbitrary directed
graph. these algorithms have been extended to directed acyclic graphs [19].
in general    nding subgraph isomorphisms of trees into dags is already an np
complete problem; our algorithm is the    rst to allow mining of trees into dags
in incremental polynomial time.

related to our work are approaches for discovering frequent conjunctive
queries. in the framework of conjunctive query mining, a pattern is expressed
as a datalog query; the data consists of a relational database. the support of
a datalog query has been de   ned in two alternative ways. one is by means
of object identity (oi) subsumption, which is related to graph isomorphism.
the other is by means of   -subsumption, a concept developed in the inductive
logic programming (ilp) community which is similar to graph homomorphism.
the most-well known conjunctive query miner that exploits   -subsumption is
warmr [5]. warmr however prunes patterns which are reducible immediately,
and hence is not capable of    nding certain patterns. most systems use oi
subsumption to avoid this problem.

an alternative approach, which takes more a database perspective, is the
approach for mining tree queries [8, 9]. this approach limits itself to conjunctive

20

queries which can be visualized as trees, and hence is similar to our work.
algorithmically, however, it proceeds in two phases: phase one, in which all
unlabeled trees up to a certain size are enumerated (avoiding isomorphic trees),
and phase two, in which each such tree is re   ned by adding labels and applying
the apriori principle. clearly, in this approach many redundant patterns are
enumerated at    rst which may never lead to frequent core patterns.
in our
approach we can prove that the amount of such patterns considered is bounded
by the numbers of patterns already enumerated; furthermore, we deal with
cycles in the data.

a recent study also explored the problem of enumerating trees and graphs
of bounded tree width under homomorphism [17]. this study focused on the
enumeration process without taking into account constraints, such as a support
constraint. essentially, this study showed that without constraints core trees
can be enumerated in polynomial delay, i.e., the amount of time spent between
two solutions is polynomial in the size of the input. however, the proof relied
on the observation that any core tree can be expanded into another core tree
within a polynomial number of steps. in frequent pattern mining we have the
additional requirement that patterns need to be frequent; also this other recent
study [17] lists as future work whether it can be shown that frequent core trees
can be enumerated with polynomial delay.

8 experiments

we perform experiments on the following datasets:

ilpnet the ilpnet network represents an authorship network of papers,
and was collected as part of a european project.[18] in our ilpnet network we
included the following nodes and edges:

    nodes for authors, each labeled with a generic    author    label;

    nodes for papers, each labeled with a generic    paper    label;

    edges for links between papers and authors (in both directions);

    for each institute associated to an author, a node representing that in-
stitute for that particular author; the institute node is labeled with the
institute and linked with an edge to the author node, directed from the
author to the institute;

    for each keyword associated to a paper, a node representing that keyword
for that particular paper; the keyword node is labeled with the keyword
and linked with an edge to the paper node, directed from the paper to the
keyword.

the resulting network consists of 2 998 nodes, 7 906 edges and 186 labels.

21

webkb the webkb network represents a subset of webpages of a number
of american universities.2 the network was processed similarly. we included
the following nodes and edges in our network:

    nodes for webpages, each labeled with a type of webpage (course, project,

. . .);

    single directional edges for links between webpage nodes;

    for each keyword associated to a webpage, a node representing that key-
word for that particular webpage; the keyword node is labeled with the
keyword and linked with an edge to the webpage node, directed from the
webpage to the keyword.

our dataset includes all 4 di   erent universities and consists of 81 068 nodes,
160 368 edges and 781 labels.

wikipedia schools the wikipedia schools network3 consists of a selection
of wikipedia pages. the dataset consists of the following nodes and edges:

    nodes for wikipedia pages, each labeled with a generic page label;

    single directional edges for links between pages;

    for each category associated to a page, a node representing the category
for that particular page; the category node is labeled with the category
and linked with an edge to the page node, directed from the page to the
category.

this dataset contains 11 700 nodes, 109 216 edges and 16 labels.

on these datasets we used the following default parameters for our algorithm.
on ilp, we applied a minimum support threshold of 20, a maximum pattern size
of 20; on webkb the maximum pattern size was 5, the minimum support 100;
on wp the minimum support constraint was 40; the maximum depth constraint
3. only on the wp data the property label constraint was applied as well. in
all cases, the additional cover constraint was used as path constraint. figures 3
and 4 provide an overview of our results, in which all parameters are set to their
default, except those mentioned otherwise in the figure.

we wish to compare our homomorphism-based algorithm with an isomorphism-

based algorithm for mining networks. unfortunately, implementations of algo-
rithms such as gspan [20] and its extensions to networks [2] do not support the
discovery of rooted trees in directed graph data.
instead, we decided to ex-
tend our homomorphism-based implementation to isomorphism-based pattern
mining. we implemented two variations:    i-eval   , in which patterns are mined
under a homomorphism constraint, but support is also evaluated by means
of isomorphism, and    i-mine   , in which we disabled the homomorphism-based

2http://alchemy.cs.washington.edu/data/webkb/
3http://schools-wikipedia.org/

22

redundancy tests, and only a support count using an exponential subgraph iso-
morphism algorithm was used, similar to other graph miners [16].

our algorithms were implemented in java.

q1: runtime of isomorphism vs homomorphism figure 3(a) and 3(b)
(without property label constraint) show the runtime of both approaches when
increasing the maximum size of patterns; increasing the size of patterns increases
the branching factor in isomorphism-based algorithms. the di   erence between
   i-eval    and    i-mine   , which only is due to the computation of isomorphism-
based support, shows that signi   cantly more computation time is needed to
determine isomorphism-based support. the runtime increases further when
mining only under isomorphism; this is due to large numbers of candidate pat-
terns being generated that are not frequent, which are all evaluated using an
isomorphism test. figure 3(g) shows that the number of patterns found on ilp
using homomorphism is actually higher than those found under isomorphism.
the graph suggests that    ltering by means of homomorphism may be useful
even if one is mining for patterns under isomorphism.

q2: delay between patterns we proved that our algorithm is incremen-
tally polynomial. ideally, however, the amount of time spent between two solu-
tions would not depend on the number of solutions listed till that moment.

figures 3(c) and (d) show a run of our algorithm for two datasets. plotted
is the number of infrequent or non-core patterns enumerated between each pair
of frequent core patterns in the output, as the search progresses. on both
datasets we can observe that this number is not very dependent on the number
of patterns enumerated; indeed, in many cases, the enumeration process only
considers between 5 and 20 patterns that are not a core or that are not frequent
between each pair of frequent core patterns. this shows that our algorithm
performs better in practice than the theory suggests.

q3: condensed representations note that we found a large number of
patterns in some of our previous experiments. figures 3(e) and (f) show the
reduction in patterns if we apply closedness and maximality constraints when
varying support. taking into account the logarithmic scale, we can see that the
number of patterns found reduces signi   cantly on the ilp dataset, but not on
the webkb dataset; wp is similar to webkb (not shown). when varying the
size of patterns in figure 3(g), we observe a similar reduction of the number of
patterns on ilp data; in this    gure we also see that this e   ect is larger under
homomorphism than under isomorphism.

q4: property label constraint we performed experiments with and with-
out the property label constraint. only a runtime comparison is shown here;
figure 3(b) shows that the runtime improves by our pruning test.

23

]
s
[

e
m

i
t
n
u
r

50
45
40
35
30
25
20
15
10
5
0

ilpnet

h-mine
h-mine + i-eval
i-mine

0

2

4

6

8

10

12

14

16

18

20

pattern size

]
s
[

e
m

i
t
n
u
r

100
90
80
70
60
50
40
30
20
10
0

wp schools

h-mine (label constraint)
h-mine
h-mine + i-eval
i-mine

1

2

4

3
5
pattern size

6

7

(a) runtime: iso- vs homomorphism (b) runtime: iso- vs homomorphism

80

70

60

50

40

30

20

10

0

ilpnet

0

1000 2000 3000 4000 5000 6000 7000

number of patterns accepted

(c) delay

ilpnet

frequent
closed
maximal

(d) delay

webkb

frequent
closed
maximal

s
n
r
e
t
t
a
p
f
o
r
e
b
m
u
n

104

103

s
n
r
e
t
t
a
p
f
o
r
e
b
m
u
n

t
p
e
c
c
a

t
s
a
l

e
c
n
i
s

s
n
r
e
t
t
a
p
f
o

r
e
b
m
u
n

103

102

10

1

0

50

150

100
200
min. support

250

300

100

150

200

300

250
350
min. support

400

450

500

(e) condensed representations

(f) condensed representations

s
n
r
e
t
t
a
p
f
o
r
e
b
m
u
n

1000
900
800
700
600
500
400
300
200
100
0

ilpnet

homo frequent
homo closed
iso frequent
iso closed

0

1

2

3

4

5

6

7

8

9

10

max. pattern size

t
r
o
p
p
u
s
m
s
i
h
p
r
o
m
o
s
i

1000
900
800
700
600
500
400
300
200
100
0

.

.

.
.
.
.

.

wp schools

.

. .
.
..

.
.
.
.
.
.

..
.
..
.
.
.
.
.
. .
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
. .
.

.
.
.
.
.
.
.

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
..
.
.
.
.
.
.
.
.
. .
.
.
.
.
.
.
. ..
. .
.
.
.
.
..
.
.
.
..
.
. .
.
. .
.
.
.
.
.
.
.
.
.
.
..
.
.
.
.
..
..
.
.
.
..
.
.
....
. .
..
..
.
.
.
.
.
..
.
.
.
..
..
.
..
.
. .
.
.
.
.
..
.
.
.
.
.
.
.. ..
.
.
.
.
. .
.
..
.
.
.
..
..
.
.
..
. .
. .
.
.
.
..
..
.
.
.. ..
.
.
.
.
.. .
.
...
.
.
.
..
..
..
.
...... ..
.
.
.
...
.. .
. ........ ................. .. .. .... ...
..
. ....
..
.
. .
..
..
.
..
..
.. . .
..
.
.....
.....
....
...
.
.
.
...
.. .... ...
.. .
.
...
.
.
..
. ..
..
.. .. ...
..
..
. ..
. .
...
..
. ..
.
..
..
.
...
.
.
.....
.
.
...
.
..
..
....
.....
...
..
.
. ...
..
.
...
.
.
.
.
..
.
..
..
..
..
.
.
..
.
.
.
..
.
.
.
.
.
..
..
..
.
.
.
..
.
..
.
.
.
.
.
.
.
.
.

0

100 200 300 400 500 600 700 800 900 1000

homomorphism support

(g) condensed representations

(h) comparing supports

figure 3: results for the remaining results

24

t
r
o
p
p
u
s
m
s
i
h
p
r
o
m
o
s
i

200
180
160
140
120
100
80
60
40
20
0

..
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
..
.
.
.
.
.
.
.
.
.
.
.
...
.
...
.. .
.
... .
.
.
...
.
.. ....
.. .
.
.
.
.. ....
.. ....
.. ....
.. ....
.. ....
.
.
.
.
.
. .
.
.
.
.
.
.
.
.
. .
.
..
. .
.
..
..
...
.
....
..
.
.
.
.
.
.
.
..
..
.
.
.
..
.
.
.
.
.
.
.
.
.
.
.
.
.
.
..
..
..
.
.
.
.. .
.. .
.. .
.
.
.
...........
.
................
.
..
.
.
.
.........
.
.................
.
.
.
.
...
.
.
.
...
.
.
...
.
.
.
.
............
.
.
.
..
.
.
.
.
.
.................
.
..
....
.
.
.
....
........
.........
.
.
.
.
.
.
.
.
.
.
.
.
.
.........
....
.
.
.
..
.....
....
.
.
.
.
.
......
.
.
...
.
.
....
.
.
..........
........
.........................
................................................................
.............................................
....
...........
............
..........................................
..
....
...........
...........
....
......
..
.
.
.
.......
.............
....
...........
....
.................................
.......
........................
..
..
..
..
..
....
...
......
..................
.....
...
............
...
...........
...
..
..
..
...
.
.
.
.
.. ......
.. .... .....
.. ...... ...
.
.. ...... ...
.. .... ..
.
.
.
.
.
.
.
.. .... ..
.. .... ..
...
..
.
.
.
.
..
...........
...........
......
...........
..
.
..
..
..
..
..
..
...
..
40
20

0

.

.

.

ilpnet

.
.

.

.

.
.

.

.
.
.
.
.

.

.
.
.
.
.
.
.
.
.
.

.
.
.
.
.

.

.
.

.

.
.

.
.
.
..
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.

.

60

80 100 120 140 160 180 200

t
r
o
p
p
u
s
m
s
i
h
p
r
o
m
o
s
i

200
180
160
140
120
100
80
60
40
20
0

.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
.
..
.
. .
.
..
.
.. .
...
... .
. .
.
.
.
......
.
..
.
..
.
. ...
.
....
..
.
.
..
.........
... ..
.
.
.
...
.
.
.
. ..
...
. ...
..
. ...
..
..
.
.... ...
.
..... ..........
...
..
.... .
.
.
.. ............
.
.
......
..
.
...............
..
...
...
.
..
..
.
.
.
..
...
.
.
....
.
..
.
.
.
.
..
.
20

40

0

ilpnet

.

.

.

.

.
.
.

.

.
.

.

.

.
.

.
.
.
.

.

.
..
.
.

.
.
.
.

60

80 100 120 140 160 180 200

homomorphism support

homomorphism support

(a) frequent patterns

(b) closed patterns

figure 4: comparing supports of patterns on the ilp data

q5: di   erences in patterns found the experiments in figures 3(h), 4(a)
and 4(b) provide insight in the di   erences between patterns found in both set-
tings. each dot represents a pattern found when mining using homomorphism,
but also evaluating under isomorphism. the experiments clearly show that both
methods provide similar support counts. in ilp we see that there are some sets
of patterns that have diverging support values (around homomorphism support
130). these are mainly patterns that are not closed; they are all subtrees of a
larger tree that has a similar support both under isomorphism and homomor-
phism.

considering closed patterns on ilp data, we still can see some patterns with

diverging supports. one such pattern is:

paper

author

oxford

author

york

which has an isomorphism-support of 61 but a homomorphism-support of 153.
this re   ects that papers were written by either an author a   liated to both
institutions or by two authors, each a   liated to one of these two institutions.

9 conclusions

in this paper we introduced the problem of mining tree patterns under homo-
morphism. experiments showed that its performance is better in practice than
the incremental polynomial time delay complexity suggests; typically, the num-
ber of infrequent, non-core patterns generated between each pair of frequent,
core patterns is small. this shows that our algorithm is also of practical rele-
vance.

our experiments clearly showed that support evaluation for homomorphism
is signi   cantly faster than using isomorphism and hence is bene   cial on large
databases. furthermore, in practice the support of patterns found using both
types of mappings is typically very similar.

we found that in most cases the number of closed patterns found using ho-
momorphisms is smaller than using isomorphisms. the type of pattern that

25

is not found using our algorithm typically encodes a degree constraint. where
such patterns are undesirable, a possibility is to use our enumeration procedure
to    lter patterns. in other cases, a possibility for future work is to search for
patterns that explicitly encode degree constraints while still using homomor-
phisms. arguably, such patterns would be easier to interpret than patterns
that encode degree implicitly.

references

[1] r. agrawal, h. mannila, r. srikant, h. toivonen, and a. i. verkamo. fast
in advances in knowledge discovery and

discovery of association rules.
data mining, pages 307   328. aaai/mit press, 1996.

[2] b. bringmann, m. berlingerio, f. bonchi, and a. gionis. learning and
ieee intelligent systems,

predicting the evolution of social networks.
25(4):26   35, 2010.

[3] b. bringmann, s. nijssen, n. tatti, j. vreeken, and a. zimmermann. min-

ing sets of patterns: a tutorial. ecml/pkdd, 2010.

[4] y. chi, r. r. muntz, s. nijssen, and j. n. kok. frequent subtree mining

- an overview. fundam. inform., 66(1-2):161   198, 2005.

[5] l. dehaspe and h. toivonen. discovery of frequent datalog patterns. data

min. knowl. discov., 3(1):7   36, 1999.

[6] w. fan, j. li, s. ma, h. wang, and y. wu. graph homomorphism revisited

for graph matching. pvldb, 3(1):1161   1172, 2010.

[7] p. hell and j. neset  ril. graphs and homomorphisms. oxford lecture series

in mathematics and its applications. oxford university press, 2004.

[8] e. hoekx and j. van den bussche. mining for tree-query associations in a

graph. in icdm, pages 254   264, 2006.

[9] e. hoekx and j. van den bussche. mining tree-query associations in graphs.

corr, abs/1008.2626, 2010.

[10] t. horvath and j. ramon. e   cient frequent connected subgraph mining
in graphs of bounded treewidth. theoretical computer science, 411:2784   
2797, 2010.

[11] t. horvath, j. ramon, and s. wrobel. frequent subgraph mining in outer-
planar graphs. knowledge discovery and data mining, 21:472   508, 2010.

[12] d. johnson, m. yannakakis, and c. papadimitriou. on generating all
information processing letters, 27:119   123,

maximal independent sets.
1988.

26

[13] m. kuramochi and g. karypis. finding frequent patterns in a large sparse

graph. data min. knowl. discov., 11(3):243   271, 2005.

[14] s. nakano and t. uno. e   cient generation of rooted trees. technical

report, 2003.

[15] s. nijssen. mining structured data. phd thesis, 2006.

[16] s. nijssen and j. n. kok. a quickstart in frequent structure mining can

make a di   erence. in kdd, pages 647   652, 2004.

[17] j. ramon, s. roy, and j. daenen. e   cient homomorphism-free enumera-

tion of conjunctive queries. in inductive logic programming, 2011.

[18] s. sabo, m. gr  car, d. fabjan, p. ljubic, and n. lavrac. exploratory anal-
ysis of the ilpnet2 social network. in proceedings of the 10th international
multi-conference information society (is-2006), 2007.

[19] a. termier, y. tamada, k. numata, s. imoto, t. washio, and t. higuchi.
digdag, a    rst algorithm to mine closed frequent embedded sub-dags. 2007.

[20] x. yan and j. han. gspan: graph-based substructure pattern mining. in

icdm, pages 721   724, 2002.

27

