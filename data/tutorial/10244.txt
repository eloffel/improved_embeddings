diversity in spectral learning for natural language parsing

shashi narayan and shay b. cohen

school of informatics
university of edinburgh
edinburgh, eh8 9le, uk

{snaraya2,scohen}@inf.ed.ac.uk

5
1
0
2

 

g
u
a
5
1

 

 
 
]
l
c
.
s
c
[
 
 

2
v
5
7
2
0
0

.

6
0
5
1
:
v
i
x
r
a

abstract

we describe an approach to create a di-
verse set of predictions with spectral learn-
ing of latent-variable pid18s (l-pid18s).
our approach works by creating multiple
spectral models where noise is added to
the underlying features in the training set
before the estimation of each model. we
describe three ways to decode with mul-
tiple models.
in addition, we describe a
simple variant of the spectral algorithm for
l-pid18s that is fast and leads to compact
models. our experiments for natural lan-
guage parsing, for english and german,
show that we get a signi   cant improve-
ment over baselines comparable to state of
the art. for english, we achieve the f1
score of 90.18, and for german we achieve
the f1 score of 83.38.
introduction

1
it has been long identi   ed in nlp that a diverse set
of solutions from a decoder can be reranked or re-
combined in order to improve the accuracy in var-
ious problems (henderson and brill, 1999). such
problems include machine translation (macherey
and och, 2007), syntactic parsing (charniak and
johnson, 2005; sagae and lavie, 2006; fossum
and knight, 2009; zhang et al., 2009; petrov,
2010; choe et al., 2015) and others (van halteren
et al., 2001).

the main argument behind the use of such a di-
verse set of solutions (such as k-best list of parses
for a natural language sentence) is the hope that
each solution in the set is mostly correct. there-
fore, recombination or reranking of solutions in
that set will further optimize the choice of a solu-
tion, combining together the information from all
solutions.

in this paper, we explore another angle for the
use of a set of parse tree predictions, where all pre-

dictions are made for the same sentence. more
speci   cally, we describe techniques to exploit di-
versity with spectral learning algorithms for natu-
ral language parsing. spectral techniques and the
method of moments have been recently used for
various problems in natural language processing,
including parsing, id96 and the deriva-
tion of id27s (luque et al., 2012; co-
hen et al., 2013; stratos et al., 2014; dhillon et al.,
2015; rastogi et al., 2015; nguyen et al., 2015; lu
et al., 2015).

cohen et al. (2013) showed how to estimate an
l-pid18 using spectral techniques, and showed
that such estimation outperforms the expectation-
maximization algorithm (matsuzaki et al., 2005).
their result still lags behind state of the art in natu-
ral language parsing, with methods such as coarse-
to-   ne (petrov et al., 2006).

we further advance the accuracy of natural lan-
guage parsing with spectral techniques and l-
pid18s, yielding a result that outperforms the orig-
inal berkeley parser from petrov and klein (2007).
instead of exploiting diversity from a k-best list
from a single model, we estimate multiple models,
where the underlying features are perturbed with
several perturbation schemes. each such model,
during test time, yields a single parse, and all
parses are then used together in several ways to
select a single best parse.

the main contributions of this paper are two-
fold. first, we present an algorithm for estimating
l-pid18s, akin to the spectral algorithm of cohen
et al. (2012), but simpler to understand and imple-
ment. this algorithm has value for readers who
are interested in learning more about spectral al-
gorithms     it demonstrates some of the core ideas
in spectral learning in a rather intuitive way.
in
addition, this algorithm leads to sparse grammar
estimates and compact models.

second, we describe how a diverse set of predic-
tors can be used with spectral learning techniques.

our approach relies on adding noise to the feature
functions that help the spectral algorithm compute
the latent states. our noise schemes are similar
to those described by wang et al. (2013). we add
noise to the whole training data, then train a model
using our algorithm (or other spectral algorithms;
cohen et al., 2013), and repeat this process mul-
tiple times. we then use the set of parses we get
from all models in a recombination step.
the rest of the paper is organized as follows.
in   2 we describe notation and background about
l-pid18 parsing. in   3 we describe our new spec-
tral algorithm for estimating l-pid18s. it is based
on similar intuitions as older spectral algorithms
for l-pid18s. in   4 we describe the various noise
schemes we use with our spectral algorithm and
the spectral algorithm of cohen et al. (2013). in
  5 we describe how to decode with multiple mod-
els, each arising from a different noise setting. in
  6 we describe our experiments with natural lan-
guage parsing for english and german.

2 background and notation
we denote by [n] the set of integers {1, . . . , n}.
for a statement   , we denote by [[  ]] its indicator
function, with values 0 when the assertion is false
and 1 when it is true.
an l-pid18 is a 5-tuple (n ,i,p, m, n) where:
    n is the set of nonterminal symbols in the
grammar. i     n is a    nite set of intermi-
nals. p     n is a    nite set of preterminals.
we assume that n = i     p, and i     p =    .
hence we have partitioned the set of nonter-
minals into two subsets.

    [m] is the set of possible hidden states.
    [n] is the set of possible words.
    for all a     i, b     n , c     n , h1, h2, h3    
[m], we have a binary context-free rule
a(h1)     b(h2) c(h3).

    for all a     p, h     [m], x     [n], we have a

lexical context-free rule a(h)     x.

to probabilistic regular

latent-variable pid18s are essentially equiv-
alent
tree grammars
(prtgs; knight and graehl, 2005) where the
righthand side trees are of depth 1. with gen-
eral prtgs, the righthand side can be of arbitrary
depth, where the leaf nodes of these trees corre-
spond to latent states in the l-pid18 formulation

vp

v

np

saw

d

n

the

woman

s

np

vp

d

n

the

dog

figure 1: the inside tree (left) and outside
tree (right) for the nonterminal vp in the parse
tree (s (np (d the) (n dog)) (vp (v
saw) (np (d the) (n woman)))).

above and the internal nodes of these trees corre-
spond to interminal symbols in the l-pid18 for-
mulation.

two important concepts that will be used
throughout of the paper are that of an    inside tree   
and an    outside tree.    given a tree, the inside tree
for a node contains the entire subtree below that
node; the outside tree contains everything in the
tree excluding the inside tree. see figure 1 for an
example. given a grammar, we denote the space
of inside trees by t and the space of outside trees
by o.

3 id91 algorithm for estimating

l-pid18s

we assume two feature functions,    : t     rd
and    : o     rd(cid:48)
, mapping inside and outside
trees, respectively, to a real vector. our training
data consist of examples (a(i), t(i), o(i), b(i)) for
i     {1 . . . m}, where a(i)     n ; t(i) is an inside
tree; o(i) is an outside tree; and b(i) = 1 if a(i) is
the root of tree, 0 otherwise. these are obtained
by splitting all trees in the training set into inside
and outside trees at each node in each tree. we
then de   ne    a     rd  d(cid:48)

:

(cid:80)m
i=1[[a(i) = a]]  (t(i))(  (o(i)))(cid:62)

   a =

(1)

(cid:80)m

i=1[[a(i) = a]]

this matrix is an empirical estimate for the
cross-covariance matrix between the inside trees
and the outside trees of a given nonterminal a. an
inside tree and an outside tree are conditionally in-
dependent according to the l-pid18 model, when
the latent state at their connecting point is known.
this means that the latent state can be identi   ed
by    nding patterns that co-occur together in in-
side and outside trees     it is the only random vari-
able that can explain such correlations. as such,
if we reduce the dimensions of    a using singu-
lar value decomposition (svd), we essentially get

inputs: an input treebank with the following additional in-
training examples (a(i), t(i), o(i), b(i)) for i    
formation:
{1 . . . m}, where a(i)     n ; t(i) is an inside tree; o(i) is
an outside tree; and b(i) = 1 if the rule is at the root of tree,
0 otherwise. a function    that maps inside trees t to feature-
vectors   (t)     rd. a function    that maps outside trees o
to feature-vectors   (o)     rd(cid:48)
. an integer k denoting the
thin-svd rank. an integer m denoting the number of latent
states.

algorithm:
(step 1: singular value decompositions)

    calculate svd on    a to get   u a     r(d  k) and   v a    

r(d(cid:48)  k) for each a     n .

(step 1: projection)

    for all i     [m ], compute y(i) = (   u ai )(cid:62)  (t(i)) and

z(i) = (   v ai )(cid:62)  (o(i)).

    for all i     [m ], set x(i) to be the concatenation of y(i)

and z(i).

(step 2: cluster projections)

    for all a     n , cluster the set {x(i) | a(i) = a} to
get a id91 function    : r2k     [m] that maps a
projected vector x(i) to a cluster in [m].

(step 3: compute final parameters)

    annotate each node in the treebank with   (x(i)).
    compute the id203 of a rule p(a[h1]    
b[h2] c[h3] | a[h1]) as the relative frequency of its ap-
pearance in the cluster-annotated treebank.

    similarly, compute the root probabilities   (a[h]) and

preterminal rules p(a[h]     x | a[h]).

figure 2: the id91 estimation algorithm for
l-pid18s.

representations for the inside trees and the outside
trees that correspond to the latent states.

this intuition leads to the algorithm that appears
in figure 2. the algorithm we describe takes as in-
put training data, in the form of a treebank, decom-
posed into inside and outside trees at each node in
each tree in the training set.

the algorithm    rst performs svd for each of
the set of inside and outside trees for all nontermi-
nals.1 this step is akin to cca, which has been
used in various contexts in nlp, mostly to derive
representations for words (dhillon et al., 2015;
rastogi et al., 2015). the algorithm then takes
the representations induced by the svd step, and

1we normalize features by their variance.

clusters them     we use id116 to do the clus-
tering. finally, it maps each svd representation
to a cluster, and as a result, gets a cluster identi-
   er for each node in each tree in the training data.
these clusters are now treated as latent states that
are    observed.    we subsequently follow up with
frequency count maximum likelihood estimate to
estimate the probabilities of each parameter in the
l-pid18.
consider for example the estimation of rules of
the form a     x. following the id91 step we
obtain for each nonterminal a and latent state h a
set of rules of the form a[h]     x. each such in-
stance comes from a single training example of a
lexical rule. next, we compute the id203 of
the rule a[h]     x by counting how many times
that rule appears in the training instances, and nor-
malize by the total count of a[h] in the training
instances. similarly, we compute probabilities for
binary rules of the form a     b c.

the features that we use for    and    are sim-
ilar to those used in cohen et al. (2013). these
features look at the local neighborhood surround-
ing a given node. more speci   cally, we indicate
the following information with the inside features
(throughout these de   nitions assume that a     b c
is at the root of the inside tree t):

    the pair of nonterminals (a, b). e.g., for the
inside tree in figure 1 this would be the pair
(vp, v).

    the pair (a, c). e.g., (vp, np).
    the rule a     b c. e.g., vp     v np.
    the rule a     b c paired with the rule at the
node b. e.g., for the inside tree in figure 1
this would correspond to the tree fragment
(vp (v saw) np).

    the rule a     b c paired with the rule at the
node c. e.g., the tree fragment (vp v (np d
n)).

    the head part-of-speech of t paired with a.

e.g., the pair (vp, v).

    the number of words dominated by t paired

with a. e.g., the pair (vp, 3).

in the case of an inside tree consisting of a sin-
gle rule a     x the feature vector simply indicates
the identity of that rule.

for the outside features, we use:
    the rule above the foot node. e.g., for the
outside tree in figure 1 this would be the rule

s     np vp    (the foot nonterminal is marked
with    ).

    the two-level and three-level rule fragments
above the foot node. these features are ab-
sent in the outside tree in figure 1.

    the label of the foot node, together with the

label of its parent. e.g., the pair (vp, s).

    the label of the foot node, together with the

label of its parent and grandparent.

    the part-of-speech of the    rst head word
along the path from the foot of the outside
tree to the root of the tree which is different
from the head node of the foot node.

    the width of the spans to the left and to the
right of the foot node, paired with the label of
the foot node.

other spectral algorithms the svd step on
the    a matrix is pivotal to many algorithms, and
has been used in the past for other l-pid18 esti-
mation algorithms. cohen et al. (2012) used it for
developing a spectral algorithm that identi   es the
parameters of the l-pid18 up to a linear transfor-
mation. their algorithm generalizes the work of
hsu et al. (2009) and bailly et al. (2010).

cohen and collins (2014) also developed an al-
gorithm that makes use of an svd step on the
inside-outside.
it relies on the idea of    pivot
features        features that uniquely identify latent
states.

louis and cohen (2015) used a id91 al-
gorithm that resembles ours but does not sepa-
rate inside trees from outside trees or follows up
with a singular value decomposition step. their
algorithm was applied to both l-pid18s and lin-
ear context-free rewriting systems. their applica-
tion was the analysis of hierarchical structure of
conversations in online forums.

in our preliminary experiments, we found out
that the id91 algorithm by itself performs
worse than the spectral algorithm of cohen et al.
(2013). we believe that the reason is two-fold: (a)
id116    nds a local maximum during id91;
(b) we do hard id91 instead of soft cluster-
ing. however, we detected that the id91 algo-
rithm gives a more diverse set of solutions, when
the features are perturbed. as such, in the next
sections, we explain how to perturb the models we
get from the id91 algorithm (and the spectral
algorithm) in order to improve the accuracy of the
id91 and spectral algorithms.

4 spectral estimation with noise

it has been shown that a diverse set of predictions
can be used to help improve decoder accuracy for
various problems in nlp (henderson and brill,
1999). usually a k-best list from a single model
is used to exploit model diversity. instead, we es-
timate multiple models, where the underlying fea-
tures are    ltered with various noising schemes.

we try three different types of noise schemes for

the algorithm in figure 2:
dropout noise: let        [0, 1]. we set each ele-
ment in the feature vectors   (t) and   (o) to
0 with id203   .

gaussian (additive): let    > 0. for each x(i),
we draw a vector        r2k of gaussians with
mean 0 and variance   2, and then set x(i)    
x(i) +   .

gaussian (multiplicative): let    > 0. for each
x(i), we draw a vector        r2k of gaussians
with mean 0 and variance   2, and then set
x(i)     x(i)     (1 +   ), where     is coordinate-
wise multiplication.

note the distinction between the dropout noise
and the gaussian noise schemes: the    rst is per-
formed on the feature vectors before the svd step,
and the second is performed after the svd step. it
is not feasible to add gaussian noise prior to the
svd step, since the matrix    a will no longer be
sparse, and its svd computation will be computa-
tionally demanding.

our use of dropout noise here is inspired by
   dropout    as is used in neural network training,
where various connections between units in the
neural network are dropped during training in or-
der to avoid over   tting of these units to the data
(srivastava et al., 2014).

the three schemes we described were also used
by wang et al. (2013) to train id148.
wang et al.   s goal was to prevent over   tting by
introducing this noise schemes as additional reg-
ularizer terms, but without explicitly changing the
training data. we do    lter the data through these
noise schemes, and show in   6 that all of these
noise schemes do not improve the performance of
our estimation on their own. however, when mul-
tiple models are created with these noise schemes,
and then combined together, we get an improved
performance. as such, our approach is related to

the one of petrov (2010), who builds a commit-
tee of latent-variable pid18s in order to improve a
natural language parser.

we also use these perturbation schemes to cre-
ate multiple models for the algorithm of cohen et
al. (2012). the dropout scheme stays the same,
but for the gaussian noising schemes, we follow a
slightly different procedure. after noising the pro-
jections of the inside and outside feature functions
we get from the svd step, we use these projected
noised features as a new set of inside and outside
feature functions, and re-run the spectral algorithm
of cohen et al. (2012) on them.

we are required to add this extra svd step be-
cause the spectral algorithm of cohen et al. as-
sumes the existence of linearly transformed pa-
rameter estimates, where the parameters of each
nonterminal a is linearly transformed by unknown
invertible matrices. these matrices cancel out
when the inside-outside algorithm is run with the
spectral estimate output.
in order to ensure that
these matrices still exactly cancel out, we have to
follow with another svd step as described above.
the latter svd step is performed on a dense    a    
rm  m but this is not an issue considering m (the
number of latent states) is much smaller than d or
d(cid:48).

5 decoding with multiple models

let g1, . . . , gp be a set of l-pid18 grammars. in
  6, we create such models using the noising tech-
niques described above. the question that remains
is how to combine these models together to get a
single best output parse tree given an input sen-
tence.

with l-pid18s, decoding a single sentence re-
quires marginalizing out the latent states to    nd
the best skeletal tree2 for a given string. let s be a
sentence. we de   ne t(gi, s) to be the output tree
according to minimum bayes risk decoding. this
means we follow goodman (1996), who uses dy-
namic programming to compute the tree that maxi-
mizes the sum of all marginals of all nonterminals
in the output tree. each marginal, for each span
(cid:104)a, i, j(cid:105) (where a is a nonterminal and i and j are
endpoints in the sentence), is computed by using
the inside-outside algorithm.
in addition, let   (a, i, j|gk, s) be the marginal,
as computed by the inside-outside algorithm, for

2a skeletal tree is a derivation tree without latent states

decorating the nonterminals.

the span (cid:104)a, i, j(cid:105) with grammar gk for string s.
we use the notation (cid:104)a, i, j(cid:105)     t to denote that a
span (cid:104)a, i, j(cid:105) is in a tree t.

we suggest the following three ways for decod-

ing with multiple models g1, . . . , gp:

maximal tree coverage: using dynamic pro-
is the

gramming, we return the tree that
solution to:

t    = arg max

t

[[(cid:104)a, i, j(cid:105)     t(gk, s)]].

(cid:88)

p(cid:88)

(cid:104)a,i,j(cid:105)   t

k=1

this implies that we    nd the tree that max-
imizes its coverage with respect to all other
trees that are decoded using g1, . . . , gp.

maximal marginal coverage: using

dynamic
programming, we return the tree that is the
solution to:

t    = arg max

t

  (a, i, j|gk, s).

(cid:88)

p(cid:88)

(cid:104)a,i,j(cid:105)   t

k=1

this is similar to maximal tree coverage, only
instead of considering just the single decoded
tree for each model among g1, . . . , gp, we
make our decoding    softer,    and rely on the
marginals that each model gives.

maxent reranking: we train a maxent reranker
on a training set that includes outputs from
multiple models, and then, during testing
time, decode with each of the models, and
use the trained reranker to select one of the
parses. we use the reranker of charniak and
johnson (2005).3

as we see later in   6, it is sometimes possible to
extract more information from the training data by
using a network, or a hierarchy of the above tree
combination methods. for example, we get our
best result for parsing by    rst using maxent with
several subsets of the models, and then combining
the output of these maxent models using maximal
tree coverage.

3implementation: https://github.com/bllip/
more speci   cally, we used the
bllip-parser.
programs extract-spfeatures, cvlm-lbfgs and
best-indices. cvlm-lbfgs was used with the default
hyperparameters from the make   le.

id91

spectral (smoothing)

spectral (no smoothing)

maxtre maxmrg maxent maxtre maxmrg maxent maxtre maxmrg maxent
87.94
88.68
86.72
89.04
88.74
86.97
89.52
88.68
88.37
89.85
87.49
88.84
86.47 (cohen et al., 2013)

88.59
88.20
89.46
88.48
89.47
88.64
88.38
89.45
88.53 (cohen et al., 2013)

88.64
88.66
88.56
88.75
86.48

88.28
88.70
88.71
88.75

86.85
86.53
88.06
87.00

89.50
89.89
89.80
89.95

add
mul

dropout

all

no noise

table 1: results on section 22 (wsj). maxtre denotes decoding using maximal tree coverage, maxmrg denotes decoding
using maximal marginal coverage, and maxent denotes the use of a discriminative reranker. add, mul and dropout denote
the use of additive gaussian noise, multiplicative gaussian noise and dropout noise, respectively. the number of models used
in the    rst three rows for the id91 algorithm is 80: 20 for each        {0.05, 0.1, 0.15, 0.2}. for the spectral algorithm,
it is 20, 5 for each    (see footnotes). the number of latent states is m = 24. for all, we use all models combined from the
   rst three rows. the    no noise    baseline for the spectral algorithm is taken from cohen et al. (2013). the best    gure in each
algorithm block is in boldface.

6 experiments
in this section, we describe parsing experiments
with two languages: english and german.

6.1 results for english
for our english parsing experiments, we use a
standard setup. more speci   cally, we use the penn
wsj treebank (marcus et al., 1993) for our experi-
ments, with sections 2   21 as the training data, and
section 22 used as the development data. section
23 is used as the    nal test set. we binarize the
trees in training data, but transform them back be-
fore evaluating them.

for ef   ciency, we use a base pid18 without
latent states to prune marginals which receive
a value less than 0.00005 in the dynamic pro-
gramming chart. the parser takes part-of-speech
tagged sentences as input. we tag all datasets us-
ing turbo tagger (martins et al., 2010), trained on
sections 2   21. we use the f1 measure according
to the parseval metric (black et al., 1991) for
the evaluation.
preliminary experiments we    rst experiment
with the number of latent states for the id91
algorithm without perturbations. we use k = 100
for the svd step. whenever we need to cluster
a set of points, we run the id116 algorithm 10
times with random restarts and choose the clus-
tering result with the lowest objective value. on
section 22, the id91 algorithm achieves the
following results (f1 measure): m = 8: 84.30%,
m = 16: 85.98%, m = 24: 86.48%, m = 32:
85.84%, m = 36: 86.05%, m = 40: 85.43%.
as we increase the number of states, performance
improves, but plateaus at m = 24. for the rest of
our experiments, both with the spectral algorithm
of cohen et al. (2012) and the id91 algorithm
presented in this paper, we use m = 24.

figure 3: f1 scores of noisy models. each data
point gives the f1 accuracy of a single model on
the development set, based on the legend. the x-
axis enumerates the models (80 in total for each
noise scheme).

compact models one of the advantage of the
id91 algorithm is that it leads to much more
compact models. the number of nonzero param-
eters with m = 24 for the id91 algorithm is
approximately 97k, while the spectral algorithms
lead to a signi   cantly larger number of nonzero
parameters with the same number of latent states:
approximately 54 million.
oracle experiments to what extent do we get
a diverse set of solutions from the different mod-
els we estimate? this question can be answered by
testing the oracle accuracy in the different settings.
for each type of noising scheme, we generated 80

method

t spectral (unsmoothed)

s
e
b

spectral (smoothed)
id91

r spectral (unsmoothed)

e
i
h

spectral (smoothed)
id91

f1
89.21
88.87
89.25
89.09
89.06
90.18

table 2: results on section 23 (english). the    rst
three results (best) are taken with the best model
in each corresponding block in table 1. the last
three results (hier) use a hierarchy of the above
tree combination methods in each block. it com-
bines all maxent results using the maximal tree
coverage (see text).

models, 20 for each        {0.05, 0.1, 0.15, 0.2}.
each noisy model by itself lags behind the best
model (see figure 3). however, when choosing
the best tree among these models, the additively-
noised models get an oracle accuracy of 95.91%
on section 22; the multiplicatively-noised models
get an oracle accuracy of 95.81%; and the dropout-
noised models get an oracle accuracy of 96.03%.
finally all models combined get an oracle accu-
racy of 96.67%. we found out that these oracle
scores are comparable to the one charniak and
johnson (2005) report.

we also tested our oracle results, comparing
the spectral algorithm of cohen et al. (2013) to
the id91 algorithm. we generated 20 mod-
els for each type of noising scheme, 5 for each
       {0.05, 0.1, 0.15, 0.2}) for the spectral al-
gorithm.4 surprisingly, even though the spectral
models were smoothed, their oracle accuracy was
lower than the accuracy of the id91 algo-
rithm: 92.81% vs. 95.73%.5 this reinforces two
ideas: (i) that noising acts as a regularizer, and has
a similar role to backoff smoothing, as we see be-
low; and (ii) the noisy estimation for the id91
algorithm produces a more diverse set of parses
than that produced with the spectral algorithm.

it is also important to note that the high ora-
cle accuracy is not just the result of id116 not

   nding the global maximum for the id91 ob-
jective.
if we just run the id91 algorithms
with 80 models as before, without perturbing the
features, the oracle accuracy is 95.82%, which is
lower than the oracle accuracy with the additive
and dropout perturbed models. to add to this, we
see below that perturbing the training set with the
spectral algorithm of cohen et al. improves the ac-
curacy of the spectral algorithm. since the spectral
algorithm of cohen et al. does not maximize any
objective locally, it shows that the role of the per-
turbations we use is important.

results results on the development set are
given in table 1 with our three decoding methods.
we present the results from three algorithms: the
id91 algorithm and the spectral algorithms
(smoothed and unsmoothed).6

it seems that dropout noise for the spectral algo-
rithm acts as a regularizer, similarly to the back-
off smoothing techniques that are used in cohen
et al. (2013). this is evident from the two spectral
algorithm blocks in table 1, where dropout noise
does not substantially improve the smoothed spec-
tral model (cohen et al. report accuracy of 88.53%
with smoothed spectral model for m = 24 without
noise)     the accuracy is 88.64%   88.71%   89.47%,
but the accuracy substantially improves for the un-
smoothed spectral model, where dropout brings an
accuracy of 86.47% up to 89.52%.

all three blocks in table 1 demonstrate that
decoding with the maxent reranker performs the
best. also it is interesting to note that our results
continue to improve when combining the output of
previous combination steps further. the best re-
sult on section 22 is achieved when we combine,
using maximal tree coverage, all maxent outputs
of the id91 algorithm (the    rst block in ta-
ble 1). this yields a 90.68% f1 accuracy. this is
also the best result we get on the test set (section
23), 90.18%. see table 2 for results on section 23.
our results are comparable to state-of-the-art
results for parsing. for example, sagae and lavie
(2006), fossum and knight (2009) and zhang et
al. (2009) report an accuracy of 93.2%-93.3% us-

4there are two reasons we use a smaller number of mod-
els with the spectral algorithm: (a) models are not compact
(see text) and (b) as such, parsing takes comparatively longer.
however, in the above comparison, we use 20 models for the
id91 algorithm as well.

5oracle scores for the id91 algorithm: 95.73% (20
models for each noising scheme) and 96.67% (80 models for
each noising scheme).

6cohen et al. (2013) propose two variants of spectral
estimation for l-pid18s: smoothed and unsmoothed. the
smoothed model uses a simple backedoff smoothing method
which leads to signi   cant improvements over the unsmoothed
one. here we compare our id91 algorithm against both
of these models. however unless speci   ed otherwise, the
spectral algorithm of cohen et al. (2013) refers to their best
model, i.e. the smoothed model.

id91

spectral (smoothing)

spectral (no smoothing)

maxtre maxmrg maxent maxtre maxmrg maxent maxtre maxmrg maxent
77.91
77.34
78.94
77.80
79.18
77.37
79.66
77.71

80.01
80.34
80.94
80.86

77.76
77.80
77.94
78.04

77.44
77.62
77.97
77.73

78.09
78.89
79.02
79.46

76.87
77.80
77.17
77.51
75.04

77.85
77.76
78.06
77.89
77.71

77.56
77.85
78.17
77.91
77.07

add
mul

dropout

all

no noise

table 3: results on the development set for german. see table 1 for interpretation of maxtre, maxmrg, maxent and
add, mul and dropout. the number of models used in the    rst three rows for the id91 algorithm is 80: 20 for each
       {0.05, 0.1, 0.15, 0.2}. for the spectral algorithm, it is 20, 5 for each   . the number of latent states is m = 8. for all, we
use all models combined from the    rst three rows. the best    gure in each algorithm block is in boldface.

ing parsing recombination; shindo et al. (2012)
report an accuracy of 92.4 f1 using a bayesian
tree substitution grammar; petrov (2010) reports
an accuracy of 92.0% using product of l-pid18s;
charniak and johnson (2005) report accuracy of
91.4 using a discriminative reranking model; car-
reras et al. (2008) report 91.1 f1 accuracy for a
discriminative, id88-trained model; petrov
and klein (2007) report an accuracy of 90.1 f1.
collins (2003) reports an accuracy of 88.2 f1.

6.2 results for german
for the german experiments, we used the negra
corpus (skut et al., 1997). we use the same setup
as in petrov (2010), and use the    rst 18,602 sen-
tences as a training set, the next 1,000 sentences as
a development set and the last 1,000 sentences as
a test set. this corresponds to an 80%-10%-10%
split of the treebank.

our german experiments follow the same set-
ting as in our english experiments. for the clus-
tering algorithm we generated 80 models, 20 for
each        {0.05, 0.1, 0.15, 0.2}. for the spectral
algorithm, we generate 20 models, 5 for each   .

for the reranking experiment, we had to modify
the bllip parser (charniak and johnson, 2005)
to use the head features from the german tree-
bank. we based our modi   cations on the docu-
mentation for the negra corpus (our modi   ca-
tions are based mostly on mapping of nontermi-
nals to coarse syntactic categories).

preliminary experiments for german, we also
experiment with the number of latent states. on
the development set, we observe that the f1 mea-
sure is: 75.04% for m = 8, 73.44% for m = 16
and 70.84% for m = 24. for the rest of our experi-
ments, we    x the number of latent states at m = 8.

experiments the

oracle
additively-noised
models get an oracle accuracy of 90.58% on
the development set; the multiplicatively-noised

method

t spectral (unsmoothed)

s
e
b

spectral (smoothed)
id91

r spectral (unsmoothed)

e
i
h

spectral (smoothed)
id91

f1
80.88
80.31
81.94
80.64
79.96
83.38

table 4: results on the test set for the german
data. the    rst three results (best) are taken with
the best model in each corresponding block in ta-
ble 3. the last three results (hier) use a hierarchy
of the above tree combination methods.

models get an oracle accuracy of 90.47%; and
the dropout-noised models get an oracle accuracy
of 90.69%. finally all models combined get an
oracle accuracy of 92.38%.

we compared our oracle results to those given
by the spectral algorithm of cohen et al. (2013).
with 20 models for each type of noising scheme,
all spectral models combined achieve an oracle ac-
curacy of 83.45%. the id91 algorithm gets
the oracle score of 90.12% when using the same
number of models.

results results on the development set and on
the test set are given in table 3 and table 4 re-
spectively.

like english, in all three blocks in table 3, de-
coding with the maxent reranking performs the
best. our results continue to improve when fur-
ther combining the output of previous combina-
tion steps. the best result of 82.04% on the devel-
opment set is achieved when we combine, using
maximal tree coverage, all maxent outputs of the
id91 algorithm (the    rst block in table 3).
this also leads to the best result of 83.38% on the
test set. see table 4 for results on the test set.

our results are comparable to state-of-the-art
results for german parsing. for example, petrov
(2010) reports an accuracy of 84.5% using prod-

uct of l-pid18s; petrov and klein (2007) report
an accuracy of 80.1 f1; and dubey (2005) reports
an accuracy of 76.3 f1.

7 discussion

from a theoretical point of view, one of the
great advantages of spectral learning techniques
for latent-variable models is that they yield consis-
tent parameter estimates. our id91 algorithm
for l-pid18 estimation breaks this, but there is a
work-around to obtain an algorithm which would
be statistically consistent.

the main reason that our algorithm is not a con-
sistent estimator is that it relies on id116 clus-
tering, which maximizes a non-convex objective
using hard id91 steps. the id116 algo-
rithm can be viewed as    hard em    for a gaussian
mixture model (gmm), where each latent state is
associated with one of the mixture components in
the gmm. this means that instead of following up
with id116, we could have identi   ed the param-
eters and the posteriors for a gmm, where the ob-
servations correspond to the vectors that we clus-
ter. there are now algorithms, some of which are
spectral, that aim to solve this estimation problem
with theoretical guarantees (vempala and wang,
2004; kannan et al., 2005; moitra and valiant,
2010).

with theoretical guarantees on the correctness
of the posteriors from this step, the subsequent
use of id113 step could
yield consistent parameter estimates. the con-
sistency guarantees will largely depend on the
amount of information that exists in the base fea-
ture functions about the latent states according to
the l-pid18 model.

8 conclusion

we presented a novel estimation algorithm for
latent-variable pid18s. this algorithm is based
on id91 of continuous tree representations,
and it also leads to sparse grammar estimates and
compact models. we also showed how to get a
diverse set of parse tree predictions with this algo-
rithm and also older spectral algorithms. each pre-
diction in the set is made by training an l-pid18
model after perturbing the underlying features that
estimation algorithm uses from the training data.
we showed that such a diverse set of predictions
can be used to improve the parsing accuracy of en-
glish and german.

acknowledgements
the authors would like to thank david mcclosky
for his help with running the bllip parser and the
three anonymous reviewers for their helpful com-
ments. this research was supported by an epsrc
grant (ep/l02411x/1).

references
rapha  el bailly, amaury habrard, and franc  ois denis.
2010. a spectral approach for probabilistic gram-
matical id136 on trees. in proceedings of alt.

ezra w. black, steven abney, daniel p. flickinger,
claudia gdaniec, ralph grishman, philip harri-
son, donald hindle, robert j. p. ingria, freder-
ick jelinek, judith l. klavans, mark y. liberman,
mitchell p. marcus, salim roukos, beatrice san-
torini, and tomek strzalkowski. 1991. a procedure
for quantitatively comparing the syntactic coverage
in proceedings of darpa
of english grammars.
workshop on speech and natural language.

xavier carreras, michael collins, and terry koo.
2008. tag, id145, and the per-
ceptron for ef   cient, feature-rich parsing. in pro-
ceedings of conll.

eugene charniak and mark johnson. 2005. coarse-
to-   ne n-best parsing and maxent discriminative
reranking. in proceedings of acl.

do kook choe, david mcclosky, and eugene char-
niak. 2015. syntactic parse fusion. in proceedings
of emnlp.

shay b. cohen and michael collins. 2014. a prov-
ably correct learning algorithm for latent-variable
pid18s. in proceedings of acl.

shay b. cohen, karl stratos, michael collins, dean p.
foster, and lyle ungar. 2012. spectral learning of
latent-variable pid18s. in proceedings of acl.

shay b. cohen, karl stratos, michael collins, dean p.
foster, and lyle ungar. 2013. experiments with
spectral learning of latent-variable pid18s. in pro-
ceedings of naacl.

michael collins. 2003. head-driven statistical mod-
els for natural language processing. computational
linguistics, 29:589   637.

paramveer dhillon, dean foster, and lyle ungar.
eigenwords: spectral id27s.
2015.
journal of machine learning research (to appear).

amit dubey.

2005. what to do when lexicaliza-
tion fails: parsing german with suf   x analysis and
smoothing. in proceedings of acl.

victoria fossum and kevin knight. 2009. combining
constituent parsers. in proceedings of hlt-naacl.

joshua goodman. 1996. parsing algorithms and met-

rics. in proceedings of acl.

john c. henderson and eric brill. 1999. exploiting
diversity in natural language processing: combining
parsers. in proceedings of emnlp.

daniel hsu, sham m. kakade, and tong zhang. 2009.
a spectral algorithm for learning hidden markov
models. in proceedings of colt.

ravindran kannan, hadi salmasian, and santosh vem-
pala. 2005. the spectral method for general mix-
ture models. in learning theory, volume 3559 of
lecture notes in computer science, pages 444   457.
springer.

kevin knight and jonathan graehl.

an
overview of probabilistic tree transducers for nat-
in computational lin-
ural language processing.
guistics and intelligent text processing, volume 3406
of lecture notes in computer science, pages 1   24.
springer.

2005.

slav petrov and dan klein. 2007. improved id136
in proceedings of hlt-

for unlexicalized parsing.
naacl.

slav petrov, leon barrett, romain thibaux, and dan
2006. learning accurate, compact, and
in proceedings of

klein.
interpretable tree annotation.
coling-acl.

slav petrov. 2010. products of random latent variable

grammars. in proceedings of hlt-naacl.

pushpendre rastogi, benjamin van durme, and raman
arora. 2015. multiview lsa: representation learn-
ing via generalized cca. in proceedings of naacl.

kenji sagae and alon lavie. 2006. parser combina-

tion by reparsing. in proceedings of hlt-naacl.

hiroyuki shindo, yusuke miyao, akinori fujino, and
masaaki nagata. 2012. bayesian symbol-re   ned
tree substitution grammars for syntactic parsing. in
proceedings of acl.

annie louis and shay b. cohen. 2015. conversation
trees: a grammar model for topic structure in fo-
rums. in proceedings of emnlp.

wojciech skut, brigitte krenn, thorsten brants, and
hans uszkoreit. 1997. an annotation scheme for
free word order languages. in proceedings of anlp.

nitish srivastava, geoffrey hinton, alex krizhevsky,
ilya sutskever, and ruslan salakhutdinov. 2014.
dropout: a simple way to prevent neural networks
from over   tting. journal of machine learning re-
search, 15(1):1929   1958.

karl stratos, do-kyum kim, michael collins, and
daniel hsu. 2014. a spectral algorithm for learn-
ing class-based id165 models of natural language.
proceedings of uai.

hans van halteren, jakub zavrel, and walter daele-
mans. 2001. improving accuracy in word class tag-
ging through the combination of machine learning
systems. computational linguistics, 27(2):199   229.

santosh vempala and grant wang. 2004. a spectral
algorithm for learning mixture models. journal of
computer and system sciences, 68(4):841   860.

sida wang, mengqiu wang, stefan wager, percy
liang, and christopher d manning. 2013. feature
noising for log-linear id170. in pro-
ceedings of emnlp.

hui zhang, min zhang, chew lim tan, and haizhou
li. 2009. k-best combination of syntactic parsers.
in proceedings of emnlp.

ang lu, weiran wang, mohit bansal, kevin gimpel,
and karen livescu. 2015. deep multilingual corre-
lation for improved id27s. in proceed-
ings of naacl.

franco m. luque, ariadna quattoni, borja balle, and
xavier carreras. 2012. spectral learning for non-
in proceedings
deterministic id33.
of eacl.

wolfgang macherey and franz josef och. 2007. an
empirical study on computing consensus transla-
tions from multiple machine translation systems. in
proceedings of emnlp-conll.

mitchell p. marcus, beatrice santorini, and mary a.
marcinkiewicz. 1993. building a large annotated
corpus of english: the id32. computa-
tional linguistics, 19:313   330.

andr  e f. t. martins, noah a. smith, eric p. xing,
m  ario a. t. figueiredo, and pedro m. q. aguiar.
2010. turboparsers: id33 by ap-
proximate variational id136. in proceedings of
emnlp.

takuya matsuzaki, yusuke miyao, and junichi tsujii.
2005. probabilistic id18 with latent annotations. in
proceedings of acl.

ankur moitra and gregory valiant. 2010. settling the
polynomial learnability of mixtures of gaussians. in
proceedings of ieee symposium on foundations of
computer science (focs).

thang nguyen, jordan boyd-graber, jeffrey lund,
kevin seppi, and eric ringger. 2015. is your an-
chor going up or down? fast and accurate super-
vised topic models. in proceedings of naacl.

