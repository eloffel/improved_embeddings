motifs in temporal networks

   
ashwin paranjape
stanford university

ashwinpp@stanford.edu

   
austin r. benson
stanford university

arbenson@stanford.edu

jure leskovec
stanford university

jure@cs.stanford.edu

6
1
0
2
 
c
e
d
9
2

 

 
 
]
i
s
.
s
c
[
 
 

1
v
9
5
2
9
0

.

2
1
6
1
:
v
i
x
r
a

abstract
networks are a fundamental tool for modeling complex systems in
a variety of domains including social and communication networks
as well as biology and neuroscience. small subgraph patterns in
networks, called network motifs, are crucial to understanding the
structure and function of these systems. however, the role of
network motifs in temporal networks, which contain many times-
tamped links between the nodes, is not yet well understood.

here we develop a notion of a temporal network motif as an ele-
mentary unit of temporal networks and provide a general method-
ology for counting such motifs. we de   ne temporal network motifs
as induced subgraphs on sequences of temporal edges, design fast
algorithms for counting temporal motifs, and prove their runtime
complexity. our fast algorithms achieve up to 56.5x speedup com-
pared to a baseline method. furthermore, we use our algorithms to
count temporal motifs in a variety of networks. results show that
networks from different domains have signi   cantly different mo-
tif counts, whereas networks from the same domain tend to have
similar motif counts. we also    nd that different motifs occur at
different time scales, which provides further insights into structure
and function of temporal networks.

1.

introduction

networks provide an abstraction for studying complex systems
in a broad set of disciplines, ranging from social and communica-
tion networks to molecular biology and neuroscience [20]. typi-
cally, these systems are modeled as static graphs that describe re-
lationships between objects (nodes) and links between the objects
(edges). however, many systems are not static as the links between
objects dynamically change over time [8]. such temporal networks
can be represented by a series of timestamped edges, or temporal
edges. for example, a network of email or instant message commu-
nication can be represented as a sequence of timestamped directed
edges, one for every message that is sent from one person to an-
other. similar representations can be used to model computer net-
works, phone calls,    nancial transactions, and biological signaling
networks.
   these authors contributed equally to this work.

permission to make digital or hard copies of all or part of this work for personal or
classroom use is granted without fee provided that copies are not made or distributed
for pro   t or commercial advantage and that copies bear this notice and the full cita-
tion on the    rst page. copyrights for components of this work owned by others than
acm must be honored. abstracting with credit is permitted. to copy otherwise, or re-
publish, to post on servers or to redistribute to lists, requires prior speci   c permission
and/or a fee. request permissions from permissions@acm.org.
wsdm    17, february 6   10, 2017, cambridge, united kingdom.
c(cid:13) 2017 acm. isbn 978-1-4503-4675-7/17/02. . . $15.00
doi: http://dx.doi.org/10.1145/3018661.3018731

figure 1: temporal graphs and   -temporal motifs. a: a tempo-
ral graph with nine temporal edges. each edge has a timestamp
(listed here in seconds). b: example 3-node, 3-edge   -temporal
motif m. the edge labels correspond to the ordering of the
edges. c: instances of the   -temporal motif m in the graph for
   = 10 seconds. the crossed-out patterns are not instances of
m because either the edge sequence is out of order or the edges
do not all occur within the time window   .

while such temporal networks are ubiquitous, there are few tools
for modeling and characterizing the underlying structure of such
dynamical systems. existing methods either model the networks
as strictly growing where a pair of nodes connect once and stay
connected forever [2, 10, 17] or aggregate temporal information
into a sequence of snapshots [1, 6, 23]. these techniques fail to
fully capture the richness of the temporal information in the data.
characterizing temporal networks also brings a number of in-
teresting challenges that distinguish it from the analysis of static
networks. for example, while the number of nodes and pairs of
connected nodes can be of manageable size, the number of tempo-
ral edges may be very large and thus ef   cient algorithms are needed
when analyzing such data. another interesting challenge is that pat-
terns in temporal networks can occur at different time scales. for
example, in telephone call networks, reciprocation (that is, a person
returning a call) can occur on very short time intervals, while more
intricate patterns (e.g., person a calling person b, who then calls
c) may occur at larger time scales. lastly, there are many possible
temporal patterns as the order as well as the sequence of edges play
an important role.
present work: temporal network motifs. here, we provide a
general methodology for analyzing temporal networks. we de   ne
temporal networks as a set of nodes and a collection of directed
temporal edges, where each edge has a timestamp. for example,
fig. 1a illustrates a small temporal network with nine temporal
edges between    ve ordered pairs of nodes.

our analytical approach is based on generalizing the notion of
network motifs to temporal networks. in static networks, network
motifs or graphlets are de   ned as small induced subgraphs occur-
ring in a bigger network structure [4, 19, 29]. we extend static mo-

acb123abcd25s17s,28s,30s,35s15s,32s31s14sabc25s28s32sabc25s30s32scda31s32s35sadc14s17s15sadc14s28s32stifs to temporal networks and de   ne   -temporal motifs, where all
the edges in a given motif m have to occur inside the time period
of    time units. these   -temporal motifs simultaneously account
for ordering of edges and a temporal window in which edges can
occur. for example, fig. 1b shows a motif on three nodes and three
edges, where the edge label denotes the order in which the edges
appear. while we focus on directed edges with a single timestamp
in this work, our methodology seaid113ssly generalizes to common
variations on this model. for example, our methods can incorporate
timestamps with durations (common in telephone call networks),
colored edges that identify different types of connections, and tem-
poral networks with undirected edges.

we then consider the problem of counting how many times does
each   -temporal motif occur in a given temporal network. we de-
velop a general algorithm for counting temporal network motifs
de   ned by any number of nodes and edges that avoids enumeration
over subsets of temporal edges and whose complexity depends on
the structure of the static graph induced by the temporal motif. for
motifs de   ned by a constant number of temporal edges between 2
nodes, this general algorithm is optimal up to constant factors   it
runs in o(m) time, where m is the number of temporal edges.

furthermore, we design fast variations of the algorithm that al-
low for counting certain classes of   -temporal motifs including star
and triangle patterns. these algorithms are based on a common
framework for managing summary counts in speci   ed time win-
dows. for star motifs with 3 nodes and 3 temporal edges, we again
achieve a running time linear in the input, i.e., o(m) time. given a
temporal graph with    induced triangles in its induced static graph,
our fast algorithm counts temporal triangle motifs with 3 tempo-
ral edges in o(   1/2m) worst-case time. in contrast, any algorithm
that processes triangles individually takes o(   m) worst-case time.
in practice, our fast temporal triangle counting algorithm is up to
56 times faster than a competitive baseline and runs in just a couple
of hours on a network with over two billion temporal edges.

our algorithmic framework enables us to study the structure
of several complex systems. for example, we explore the differ-
ences in human communication patterns by analyzing motif fre-
quencies in text message, facebook wall post, email and private
online message network datasets. temporal network motif counts
reveal that text messaging and facebook wall posting are domi-
nated by    blocking    communication, where a user only engages
with one other user at a time, whereas email is mostly characterized
by    non-blocking    communication as individuals send out several
emails in a row. furthermore, private online messaging contains a
mixture of blocking and non-blocking behavior.

temporal network motifs can also be used to measure the fre-
quency of patterns at different time scales. for example, the differ-
ence in   -temporal motif counts for    = 60 minutes and    = 30
minutes counts only the motifs that take at least 30 minutes and
at most 60 minutes to form. with this type of analysis, we    nd
that certain question-and-answer patterns on stack over   ow need
at least 30 minutes to develop. we also see that in online private
messaging, star patterns constructed by outgoing messages sent by
one user tend to increase in frequency from time scales of 1 to 20
minutes before peaking and then declining in frequency.

all in all, our work de   nes a    exible notion of motifs in temporal
networks and provides ef   cient algorithms for counting them. it
enables new analyses in a variety of scienti   c domains and paves a
new way for modeling dynamic complex systems.

2. related work

our work builds upon the rich literature on network motifs in
static graphs, where these models have proved crucial to under-

standing the mechanisms driving complex systems [19] and to char-
acterizing classes of static networks [25, 29]. furthermore, motifs
are critical for understanding the higher-order organizational pat-
terns in networks [3, 4]. on the algorithmic side, a large amount
of research has been devoted simply to counting triangles in undi-
rected static graphs [14].

prior de   nitions of temporal network motifs either do not ac-
count for edge ordering [30], only have heuristic counting algo-
rithms [7], or assume temporal edges in a motif must be consecu-
tive events for a node [13]. in the last case, the restrictive de   nition
permits fast counting algorithms but misses important structures.
for example, many related edges occurring in a short burst at a
node would not be counted together. in contrast,   -temporal motifs
capture every occasion that edges form a particular pattern within
the prescribed time window.

there are several studies on pattern formation in growing net-
works where one only considers the addition of edges to a static
graph over time. in this context, motif-like patterns have been used
to create evolution rules that govern the ways that networks de-
velop [5, 24]. the way we consider ordering of temporal edges in
our de   nition of   -temporal motifs is similar in spirit. there are
also several analyses on the formation of triangles in a variety of
social networks [9, 12, 15]. in contrast, in the temporal graphs we
study here, three nodes may form a triangle several times.

3. preliminaries

we now provide formal de   nitions of temporal graphs and   -
temporal motifs. in section 4, we provide algorithms for counting
the number of   -temporal motifs in a given temporal graph.
temporal edges and graphs. we de   ne a temporal edge to be a
timestamped directed edge between an ordered pair of nodes. we
call a collection of temporal edges a temporal graph (fig. 1a). for-
mally, a temporal graph t on a node set v is a collection of tuples
(ui, vi, ti), i = 1, . . . , m, where each ui and vi are elements of v
and each ti is a timestamp in r. we refer to a speci   c (ui, vi, ti)
tuple as a temporal edge. there can be many temporal edges di-
rected from u to v, and we refer to them as edges between u and
v. we assume that the timestamps ti are unique so that the tuples
may be strictly ordered. this assumption makes the presentation of
the de   nitions and algorithms clearer, but our methods can easily
be adapted to the case when timestamps are not unique. when it is
clear from context, we refer to a temporal edge as simply an edge.
finally, by ignoring timestamps and duplicate edges, the temporal
graph induces a standard directed graph, which we call the static
graph g of t with static edges, i.e., (u, v) is an edge in g if and
only if there is some temporal edge (u, v, t) in t .
  -temporal motifs and motif instances. we formalize   -temporal
motifs with the following de   nition.
de   nition. a k-node, l-edge,   -temporal motif is a sequence of l
edges, m = (u1, v1, t1), (u2, v2, t2) . . . , (ul, vl, tl) that are time-
ordered within a    duration, i.e., t1 < t2 . . . < tl and tl     t1       ,
such that the induced static graph from the edges is connected and
has k nodes.

note that with this de   nition, many edges between the same pair
of nodes may occur in the motif m. also, we note that the purpose
of the timestamps is to induce an ordering on the edges. fig. 1b
illustrates a particular 3-node, 3-edge   -temporal motif.

the above de   nition provides a template for a particular pattern,
and we are interested in how many times a given pattern occurs
in a dataset. intuitively, a collection of edges in a given temporal
graph is an instance of a   -temporal motif m if it matches the same
edge pattern and all of the edges occur in the right order within the

algorithm 1: algorithm for counting the number of instances
of all possible l-edge   -temporal motifs in an ordered sequence
of temporal edges. we assume the keys of counts[  ] are ac-
cessed in order of length.
input: sequence s(cid:48) of edges (e1 = (u1, v1), t1), . . . ,

(el, tl) with t1 < . . . < tl, time window   

output: number of instances of each l-edge   -temporal motif
start     1, counts     counter(default = 0)
for end = 1, . . . , l :

m contained in the sequence

while tstart +    < tend do

decrementcounts(estart), start += 1

incrementcounts(eend)

return counts
procedure decrementcounts(e)

counts[e]    = 1
for suf   x in counts.keys of length < l     1 :

counts[concat(e, suf   x)]    = counts[suf   x]

procedure incrementcounts(e)

for pre   x in counts.keys.reverse() of length < l :

counts[concat(pre   x, e)] += counts[pre   x]

counts[e] += 1

1. identify all instances h(cid:48) of the static motif h induced by m
within the static graph g induced by the temporal graph t
(e.g., there are three instances of h induced by m in fig. 1).
2. for each static motif instance h(cid:48), gather all temporal edges
between pairs of nodes forming an edge in h(cid:48) into an ordered
sequence s(cid:48) = (u1, v1, t1), . . ., (ul, vl, tl).
3. count the number of (potentially non-contiguous) subse-
quences of edges in s(cid:48) occurring within    time units that
correspond to instances of m.

the    rst step can use known algorithms for enumerating mo-
tifs in static graphs [27], and the second step is a simple matter
of fetching the appropriate temporal edges. to perform the third
step ef   ciently, we develop a id145 approach for
counting the number of subsequences (instances of motif m) that
match a particular pattern within a larger sequence (s(cid:48)). the key
idea is that, as we stream through an input sequence of edges, the
count of a given length-l pattern (i.e., motif) with a given    nal edge
is computed from the current count of the length-(l     1) pre   x of
the pattern. inductively, we maintain auxiliary counters of all of
the pre   xes of the pattern (motif). second, we also require that all
edges in the motif be at most    time apart. thus, we use the no-
tion of a moving time window such that any two edges in the time
window are at most    time apart. the auxiliary counters now keep
track of only the subsequences occurring within the current time
window. last, it is important to note that the algorithm only counts
the number of instances of motifs rather than enumerating them.
alg. 1 counts all possible l-edge motifs that occur in a given se-
quence of edges. the data structure counts[  ] maintains auxiliary
counts of all (ordered) patterns of length at most l. speci   cally,
counts[e1        er] is the number of times the subsequence [e1        er]
occurs in the current time window (if r < l) or the number of times
the subsequence has occurred within all time windows of length   
(if r = l). we also assume the keys of counts[  ] are accessed in
order of length. moving the time window forward by adding a new
edge into the window, all edges (e = (u, v), t) farther than    time
from the new edge are removed from the window and the appropri-
ate counts are decremented (the decrementcounts() method). first,

figure 2: example execution of alg. 1 for counting instances
of the   -temporal motif m in fig. 1. each column shows the
value of counters at the end of the for loop that processes
temporal edges. color indicates change in the variable: in-
cremented (blue), decremented (red), incremented and decre-
mented (purple), or no change (black). at the end of execution,
counts[(a, b)(a, c)(c, a)] = 2 for the two instances of the tempo-
ral motif m with center node a. here we only show the counters
needed to count m; in total, alg. 1 maintains 39 total counters
for this input edge sequence, 25 of which are non-zero.
   time window (fig. 1c). formally, we say that any time-ordered
sequence s = (w1, x1, t(cid:48)
l) of l unique edges is an
instance of the motif m = (u1, v1, t1), . . . , (ul, vl, tl) if

1), . . . , (wl, xl, t(cid:48)

ui and f (xi) = vi, i = 1, . . . , l, and

1. there exists a bijection f on the vertices such that f (wi) =
2. the edges all occur within    time, i.e., t(cid:48)
a central goal of this work is to count the number of ordered
subsets of edges from a temporal graph t that are instances of a
particular motif. in other words, given a k-node, l-edge   -temporal

motif, we seek to    nd how many of the l!(cid:0)m

(cid:1) ordered length-l se-

1       

l     t(cid:48)

quences of edges in the temporal graph t are instances of the motif.
a naive approach to this problem would be to simply enumerate all
ordered subsets and then check if it is an instance of the motif. in
modern datasets, the number of edges m is typically quite large
(we analyze a dataset in section 5 with over two billion edges), and
this approach is impractical even for l = 2. in the following sec-
tion, we discuss several faster algorithms for counting the number
of instances of   -temporal motifs in a temporal graph.

l

4. algorithms

we now present several algorithms for exactly counting the num-
ber of instances of   -temporal motifs in a temporal graph. we
   rst present a general counting algorithm in section 4.1, which can
count instances of any k-node, l-edge temporal motif faster than
simply enumerating over all size-l ordered subsets of edges. this
algorithm is optimal for counting 2-node temporal motifs in the
sense that it is linear in the number of edges in the temporal graph.
in section 4.2, we provide faster, specialized algorithms for count-
ing speci   c types of 3-node, 3-edge temporal motifs (fig. 3).

4.1 general counting framework

we begin with a general framework for counting the number of
instances of a k-node, l-edge temporal motif m. to start, consider
h to be the static directed graph induced by the edges of m. a
sequence of temporal edges s is an instance of m if and only if
the static subgraph induced by edges in s is isomorphic to h, the
ordering of the edges in s matches the order in m, and all the
edges in s span a time window of at most    time units. this leads
to the following general algorithm for counting instances of m in
a temporal graph t :

abcthe single edge counts ([e]) are updated. based on these updates,
length-2 subsequences formed with e as its    rst edge are updated
and so on, up through length-(l     1) subsequences. on the other
hand, when an edge e is added to the window, similar updates take
place, but in reverse order, from longest to shortest subsequences,
in order to increment counts in subsequences where e is the last
edge (the incrementcounts() method). importantly, length-l subse-
quence counts are incremented in this step but never decremented.
as the time window moves from the beginning to the end of the
sequence of edges, the algorithm accumulates counts of all length-l
subsequences in all possible time windows of length   .
fig. 2 shows the execution of the alg. 1 for a particular sequence
of edges. note that the    gure only displays values of counts[  ]
for contiguous subsequences of the motif m, but the algorithm
keeps counts for other subsequences as well. in general, there are
o(l2) contiguous subsequences of an l-edge motif m, and there
are o(|h|l) total keys in counts[  ], where |h| is the number of
edges in the static subgraph h induced by m, in order to count all
l-edge motifs in the sequence (i.e., not just motif m).

we now analyze the complexity of the overall 3-step algorithm.
we assume that the temporal graph t has edges sorted by time-
stamps, which is reasonable if edges are logged in their order of
occurrence, and we pre-process t in linear time such that we can
access the sorted list of all edges between u and v in o(1) time.
constructing the time-sorted sequence s(cid:48) in step 2 of the algorithm
then takes o(log(|h|)|s(cid:48)|) time. each edge inputted to alg. 1 is
processed exactly twice: once to increment counts when it enters
the time window and once to decrement counts when it exits the
time window. as presented in alg. 1, each update changes o(|h|l)
counters resulting in an overall complexity of o(|h|l|s(cid:48)|). how-
ever, one could modify alg. 1 to only update counts for contigu-
ous subsequences of the sequence m, which would change o(l2)
counters and have overall complexity o(l2|s(cid:48)|). we are typically
only interested in small constant values of |h| and l (for our exper-
iments in section 5, |h|     3 and l = 3), in which case the running
time is linear in the size of the input to the algorithm, i.e., o(|s(cid:48)|).
in the remainder of this section we analyze our 3-step algorithm
with respect to different types of motifs (2-node, stars, and trian-
gles) and argue bene   ts as well as de   ciencies of the proposed
framework. we show that for 2-node motifs, our general counting
framework takes time linear in the total number of edges m. since
all the input data needs to be examined for computing exact counts,
this means the algorithm is optimal for 2-node motifs. however, we
also show that for star and triangle motifs the algorithm is not opti-
mal, which then motivates us to design faster algorithms in sec. 4.2.
general algorithm for 2-node motifs. we    rst show how to map
2-node motifs to the framework described above. any induced
graph h of a 2-node   -temporal motif is either a single or a bidirec-
tional edge. in either case, it is straightforward to enumerate over
all instances of h in the static graph. this leads to the following
procedure: (1) for each pair of nodes u and v for which there is at
least one edge, gather and sort the edges in either direction between
u and v; (2) call alg. 1 with these edges. the obtain the total motif
count the counts from each call to alg. 1 are then summed together.
we only need to input each edge to alg. 1 once, and under the
assumption that we can access the sorted directed edges from one
node to another in o(1) time, the merging of edges into sorted or-
der takes linear time. therefore, the total running time is o(2lm),
which is linear in the number of temporal edges m. we are mostly
interested in small patterns, i.e., cases when l is a small constant.
thus, this methodology is optimal (linear in the input, m) for
counting 2-node   -temporal motif instances.
general algorithm for star motifs. next, we consider k-node, l-

2

2

3

3

2

2

1, 3

m1,1

2

1, 3

m2,1

13

m1,2

2

13

m2,2

1, 3

2

13

2

m3,1

m3,2

2

2

3

3

2

3

1
m1,3

1
m2,3

1
m3,3

1
m1,4

1
m2,4

1
m3,4

1, 3

2

13

2

m4,1

m4,2

2, 3

1
m4,3

1
m4,4

2

3

1
m1,5

2, 3

1
m2,5

1
m3,5

1
m4,5

3

3

3

12

m5,5

3

1, 2

2

2

2, 3

3

2

2

2

3

3

3

3

1
m1,6

1
m2,6

1
m3,6

1
m4,6

12

m5,6

1, 2

2, 3

3

2

3

3

1

2, 3
m5,2

12

3

m5,3

12

m5,4

1, 3

2
m5,1

1, 2, 3

1, 2

3
m6,2

1, 2

3

1, 2

m6,6

m6,5

m6,4

m6,3

m6,1
figure 3: all 2-node and 3-node, 3-edge   -temporal motifs. the
green background highlights the four 2-node motifs (bottom
left) and the grey background highlights the eight triangles.
the 24 other motifs are stars. we index the 36 motifs mi,j by
6 rows and 6 columns. the    rst edge in each motif is from the
green to the orange node. the second edge is the same along
each row, and the third edge is the same along each column.
edge star motifs m, whose induced static graph h consists of a
center node and k     1 neighbors, where edges may occur in either
direction between the center node and a neighbor node. for exam-
ple, in the top left corner of fig. 3, m1,1 is a star motif with all
edges pointing toward the center node. in such motifs, the induced
static graph h contains at most 2(k   1) = 2k   2 static edges   one
incoming and outgoing edge from the center node to each neighbor
node. we have the following method for counting the number of
instances of k-node, l-edge star motifs: (1) for each node u in the
static graph and for each unique set of k     1 neighbors, gather and
sort the edges in either direction between u and the neighbors; (2)
count the number of instances of m using alg. 1. the counts from
each call to alg. 1 are summed over all center nodes.
the major drawback of this approach is that we have to loop over
each size-(k    1) neighbor set. this can be prohibitively expensive
even when k = 3 if the center node has large degree. in section 4.2,
we shall design an algorithm that avoids this issue for the case when
the star motif has l = 3 edges and k = 3.
general algorithm for triangle motifs.
in triangle motifs, the
induced graph h consists of 3 nodes and at least one directed edge
between any pair of nodes (see fig. 3 for all eight of the 3-edge
triangle motifs). the induced static graph h of m contains at least
three and at most six static edges. a straightforward algorithm for
counting l-edge triangle motifs in a temporal graph t is:

1. use a fast static graph triangle enumeration algorithm to    nd

all triangles in the static graph g induced by t [14].

2. for each triangle (u, v, w), merge all temporal edges from
each pair of nodes to get a time-sorted list of edges. use
alg. 1 to count the number of instances of m.

this approach is problematic as the edges between a pair of nodes
may participate in many triangles. fig. 4 shows a worst-case exam-
3) with    =    .
ple for the motif m = (w, u, t(cid:48)
in this case, the timestamps are ordered by their index. there are
m     2n edges between u and v, and each of these edges forms an
instance of m with every wi. thus, the overall worst-case running
time of the algorithm is o(trienum + m   ), where trienum is the
time to enumerate the number of triangles    in the static graph. in

1), (w, v, t(cid:48)

2), (u, v, t(cid:48)

u

t2n+1, . . . , tm
t2n   1

t1

t3

t2

w1

w2

t4

. . .
. . .

v

t2n

wn

figure 4: worst-case example for counting triangular motifs
with alg. 1.
the following section, we devise an algorithm that signi   cantly re-
   
duces the dependency on    from linear to sub-linear (speci   cally,

  ) when there are l = 3 edges.
4.2 faster algorithms

the general counting algorithm from the previous subsection
counts the number of instances of any k-node, l-edge   -temporal
motif, and is also optimal for 2-node motifs. however, the com-
putational cost may be expensive for other motifs such as stars and
triangles. we now develop specialized algorithms that count cer-
tain motif classes faster. speci   cally, we design faster algorithms
for counting all 3-node, 3-edge star and triangle motifs (fig. 3 il-
lustrates these motifs). our algorithm for stars is linear in the input
size, so it is optimal up to constant factors.
fast algorithm for 3-node, 3-edge stars. with 3-node, 3-edge
star motifs, the key drawback of using the previous algorithmic ap-
proach would be that we would have to loop over all pairs of neigh-
bors given a center node. instead, we will count all instances of star
motifs for a given center node in just a single pass over the edges
adjacent to the center node.

we use a id145 approach for counting star mo-
tifs. first, note that every temporal edge in a star with center u is
de   ned by (1) a neighbor node, (2) a direction of the edge (outward
from or inward to u), and (3) the timestamp. with this insight we
then notice that there are 3 classes of star motifs on 3 nodes and 3
edges:

pre

1, 2

3

post

1

2, 3

mid

1, 3

2

where each class has 23 = 8 motifs for each of the possible direc-
tions on the three edges.

now, suppose we process the time-ordered sequence of edges
containing the center node u. we maintain the following counters
when processing an edge with timestamp tj:
    pre_sum[dir1, dir2] is the number of sequentially ordered
pairs of edges in [tj       , tj) where the    rst edge points in
direction dir1 and the second edge points in direction dir2
    post_sum[dir1, dir2] is the analogous counter for the time
    mid_sum[dir1, dir2] is the number of pairs of edges where
the    rst edge is in direction dir1 and occurred at time t < tj
and the second edge is in direction dir2 and occurred at time
t(cid:48) > tj such that t(cid:48)     t       .

window (tj, tj +   ].

if we are currently processing an edge, the    pre    class gets
pre_sum[dir1, dir2] new motif instances for any choice of direc-
tions dir1 and dir2 (specifying the    rst two edge directions) and
the current edge serves as the third edge in the motif (hence speci-
fying the third edge direction). similar updates are made with the
post_sum[  ,  ] and mid_sum[  ,  ] counters, where the current edge
serves as the    rst or second edge in the motif, respectively.

in order for our algorithm to be ef   cient, we must quickly update
our counters. to aid in this, we introduce two additional counters:

algorithm 2: algorithmic framework for faster counting of
3-node, 3-edge star and triangle temporal motifs. the fast
star counting method (alg. 3) and triangle counting method
(alg. 4) implement different versions of the push(), pop(), and
processcurrent() subroutines.
input: sequence of edges (e1 = (u1, v1), t1), . . . , (el, tl)

with t1 < . . . < tl, time window   

initialize counters pre_nodes, post_nodes, mid_sum, pre_sum,
and post_sum; start     1, end     1
for j = 1, . . . , l :

while tstart +    < tj do
while tend     tj +    do

pop(pre_nodes, pre_sum, estart), start += 1

push(post_nodes, post_sum, eend), end += 1

pop(post_nodes, post_sum, ej)
processcurrent(ej)
push(pre_nodes, pre_sum, ej)

    pre_nodes[dir, vi] is the number of times node vi has ap-
peared in an edge with u with direction dir in the time win-
dow [tj       , tj)
    post_nodes[dir, vi] is the analogous counter but for the time

window (tj, tj +   ].

following the ideas of alg. 1, it is easy to update these coun-
ters when we process a new edge. consequently, pre_sum[  ,  ],
post_sum[  ,  ], and mid_sum[  ,  ] can be maintained when process-
ing an edge with just a few simple primitives:
    push() and pop() update the counts for pre_nodes[  ,  ],
post_nodes[  ,  ], pre_sum[  ,  ] and post_sum[  ,  ] when edges
enter and leave the time windows [tj       , tj) and (tj, tj +   ].
    processcurrent() updates motif counts involving the current
edge and updates the counter mid_sum[  ,  ].

we describe the general procedure in alg. 2, which will
also serve as the basis for our fast
triangle counting proce-
dure, and alg. 3 implements the subroutines push(), pop(), and
processcurrent() for counting instances of 3-node, 3-edge star mo-
tifs. the count_pre[  ,  ,  ], count_post[  ,  ,  ], and count_mid[  ,  ,  ]
counters in alg. 3 maintain the counts of the three different classes
of stars described above.

finally, we note that our counting scheme incorrectly includes
instances of 2-node motifs such as m = (u, vi, t1), (u, vi, t2),
(u, vi, t3), but we can use the ef   cient 2-node motif counting algo-
rithm to account for this. putting everything together, we have the
following procedure:

1. for each node u in the temporal graph t , get a time-ordered

list of all edges containing u.

2. use algs. 2 and 3 to count star motif instances.
3. for each neighbor v of a star center u, subtract the 2-node

motif counts using alg. 1.

if the m edges of t are time-sorted, the    rst step can be done
in linear time. the second and third steps run in linear time in the
input size. each edge is used in steps 2 and 3 exactly twice: once
for each end point as the center node. thus, the overall complexity
of the algorithm is o(m), which is optimal up to constant factors.
fast algorithm for 3-edge triangle motifs. while our fast star
counting routine relied on counting motif instances for all edges
adjacent to a given node, our fast triangle algorithm is based on
counting instances for all edges adjacent to a given pair of nodes.
speci   cally, given a pair of nodes u and v and a list of common
neighbors w1, . . . , wd, we count the number of motif instances for
triangles (wi, u, v). given all of the edges between these three

algorithm 3: implementation of alg. 2 subroutines for ef   -
ciently counting instances of 3-node, 3-edge star motifs. tem-
poral edges are speci   ed by a neighbor nbr, a direction dir (in-
coming or outgoing), and a timestamp. the    :    notation repre-
sents a selection of all indices in an array.
initialize counters count_pre, count_post, count_mid
procedure push(node_count, sum, e = (nbr, dir))

sum[:, dir] += node_count[:, nbr]
node_count[dir, nbr] += 1

procedure pop(node_count, sum, e = (nbr, dir))

node_count[dir, nbr]    = 1
sum[dir, :]    = node_count[:, nbr]

procedure processcurrent(e = (nbr, dir))
mid_sum[:, dir]    = pre_nodes[:, nbr]
count_pre[:, :, dir] += pre_sum[:, :]
count_post[dir, :, :] += post_sum[:, :]
count_mid[:, dir, :] += mid_sum[:, :]
mid_sum[dir, :] += post_nodes[:, nbr]
return count_pre, count_post, count_mid

nodes, the counting procedures are nearly identical to the case of
stars. we use the same general counting method (alg. 2), but the
behavior of the subroutines push(), pop(), and processcurrent()
depends on whether or not the edge is between u and v.

these methods are implemented in alg. 4. the input is a list of
edges adjacent to a given pair of neighbors u and v, where each
edge consists of four pieces of information: (1) a neighbor node
nbr, (2) an indicator of whether or not the node nbr connects to
node u or node v, (3) the direction dir of the edge, and (4) the time-
stamp. the node counters (pre_nodes[  ,  ,  ] and post_nodes[  ,  ,  ])
in alg. 4 have an extra dimension compared to alg. 3 to indicate
whether the counts correspond to edges containing node u or node
v (denoted by    uorv   ). similarly, the sum counters (pre_sum[  ,  ,  ],
mid_sum[  ,  ,  ] and post_sum[  ,  ,  ]) have an extra dimension to de-
note if the    rst edge is incident on node u or node v.

recall that the problem with counting triangle motifs by the gen-
eral framework in alg. 1 is that a pair of nodes with many edges
might have to be counted for many triangles in the graph. however,
with alg. 4, we can simultaneously count all triangles adjacent to
a given pair of nodes. what remains is that we must assign each
triangle in the static graph to a pair of nodes. here, we propose to
assign each triangle to the pair of nodes in that triangle containing
the largest number of edges, which is sketched in alg. 5. alg. 5
aims to process as many triangles as possible for pairs of nodes
with many edges. the following theorem says that this is faster
   
than simply counting for each triangle (described in section 4.1).
speci   cally, we reduce o(m   ) complexity to o(m
   
theorem. in the worse case, alg. 5 runs in time o(trienum +
   ), where trienum is the time to enumerate all triangles in the
m
static graph g, m is the total number of temporal edges, and    is
the number of static triangles in g.
proof. let   i be the number of edges between the ith pair of nodes
with at least one edge, and let pi     1 be the number of times that
edges on this pair are used in a call to alg. 4 by alg. 5. since
alg. 4 runs in linear time in the number of edges in its input, the

total running time is on the order of(cid:80)

   ).

the   i are    xed, and we wish to    nd the values of pi that maxi-
mize the summation. without loss of generality, assume that the   i
are in decreasing order so that the most number of edges between a
pair of nodes is   1. consequently, pi     i. note that each triangle
contributes to at most a constant repeat processing of edges for a
i pi     c   for some constant c. the

given pair of nodes. hence,(cid:80)

i   ipi.

algorithm 4: implementation of alg. 2 subroutines for count-
ing 3-edge triangle motifs containing a speci   ed pair of nodes u
and v. temporal edges are speci   ed by a neighbor nbr, a direc-
tion dir (incoming or outgoing), an indicator    uorv    denoting if
the edge connects to u or v, and a timestamp. the    :    notation
represents a selection of all indices in an array.
initialize counter count
procedure push(node_count, sum, e = (nbr, dir, uorv))

if nbr     {u, v} then return
sum[1-uorv, :, dir] += node_count[1-uorv, :, nbr]
node_count[uorv, dir, nbr] += 1

procedure pop(node_count, sum, e = (nbr, dir, uorv))

if nbr     {u, v} then return
node_count[uorv, dir, nbr]    = 1
sum[uorv, dir, :]    = node_count[1-uorv, :, nbr]
if nbr /    {u, v} then

procedure processcurrent(e = (nbr, dir, uorv))

mid_sum[1-uorv, :, dir]    = pre_nodes[1-uorv, :, nbr]
mid_sum[uorv, dir, :] += post_nodes[1-uorv, :, nbr]

else

utov = (nbr == u) xor dir
for 0     i, j, k     1 :

count[i, j, k] += mid_sum[j xor utov, i, k]
+post_sum[i xor utov, j, 1     k]
+pre_sum[k xor utov, 1     i, 1     j]

/* count key map to fig. 3:
/* [0, 0, 0] (cid:55)    m1,3, [0, 0, 1] (cid:55)    m1,4, [0, 1, 0] (cid:55)    m2,3
/* [0, 1, 1] (cid:55)    m2,4, [1, 0, 0] (cid:55)    m3,5, [1, 0, 1] (cid:55)    m3,6
/* [1, 1, 0] (cid:55)    m4,5, [1, 1, 1] (cid:55)    m4,6
return count

*/
*/
*/
*/

algorithm 5: sketch of fast algorithm for counting the number
of 3-edge   -temporal triangle motifs in a temporal graph t .
enumerate all triangles in the undirected static graph g of t
       number of temporal edges on each static edge e in g
foreach static triangle     = (e1, e2, e3) in g do

emax = arg maxe      {  e}
foreach e in     do add emax to edge set (cid:96)e
/* e(cid:48)     (cid:96)e if e         and     assigned to e(cid:48)

*/

foreach temporal edge (e = (u, v), t) in time-sorted t do
foreach e(cid:48) in (cid:96)e do append (e, t) to temporal-edge list ae(cid:48)
/* (e, t)     ae(cid:48) if e         and     assigned to e(cid:48)
*/

foreach undirected edge e in g do

update counts using alg. 4 with input ae

summation(cid:80)
(cid:80)
i   ipi =(cid:80)j

   ) for which(cid:80)j

i=1 pj =(cid:80)j

i   ipi is maximized when p1 = 1, p2 = 2, and so on
up to some index j = o(
i=1 i = c  .
now given that the pj are    xed and the   i are ordered, the summa-
tion is maximized when   1 =   2 = . . . =   j = m/j. in this case,

   

   
i=1(m/j)(1 + i) = o(m

   ).

5. experiments

next, we use our algorithms to reveal patterns in a variety of
temporal network datasets. we    nd that the number of instances
of various   -temporal motifs reveal basic mechanisms of the net-
works. datasets and implementations of our algorithms are avail-
able at http://snap.stanford.edu/temporal-motifs.

figure 5: counts of instances of all 2- and 3-node, 3-edge   -temporal motifs with    = 1 hour. for each dataset, counts in the ith row
and jth column is the number of instances of motif mi,j (see fig. 3); this motif is the union of the two edges in the row label and
the edge in the column label. for example, there are 0.7 million instances of motif m4,1 in the email-eu dataset. the color for the
count of motif mi,j indicates the fraction over all mi,j on a linear scale   darker blue means a higher count.

table 1: summary statistics of datasets.

dataset

# nodes # static # edges time span

edges
986
2.49k 332k
email-eu
1.05m 2.74m 8.55m
phonecall-eu
44.1k 67.2k 545k
sms-a
collegemsg
1.90k 20.3k 59.8k
stackoverflow 2.58m 34.9m 47.9m
24.6m 88.9m 123m
bitcoin
45.8k 264k 856k
fbwall
wikitalk
1.09m 3.13m 6.10m
phonecall-me 18.7m 360m 2.04b
sms-me
6.94m 51.5m 800m
5.1 data

(days)
803
7
338
193
2774
1811
1560
2277
364
89

we gathered a variety of datasets in order to study the patterns of
  -temporal motifs in several domains. the datasets are described
below and summary statistics are in table 1. the time resolution
of the edges in all datasets is one second.
email-eu. this dataset is a collection of emails between mem-
bers of a european research institution [17]. an edge (u, v, t) sig-
ni   es that person u sent person v an email at time t.
phonecall-eu. this dataset was constructed from telephone
call records for a major european service provider. an edge
(u, v, t) signi   es that person u called person v starting at time t.
sms-a. short messaging service (sms) is a texting service pro-
vided on mobile phones. in this dataset, an edge (u, v, t) means
that person u sent an sms message to person v at time t [28].
collegemsg. this dataset is comprised of private messages
sent on an online social network at the university of california,
irvine [21]. users could search the network for others and then
initiate conversation based on pro   le information. an edge (u, v, t)
means that user u sent a private message to user v at time t.

stackoverflow. on stack exchange web sites, users post ques-
tions and receive answers from other users, and users may comment
on both questions and answers. we derive a temporal network by
creating an edge (u, v, t) if, at time t, user u: (1) posts an answer to
user v   s question, (2) comments on user v   s question, or (3) com-
ments on user v   s answer. we formed the temporal network from
the entirety of stack over   ow   s history up to march 6, 2016.
bitcoin. bitcoin is a decentralized digital currency and payment
system. this dataset consists of all payments made up to october
19, 2014 [11]. nodes in the network correspond to bitcoin ad-
dresses, and an individual may have several addresses. an edge
(u, v, t) signi   es that bitcoin was transferred from address u to ad-
dress v at time t.
fbwall. the edges of this dataset are wall posts between users
on the social network facebook located in the new orleans re-
gion [26]. any friend of a given user can see all posts on that user   s
wall, so communication is public among friends. an edge (u, v, t)
means that user u posted on user v   s wall at time t.
wikitalk. this dataset represents edits on user talk pages on
wikipedia [16]. an edge (u, v, t) signi   es that user u edited user
v   s talk page at time t.
phonecall-me and sms-me. this dataset is constructed
from phone call and sms records of a large telecommunica-
tions service provider in the middle east. an edge (u, v, t) in
phonecall-me means that user u initiated a call to user v at
time t. an edge (u, v, t) in sms-me means that user u sent an
sms message to user v at time t. we use these networks for scala-
bility experiments in section 5.3.

5.2 empirical observations of motif counts

we    rst examine the distribution of 2- and 3-node, 3-edge mo-
tif instance counts from 8 of the datasets described in section 5.1
with    = 1 hour (fig. 5). we choose 1 hour for the time win-
dow as this is close to the median time for a node to take part in

3333331,212121212121,212121212123333333333333333330.4m59k0.8m40k34k28k68k59k28k16k38k15k0.7m35k0.8m45k6k6k18k12k35k40k3k6k18k30k3k2k35k14k13k10k4k6k14k28kemail-eu4m0.3m0.7m2m2m0.9m0.3m0.3m0.3m0.3m0.3m0.3m0.6m0.2m0.7m0.3m68k75k2m0.2m0.3m1m46k71k1m0.3m57k50k2m0.3m0.5m0.2m56k69k0.3m0.8mphonecall-eu5m3m0.2m90k84k62k3m3m0.1m81k89k58k0.1m59k0.2m0.1m1k1k38k35k0.1m91k1k2k45k47k1k0.9k97k82k31k26k2k2k75k85ksms-a0.3m0.2m0.2m0.1m0.1m0.2m0.2m0.1m0.1m0.1m0.1m0.1m0.2m79k0.3m0.1m3k2k81k85k0.1m0.2m2k3k92k64k2k2k0.1m0.1m0.1m75k3k2k0.1m0.2mcollegemsg7m2m8m4m5m7m0.4m4m4m3m3m3m3m3m9m5m0.7m0.3m2m2m2m6m0.3m0.7m2m2m0.6m0.2m6m2m6m4m1m1m7m8mstackoverflow15b9b25b25b20b23b8b9b14b16b17b15b21b11b25b14b1b1b19b14b15b19b2b1b15b13b1b2b22b15b18b10b1b1b14b23bbitcoin17m0.7m0.4b2m1m2m0.8m0.7m1m0.3m0.8m0.3m0.2b0.7m0.4b1m91k91k0.6m0.1m1m2m27k0.1m0.6m0.3m0.1m18k1m0.2m1m0.1m0.1m0.2m0.2m1mwikitalk0.3m0.2m27k17k17k22k0.3m0.2m24k27k22k22k13k12k30k21k2k2k15k15k19k14k1k1k11k14k2k1k28k34k18k22k2k2k35k27kfbwallfigure 6: fraction of all 2 and 3-node, 3-edge   -temporal motif
counts that correspond to two groups of motifs (   = 1 hour).
motifs on the left capture    blocking    behavior, common in
sms messaging and facebook wall posting, and motifs on the
right exhibit    non-blocking    behavior, common in email.

figure 8: fraction of 3-edge   -temporal triangle motif counts
(   = 1 hour) corresponding to cyclic triangles (right) in the four
datasets for which this fraction is the largest. bitcoin has a
much higher fraction compared to all other datasets.

figure 7: distribution of switching behavior amongst the non-
blocking motifs. switching is least common on stack over   ow
and most common in email.
three edges in most of our datasets. we make a few empirical ob-
servations uniquely available due to temporal motifs and provide
possible explanations for these observations.
blocking communication. if an individual typically waits for a
reply from one individual before proceeding to communicate with
another individual, we consider it a blocking form of communi-
cation. a typical conversation between two individuals character-
ized by fast exchanges happening back and forth is blocking as it
requires complete attention of both individuals. we capture this
behavior in the    blocking motifs    m5,1, m5,2 and m6,2, which
contain 3 edges between two nodes with at least one edge in either
direction (fig. 6, left). however, if the reply doesn   t arrive soon,
we might expect the individual to communicate with others without
waiting for a reply from the    rst individual. this is a non-blocking
form of communication and is captured by the    non-blocking mo-
tifs    m4,1, m4,3 and m6,3 having edges originating from the same
source but directed to different destinations (fig. 6, right)

the fractions of counts corresponding to the blocking and non-
blocking motifs out of the counts for all 36 motifs in fig. 3 uncover
several interesting characteristics in communication networks (   =
1 hour; see fig. 6). in fbwall and sms-a, blocking communi-
cation is vastly more common, while in email-eu non-blocking
communication is prevalent. email is not a dynamic method of
communication and replies within an hour are rare. thus, we would
expect non-blocking behavior.
interestingly, the collegemsg
dataset shows both behaviors as we might expect individuals to en-
gage in multiple conversations simultaneously. in complete con-
trast, the phonecall-eu dataset shows neither behavior. a sim-
ple explanation is that that a single edge (a phone call) captures an
entire conversation and hence blocking behavior does not emerge.
cost of switching. amongst the non-blocking motifs discussed
above, m4,1 captures two consecutive switches between pairs of
nodes whereas m4,3 and m6,3 each have a single switch (fig. 7,
right). prevalence of m4,1 indicates a lower cost of switching tar-
gets, whereas prevalence of the other two motifs are indicative of
a higher cost. we observe in fig. 7 that the ratio of 2-switch to 1-

figure 9: percentage of explained variance of relative counts
of collections of datasets plotted as a function of the number of
principal components. in datasets from the same domain, 90%
of variance is explained with fewer components.
switch motif counts is the least in stackoverflow, followed by
wikitalk, collegemsg and then email-eu. on stack over-
   ow and wikipedia talk pages, there is a high cost to switch targets
because of peer engagement and depth of discussion. on the other
hand, in the collegemsg dataset there is a lesser cost to switch
because it lacks depth of discussion within the time frame of    =
1 hour. finally, in email-eu, there is almost no peer engagement
and cost of switching is negligible.
cycles in bitcoin. of the eight 3-edge triangle motifs, m2,4 and
m3,5 are cyclic, i.e., the target of each edge serves as the source
of another edge. we observe in fig. 8 that the fraction of trian-
gles that are cyclic is much higher in bitcoin compared to any
other dataset. this can be attributed to the transactional nature of
bitcoin where the total amount of bitcoin is limited. since re-
mittance (outgoing edges) is typically associated with earnings (in-
coming edges), we should expect cyclic behavior.
datasets from the same domain have similar counts. static
graphs from similar domains tend to have similar motif count dis-
tributions [18, 25, 29]. here, we    nd similar results in temporal
networks. we formed two collections of datasets from similar do-
mains. first, we took subsets of the email-eu dataset correspond-
ing to email communication within four different departments at
the institution. second, we constructed temporal graphs from
the stack exchange communities math over   ow, super user, and
ask ubuntu to study in conjunction with the stackoverflow
dataset. we form count distributions by normalizing the counts of
the 36 different motifs in fig. 5. for datasets from a similar domain,
we expect that if the count distributions are similar, then most of
the variance is captured by a few principal components. to com-
pare, we use four datasets from dissimilar domains (email-eu,
phonecall-eu, sms-a, wikitalk). fig. 9 shows that to ex-
plain 90% variance, email-eu subnetworks need just one princi-
pal component, stack exchange networks need two, and the dissim-
ilar networks need three.
motif counts at varying time scales. we now explore how motif
counts change at different time scales. for the stackoverflow
dataset we counted the number of instances of 2- and 3-node, 3-
edge   -temporal motifs for    = 60, 300, 1800, and 3600 seconds

1,3212,31,23phonecall-eucollegemsgemail-eusms-afbwall0.00.5fraction of countsblocking motifs0.00.5fraction of countsnon-blocking motifs1,3212,31,230.00.20.40.60.81.0fractional distributionemail-eucollegemsgwikitalkstackoverflow1,322 switches12,31,231 switch0.00.20.40.60.81.0fraction cyclic trianglesfbwallcollegemsgphonecall-eubitcoincyclic triangles1231231234number of principal components5060708090100variance explained (%)email-eu subnetworksstack exchange networksdissimilar networkstable 2: time to count the eight 3-edge   -temporal triangle
motifs (   = 3600) using the general counting method (alg. 1)
and the fast counting method (alg. 5).
dataset

# static time, alg. 1 time, alg. 5 speedup
triangles
8.11m
wikitalk
73.1m
bitcoin
sms-me
78.0m
stackoverflow 114m
phonecall-me
667m

26.6
483
1.11k
606
8.59k

51.1
27.3k
2.54k
783
12.2k

1.92x
56.5x
2.28x
1.29x
1.42x

(seconds)

(seconds)

figure 12: time to count 3-edge motifs on the    rst k temporal
million edges in the phonecall-me as a function of k.
to one or two neighbors (motifs m6,1, m6,3, m4,1, and m4,3) in
the time bins [10(i     1), 10i) seconds, i = 1, . . . , 500 (fig. 11).
we    rst notice that at small time scales, the motif consisting of
three edges to a single neighbor (m6,1) occurs frequently. this
pattern could emerge from a succession of quick introductory mes-
sages. overall, motif counts increase from roughly 1 minute to 20
minutes and then decline. interestingly, after 5 minutes, counts for
the three motifs with one switch in the target (m6,1, m6,3, and
m4,3) grow at a faster rate than the counts for the motif with two
switches (m4,1). as mentioned above, this pattern could emerge
from a tendency to send several messages in one conversation be-
fore switching to a conversation with another friend.
5.3 algorithm scalability

finally, we performed scalability experiments of our algorithms.
all algorithms were implemented in c++, and all experiments ran
using a single thread of a 2.4ghz intel xeon e7-4870 processor.
we did not measure the time to load datasets into memory, but our
timings include all pre-processing time needed by the algorithms
(e.g., the triangle counting algorithms    rst    nd triangles in the static
graph). we emphasize that our implementation is single threaded,
and the methods can be sped up with a parallel algorithm.

first, we used both the general counting method (alg. 1) and
the fast counting method (alg. 5) to count the number of all eight
3-edge   -temporal triangle motifs in our datasets (   = 1 hour).
table 2 reports the running times of the algorithms for all datasets
with at least one million triangles in the static graph. for all of these
datasets, our fast temporal triangle counting algorithm provides sig-
ni   cant performance gains over the general counting method, rang-
ing between a 1.29x and a 56.5x speedup. the gains of the fast
algorithm are the largest for bitcoin, which is due to some pairs
of nodes having many edges between them and also participating
in many triangles.

second, we measured the time to count various 3-edge   -
temporal motifs in our largest dataset, phonecall-me. specif-

figure 10: counts for all 2- and 3-node, 3-edge   -temporal mo-
tifs in four time intervals for the stackoverflow dataset.
for each interval, the count in the ith row and jth column is
the number of instances of motif mi,j (see fig. 3).

figure 11: counts over various time scales for the motifs repre-
senting a node sending 3 outgoing messages to 1 or 2 neighbors
in the collegemsg dataset.
(fig. 10). these counts determine the number of motifs that com-
pleted in the intervals [0, 60], (60, 300], (300, 1800s], and (1800,
3600] seconds (e.g., subtracting 60 second counts from 300 sec-
ond counts gives the interval (60, 300]). observations at smaller
timescales reveal phenomenon which start to get eclipsed at larger
timescales. for instance, on short time scales, motif m1,1 (fig. 10,
top-left corner) is quite common. we suspect this arises from multi-
ple, quick comments on the original question, so the original poster
receives many incoming edges. at larger time scales, this behavior
is still frequent but relatively less so. now let us compare counts
for m1,5, m1,6, m2,5, m2,6 (the four in the top right corner) with
counts for m3,3, m3,4, m4,3, m4,4 (the four in the center). the
former counts likely correspond to conversations with the original
poster while the latter are constructed by the same user interact-
ing with multiple questions. between 300 and 1800 seconds (5 to
30 minutes), the former counts are relatively more common while
the latter counts only become more common after 1800 seconds.
a possible explanation is that the typical length of discussions on a
post is about 30 minutes, and later on, users answer other questions.
next, we examine messaging behavior in the collegemsg
dataset at    ne-grained time intervals. we counted the number of
motifs consisting of a single node sending three outgoing messages

[0s,60s](60s,300s]stackoverflow4m0.8m3m2m2m4m0.2m2m2m1m1m2m2m1m4m2m0.4m0.2m1m1m0.8m3m0.2m0.4m1m1m0.3m88k3m0.9m4m3m0.6m0.6m4m5m(300s,1800s]3m0.7m4m2m3m3m0.2m2m3m2m1m1m1m1m5m3m0.2m92k0.6m1m0.8m4m0.1m0.2m1m0.7m0.2m62k3m1m2m1m0.3m0.3m2m3m(1800s,3600s]3333331,212121212121,212121212123333337k0.4k1k2k1k14k0.4k0.3k0.4k1k0.3k4k0.7k0.3k1k0.2k0.9k0.7k4k1k1k2k0.3k2k3k1k2k0.3k2k1k32k9k5k9k3k17k0.3m41k0.2m0.1m80k0.5m17k77k49k98k72k0.2m0.1m54k0.2m35k39k24k0.1m0.1m59k0.1m16k70k89k90k39k8k0.1m34k0.8m0.4m0.1m0.1m0.3m0.6m101102103time to complete motif (seconds)020040060080010001200number of instancesmotif counts over time in collegemsg12,31,321,231,2,3ically, we measured the time to compute (1) 2-node motifs, (2)
3-node stars, and (3) triangles on the    rst k million edges in the
dataset for k = 250, 500, . . . , 2000 (fig. 12). the time to compute
the 2-node, 3-edge motifs and the 3-node, 3-edge stars scales lin-
early, as expected from our algorithm analysis. the time to count
triangle motifs grows superlinearly and becomes the dominant cost
when there is a large number of edges. for practical purposes, the
running times are quite modest. with two billion edges, our meth-
ods take less than 3.5 hours to complete (executing sequentially).

6. discussion

we have developed   -temporal network motifs as a tool for an-
alyzing temporal networks. we introduced a general framework
for counting instances of any temporal motif as well as faster al-
gorithms for certain classes of motifs and found that motif counts
reveal key structural patterns in a variety of temporal network
datasets. our work opens a number of avenues for additional re-
search. first, our fast algorithms are designed for 3-node, 3-edge
star and triangle motifs. we expect that the same general techniques
can be used to count more complex temporal motifs. next, it is im-
portant to note that our fast algorithms only count the number of in-
stances of motifs rather than enumerate the instances. this concept
has also been used to accelerate static motif counting [22]. tempo-
ral motif enumeration algorithms provide an additional algorithmic
design challenge. there is also a host of theoretical questions in this
area for lower bounds on temporal motif counting. finally, motif
counts can also be measured with respect to a null model [13, 19].
such analysis may yield additional discoveries. importantly, our
algorithms will speed up such computations, which use raw counts
from many random instances of a generative null model.
acknowledgements. we thank moses charikar for valuable dis-
cussion. this research has been supported in part by nsf iis-
1149837, aro muri, darpa simplex and ngs2, boeing,
bosch, huawei, lightspeed, sap, tencent, volkswagen, stanford
data science initiative, and a stanford graduate fellowship.
7. references
[1] m. araujo, s. papadimitriou, s. g  nnemann, c. faloutsos,

p. basu, a. swami, e. e. papalexakis, and d. koutra. com2:
fast automatic discovery of temporal (   comet   ) communities.
in pakdd, 2014.

[2] a.-l. barab  si and r. albert. emergence of scaling in
random networks. science, 286(5439):509   512, 1999.

[3] a. r. benson, d. f. gleich, and j. leskovec. tensor spectral
id91 for partitioning higher-order network structures. in
sdm, 2015.

[4] a. r. benson, d. f. gleich, and j. leskovec. higher-order

organization of complex networks. science,
353(6295):163   166, 2016.

[5] m. berlingerio, f. bonchi, b. bringmann, and a. gionis.

mining graph evolution rules. in ecml pkdd, 2009.

[6] d. m. dunlavy, t. g. kolda, and e. acar. temporal link
prediction using matrix and tensor factorizations. tkdd,
5(2):10, 2011.

[7] s. gurukar, s. ranu, and b. ravindran. commit: a scalable

approach to mining communication motifs from dynamic
networks. in sigmod, 2015.

[8] p. holme and j. saram  ki. temporal networks. physics

reports, 519(3):97   125, 2012.

[9] h. huang, j. tang, s. wu, l. liu, et al. mining triadic

closure patterns in social networks. in www, 2014.

[10] a. z. jacobs, s. f. way, j. ugander, and a. clauset.

assembling thefacebook: using heterogeneity to understand
online social network assembly. in web science, 2015.

[11] d. kondor, m. p  sfai, i. csabai, and g. vattay. do the rich
get richer? an empirical analysis of the bitcoin transaction
network. plos one, 9(2):e86197, 2014.

[12] g. kossinets and d. j. watts. empirical analysis of an

evolving social network. science, 311(5757):88   90, 2006.

[13] l. kovanen, m. karsai, k. kaski, j. kert  sz, and

j. saram  ki. temporal motifs in time-dependent networks.
jstat, 2011(11):p11005, 2011.

[14] m. latapy. main-memory triangle computations for very
large (sparse (power-law)) graphs. theoretical computer
science, 407(1):458   473, 2008.

[15] j. leskovec, d. huttenlocher, and j. kleinberg. signed

networks in social media. in chi, 2010.

[16] j. leskovec, d. p. huttenlocher, and j. m. kleinberg.

governance in social media: a case study of the wikipedia
promotion process. in icwsm, 2010.

[17] j. leskovec, j. kleinberg, and c. faloutsos. graph evolution:
densi   cation and shrinking diameters. tkdd, 1(1):2, 2007.

[18] r. milo, s. itzkovitz, n. kashtan, r. levitt, s. shen-orr,
i. ayzenshtat, m. sheffer, and u. alon. superfamilies of
evolved and designed networks. science,
303(5663):1538   1542, 2004.

[19] r. milo, s. shen-orr, s. itzkovitz, n. kashtan,

d. chklovskii, and u. alon. network motifs: simple
building blocks of complex networks. science,
298(5594):824   827, 2002.

[20] m. e. newman. the structure and function of complex

networks. siam review, 45(2):167   256, 2003.

[21] p. panzarasa, t. opsahl, and k. m. carley. patterns and
dynamics of users    behavior and interaction: network
analysis of an online community. jasist, 2009.

[22] a. pinar, c. seshadhri, and v. vishal. escape: ef   ciently
counting all 5-vertex subgraphs. arxiv: 1610.09411, 2016.

[23] c. tantipathananandh, t. berger-wolf, and d. kempe. a

framework for community identi   cation in dynamic social
networks. in kdd, 2007.

[24] j. ugander, l. backstrom, and j. kleinberg. subgraph

frequencies: mapping the empirical and extremal geography
of large graph collections. in www, 2013.

[25] a. vazquez, r. dobrin, d. sergi, j.-p. eckmann, z. oltvai,

and a.-l. barab  si. the topological relationship between the
large-scale attributes and local interaction patterns of
complex networks. pnas, 101(52):17940   17945, 2004.

[26] b. viswanath, a. mislove, m. cha, and k. p. gummadi. on

the evolution of user interaction in facebook. in wosn,
2009.

[27] s. wernicke and f. rasche. fanmod: a tool for fast network

motif detection. bioinformatics, 22(9):1152   1153, 2006.

[28] y. wu, c. zhou, j. xiao, j. kurths, and h. j. schellnhuber.

evidence for a bimodal distribution in human
communication. pnas, 107(44):18803   18808, 2010.

[29]   . n. yavero  glu, n. malod-dognin, d. davis, z. levnajic,

v. janjic, r. karapandza, a. stojmirovic, and n. pr  ulj.
revealing the hidden language of complex networks.
scienti   c reports, 4, 2014.

[30] q. zhao, y. tian, q. he, n. oliver, r. jin, and w.-c. lee.

communication motifs: a tool to characterize social
communications. in cikm, 2010.

