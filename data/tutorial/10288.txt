revisiting semi-supervised learning with graph embeddings

6
1
0
2

 

y
a
m
6
2

 

 
 
]

g
l
.
s
c
[
 
 

2
v
1
6
8
8
0

.

3
0
6
1
:
v
i
x
r
a

zhilin yang
william w. cohen
ruslan salakhutdinov
school of computer science, carnegie mellon university

zhiliny@cs.cmu.edu
wcohen@cs.cmu.edu
rsalakhu@cs.cmu.edu

abstract

we present a semi-supervised learning frame-
work based on graph embeddings. given a graph
between instances, we train an embedding for
each instance to jointly predict the class label and
the neighborhood context in the graph. we de-
velop both transductive and inductive variants of
our method.
in the transductive variant of our
method, the class labels are determined by both
the learned embeddings and input feature vec-
tors, while in the inductive variant, the embed-
dings are de   ned as a parametric function of the
feature vectors, so predictions can be made on in-
stances not seen during training. on a large and
diverse set of benchmark tasks, including text
classi   cation, distantly supervised entity extrac-
tion, and entity classi   cation, we show improved
performance over many of the existing models.

1. introduction
semi-supervised learning aims to leverage unlabeled data
to improve performance.
a large number of semi-
supervised learning algorithms jointly optimize two train-
ing objective functions:
the supervised loss over labeled
data and the unsupervised loss over both labeled and unla-
beled data. graph-based semi-supervised learning de   nes
the id168 as a weighted sum of the supervised loss
over labeled instances and a graph laplacian regulariza-
tion term (zhu et al., 2003; zhou et al., 2004; belkin et al.,
2006; weston et al., 2012). the graph laplacian regular-
ization is based on the assumption that nearby nodes in a
graph are likely to have the same labels. graph laplacian
id173 is effective because it constrains the labels to
be consistent with the graph structure.
recently developed unsupervised representation learning

proceedings of the 33 rd international conference on machine
learning, new york, ny, usa, 2016. jmlr: w&cp volume
48. copyright 2016 by the author(s).

methods learn embeddings that predict a distributional con-
text, e.g. a id27 might predict nearby context
words (mikolov et al., 2013; pennington et al., 2014), or
a node embedding might predict nearby nodes in a graph
(perozzi et al., 2014; tang et al., 2015). embeddings
trained with distributional context can be used to boost the
performance of related tasks. for example, word embed-
dings trained from a language model can be applied to part-
of-speech tagging, chunking and id39
(collobert et al., 2011; yang et al., 2016).
in this paper we consider not id27s but graph
embeddings. existing results show that graph embeddings
are effective at classifying the nodes in a graph, such as
user behavior prediction in a social network (perozzi et al.,
2014; tang et al., 2015). however, the graph embeddings
are usually learned separately from the supervised task,
and hence do not leverage the label information in a spe-
ci   c task. hence graph embeddings are in some sense
complementary to graph laplacian id173 that does
not produce useful features itself and might not be able to
fully leverage the distributional information encoded in the
graph structure.
the main highlight of our work is to incorporate em-
bedding techniques into the graph-based semi-supervised
learning setting. we propose a novel graph-based semi-
supervised learning framework, planetoid (predicting la-
bels and neighbors with embeddings transductively or
inductively from data). the embedding of an instance is
jointly trained to predict the class label of the instance and
the context in the graph. we then concatenate the embed-
dings and the hidden layers of the original classi   er and
feed them to a softmax layer when making the prediction.
since the embeddings are learned based on the graph struc-
ture, the above method is transductive, which means we
can only predict instances that are already observed in the
graph at training time. in many cases, however, it may be
desirable to have an inductive approach, where predictions
can be made on instances unobserved in the graph seen at
training time. to address this issue, we further develop an
inductive variant of our framework, where we de   ne the

revisiting semi-supervised learning with graph embeddings

embeddings as a parameterized function of input feature
vectors; i.e., the embeddings can be viewed as hidden lay-
ers of a neural network.
to demonstrate the effectiveness of our proposed approach,
we conducted experiments on    ve datasets for three tasks,
including text classi   cation, distantly supervised entity ex-
traction, and entity classi   cation. our inductive method
outperforms the second best inductive method by up to
18.7%1 points and on average 7.8% points in terms of ac-
curacy. the best of our inductive and transductive methods
outperforms the best of all the other compared methods by
up to 8.5% and on average 4.1%.

2. related work
2.1. semi-supervised learning

let l and u be the number of labeled and unlabeled in-
stances. let x1:l and xl+1:l+u denote the feature vec-
tors of labeled and unlabeled instances respectively. the
labels y1:l are also given. based on both labeled and un-
labeled instances, the problem of semi-supervised learning
is de   ned as learning a classi   er f : x     y. there are
two learning paradigms, transductive learning and induc-
tive learning. transductive learning (zhu et al., 2003; zhou
et al., 2004) only aims to apply the classi   er f on the unla-
beled instances observed at training time, and the classi   er
does not generalize to unobserved instances. for instance,
transductive support vector machine (tid166) (joachims,
1999) maximizes the    unlabeled data margin    based on the
low-density separation assumption that a good decision hy-
perplane lies on a sparse area of the feature space. inductive
learning (belkin et al., 2006; weston et al., 2012), on the
other hand, aims to learn a parameterized classi   er f that
is generalizable to unobserved instances.

2.2. graph-based semi-supervised learning

in addition to labeled and unlabeled instances, a graph, de-
noted as a (l + u )    (l + u ) matrix a, is also given to
graph-based semi-supervised learning methods. each entry
aij indicates the similarity between instance i and j, which
can be either labeled or unlabeled. the graph a can either
be derived from distances between instances (zhu et al.,
2003), or be explicitly derived from external data, such as
a id13 (wijaya et al., 2013) or a citation net-
work between documents (ji et al., 2010). in this paper,
we mainly focus on the setting that a graph is explicitly
given and represents additional information not present in
the feature vectors (e.g., the graph edges correspond to hy-
perlinks between documents, rather than distances between
the bag-of-words representation of a document).

1% refers to absolute percentage points thoughout the paper.

(cid:88)

l(cid:88)
l(cid:88)

i=1

=

graph-based semi-supervised learning is based on the as-
sumption that nearby nodes tend to have the same la-
bels. generally, the id168 of graph-based semi-
supervised learning in the binary case can be written as

l(yi, f (xi)) +   

aij(cid:107)f (xi)     f (xj)(cid:107)2

i,j

l(yi, f (xi)) +   f t    f

(1)

i=1

entry de   ned as dii = (cid:80)

in eq.
(1), the    rst term is the standard supervised loss
function, where l(  ,  ) can be log loss, squared loss or hinge
loss. the second term is the graph laplacian regular-
ization, which incurs a large penalty when similar nodes
with a large wij are predicted to have different labels
f (xi) (cid:54)= f (xj). the graph laplacian matrix     is de   ned
as     = a     d, where d is a diagonal matrix with each
j aij.    is a constant weight-
ing factor. (note that we omit the parameter id173
terms for simplicity.) various graph-based semi-supervised
learning algorithms de   ne the id168s as variants of
eq. (1). label propagation (zhu et al., 2003) forces f to
agree with labeled instances y1:l; f is a label lookup table
for unlabeled instances in the graph, and can be obtained
with a closed-form solution. learning with local and global
consistency (zhou et al., 2004) de   nes l as squared loss and
f as a label lookup table; it does not force f to agree with
labeled instances. modi   ed adsorption (mad) (talukdar
& crammer, 2009) is a variant of label propagation that
allows prediction on labeled instances to vary and incor-
porates node uncertainty. manifold id173 (belkin
et al., 2006) parameterizes f in the reproducing kernel
hilbert space (rkhs) with l being squared loss or hinge
loss. since f is a parameterized classi   er, manifold regu-
larization is inductive and can naturally handle unobserved
instances.
semi-supervised embedding (weston et al., 2012) extends
i,j aij(cid:107)g(xi)    
g(xj)(cid:107)2, where g represents embeddings of instances,
which can be the output labels, hidden layers or auxiliary
embeddings in a neural network. by extending the regu-
larization from f to g, this method imposes stronger con-
straints on a neural network. iterative classi   cation algo-
rithm (ica) (sen et al., 2008) uses a local classi   er that
takes the labels of neighbor nodes as input, and employs an
iterative process between estimating the local classi   er and
assigning new labels.

the id173 term in eq. (1) to be(cid:80)

2.3. learning embeddings

extensive research was done on learning graph embed-
dings. a probabilistic generative model was proposed to
learn node embeddings that generate the edges in a graph

revisiting semi-supervised learning with graph embeddings

   
means using the given for-
table 1. comparison of various semi-supervised learning algorithms and graph embedding algorithms.
mulation or information;   means not available or not using the information. in the column graph, id173 means imposing
id173 with the graph structure; features means using graph structure as features; context means predicting the graph context.

method

tid166 (joachims, 1999)

label propagation (zhu et al., 2003)
manifold reg (belkin et al., 2006)

ica (sen et al., 2008)

mad (talukdar & crammer, 2009)

semi emb (weston et al., 2012)
graph emb (perozzi et al., 2014)

planetoid (this paper)

features

   
  
   
  
  
   
  
   

labels

   
   
   
   
   
   
  
   

paradigm

embeddings

transductive
transductive

inductive

transductive
transductive

inductive

transductive

both

  
  
  
  
  
   
   
   

graph
  

id173
id173

features

id173
id173

context
context

(snijders & nowicki, 1997). a id91 method (hand-
cock et al., 2007) was proposed to learn latent social states
in a social network to predict social ties.
more recently, a number of embedding learning methods
are based on the skipgram model, which is a variant of
the softmax model. given an instance and its context, the
objective of skipgram is usually formulated as minimizing
the log loss of predicting the context using the embedding
of an instance as input features. formally, let {(i, c)} be a
set of pairs of instance i and context c, the id168 can
be written as

   (cid:88)

log p(c|i) =    (cid:88)

(i,c)

(i,c)

(cid:32)

c ei     log
wt

exp(wt

c(cid:48)ei)

(cid:88)

c(cid:48)   c

(cid:33)

(2)
where c is the set of all possible context, w   s are param-
eters of the skipgram model, and ei is the embedding of
instance i. skipgram was    rst introduced to learn repre-
sentations of words, known as id97 (mikolov et al.,
2013). in id97, for each training pair (i, c), the in-
stance i is the current word whose embedding is under es-
timation; the context c is each of the surrounding words
of i within a    xed window size in a sentence; the context
space c is the vocabulary of the corpus. skipgram was later
extended to learn graph embeddings. deepwalk (perozzi
et al., 2014) uses the embedding of a node to predict the
context in the graph, where the context is generated by ran-
dom walk. more speci   cally, for each training pair (i, c),
the instance i is the current node whose embedding is un-
der estimation; the context c is each of the neighbor nodes
within a    xed window size in a generated random walk se-
quence; the context space c is all the nodes in the graph.
line (tang et al., 2015) extends the model to have mul-
tiple context spaces c for modeling both    rst and second
order proximity.
although skipgram-like models for graphs have received
much recent attention, many other models exist. transe
(bordes et al., 2013) learns the embeddings of entities in
a id13 jointly with their relations. autoen-

coders were used to learn graph embeddings for id91
on graphs (tian et al., 2014).

2.4. comparison

we compare our approach in this paper with other methods
in semi-supervised learning and embedding learning in ta-
ble 1. unlike our approach, conventional graph laplacian
based methods (zhu et al., 2003; belkin et al., 2006; taluk-
dar & crammer, 2009) impose id173 on the labels
but do not learn embeddings. semi-supervised embedding
method (weston et al., 2012) learns embeddings in a neural
network, but our approach is different from this method in
that instead of imposing id173, we use the embed-
dings to predict the context in the graph. graph embedding
methods (perozzi et al., 2014; tian et al., 2014) encode the
graph structure into embeddings; however, different from
our approach, these methods are purely unsupervised and
do not leverage label information for a speci   c task. more-
over, these methods are transductive and cannot be directly
generalized to instances unseen at training time.

3. semi-supervised learning with graph

embeddings

following the notations in the previous section, the input
to our method includes labeled instances x1:l, y1:l, unla-
beled instances xl+1:l+u and a graph denoted as a matrix
a. each instance i has an embedding denoted as ei.
we formulate our framework based on feed-forward neural
networks. given the input feature vector x, the k-th hidden
layer of the network is denoted as hk, which is a nonlin-
ear function of the previous hidden layer hk   1 de   ned as:
hk(x) = relu(wkhk   1(x) + bk), where wk and bk
are parameters of the k-th layer, and h0(x) = x. we adopt
recti   ed linear unit relu(x) = max(0, x) as the nonlinear
function in this work.
the id168 of our framework can be expressed as

ls +   lu,

revisiting semi-supervised learning with graph embeddings

vised loss with negative sampling can be written as

lu =    e(i,c,  ) log   (  wt

c ei)

(3)

the distribution p(i, c,   ) is conditioned on labels y1:l and
the graph a. however, since they are the input to our al-
gorithm and kept    xed, we drop the conditioning in our
notation.
we now de   ne the distribution p(i, c,   ) directly using
a sampling process, which is illustrated in algorithm 1.
there are two types of context that are sampled in this al-
gorithm. the    rst type of context is based on the graph
a, which encodes the structure (distributional) informa-
tion, and the second type of context is based on the labels,
which we use to inject label information into the embed-
dings. we use a parameter r1     (0, 1) to control the ratio
of positive and negative samples, and use r2     (0, 1) to
control the ratio of two types of context.
with id203 r2, we sample the context based on the
graph a. we    rst uniformly sample a random walk se-
quence s. more speci   cally, we uniformly sample the
   rst instance s1 from the set 1 : l + u. given the
previous instance sk   1 = i, the next instance sk = j
j(cid:48)=1 aij(cid:48). with prob-
ability r1, we sample a positive pair (i, c) from the set
{(sj, sk) : |j     k| < d}, where d is another parameter
determining the window size. with id203 (1     r1),
we uniformly corrupt the context c to sample a negative
pair.
with id203 (1     r2), we sample the context based on
the class labels. positive pairs have the same labels and
negative pairs have different labels. only labeled instances
1 : l are sampled.
our random walk based sampling method is built upon
deepwalk (perozzi et al., 2014).
in contrast to their
method, our method handles real-valued a, incorporates
negative sampling, and explicitly samples from labels with
id203 (1     r2) to inject supervised information.
an example of sampling when    = 1 is shown in figure 1.

is sampled with id203 aij/(cid:80)l+u

3.2. transductive formulation

in this section, we present a method that infers the labels
of unlabeled instances yl+1:l+u without generalizing to
unobserved instances. transductive learning usually per-
forms better than inductive learning because transductive
learning can leverage the unlabeled test data when training
the model (joachims, 1999).
we apply k layers on the input feature vector x to obtain
hk(x), and l layers on the embedding e to obtain hl(e), as
illustrated in figure 2(a). the two hidden layers are con-
catenated, and fed to a softmax layer to predict the class

figure 1. an example of sampling from context distribution
p(i, c,   ) when    = 1 and d = 2. in circles, +1 denotes pos-
itive instances,    1 denotes negative instances, and ? denotes un-
labeled instances. if random < r2, we    rst sample a random
walk 2     1     4     6, and then sample two nodes in the ran-
dom walk within distance d. if random     r2, we sample two
instances with the same labels.

where ls is a supervised loss of predicting the labels, and
lu is an unsupervised loss of predicting the graph context.
in the following sections, we    rst formulate lu by intro-
ducing how to sample context from the graph, and then
formulate ls to form our semi-supervised learning frame-
work.

3.1. sampling context
we formulate the unsupervised loss lu as a variant of eq.
(2). given a graph a, the basic idea of our approach is to
sample pairs of instance i and context c, and then formulate
the loss lu using the log loss     log p(c|i) as in eq. (2). we
   rst present the formulation of lu by introducing negative
sampling, and then discuss how to sample pairs of instance
and context.
it is usually intractable to directly optimize eq.
(2) due
to id172 over the whole context space c. nega-
tive sampling was introduced to address this issue (mikolov
et al., 2013), which samples negative examples to approxi-
mate the id172 term. in our case, we are sampling
(i, c,   ) from a distribution, where i and c denote instance
and context respectively,    = +1 means (i, c) is a positive
pair and    =    1 means negative. given (i, c,   ), we min-
imize the cross id178 loss of classifying the pair (i, c) to
a binary label   :

   i(   = 1) log   (wt

c ei)     i(   =    1) log   (   wt

c ei),

where    is the sigmoid function de   ned as   (x) = 1/(1 +
e   x), and i(  ) is an indicator function that outputs 1 when
the argument is true, otherwise 0. therefore, the unsuper-

revisiting semi-supervised learning with graph embeddings

algorithm 1 sampling context distribution p(i, c,   )
input: graph a, labels y1:l, parameters r1, r2, q, d
initialize triplet (i, c,   )
if random < r1 then        +1 else           1
if random < r2 then

uniformly sample a random walk s of length q
uniformly sample (sj, sk) with |j     k| < d
i     sj, c     sk
if    =    1 then uniformly sample c from 1 : l + u

else

if    = +1 then

else

uniformly sample (i, c) with yi = yc
uniformly sample (i, c) with yi (cid:54)= yc

end if

end if
return (i, c,   )

(cid:80)

label of the instance. more speci   cally, the id203 of
predicting the label y is written as:

p(y|x, e) =

exp[hk(x)t , hl(e)t ]wy
y(cid:48) exp[hk(x)t , hl(e)t ]wy(cid:48)

,

(4)

where [  ,  ] denotes concatenation of two row vectors, the
super script ht denotes the transpose of vector h, and w
represents the model parameter.
combined with eq. (3), the id168 of transductive
learning is de   ned as:

log p(yi|xi, ei)       e(i,c,  ) log   (  wt

c ei),

l(cid:88)

i=1

    1
l

where the    rst term is de   ned by eq. (4), and    is a con-
stant weighting factor. the    rst term is the id168 of
class label prediction and the second term is the loss func-
tion of context prediction. this formulation is transductive
because the prediction of label y depends on the embed-
ding e, which can only be learned for instances observed in
the graph a during training time.

3.3. inductive formulation

while we consider transductive learning in the above for-
mulation, in many cases, it is desirable to learn a classi-
   er that can generalize to unobserved instances, especially
for large-scale tasks. for example, machine reading sys-
tems (carlson et al., 2010) very frequently encounter novel
entities on the web and it is not practical to train a semi-
supervised learning system on the entire web. however,
since learning graph embeddings is transductive in nature,
it is not straightforward to do it in an inductive setting. per-
ozzi et al. (2014) addressed this issue by retraining the em-

(a) transductive formulation

(b) inductive formulation

figure 2. network architecture: transductive v.s. inductive. each
dotted arrow represents a feed-forward network with an arbitrary
number of layers (we use only one layer in our experiments).
solid arrows denote direct connections.

beddings incrementally, which is time consuming and does
not scale (and not inductive essentially).
to make the method inductive, the prediction of label y
should only depend on the input feature vector x. there-
fore, we de   ne the embedding e as a parameterized func-
tion of feature x, as shown in figure 2(b). similar to the
transductive formulation, we apply k layers on the input
feature vector x to obtain hk(x). however, rather than
using a    free    embedding, we apply l1 layers on the in-
put feature vector x and de   ne it as the embedding e =
hl1(x). then another l2 layers are applied on the em-
bedding hl2(e) = hl2 (hl1(x)), denoted as hl(x) where
l = l1 + l2. the embedding e in this formulation can be
viewed as a hidden layer that is a parameterized function of
the feature x.
with the above formulation, the label y only depends on
the feature x. more speci   cally,

(cid:80)

p(y|x) =

exp[hk(x)t , hl(x)t ]wy
y(cid:48) exp[hk(x)t , hl(x)t ]wy(cid:48)

(5)

replacing ei in eq. (3) with hl1(xi), the id168 of
inductive learning is

log p(yi|xi)       e(i,c,  ) log   (  wt

c hl1 (xi))

l(cid:88)

i=1

    1
l

where the    rst term is de   ned by eq. (5).

revisiting semi-supervised learning with graph embeddings

algorithm 2 model training (transductive)

input: a, x1:l+u , y1:l,   , batch iterations t1, t2 and
sizes n1, n2
repeat

n1

for t     1 to t1 do

(cid:80)
sample a batch of labeled instances i of size n1
i p(yi|xi, ei)
ls =     1
take a gradient step for ls
(cid:80)

sample a batch of context from p(i, c,   ) of size n2
lu =     1
take a gradient step for lu

(i,c,  ) log   (  wt

end for
for t     1 to t2 do

c ei)

n2

end for

until stopping

table 2. dataset statistics.

dataset

#classes

#nodes

#edges

citeseer

cora
pubmed

diel
nell

6
7
3
4
210

3,327
2,708
19,717
4,373,008
65,755

4,732
5,429
44,338
4,464,261
266,144

3.4. training

we adopt stochastic id119 (sgd) (bottou, 2010)
to train our model in the mini-batch mode. we    rst sample
a batch of labeled instances and take a gradient step to op-
timize the id168 of class label prediction. we then
sample a batch of context (i, c,   ) and take another gradient
step to optimize the id168 of context prediction. we
repeat the above procedures for t1 and t2 iterations respec-
tively to approximate the weighting factor   . algorithm 2
illustrates the sgd-based training algorithm for the trans-
ductive formulation. similarly, we can replace p(yi|xi, ei)
with p(yi|xi) in ls to obtain the training algorithm for the
inductive formulation. let    denote all model parameters.
we update both embeddings e and parameters    in trans-
ductive learning, and update only parameters    in induc-
tive learning. before the joint training procedure, we apply
a number of training iterations that optimize the unsuper-
vised loss lu alone and use the learned embeddings e as
initialization for joint training.

4. experiments
in our experiments, planetoid-t and planetoid-i denote
the transductive and inductive formulation of our approach.
we compare our approach with label propagation (lp)
(zhu et al., 2003), semi-supervised embedding (semiemb)
(weston et al., 2012), manifold id173 (manireg)

table 3. accuracy on text classi   cation. upper rows are inductive
methods and lower rows are transductive methods.

method

citeseer

cora

pubmed

feat

manireg
semiemb

planetoid-i

0.572
0.601
0.596
0.647

lp

tid166

0.640
0.453
graphemb
0.432
planetoid-g 0.493
planetoid-t
0.629

0.574
0.595
0.590
0.612

0.575
0.680
0.672
0.691
0.757

0.698
0.707
0.711
0.772

0.622
0.630
0.653
0.664
0.757

table 4. recall@k on diel distantly-supervised entity extrac-
tion. upper rows are inductive methods and lower rows are trans-
ductive methods. results marked with     are taken from the origi-
nal diel paper (bing et al., 2015) with the same data splits.

method
   feat
manireg
semiemb

planetoid-i

   diel
   lp

graphemb
planetoid-g
planetoid-t
   upper bound

recall@k

0.349
0.477
0.486
0.501

0.405
0.162
0.258
0.394
0.500

0.617

(belkin et al., 2006), tid166 (joachims, 1999), and graph
embeddings (graphemb) (perozzi et al., 2014). another
baseline method, denoted as feat, is a linear softmax model
that takes only the feature vectors x as input. we also de-
rive a variant planetoid-g that learns embeddings to jointly
predict class labels and graph context without use of feature
vectors. the architecture of planetoid-g is similar to fig-
ure 2(a) except that the input feature and the correspond-
ing hidden layers are removed. among the above meth-
ods, lp, graphemb and planetoid-g do not use the fea-
tures x, while tid166 and feat do not use the graph a. we
include these methods into our experimental settings to bet-
ter evaluate our approach. our preliminary experiments on
the text classi   cation datasets show that the performance
of our model is not very sensitive to speci   c choices of
the network architecture2. we adapt the implementation
of graphemb3 to our skipgram implementation. we use
the junto library (talukdar & crammer, 2009) for label

2we note that it is possible to develop other architectures for
different applications, such as using a shared hidden layer for fea-
ture vectors and embeddings.

3https://github.com/phanein/deepwalk

revisiting semi-supervised learning with graph embeddings

(a) graphemb

(b) planetoid-t

(c) semiemb

figure 3. id167 visualization of embedding spaces on the cora dataset. each color denotes a class.

table 5. accuracy on nell entity classi   cation with labeling
rates of 0.1, 0.01, and 0.001. upper rows are inductive methods
and lower rows are transductive methods.

method

feat

manireg
semiemb

planetoid-i

lp

graphemb

planetoid-g/t

0.1

0.621
0.634
0.654
0.702

0.714
0.795
0.845

0.01

0.404
0.413
0.438
0.598

0.448
0.725
0.757

0.001

0.217
0.218
0.267
0.454

0.265
0.581
0.619

propagation, and id166light4 for tid166. we also use our
own implementation of manireg and semiemb by modi-
fying the symbolic objective function in planetoid. in all
of our experiments, we set the model hyper-parameters to
r1 = 5/6, q = 10, d = 3, n1 = 200 and n2 = 200 for
planetoid. we use the same r1, q and d for graphemb, and
the same n1 and n2 for manireg and semiemb. we tune
r2, t1, t2, the learning rate and hyper-parameters in other
models based on an additional data split with a different
random seed.
the statistics for    ve of our benchmark datasets are re-
ported in table 2. for each dataset, we split all instances
into three parts, labeled data, unlabeled data, and test data.
inductive methods are trained on the labeled and unlabeled
data, and tested on the test data. transductive methods, on
the other hand, are trained on the labeled, unlabeled data,
and test data without labels.

4.1. text classi   cation
we    rst considered three text classi   cation datasets5, cite-
seer, cora and pubmed (sen et al., 2008). each dataset

4http://id166light.joachims.org/
5http://linqs.umiacs.umd.edu/projects//projects/lbc/

contains bag-of-words representation of documents and ci-
tation links between the documents. we treat the bag-of-
words as feature vectors x. we construct the graph a based
on the citation links; if document i cites j, then we set
aij = aji = 1. the goal is to classify each document
into one class. we randomly sample 20 instances for each
class as labeled data, 1, 000 instances as test data, and the
rest are used as unlabeled data. the same data splits are
used for different methods, and we compute the average
accuracy for comparison.
the experimental results are reported in table 3. among
the inductive methods, planetoid-i achieves the best perfor-
mance on all the three datasets with the improvement of up
to 6.1% on pubmed, which indicates that our embedding
techniques are more effective than graph laplacian regu-
larization. among the transductive methods, planetoid-t
achieves the best performance on cora and pubmed, while
tid166 performs the best on citeseer. however, tid166
does not perform well on cora and pubmed. planetoid-i
slightly outperforms planetoid-t on citeseer and pubmed,
while planetoid-t gets up to 14.5% improvement over
planetoid-i on cora. we conjecture that in planetoid-i, the
feature vectors impose constraints on the learned embed-
dings, since they are represented by a parameterized func-
tion of the input feature vectors.
if such constraints are
appropriate, as is the case on citeseer and pubmed, it im-
proves the non-id76 of embedding learn-
ing and leads to better performance. however, if such
constraints rule out the optimal embeddings, the inductive
model will suffer.
planetoid-g consistently outperforms graphemb on all
three datasets, which indicates that joint training with la-
bel information can improve the performance over train-
ing the supervised and unsupervised objectives separately.
figure 3 displays the 2-d embedding spaces on the cora
dataset using id167 (van der maaten & hinton, 2008).
note that different classes are better separated in the em-
bedding space of planetoid-t than that of graphemb and

revisiting semi-supervised learning with graph embeddings

semiemb, which is consistent with our empirical    ndings.
we also observe similar results for the other two datasets.

4.2. distantly-supervised entity extraction

we next considered the diel (distant information ex-
traction using coordinate-term lists) dataset (bing et al.,
2015). the diel dataset contains pre-extracted features
for each entity mention in text, and a graph that connects
entity mentions to coordinate lists. the goal is to extract
medical entities from text given feature vectors and the
graph.
we follow the exact experimental setup as in the original
diel paper (bing et al., 2015), including data splits of dif-
ferent runs, preprocessing of entity mentions and coordi-
nate lists, and evaluation. we treat the top-k entities given
by a model as positive instances, and compute recall@k
for evaluation (k is set to 240, 000 following the diel pa-
per). we report the average result of 10 runs in table 4,
where feat refers to a result obtained by id166 (referred to
as ds-baseline in the diel paper). the result of lp was
also taken from (bing et al., 2015). diel in table 4 refers
to the method proposed by the original paper, which is an
improved version of label propagation that trains classi   ers
on feature vectors based on the output of label propagation.
we did not include tid166 into the comparison since it does
not scale. since we use freebase as ground truth and some
entities are not present in text, the upper bound of recall as
shown in table 4 is 0.617.
both planetoid-i and planetoid-t signi   cantly outperform
all other methods. each of planetoid-i and planetoid-t
achieves the best performance in 5 out of 10 runs, and they
give a similar recall on average, which indicates that there
is no signi   cant difference between these two methods on
this dataset. planetoid-g clearly outperforms graphemb,
which again shows the bene   t of joint training.

4.3. entity classi   cation

we sorted out an entity classi   cation dataset from the
knowledge base of never ending language learning
(nell) (carlson et al., 2010) and a hierarchical entity clas-
si   cation dataset (dalvi & cohen, 2016) that links nell
entities to text in clueweb09. we extracted the entities and
the relations between entities from the nell knowledge
base, and then obtained text description by linking the en-
tities to clueweb09. we use text bag-of-words representa-
tion as feature vectors of the entities.
we next describe how to construct the graph based on
the knowledge base. we    rst remove relations that
are not populated in nell, including    generalizations   ,
   haswikipediaurl   , and    atdate   .
in the knowledge base,
each relation is denoted as a triplet (e1, r, e2), where e1, r,

e2 denote head entity, relation, and tail entity respectively.
we treat each entity e as a node in the graph, and each re-
lation r is split as two nodes r1 and r2 in the graph. for
each (e1, r, e2), we add two edges in the graph, (e1, r1)
and (e2, r2).
we removed all classes with less than 10 entities. the goal
is to classify the entities in the knowledge base into one of
the 210 classes given the feature vectors and the graph. let
   be the labeling rate. we set    to 0.1, 0.01, and 0.001.
max(  n, 1) instances are labeled for a class with n enti-
ties, so each class has at least one entity in the labeled data.
we report the results in table 5. we did not include tid166
since it does not scale to such a large number of classes
with the one-vs-rest scheme. adding feature vectors does
not improve the performance of planetoid-t, so we set the
feature vectors for planetoid-t to be all empty, and there-
fore planetoid-t is equivalent to planetoid-g in this case.
planetoid-i signi   cantly outperforms the best of the other
compared inductive methods   i.e., semiemb   by 4.8%,
16.0%, and 18.7% respectively with three labeling rates.
as the labeling rate decreases,
the improvement of
planetoid-i over semiemb becomes more signi   cant.
graph structure is more informative than features in this
dataset, so inductive methods perform worse than trans-
ductive methods. planetoid-g outperforms graphemb by
5.0%, 3.2% and 3.8%.

5. conclusion
our contribution is three-fold: a) incontrast to previous
semi-supervised learning approaches that largely depend
on graph laplacian id173, we propose a novel ap-
proach by joint training of classi   cation and graph context
prediction; b) since it is dif   cult to generalize graph em-
beddings to novel instances, we design a novel inductive
approach that conditions embeddings on input features; c)
we empirically show substantial improvement over exist-
ing methods (up to 8.5% and on average 4.1%), and even
more signi   cant improvement in the inductive setting (up
to 18.7% and on average 7.8%).
our experimental results on    ve benchmark datasets also
show that a) joint training gives improvement over unsuper-
vised learning; b) predicting graph context is more effective
than graph laplacian id173; c) the performance of
the inductive variant depends on the informativeness of fea-
ture vectors.
one direction of future work would be to apply our frame-
work to more complex networks, including recurrent net-
works.
it would also be interesting to experiment with
datasets where a graph is computed based on distances be-
tween feature vectors.

revisiting semi-supervised learning with graph embeddings

acknowledgements
this work was funded by the nsf under grants ccf-
1414030 and iis-1250956, and by google.

references
belkin, mikhail, niyogi, partha, and sindhwani, vikas.
manifold id173: a geometric framework for
learning from labeled and unlabeled examples. jmlr,
7:2399   2434, 2006.

bing, lidong, chaudhari, sneha, wang, richard c, and
cohen, william w.
improving distant supervision for
information extraction using label propagation through
lists. in emnlp, 2015.

bordes, antoine, usunier, nicolas, garcia-duran, alberto,
weston, jason, and yakhnenko, oksana. translating em-
in nips,
beddings for modeling multi-relational data.
pp. 2787   2795, 2013.

bottou, l  eon. large-scale machine learning with stochas-
in compstat, pp. 177   186.

tic id119.
springer, 2010.

carlson, andrew, betteridge, justin, kisiel, bryan, settles,
burr, hruschka jr, estevam r, and mitchell, tom m. to-
ward an architecture for never-ending language learning.
in aaai, volume 5, pp. 3, 2010.

collobert, ronan, weston, jason, bottou, l  eon, karlen,
michael, kavukcuoglu, koray, and kuksa, pavel. nat-
ural language processing (almost) from scratch. jmlr,
12:2493   2537, 2011.

dalvi, bhavana and cohen, william w. hierarchical semi-
supervised classi   cation with incomplete class hierar-
chies. in wsdm, 2016.

handcock, mark s, raftery, adrian e, and tantrum,
jeremy m. model-based id91 for social networks.
journal of the royal statistical society: series a (statis-
tics in society), 170(2):301   354, 2007.

ji, ming, sun, yizhou, danilevsky, marina, han, jiawei,
and gao, jing. graph regularized transductive classi   -
cation on heterogeneous information networks. in ma-
chine learning and knowledge discovery in databases,
pp. 570   586. springer, 2010.

joachims, thorsten. transductive id136 for text clas-
si   cation using support vector machines. in icml, vol-
ume 99, pp. 200   209, 1999.

mikolov, tomas, sutskever, ilya, chen, kai, corrado,
greg s, and dean, jeff. distributed representations of
words and phrases and their compositionality. in nips,
pp. 3111   3119, 2013.

pennington,

jeffrey, socher, richard, and manning,
christopher d. glove: global vectors for word repre-
sentation. emnlp, 12:1532   1543, 2014.

perozzi, bryan, al-rfou, rami, and skiena, steven. deep-
walk: online learning of social representations. in kdd,
pp. 701   710, 2014.

sen, prithviraj, namata, galileo, bilgic, mustafa, getoor,
lise, galligher, brian, and eliassi-rad, tina. collective
classi   cation in network data. ai magazine, 29(3):93,
2008.

snijders, tom ab and nowicki, krzysztof. estimation and
prediction for stochastic blockmodels for graphs with la-
tent block structure. journal of classi   cation, 14(1):75   
100, 1997.

talukdar, partha pratim and crammer, koby. new regu-
larized algorithms for transductive learning. in machine
learning and knowledge discovery in databases, pp.
442   457. springer, 2009.

tang, jian, qu, meng, wang, mingzhe, zhang, ming, yan,
jun, and mei, qiaozhu. line: large-scale information
network embedding. in www, pp. 1067   1077, 2015.

tian, fei, gao, bin, cui, qing, chen, enhong, and liu,
tie-yan. learning deep representations for graph clus-
tering. in aaai, pp. 1293   1299, 2014.

van der maaten, laurens and hinton, geoffrey. visualizing

data using id167. jmlr, 9(2579-2605):85, 2008.

weston, jason, ratle, fr  ed  eric, mobahi, hossein, and col-
lobert, ronan. deep learning via semi-supervised em-
bedding. in neural networks: tricks of the trade, pp.
639   655. springer, 2012.

wijaya, derry, talukdar, partha pratim, and mitchell, tom.
pidgin: ontology alignment using web text as interlin-
gua. in cikm, pp. 589   598, 2013.

yang, zhilin, salakhutdinov, ruslan, and cohen, william.
multi-task cross-lingual sequence tagging from scratch.
arxiv preprint arxiv:1603.06270, 2016.

zhou, dengyong, bousquet, olivier, lal, thomas navin,
weston, jason, and sch  olkopf, bernhard. learning with
local and global consistency. nips, 16(16):321   328,
2004.

zhu, xiaojin, ghahramani, zoubin, lafferty, john, et al.
semi-supervised learning using gaussian    elds and har-
in icml, volume 3, pp. 912   919,
monic functions.
2003.

