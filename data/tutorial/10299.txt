5
1
0
2

 

n
u
j
 

5

 
 
]

g
l
.
s
c
[
 
 

1
v
5
7
0
2
0

.

6
0
5
1
:
v
i
x
r
a

large-scale simple id53 with memory networks

antoine bordes

facebook ai research

770 broadway

new york, ny. usa
abordes@fb.com

nicolas usunier

sumit chopra, jason weston

facebook ai research
112, avenue de wagram

75017 paris, france
usunier@fb.com

facebook ai research

770 broadway

new york, ny. usa

{spchopra, jase}@fb.com

abstract

training large-scale id53
systems is complicated because training
sources usually cover a small portion of
the range of possible questions. this pa-
per studies the impact of multitask and
id21 for simple question an-
swering; a setting for which the reason-
ing required to answer is quite easy, as
long as one can retrieve the correct evi-
dence given a question, which can be dif   -
cult in large-scale conditions. to this end,
we introduce a new dataset of 100k ques-
tions that we use in conjunction with ex-
isting benchmarks. we conduct our study
within the framework of memory net-
works (weston et al., 2015) because this
perspective allows us to eventually scale
up to more complex reasoning, and show
that memory networks can be success-
fully trained to achieve excellent perfor-
mance.

1 introduction

open-domain id53 (qa) systems
aim at providing the exact answer(s) to questions
formulated in natural language, without restriction
of domain. while there is a long history of qa
systems that search for textual documents or on
the web and extract answers from them (see e.g.
(voorhees and tice, 2000; dumais et al., 2002)),
recent progress has been made with the release of
large knowledge bases (kbs) such as freebase,
which contain consolidated knowledge stored as
atomic facts, and extracted from different sources,
such as free text, tables in webpages or collab-
orative input. existing approaches for qa from
kbs use learnable components to either trans-
form the question into a structured kb query
(berant et al., 2013) or learn to embed questions

and facts in a low dimensional vector space and re-
trieve the answer by computing similarities in this
embedding space (bordes et al., 2014a). how-
ever, while most recent efforts have focused on
designing systems with higher reasoning capabil-
ities, that could jointly retrieve and use multiple
facts to answer, the simpler problem of answer-
ing questions that refer to a single fact of the kb,
which we call simple id53 in this
paper, is still far from solved.

hence, existing benchmarks are small;

they
mostly cover the head of the distributions of facts,
and are restricted in their question types and their
syntactic and lexical variations. as such, it is still
unknown how much the existing systems perform
outside the range of the speci   c question tem-
plates of a few, small benchmark datasets, and it is
also unknown whether learning on a single dataset
transfers well on other ones, and whether such
systems can learn from different training sources,
which we believe is necessary to capture the whole
range of possible questions.

besides, the actual need for reasoning, i.e. con-
structing the answer from more than a single fact
from the kb, depends on the actual structure of the
kb. as we shall see, for instance, a simple prepro-
cessing of freebase tremendously increases the
coverage of simple qa in terms of possible ques-
tions that can be answered with a single fact, in-
cluding list questions that expect more than a sin-
gle answer. in fact, the task of simple qa itself
might already cover a wide range of practical us-
ages, if the kb is properly organized.

this paper presents two contributions. first, as
an effort to study the coverage of existing sys-
tems and the possibility to train jointly on differ-
ent data sources via multitasking, we collected the
   rst large-scale dataset of questions and answers
based on a kb, called simplequestions. this
dataset, which is presented in section 2, contains
more than 100k questions written by human anno-

what american cartoonist is the creator of andy lippincott?
which forest is fires creek in?
what is an active ingredient in childrens earache relief ?
what does jimmy neutron do?
what dietary restriction is incompatible with kimchi?

(andy lippincott, character created by, garry trudeau)
(fires creek, containedby, nantahala national forest)
(childrens earache relief, active ingredients, capsicum)
(jimmy neutron, fictional character occupation, inventor)
(kimchi, incompatible with dietary restrictions, veganism)

table 1: examples of simple qa. questions and corresponding facts have been extracted from the new
dataset simplequestions introduced in this paper. actual answers are underlined.

tators and associated to freebase facts, while the
largest existing benchmark, webquestions, con-
tains less than 6k questions created automatically
using the google suggest api.

second,

in sections 3 and 4, we present an
embedding-based qa system developed under
the framework of memory networks (memnns)
(weston et al., 2015;
sukhbaatar et al., 2015).
memory networks are learning systems centered
around a memory component that can be read and
written to, with a particular focus on cases where
the relationship between the input and response
languages (here natural language) and the storage
language (here, the facts from kbs) is performed
by embedding all of them in the same vector
space. the setting of the simple qa corresponds
to the elementary operation of performing a single
lookup in the memory. while our model bares
similarity with previous embedding models for
qa (bordes et al., 2014b; bordes et al., 2014a),
using the framework of memnns opens the
perspective to more involved id136 schemes
in future work, since memnns were shown to
perform well on complex reasoning toy qa tasks
(weston et al., 2015). we discuss related work in
section 5.

we report experimental results in section 6,
where we show that our model achieves excel-
lent results on the benchmark webquestions.
we also show that it can learn from two different
qa datasets to improve its performance on both.
we also present the    rst successful application of
id21 for qa. using the reverb kb
and qa datasets, we show that reverb facts can
be added to the memory and used to answer with-
out retraining, and that memnns achieve better
results than some systems designed on this dataset.

2 simple id53

knowledge bases contain facts expressed as
triples
(subject, relationship, object),
where subject and object are entities and
relationship describes the type of (directed)
link between these entities. the simple qa prob-

lem we address here consist in    nding the answer
to questions that can be rephrased as queries of the
form (subject, relationship, ?), asking for
all objects linked to subject by relationship.
the question what do jamaican people speak ?,
for instance, could be rephrased as the freebase
query (jamaica, language spoken, ?).
in
other words, fetching a single fact from a kb is
suf   cient to answer correctly.

the term simple qa refers to the simplicity of
the reasoning process needed to answer questions,
since it involves a single fact. however, this does
not mean that the qa problem is easy per se, since
retrieving this single supporting fact can be very
challenging as it involves to search over millions
of alternatives given a query expressed in natural
language. table 1 shows that, with a kb with
many types of relationships like freebase, the
range of questions that can be answered with a sin-
gle fact is already very broad. besides, as we shall
see, modiying slightly the structure of the kb can
make some qa problems simpler by adding direct
connections between entities and hence allow to
bypass the need for more complex reasoning.

2.1 knowledge bases
we use the kb freebase1 as the basis of our
qa system, our source of facts and answers. all
freebase entities and relationships are typed and
the lexicon for types and relationships is closed.
freebase data is collaboratively collected and
curated, to ensure a high reliability of the facts.
each entity has an internal identi   er and a set of
strings that are usually used to refer to that entity
in text, termed aliases. we consider two extracts
of freebase, whose statistics are given in table 2.
fb2m, which was used in (bordes et al., 2014a),
contains about 2m entities and 5k relationships.
fb5m, is much larger with about 5m entities and
more than 7.5k relationships.

we also use the kb reverb as a secondary
source of facts to study how well a model trained
to answer questions using freebase facts could

1www.freebase.com

entities
relationships
atomic facts
facts (grouped)

fb2m
2,150,604
6,701
14,180,937
10,843,106

fb5m
4,904,397
7,523
22,441,880
12,010,500

reverb
2,044,752
601,360
14,338,214
   

table 2: knowledge bases used in this paper.
fb2m and fb5m are two versions of freebase.

be used to answer using reverb   s as well, with-
out being trained on reverb data. this is a pure
setting of id21. reverb is interesting
for this experiment because it differs a lot from
freebase.
its data was extracted automatically
from text with minimal human intervention and is
highly unstructured: entities are unique strings and
the lexicon for relationships is open. this leads
to many more relationships, but entities with mul-
tiple references are not deduplicated, ambiguous
referents are not resolved, and the reliability of the
stored facts is much lower than in freebase. we
used the full extraction from (fader et al., 2011),
which contains 2m entities and 600k relationships.

2.2 the simplequestions dataset
existing resources for qa such as webques-
tions (berant et al., 2013) are rather small (few
thousands questions) and hence do not provide a
very thorough coverage of the variety of ques-
tions that could be answered using a kb like
freebase, even in the context of simple qa.
hence, in this paper, we introduce a new dataset
of much larger scale for the task of simple qa
called simplequestions.2 this dataset consists
of a total of 108,442 questions written in natu-
ral language by human english-speaking annota-
tors each paired with a corresponding fact from
fb2m that provides the answer and explains it.
we randomly shuf   e these questions and use 70%
of them (75910) as training set, 10% as validation
set (10845), and the remaining 20% as test set. ex-
amples of questions and facts are given in table 1.
we collected simplequestions in two phases.
the    rst phase consisted of shortlisting the set of
facts from freebase to be annotated with ques-
tions. we used fb2m as background kb and re-
moved all facts with unde   ned relationship type
i.e. containing the word freebase. we also re-
moved all facts for which the (subject, relation-
ship) pair had more than a threshold number of ob-
jects. this    ltering step is crucial to remove facts

2the dataset is available from http://fb.ai/babi.

which would result in trivial uninformative ques-
tions, such as, name a person who is an actor?.
the threshold was set to 10.

in the second phase, these selected facts were
sampled and delivered to human annotators to
generate questions from them. for the sampling,
each fact was associated with a id203 which
de   ned as a function of its relationship frequency
in the kb: to favor variability, facts with relation-
ship appearing more frequently were given lower
probabilities. for each sampled facts, annotators
were shown the facts along with hyperlinks to
freebase.com to provide some context while
framing the question. given this information, an-
notators were asked to phrase a question involving
the subject and the relationship of the fact, with
the answer being the object. the annotators were
explicitly instructed to phrase the question differ-
ently as much as possible, if they encounter multi-
ple facts with similar relationship. they were also
given the option of skipping facts if they wish to
do so. this was very important to avoid the anno-
tators to write a boiler plate questions when they
had no background knowledge about some facts.

3 memory networks for simple qa

a memory network consists of a memory (an in-
dexed array of objects) and a neural network that
is trained to query it given some inputs (usually
questions).
input map
(i), generalization (g), output map (o) and re-
sponse (r) which we detail below. but    rst, we
describe the memnns work   ow used to set up a
model for simple qa. this proceeds in three steps:

it has four components:

1. storing freebase:
this    rst phase parses
freebase (either fb2m or fb5m depending on
the setting) and stores it in memory.
it uses the
input module to preprocess the data.

training:

2.
this second phase trains the
memnn to answer question. this uses input, out-
put and response modules, the training concerns
mainly the parameters of the embedding model at
the core of the output module.

3. connecting reverb:
this third phase adds
new facts coming from reverb to the memory.
this is done after training to test the ability of
memnns to handle new facts without having to
be re-trained. it uses the input module to prepro-
cess reverb facts and the generalization module
to connect them to the facts already stored.

after these three stages, the memnn is ready
to answer any question by running the i, o and r
modules in turn. we now detail the implementa-
tion of the four modules.

an entity (independent of whether it appears as
subject or object). the entries of the subject and
of the relationship have value 1, and the entries of
the objects are set to 1/k. all other entries are 0.

input module

3.1
this module preprocesses the three types of data
that are input to the network: freebase facts that
are used to populate the memory, questions that
the system need to answer, and reverb facts that
we use, in a second phase, to extend the memory.

preprocessing freebase the freebase data is
initially stored as atomic facts involving single en-
tities as subject and object, plus a relationship be-
tween them. however, this storage needs to be
adapted to the qa task in two aspects.

first, in order to answer list questions, which
expect more than one answer, we rede   ne a fact
as being a triple containing a subject, a relation-
ship, and the set of all objects linked to the subject
by the relationship. this grouping process trans-
forms atomic facts into grouped facts, which we
simply refer to as facts in the following. table 2
shows the impact of this grouping: on fb2m, this
decreases the number of facts from 14m to 11m
and, on fb5m, from 22m to 12m.

second, the underlying structure of freebase
is a hypergraph, in which more than two entities
can be linked. for instance dates can be linked
together with two entities to specify the time pe-
riod over which the link was valid. the under-
lying triple storage involves mediator nodes for
each such fact, effectively making entities linked
through paths of length 2, instead of 1. to ob-
tain direct links between entities in such cases, we
created a single fact for these facts by removing
the intermediate node and using the second rela-
tionship as the relationship for the new condensed
fact. this step reduces the need for searching the
answer outside the immediate neighborhood of the
subject referred to in the question, widely increas-
ing the scope of the simple qa task on freebase.
on webquestions, a benchmark not primarily
designed for simple qa, removing mediator nodes
allows to jump from around 65% to 86% of ques-
tions that can be answered with a single fact.

preprocessing freebase facts a fact with k ob-
jects y = (s, r, {o1, ..., ok}) is represented by a
bag-of-symbol vector f (y) in rns , where ns is
the number of entities and relationships. each di-
mension of f (y) corresponds to a relationship or

preprocessing questions a question q
is
mapped to a bag-of-ngrams representation g(q) of
dimension rnv where nv is the size of the vo-
cabulary. the vocabulary contains all individual
words that appear in the questions of our datasets,
together with the aliases of freebase entities,
each alias being a single id165. the entries of
g(q) that correspond to words and id165s of q
are equal to 1, all other ones are set to 0.

preprocessing reverb facts
in our experiments
with reverb, each fact y = (s, r, o) is represented
as a vector h(y)     rns+nv . this vector is a bag-
of-symbol for the subject s and the object o, and
a bag-of-words for the relationship r. the exact
composition of h is provided by the generaliza-
tion module, which we describe now.

3.2 generalization module
this module is responsible for adding new ele-
ments to the memory. in our case, the memory has
a multigraph structure where each node is a free-
base entity and labeled arcs in the multigraph are
freebase relationships: after their preprocessing,
all freebase facts are stored using this structure.
we also consider the case where new facts,
with a different structure (i.e. new kinds of re-
lationship), are provided to the memnns by us-
ing reverb. in this case, the generalization mod-
ule is then used to connect reverb facts to the
freebase-based memory structure,
in order to
make them usable and searchable by the memnn.
to link the subject and the object of a reverb
fact to freebase entities, we use precomputed en-
tity links (lin et al., 2012).
if such links do not
give any result for an entity, we search for free-
base entities with at least one alias that matches
the reverb entity string. these two processes al-
lowed to match 17% of reverb entities to free-
base ones. the remainder of entities were en-
coded using bag-of-words representation of their
strings, since we had no other way of matching
them to freebase entities. all reverb relation-
ships were encoded using bag-of-words of their
strings. using this approximate process, we are
able to store each reverb fact as a bag-of-symbols
(words or freebase entities) all already seen by
the memnn during its training phase based on

freebase. we can then hope that what had been
learned there could also be successfully used to
query reverb facts.

3.3 output module
the output module performs the memory lookups
given the input to return the supporting facts des-
tined to eventually provide the answer given a
question.
in our case of simple qa, this mod-
ule only returns a single supporting fact. to avoid
scoring all the stored facts, we    rst perform an ap-
proximate entity linking step to generate a small
set of candidate facts. the supporting fact is the
candidate fact that is most similar to the question
according to an embedding model.

candidate generation to generate candidate
facts, we match id165s of words of the question
to aliases of freebase entities and select a few
matching entities. all facts having one of these
entities as subject are scored in a second step.

we    rst generate all possible id165s from the
question, removing those that contain an interrog-
ative pronoun or 1-grams that belong to a list of
stopwords. we only keep the id165s which are
an alias of an entity, and then discard all id165s
that are a subsequence of another id165, except
if the longer id165 only differs by in, of, for or
the at the beginning. we    nally keep the two enti-
ties with the most links in freebase retrieved for
each of the    ve longest matched id165s.

scoring scoring is performed using an embed-
ding model. given two embedding matrices
wv     rd  nv and ws     rd  ns , which re-
spectively contain, in columns, the d-dimensional
embeddings of the words/id165s of the vocabu-
lary and the embeddings of the freebase entities
and relationships, the similarity between question
q and a freebase candidate fact y is computed as:

sqa(q, y) = cos(wv g(q), ws f (y)) ,

with cos() the cosine similarity. when scoring a
fact y from reverb, we use the same embeddings
and build the matrix wv s     rd  (nv +ns ), which
contains the concatenation in columns of wv and
ws, and also compute the cosine similarity:

srv b(q, y) = cos(wv g(q), wv sh(y)) .

the dimension d is a hyperparameter, and the em-
bedding matrices wv and ws are the parameters
learned with the training algorithm of section 4.

3.4 response module
in memory networks, the response module post-
processes the result of the output module to com-
pute the intended answer. in our case, it returns
the set of objects of the selected supporting fact.

4 training

this section details how we trained the scoring
function of the output module using a multitask
training process on four different sources of data.
first, in addition to the new simplequestions
dataset described in section 2, we also used we-
bquestions, a benchmark for qa introduced in
(berant et al., 2013): questions are labeled with
answer strings from aliases of freebase entities,
and many questions expect multiple answers. ta-
ble 3 details the statistics of both datasets.

we also train on automatic questions gener-
ated from the kb, that is fb2m or fb5m de-
pending on the setting, which are essential
to
learn embeddings for the entities not appearing
in either webquestions or simplequestions.
statistics of fb2m or fb5m are given in ta-
ble 2; we generated one training question per
fact following the same process as that used in
(bordes et al., 2014a).

such

work

previous

following

as
(fader et al., 2013), we also use the indirect
supervision signal of pairs of question para-
phrases. we used a subset of the large set of
from wikianswers
paraphrases
and introduced in (fader et al., 2014).
our
paraphrases dataset is made of 15m clusters
containing 2 or more paraphrases each.

extracted

4.1 multitask training
as
in previous work on embedding mod-
els and memory networks (bordes et al., 2014a;
bordes et al., 2014b; weston et al., 2015), the em-
beddings are trained with a ranking criterion. for
qa datasets the goal is that in the embedding
space, a supporting fact is more similar to the
question than any other non-supporting fact. for
the paraphrase dataset, a question should be more
similar to one of its paraphrases than to any an-
other question.

the multitask learning of the embedding ma-
trices wv and ws is performed by alternating
stochastic id119 (sgd) steps over the
id168 on the different datasets. for the
qa datasets, given a question/supporting fact pair

(q, y) and a non-supporting fact y   , we perform a
step to minimize the id168

   qa(q, y, y   ) = (cid:2)       sqa(q, y) + sqa(q, y   )(cid:3)+ ,
where [.]+ is the positive part and    is a margin
hyperparameter. for the paraphrase dataset, the
similarity score between two questions q and q   
is also the cosine between their embeddings, i.e.
sqq(q, q   ) = cos(wv g(q), wv g(q   )), and given
a paraphrase pair (q, q   ) and another question q      ,
the loss is:

   qq(q, q   , q      ) = (cid:2)      sqq(q, q   )+sqq(q, q      )(cid:3)+ .
the embeddings (i.e.
the columns of wv and
ws) are projected onto the l2 unit ball after
each update. at each time step, a sample from
the paraphrase dataset is drawn with probabil-
ity 0.2 (this id203 is arbitrary). otherwise,
a sample from one of the three qa datasets,
chosen uniformly at random, is taken. we use
the warp loss (weston et al., 2010) to speed
up training, and adagrad (duchi et al., 2011) as
sgd algorithm multi-threaded with hogwild!
(recht et al., 2011). training takes 2-3 hours on
20 threads.

4.2 distant supervision
unlike for simplequestions or the synthetic qa
data generated from freebase, for webques-
tions only answer strings are provided for ques-
tions: the supporting facts are unknown.

in order to generate the supervision, we use
the candidate fact generation algorithm of sec-
tion 3.3. for each candidate fact, the aliases of its
objects are compared to the set of provided answer
strings. the fact(s) which can generate the maxi-
mum number of answer strings from their objects   
aliases are then kept. if multiple facts are obtained
for the same question, the ones with the minimal
number of objects are considered as supervision
facts. this last selection avoids favoring irrelevant
relationships that would be kept only because they
point to many objects but would not be speci   c
enough. if no answer string could be found from
the objects of the initial candidates, the question is
discarded from the training set.

future work should investigate the process of
weak supervised training of memnns recently in-
troduced in (sukhbaatar et al., 2015) that allows to
train them without any supervision coming from
the supporting facts.

train
valid.
test

webquestions simplequestions reverb
   
   
691

75,910
10,845
21,687

3,000
778
2,032

table 3: training and evaluation datasets.
questions automatically generated from the kb
and paraphrases can also be used in training.

4.3 generating negative examples

as in (bordes et al., 2014a; bordes et al., 2014b),
learning is performed with id119, so
that negative examples (non-supporting facts or
non-paraphrases) are generated according to a ran-
domized policy during training.

for paraphrases, given a pair (q, q   ), a non-
paraphrase pair is generated as (q, q      ) where q       is
a random question of the dataset, not belonging to
the cluser of q. for question/supporting fact pairs,
we use two policies. the default policy to ob-
tain a non-supporting fact is to corrupt the answer
fact by exchanging its subject, its relationship or
its object(s) with that of another fact chosen uni-
formly at random from the kb. in this policy, the
element of the fact to corrupt is chosen randomly,
with a small id203 (0.3) of corrupting more
than one element of the answer fact. the second
policy we propose, called candidates as negatives,
is to take as non-supporting fact a randomly cho-
sen fact from the set of candidate facts. while the
   rst policy is standard in learning embeddings, the
second one is more original, and, as we see in the
experiments, gives slightly better performance.

5 related work

the    rst approaches to open-domain qa were
search engine-based systems, where keywords ex-
tracted from the question are sent to a search en-
gine, and the answer is extracted from the top re-
sults (yahya et al., 2012; unger et al., 2012). this
method has been adapted to kb-based qa
(yahya et al., 2012; unger et al., 2012), and ob-
tained competitive results with respect to semantic
parsing and embedding-based approaches.

parsing

semantic

ap-
(cai and yates, 2013;
proaches
berant et al., 2013;
kwiatkowski et al., 2013;
berant and liang, 2014; fader et al., 2014) per-
form a functional parse of the sentence that
can be interpreted as a kb query. even though
these approaches are dif   cult to train at scale

because of the complexity of their id136, their
advantage is to provide a deep interpretation of the
question. some of these approaches require little
to no question-answer pairs (fader et al., 2013;
reddy et al., 2014), relying on simple rules to
tranform the semantic interpretation to a kb
query.

of

algorithms

like our work,

embedding-based meth-
ods for qa can be seen as simple memnns.
the
(bordes et al., 2014b;
weston et al., 2015) use an approach similar
to ours but are based on reverb rather than
freebase, and relied purely on bag-of-word
for both questions and facts. the approach of
(yang et al., 2014) uses a different representation
of questions,
in which recognized entities are
replaced by an entity token, and a different train-
ing data using entity mentions from wikipedia.
our model
to the one presented in
(bordes et al., 2014a), which is discussed in more
details in the experiments.

is closest

6 experiments

this section provides an extensive evaluation of
our memnns implementation against state-of-
the-art qa methods as well as an empirical study
of the impact of using multiple training sources on
the prediction performance.

6.1 evaluation and baselines

the dimensions of

the test
table 3 details
of webquestions, simplequestions
sets
and reverb which we used for
evalua-
on webquestions, we
evaluate
tion.
against previous
results on this benchmark
(berant et al., 2013; yao and van durme, 2014;
berant and liang, 2014;
bordes et al., 2014a;
yang et al., 2014) in terms of f1-score as de   ned
in (berant and liang, 2014), which is the average,
over all test questions, of the f1-score of the
sets of predicted answers.
since no previous
result was published on simplequestions, we
only compare different versions of memnns.
simplequestions questions are labeled with
their entire freebase fact, so we evaluate in
terms of path-level accuracy, in which a prediction
is correct if the subject and the relationship were
correctly retrieved by the system.

the reverb test set, based on the kb of the
same name and introduced in (fader et al., 2013)
is used for evaluation only.
it contains 691

questions. we consider the task of re-ranking a
small set of candidate answers, which are re-
verb facts and are labeled as correct or incorrect.
we compare our approach to the original system
(fader et al., 2013), to (bordes et al., 2014b) and
to the original memnns (weston et al., 2015), in
terms of accuracy, which is the percentage of ques-
tions for which the top-ranked candidate fact is
correct.

6.2 experimental setup
all models were trained with at least the dataset
made of synthetic questions created from the kb.
the hyperparameters were chosen to maximize
the f1-score on webquestions validation set, in-
dependently of the testing dataset. the embed-
ding dimension and the learning rate were chosen
among {64, 128, 256} and {1, 0.1, ..., 1.0e   4} re-
spectively, and the margin    was set to 0.1. for
each con   guration of hyperparameters,
the f1-
score on the validation set was computed regularly
during learning to perform early stopping.

we tested additional con   gurations for our al-
gorithm. first, in the candidates as negatives set-
ting (negative facts are sampled from the candi-
date set, see section 4), abbreviated cands as
negs, the experimental protocol is the same as
in the default setting but the embeddings are ini-
tialized with the best con   guration of the default
setup. second, our model shares some similarities
with an approach studied in (bordes et al., 2014a),
in which the authors noticed important gains using
a subgraph representation of answers. for com-
pleteness, we also added such a subgraph repre-
sentation of objects.
in that setting, called sub-
graph, each object o of a fact is itself repre-
sented as a bag-of-entities that encodes the imme-
diate neighborhood of o. this subgraph model is
trained similarly as our main approach and only
the results of a post-hoc ensemble combination of
the two models (where the scores are added) are
presented. we also report the results obtained by
an ensemble of the 5 best models on validation
(subgraph excepted); this is denoted 5 models.

6.3 results
comparative results the results of the com-
parative experiments are given in table 4. on
the main benchmark webquestions, our best re-
sults use all data sources, the bigger extract from
freebase and the cands as negs setting. the
two ensembles achieve excellent results, with f1-

baselines

webquestions simplequestions
f1-score (%)
accuracy (%)

reverb

accuracy (%)

random guess

(berant et al., 2013)
(fader et al., 2014)
(bordes et al., 2014b)

(bordes et al., 2014a)     using path

(bordes et al., 2014a)     using path + subgraph

(berant and liang, 2014)

(yang et al., 2014)

(weston et al., 2015)     the original memnn

memory networks (never trained on reverb     only transfer)

kb

train sources

cands
wq siq prp as negs

fb2m yes
fb5m
   
fb5m
   
fb5m
   
fb5m
   
fb5m yes
fb5m yes
fb5m yes
fb5m yes
fb5m yes
fb5m yes
fb5m yes

yes
   
   
yes
yes
   
   
yes
yes
yes
yes
yes

yes
   
yes
   
yes
   
yes
   
yes
yes
yes
yes

   
   
   
   
   
   
   
   
   
yes
yes
yes

ensemble

   
   
   
   
   
   
   
   
   
   

5 models
subgraph

1.9
31.3
n/a
29.7
35.3
39.2
39.9
41.3
n/a

36.2
18.7
22.0
22.7
28.2
40.1
40.4
41.0
41.0
41.2
41.9
42.2

4.9
n/a
n/a
n/a
n/a
n/a
n/a
n/a
n/a

62.7
44.5
48.1
61.6
61.2
46.6
47.4
61.7
62.1
62.2
63.9
62.9

35
n/a
54
73
n/a
n/a
n/a
n/a
72

n/a
52
62
52
64
58
61
52
67
65
68
62

table 4: experimental results for previous models of the literature and variants of memory networks.
all results are on the test sets. wq, siq and prp stand for webquestions, simplequestions and
paraphrases respectively. more details in the text.

scores of 41.9% and 42.2% respectively. the best
published competing approach (yang et al., 2014)
has an f1-score of 41.3%, which is comparable
to a single run of our model (41.2%). on the
new simplequestions dataset, the best models
achieve 62     63% accuracy, while the support-
ing fact is in the candidate set for about 86%
of simplequestions questions. this shows that
memnns are effective at re-ranking the candi-
dates, but also that simple qa is still not solved.

our

bares

approach

similarity

to
(bordes et al., 2014a) - using path.
they use
fb2m, and so their result (35.3% f1-score on
webquestions) should be compared to our
36.2%. the models are slightly different in that
they replace the entity string with the subject
entity in the question representation and that
we use the cosine similarity instead of the dot
product, which gave consistent
improvements.
still, the major differences come from how we
use freebase. first, the removal of the mediator
nodes allows us to restrict ourselves to single sup-
porting facts, while they search in paths of length
2 with a heuristic to select the paths to follow
(otherwise, id136 is too costly), which makes
our id136 simpler and more ef   cient. second,

using grouped facts, we integrate multiple answers
during learning (through the distant supervision),
while they use a grouping heuristic at test time.
grouping facts also allows us to scale much better
and to train on fb5m. on webquestions, not
speci   cally designed as a simple qa dataset,
86% of the questions can now be answered with a
single supporting fact, and performance increases
signi   cantly (from 36.2% to 41.0% f1-score).
using the bigger fb5m as kb does not change
performance on simplequestions because it
was based on fb2m, but the results show that our
model is robust to the addition of more entities
than necessary.

id21 on reverb in this set of ex-
periments, all reverb facts are added to the mem-
ory, without any retraining, and we test our ability
to rerank answers on the companion qa set. thus,
table 4 (last column) presents the result of our
model without training on reverb against meth-
ods speci   cally developed on that dataset. our
best results are 67% accuracy (and 68% for the
ensemble of 5 models), which are better than the
54% of the original paper and close to the state-
of-the-art 73% of (bordes et al., 2014b). these re-
sults show that the memory network approach can

integrate and use new entities and links.

importance of data sources the bottom half of
table 4 presents the results on the three datasets
when our model is trained with different data
sources. we    rst notice that models trained on
a single qa dataset perform poorly on the other
datasets (e.g. 46.6% accuracy on simpleques-
tions for the model trained on webquestions
only), which shows that the performance on we-
bquestions does not necessarily guarantee high
coverage for simple qa. on the other hand, train-
ing on both datasets only improves performance;
in particular, the model is able to capture all ques-
tion patterns of the two datasets; there is no    neg-
ative interaction   .

while paraphrases do not seem to help much
on webquestions and simplequestions, ex-
cept when training only with synthetic questions,
they have a dramatic impact on the performance
on reverb. this is because webquestions and
simplequestions questions follow simple pat-
terns and are well formed, while reverb questions
have more syntactic and lexical variability. thus,
paraphrases are important to avoid over   tting on
speci   c question patterns of the training sets.

7 conclusion

this paper presents
an implementation of
memnns for the task of large-scale simple qa.
our results demonstrate that, if properly trained,
memnns are able to handle natural language and
a very large memory (millions of entries), and
hence can reach state-of-the-art on the popular
benchmark webquestions.

we want to emphasize that many of our    nd-
ings, especially those regarding how to format the
kb, do not only concern memnns but potentially
any qa system. this paper also introduced the
new dataset simplequestions, which, with 100k
examples, is one order of magnitude bigger than
webquestions: we hope that it will foster inter-
esting new research in qa, simple or not.

references
[berant and liang2014] jonathan berant and percy
liang. 2014. id29 via id141. in
proceedings of the 52nd annual meeting of the as-
sociation for computational linguistics (acl   14),
baltimore, usa.

[berant et al.2013] jonathan berant, andrew chou,

roy frostig, and percy liang. 2013. semantic pars-
ing on freebase from question-answer pairs. in pro-
ceedings of the 2013 conference on empirical meth-
ods in natural language processing (emnlp   13),
seattle, usa.

[bordes et al.2014a] antoine bordes, sumit chopra,
and jason weston. 2014a. id53 with
subgraph embeddings. in proceedings of the 2014
conference on empirical methods in natural lan-
guage processing (emnlp), pages 615   620, doha,
qatar, october. association for computational lin-
guistics.

[bordes et al.2014b] antoine bordes, jason weston,
and nicolas usunier. 2014b. open question an-
swering with weakly supervised embedding mod-
els.
in proceedings of the 7th european confer-
ence on machine learning and principles and prac-
tice of knowledge discovery in databases (ecml-
pkdd   14), nancy, france. springer.

[cai and yates2013] qingqing cai

and alexander
2013. large-scale id29 via
yates.
in
schema matching and lexicon extension.
proceedings of
the
association for computational linguistics (volume
1: long papers), so   a, bulgaria, august.

the 51st annual meeting of

[duchi et al.2011] john duchi, elad hazan, and yoram
singer. 2011. adaptive subgradient methods for on-
line learning and stochastic optimization. the jour-
nal of machine learning research, 12.

[dumais et al.2002] susan dumais, michele banko,
eric brill, jimmy lin, and andrew ng. 2002. web
id53: is more always better? in pro-
ceedings of the 25th annual international acm si-
gir conference on research and development in in-
formation retrieval, pages 291   298. acm.

[fader et al.2011] anthony fader, stephen soderland,
and oren etzioni.
identifying relations
for id10.
in proceedings
of the conference of empirical methods in natu-
ral language processing (emnlp   11), edinburgh,
uk, july 27-31.

2011.

[fader et al.2013] anthony fader, luke zettlemoyer,
and oren etzioni. 2013. paraphrase-driven learn-
ing for open id53. in proceedings of
the 51st annual meeting of the association for com-
putational linguistics (acl   13), so   a, bulgaria.

[fader et al.2014] anthony fader, luke zettlemoyer,
and oren etzioni. 2014. open id53
over curated and extracted knowledge bases. in pro-
ceedings of 20th sigkdd conference on knowl-
edge discovery and data mining (kdd   14), new
york city, usa. acm.

[kwiatkowski et al.2013] tom kwiatkowski, eunsol
choi, yoav artzi, and luke zettlemoyer.
2013.
scaling semantic parsers with on-the-   y ontology
matching. in proceedings of the 2013 conference

structured data: id53 with free-
base.
in proceedings of the 52nd annual meet-
ing of the association for computational linguistics
(acl   14), baltimore, usa.

on empirical methods in natural language pro-
cessing (emnlp   13), seattle, usa, october.

[lin et al.2012] thomas lin, mausam, and oren et-
zioni. 2012. entity linking at web scale.
in pro-
ceedings of the joint workshop on automatic knowl-
edge base construction and web-scale knowledge
extraction (akbc-wekex   12), montreal, canada.

[recht et al.2011] benjamin recht, christopher r  e,
stephen j wright, and feng niu. 2011. hogwild!:
a lock-free approach to parallelizing stochastic gra-
dient descent.
in advances in neural information
processing systems (nips 24)., vancouver, canada.

[reddy et al.2014] siva reddy, mirella lapata, and
mark steedman. 2014. large-scale semantic pars-
ing without question-answer pairs. transactions
of the association for computational linguistics,
2:377   392.

[sukhbaatar et al.2015] sainbayar sukhbaatar, arthur
2015.
arxiv

szlam, jason weston, and rob fergus.
weakly supervised memory networks.
preprint arxiv:1503.08895.

[unger et al.2012] christina unger, lorenz b  uhmann,
jens lehmann, axel-cyrille ngonga ngomo,
daniel gerber, and philipp cimiano.
2012.
template-based id53 over rdf data.
in proceedings of the 21st international confer-
ence on world wide web (www   12), lyon, france.
acm.

[voorhees and tice2000] ellen m voorhees

and
dm tice. 2000. overview of the trec-9 question
answering track. in trec.

[weston et al.2010] jason weston, samy bengio, and
nicolas usunier. 2010. large scale image anno-
tation: learning to rank with joint word-image em-
beddings. machine learning, 81(1).

[weston et al.2015] jason weston, sumit chopra, and
antoine bordes. 2015. memory networks. in pro-
ceedings of the 2014 international conference on
learning representations (iclr).
arxiv preprint
arxiv:1410.3916.

[yahya et al.2012] mohamed yahya, klaus berberich,
shady elbassuoni, maya ramanath, volker tresp,
and gerhard weikum.
2012. natural language
questions for the web of data. in proceedings of the
conference on empirical methods in natural lan-
guage processing.

[yang et al.2014] min-chul yang, nan duan, ming
zhou, and hae-chang rim. 2014. joint relational
embeddings for knowledge-based question answer-
ing.
in proceedings of the 2014 conference on
empirical methods in natural language processing
(emnlp), pages 645   650.

[yao and van durme2014] xuchen yao and benjamin
information extraction over

van durme.

2014.

