deep residual learning for image recognition

kaiming he

xiangyu zhang

shaoqing ren

jian sun

microsoft research

{kahe, v-xiangz, v-shren, jiansun}@microsoft.com

5
1
0
2
 
c
e
d
0
1

 

 
 
]

v
c
.
s
c
[
 
 

1
v
5
8
3
3
0

.

2
1
5
1
:
v
i
x
r
a

abstract

deeper neural networks are more dif   cult to train. we
present a residual learning framework to ease the training
of networks that are substantially deeper than those used
previously. we explicitly reformulate the layers as learn-
ing residual functions with reference to the layer inputs, in-
stead of learning unreferenced functions. we provide com-
prehensive empirical evidence showing that these residual
networks are easier to optimize, and can gain accuracy from
considerably increased depth. on the id163 dataset we
evaluate residual nets with a depth of up to 152 layers   8  
deeper than vgg nets [41] but still having lower complex-
ity. an ensemble of these residual nets achieves 3.57% error
on the id163 test set. this result won the 1st place on the
ilsvrc 2015 classi   cation task. we also present analysis
on cifar-10 with 100 and 1000 layers.

the depth of representations is of central importance
for many visual recognition tasks. solely due to our ex-
tremely deep representations, we obtain a 28% relative im-
provement on the coco id164 dataset. deep
residual nets are foundations of our submissions to ilsvrc
& coco 2015 competitions1, where we also won the 1st
places on the tasks of id163 detection, id163 local-
ization, coco detection, and coco segmentation.

1. introduction

deep convolutional neural networks [22, 21] have led
to a series of breakthroughs for image classi   cation [21,
50, 40]. deep networks naturally integrate low/mid/high-
level features [50] and classi   ers in an end-to-end multi-
layer fashion, and the    levels    of features can be enriched
by the number of stacked layers (depth). recent evidence
[41, 44] reveals that network depth is of crucial importance,
and the leading results [41, 44, 13, 16] on the challenging
id163 dataset [36] all exploit    very deep    [41] models,
with a depth of sixteen [41] to thirty [16]. many other non-
trivial visual recognition tasks [8, 12, 7, 32, 27] have also

1http://image-net.org/challenges/lsvrc/2015/

and
http://mscoco.org/dataset/#detections-challenge2015.

figure 1. training error (left) and test error (right) on cifar-10
with 20-layer and 56-layer    plain    networks. the deeper network
has higher training error, and thus test error. similar phenomena
on id163 is presented in fig. 4.

greatly bene   ted from very deep models.

driven by the signi   cance of depth, a question arises: is
learning better networks as easy as stacking more layers?
an obstacle to answering this question was the notorious
problem of vanishing/exploding gradients [1, 9], which
hamper convergence from the beginning. this problem,
however, has been largely addressed by normalized initial-
ization [23, 9, 37, 13] and intermediate id172 layers
[16], which enable networks with tens of layers to start con-
verging for stochastic id119 (sgd) with back-
propagation [22].

when deeper networks are able to start converging, a
degradation problem has been exposed: with the network
depth increasing, accuracy gets saturated (which might be
unsurprising) and then degrades rapidly. unexpectedly,
such degradation is not caused by over   tting, and adding
more layers to a suitably deep model leads to higher train-
ing error, as reported in [11, 42] and thoroughly veri   ed by
our experiments. fig. 1 shows a typical example.

the degradation (of training accuracy) indicates that not
all systems are similarly easy to optimize. let us consider a
shallower architecture and its deeper counterpart that adds
more layers onto it. there exists a solution by construction
to the deeper model: the added layers are identity mapping,
and the other layers are copied from the learned shallower
model. the existence of this constructed solution indicates
that a deeper model should produce no higher training error
than its shallower counterpart. but experiments show that
our current solvers on hand are unable to    nd solutions that

1

01234560 1020iter. (1e4)training error (%)  012345601020iter. (1e4)test error (%)  56-layer20-layer56-layer20-layerid163 test set, and won the 1st place in the ilsvrc
2015 classi   cation competition. the extremely deep rep-
resentations also have excellent generalization performance
on other recognition tasks, and lead us to further win the
1st places on: id163 detection, id163 localization,
coco detection, and coco segmentation in ilsvrc &
coco 2015 competitions. this strong evidence shows that
the residual learning principle is generic, and we expect that
it is applicable in other vision and non-vision problems.

2. related work
residual representations. in image recognition, vlad
[18] is a representation that encodes by the residual vectors
with respect to a dictionary, and fisher vector [30] can be
formulated as a probabilistic version [18] of vlad. both
of them are powerful shallow representations for image re-
trieval and classi   cation [4, 48]. for vector quantization,
encoding residual vectors [17] is shown to be more effec-
tive than encoding original vectors.

in low-level vision and computer graphics, for solv-
ing partial differential equations (pdes), the widely used
multigrid method [3] reformulates the system as subprob-
lems at multiple scales, where each subproblem is respon-
sible for the residual solution between a coarser and a    ner
scale. an alternative to multigrid is hierarchical basis pre-
conditioning [45, 46], which relies on variables that repre-
sent residual vectors between two scales. it has been shown
[3, 45, 46] that these solvers converge much faster than stan-
dard solvers that are unaware of the residual nature of the
solutions. these methods suggest that a good reformulation
or preconditioning can simplify the optimization.
shortcut connections. practices and theories that lead to
shortcut connections [2, 34, 49] have been studied for a long
time. an early practice of training multi-layer id88s
(mlps) is to add a linear layer connected from the network
input to the output [34, 49].
in [44, 24], a few interme-
diate layers are directly connected to auxiliary classi   ers
for addressing vanishing/exploding gradients. the papers
of [39, 38, 31, 47] propose methods for centering layer re-
sponses, gradients, and propagated errors, implemented by
shortcut connections. in [44], an    inception    layer is com-
posed of a shortcut branch and a few deeper branches.

concurrent with our work,    id199    [42, 43]
present shortcut connections with gating functions [15].
these gates are data-dependent and have parameters, in
contrast to our identity shortcuts that are parameter-free.
when a gated shortcut is    closed    (approaching zero), the
layers in id199 represent non-residual func-
tions. on the contrary, our formulation always learns
residual functions; our identity shortcuts are never closed,
and all information is always passed through, with addi-
tional residual functions to be learned. in addition, high-

figure 2. residual learning: a building block.

are comparably good or better than the constructed solution
(or unable to do so in feasible time).

learning framework.

in this paper, we address the degradation problem by
introducing a deep residual
in-
stead of hoping each few stacked layers directly    t a
desired underlying mapping, we explicitly let these lay-
ers    t a residual mapping. formally, denoting the desired
underlying mapping as h(x), we let the stacked nonlinear
layers    t another mapping of f(x) := h(x)    x. the orig-
inal mapping is recast into f(x)+x. we hypothesize that it
is easier to optimize the residual mapping than to optimize
the original, unreferenced mapping. to the extreme, if an
identity mapping were optimal, it would be easier to push
the residual to zero than to    t an identity mapping by a stack
of nonlinear layers.

the formulation of f(x) + x can be realized by feedfor-
ward neural networks with    shortcut connections    (fig. 2).
shortcut connections [2, 34, 49] are those skipping one or
more layers. in our case, the shortcut connections simply
perform identity mapping, and their outputs are added to
the outputs of the stacked layers (fig. 2).
identity short-
cut connections add neither extra parameter nor computa-
tional complexity. the entire network can still be trained
end-to-end by sgd with id26, and can be eas-
ily implemented using common libraries (e.g., caffe [19])
without modifying the solvers.

we present comprehensive experiments on id163
[36] to show the degradation problem and evaluate our
method. we show that: 1) our extremely deep residual nets
are easy to optimize, but the counterpart    plain    nets (that
simply stack layers) exhibit higher training error when the
depth increases; 2) our deep residual nets can easily enjoy
accuracy gains from greatly increased depth, producing re-
sults substantially better than previous networks.

similar phenomena are also shown on the cifar-10 set
[20], suggesting that the optimization dif   culties and the
effects of our method are not just akin to a particular dataset.
we present successfully trained models on this dataset with
over 100 layers, and explore models with over 1000 layers.
on the id163 classi   cation dataset [36], we obtain
excellent results by extremely deep residual nets. our 152-
layer residual net is the deepest network ever presented on
id163, while still having lower complexity than vgg
nets [41]. our ensemble has 3.57% top-5 error on the

2

identityweight layerweight layerrelureluf(x)(cid:1)+(cid:1)xxf(x)xway networks have not demonstrated accuracy gains with
extremely increased depth (e.g., over 100 layers).

3. deep residual learning
3.1. residual learning

let us consider h(x) as an underlying mapping to be
   t by a few stacked layers (not necessarily the entire net),
with x denoting the inputs to the    rst of these layers. if one
hypothesizes that multiple nonlinear layers can asymptoti-
cally approximate complicated functions2, then it is equiv-
alent to hypothesize that they can asymptotically approxi-
mate the residual functions, i.e., h(x)     x (assuming that
the input and output are of the same dimensions). so
rather than expect stacked layers to approximate h(x), we
explicitly let these layers approximate a residual function
f(x) := h(x)     x. the original function thus becomes
f(x)+x. although both forms should be able to asymptot-
ically approximate the desired functions (as hypothesized),
the ease of learning might be different.

this reformulation is motivated by the counterintuitive
phenomena about the degradation problem (fig. 1, left). as
we discussed in the introduction, if the added layers can
be constructed as identity mappings, a deeper model should
have training error no greater than its shallower counter-
part. the degradation problem suggests that the solvers
might have dif   culties in approximating identity mappings
by multiple nonlinear layers. with the residual learning re-
formulation, if identity mappings are optimal, the solvers
may simply drive the weights of the multiple nonlinear lay-
ers toward zero to approach identity mappings.

in real cases, it is unlikely that identity mappings are op-
timal, but our reformulation may help to precondition the
problem.
if the optimal function is closer to an identity
mapping than to a zero mapping, it should be easier for the
solver to    nd the perturbations with reference to an identity
mapping, than to learn the function as a new one. we show
by experiments (fig. 7) that the learned residual functions in
general have small responses, suggesting that identity map-
pings provide reasonable preconditioning.
3.2. identity mapping by shortcuts

we adopt residual learning to every few stacked layers.
a building block is shown in fig. 2. formally, in this paper
we consider a building block de   ned as:

y = f(x,{wi}) + x.

(1)

here x and y are the input and output vectors of the lay-
ers considered. the function f(x,{wi}) represents the
residual mapping to be learned. for the example in fig. 2
that has two layers, f = w2  (w1x) in which    denotes

2this hypothesis, however, is still an open question. see [28].

relu [29] and the biases are omitted for simplifying no-
tations. the operation f + x is performed by a shortcut
connection and element-wise addition. we adopt the sec-
ond nonlinearity after the addition (i.e.,   (y), see fig. 2).

the shortcut connections in eqn.(1) introduce neither ex-
tra parameter nor computation complexity. this is not only
attractive in practice but also important in our comparisons
between plain and residual networks. we can fairly com-
pare plain/residual networks that simultaneously have the
same number of parameters, depth, width, and computa-
tional cost (except for the negligible element-wise addition).
the dimensions of x and f must be equal in eqn.(1).
if this is not the case (e.g., when changing the input/output
channels), we can perform a linear projection ws by the
shortcut connections to match the dimensions:

y = f(x,{wi}) + wsx.

(2)

we can also use a square matrix ws in eqn.(1). but we will
show by experiments that the identity mapping is suf   cient
for addressing the degradation problem and is economical,
and thus ws is only used when matching dimensions.

the form of the residual function f is    exible. exper-
iments in this paper involve a function f that has two or
three layers (fig. 5), while more layers are possible. but if
f has only a single layer, eqn.(1) is similar to a linear layer:
y = w1x + x, for which we have not observed advantages.
we also note that although the above notations are about
fully-connected layers for simplicity, they are applicable to
convolutional layers. the function f(x,{wi}) can repre-
sent multiple convolutional layers. the element-wise addi-
tion is performed on two feature maps, channel by channel.
3.3. network architectures

we have tested various plain/residual nets, and have ob-
served consistent phenomena. to provide instances for dis-
cussion, we describe two models for id163 as follows.
plain network. our plain baselines (fig. 3, middle) are
mainly inspired by the philosophy of vgg nets [41] (fig. 3,
left). the convolutional layers mostly have 3  3    lters and
follow two simple design rules:
(i) for the same output
feature map size, the layers have the same number of    l-
ters; and (ii) if the feature map size is halved, the num-
ber of    lters is doubled so as to preserve the time com-
plexity per layer. we perform downsampling directly by
convolutional layers that have a stride of 2. the network
ends with a global average pooling layer and a 1000-way
fully-connected layer with softmax. the total number of
weighted layers is 34 in fig. 3 (middle).

it is worth noticing that our model has fewer    lters and
lower complexity than vgg nets [41] (fig. 3, left). our 34-
layer baseline has 3.6 billion flops (multiply-adds), which
is only 18% of vgg-19 (19.6 billion flops).

3

residual network. based on the above plain network, we
insert shortcut connections (fig. 3, right) which turn the
network into its counterpart residual version. the identity
shortcuts (eqn.(1)) can be directly used when the input and
output are of the same dimensions (solid line shortcuts in
fig. 3). when the dimensions increase (dotted line shortcuts
in fig. 3), we consider two options: (a) the shortcut still
performs identity mapping, with extra zero entries padded
for increasing dimensions. this option introduces no extra
parameter; (b) the projection shortcut in eqn.(2) is used to
match dimensions (done by 1  1 convolutions). for both
options, when the shortcuts go across feature maps of two
sizes, they are performed with a stride of 2.
3.4. implementation

our implementation for id163 follows the practice
in [21, 41]. the image is resized with its shorter side ran-
domly sampled in [256, 480] for scale augmentation [41].
a 224  224 crop is randomly sampled from an image or its
horizontal    ip, with the per-pixel mean subtracted [21]. the
standard color augmentation in [21] is used. we adopt batch
id172 (bn) [16] right after each convolution and
before activation, following [16]. we initialize the weights
as in [13] and train all plain/residual nets from scratch. we
use sgd with a mini-batch size of 256. the learning rate
starts from 0.1 and is divided by 10 when the error plateaus,
and the models are trained for up to 60   104 iterations. we
use a weight decay of 0.0001 and a momentum of 0.9. we
do not use dropout [14], following the practice in [16].

in testing, for comparison studies we adopt the standard
10-crop testing [21]. for best results, we adopt the fully-
convolutional form as in [41, 13], and average the scores
at multiple scales (images are resized such that the shorter
side is in {224, 256, 384, 480, 640}).
4. experiments
4.1. id163 classi   cation

we evaluate our method on the id163 2012 classi   -
cation dataset [36] that consists of 1000 classes. the models
are trained on the 1.28 million training images, and evalu-
ated on the 50k validation images. we also obtain a    nal
result on the 100k test images, reported by the test server.
we evaluate both top-1 and top-5 error rates.
plain networks. we    rst evaluate 18-layer and 34-layer
plain nets. the 34-layer plain net is in fig. 3 (middle). the
18-layer plain net is of a similar form. see table 1 for de-
tailed architectures.

the results in table 2 show that the deeper 34-layer plain
net has higher validation error than the shallower 18-layer
plain net. to reveal the reasons, in fig. 4 (left) we com-
pare their training/validation errors during the training pro-
cedure. we have observed the degradation problem - the

figure 3. example network architectures for id163. left: the
vgg-19 model [41] (19.6 billion flops) as a reference. mid-
dle: a plain network with 34 parameter layers (3.6 billion flops).
right: a residual network with 34 parameter layers (3.6 billion
flops). the dotted shortcuts increase dimensions. table 1 shows
more details and other variants.

4

7x7 conv, 64, /2pool, /23x3 conv, 643x3 conv, 643x3 conv, 643x3 conv, 643x3 conv, 643x3 conv, 643x3 conv, 128, /23x3 conv, 1283x3 conv, 1283x3 conv, 1283x3 conv, 1283x3 conv, 1283x3 conv, 1283x3 conv, 1283x3 conv, 256, /23x3 conv, 2563x3 conv, 2563x3 conv, 2563x3 conv, 2563x3 conv, 2563x3 conv, 2563x3 conv, 2563x3 conv, 2563x3 conv, 2563x3 conv, 2563x3 conv, 2563x3 conv, 512, /23x3 conv, 5123x3 conv, 5123x3 conv, 5123x3 conv, 5123x3 conv, 512avg poolfc 1000image3x3 conv, 5123x3 conv, 643x3 conv, 64pool, /23x3 conv, 1283x3 conv, 128pool, /23x3 conv, 2563x3 conv, 2563x3 conv, 2563x3 conv, 256pool, /23x3 conv, 5123x3 conv, 5123x3 conv, 512pool, /23x3 conv, 5123x3 conv, 5123x3 conv, 5123x3 conv, 512pool, /2fc 4096fc 4096fc 1000imageoutput size: 112output size: 224output size: 56output size: 28output size: 14output size: 7output size: 1vgg-1934-layer plain7x7 conv, 64, /2pool, /23x3 conv, 643x3 conv, 643x3 conv, 643x3 conv, 643x3 conv, 643x3 conv, 643x3 conv, 128, /23x3 conv, 1283x3 conv, 1283x3 conv, 1283x3 conv, 1283x3 conv, 1283x3 conv, 1283x3 conv, 1283x3 conv, 256, /23x3 conv, 2563x3 conv, 2563x3 conv, 2563x3 conv, 2563x3 conv, 2563x3 conv, 2563x3 conv, 2563x3 conv, 2563x3 conv, 2563x3 conv, 2563x3 conv, 2563x3 conv, 512, /23x3 conv, 5123x3 conv, 5123x3 conv, 5123x3 conv, 5123x3 conv, 512avg poolfc 1000image34-layer residuallayer name output size
112  112

conv1

conv2 x

56  56

conv3 x

conv4 x

conv5 x

28  28

14  14

7  7
1  1

18-layer

34-layer

3  3, 64

(cid:20) 3  3, 64
(cid:20) 3  3, 128
(cid:20) 3  3, 256
(cid:20) 3  3, 512

3  3, 128

3  3, 256

3  3, 512

(cid:21)
  2
(cid:21)
  2
(cid:21)
  2
(cid:21)
  2

3  3, 64

(cid:20) 3  3, 64
(cid:20) 3  3, 128
(cid:20) 3  3, 256
(cid:20) 3  3, 512

3  3, 128

3  3, 256

3  3, 512

101-layer

50-layer
7  7, 64, stride 2

3  3 max pool, stride 2

        3
        4
        6
        3

       1  1, 64
       1  1, 128
       1  1, 256
       1  1, 512

(cid:21)
  3
(cid:21)
  4
(cid:21)
  6
(cid:21)
  3
average pool, 1000-d fc, softmax

3  3, 64
1  1, 256
3  3, 128
1  1, 512
3  3, 256
1  1, 1024
3  3, 512
1  1, 2048
3.8  109

       1  1, 64
       1  1, 128
       1  1, 256
       1  1, 512

3  3, 64
1  1, 256
3  3, 128
1  1, 512
3  3, 256
1  1, 1024
3  3, 512
1  1, 2048
7.6  109

        3
        4
        23
        3

        3
        8
        36
        3

152-layer

       1  1, 64
       1  1, 128
       1  1, 256
       1  1, 512

3  3, 64
1  1, 256
3  3, 128
1  1, 512
3  3, 256
1  1, 1024
3  3, 512
1  1, 2048
11.3  109

flops

1.8  109

3.6  109

table 1. architectures for id163. building blocks are shown in brackets (see also fig. 5), with the numbers of blocks stacked. down-
sampling is performed by conv3 1, conv4 1, and conv5 1 with a stride of 2.

figure 4. training on id163. thin curves denote training error, and bold curves denote validation error of the center crops. left: plain
networks of 18 and 34 layers. right: resnets of 18 and 34 layers. in this plot, the residual networks have no extra parameter compared to
their plain counterparts.

18 layers
34 layers

plain
27.94
28.54

resnet
27.88
25.03

table 2. top-1 error (%, 10-crop testing) on id163 validation.
here the resnets have no extra parameter compared to their plain
counterparts. fig. 4 shows the training procedures.

34-layer plain net has higher training error throughout the
whole training procedure, even though the solution space
of the 18-layer plain network is a subspace of that of the
34-layer one.

we argue that this optimization dif   culty is unlikely to
be caused by vanishing gradients. these plain networks are
trained with bn [16], which ensures forward propagated
signals to have non-zero variances. we also verify that the
backward propagated gradients exhibit healthy norms with
bn. so neither forward nor backward signals vanish.
in
fact, the 34-layer plain net is still able to achieve compet-
itive accuracy (table 3), suggesting that the solver works
to some extent. we conjecture that the deep plain nets may
have exponentially low convergence rates, which impact the

5

reducing of the training error3. the reason for such opti-
mization dif   culties will be studied in the future.
residual networks. next we evaluate 18-layer and 34-
layer residual nets (resnets). the baseline architectures
are the same as the above plain nets, expect that a shortcut
connection is added to each pair of 3  3    lters as in fig. 3
(right). in the    rst comparison (table 2 and fig. 4 right),
we use identity mapping for all shortcuts and zero-padding
for increasing dimensions (option a). so they have no extra
parameter compared to the plain counterparts.

we have three major observations from table 2 and
fig. 4. first, the situation is reversed with residual learn-
ing     the 34-layer resnet is better than the 18-layer resnet
(by 2.8%). more importantly, the 34-layer resnet exhibits
considerably lower training error and is generalizable to the
validation data. this indicates that the degradation problem
is well addressed in this setting and we manage to obtain
accuracy gains from increased depth.

second, compared to its plain counterpart, the 34-layer
3we have experimented with more training iterations (3  ) and still ob-
served the degradation problem, suggesting that this problem cannot be
feasibly addressed by simply using more iterations.

010203040502030405060iter. (1e4)error (%)  plain-18plain-34010203040502030405060iter. (1e4)error (%)  resnet-18resnet-3418-layer34-layer18-layer34-layermodel
vgg-16 [41]
googlenet [44]
prelu-net [13]

plain-34
resnet-34 a
resnet-34 b
resnet-34 c
resnet-50
resnet-101
resnet-152

top-1 err.
28.07

-

24.27
28.54
25.03
24.52
24.19
22.85
21.75
21.43

top-5 err.

9.33
9.15
7.38
10.02
7.76
7.46
7.40
6.71
6.05
5.71

table 3. error rates (%, 10-crop testing) on id163 validation.
vgg-16 is based on our test. resnet-50/101/152 are of option b
that only uses projections for increasing dimensions.

method
vgg [41] (ilsvrc   14)
googlenet [44] (ilsvrc   14)
vgg [41] (v5)
prelu-net [13]
bn-inception [16]
resnet-34 b
resnet-34 c
resnet-50
resnet-101
resnet-152

top-1 err.

-
-

24.4
21.59
21.99
21.84
21.53
20.74
19.87
19.38

top-5 err.
8.43   
7.89
7.1
5.71
5.81
5.71
5.60
5.25
4.60
4.49

table 4. error rates (%) of single-model results on the id163
validation set (except     reported on the test set).

method
vgg [41] (ilsvrc   14)
googlenet [44] (ilsvrc   14)
vgg [41] (v5)
prelu-net [13]
bn-inception [16]
resnet (ilsvrc   15)

top-5 err. (test)

7.32
6.66
6.8
4.94
4.82
3.57

table 5. error rates (%) of ensembles. the top-5 error is on the
test set of id163 and reported by the test server.

resnet reduces the top-1 error by 3.5% (table 2), resulting
from the successfully reduced training error (fig. 4 right vs.
left). this comparison veri   es the effectiveness of residual
learning on extremely deep systems.

last, we also note that the 18-layer plain/residual nets
are comparably accurate (table 2), but the 18-layer resnet
converges faster (fig. 4 right vs. left). when the net is    not
overly deep    (18 layers here), the current sgd solver is still
able to    nd good solutions to the plain net. in this case, the
resnet eases the optimization by providing faster conver-
gence at the early stage.
identity vs. projection shortcuts. we have shown that

figure 5. a deeper residual function f for id163. left: a
building block (on 56  56 feature maps) as in fig. 3 for resnet-
34. right: a    bottleneck    building block for resnet-50/101/152.

parameter-free, identity shortcuts help with training. next
we investigate projection shortcuts (eqn.(2)). in table 3 we
compare three options: (a) zero-padding shortcuts are used
for increasing dimensions, and all shortcuts are parameter-
free (the same as table 2 and fig. 4 right); (b) projec-
tion shortcuts are used for increasing dimensions, and other
shortcuts are identity; and (c) all shortcuts are projections.
table 3 shows that all three options are considerably bet-
ter than the plain counterpart. b is slightly better than a. we
argue that this is because the zero-padded dimensions in a
indeed have no residual learning. c is marginally better than
b, and we attribute this to the extra parameters introduced
by many (thirteen) projection shortcuts. but the small dif-
ferences among a/b/c indicate that projection shortcuts are
not essential for addressing the degradation problem. so we
do not use option c in the rest of this paper, to reduce mem-
ory/time complexity and model sizes. identity shortcuts are
particularly important for not increasing the complexity of
the bottleneck architectures that are introduced below.
deeper bottleneck architectures. next we describe our
deeper nets for id163. because of concerns on the train-
ing time that we can afford, we modify the building block
as a bottleneck design4. for each residual function f, we
use a stack of 3 layers instead of 2 (fig. 5). the three layers
are 1  1, 3  3, and 1  1 convolutions, where the 1  1 layers
are responsible for reducing and then increasing (restoring)
dimensions, leaving the 3  3 layer a bottleneck with smaller
input/output dimensions. fig. 5 shows an example, where
both designs have similar time complexity.

the parameter-free identity shortcuts are particularly im-
portant for the bottleneck architectures. if the identity short-
cut in fig. 5 (right) is replaced with projection, one can
show that the time complexity and model size are doubled,
as the shortcut is connected to the two high-dimensional
ends. so identity shortcuts lead to more ef   cient models
for the bottleneck designs.

50-layer resnet: we replace each 2-layer block in the

4deeper non-bottleneck resnets (e.g., fig. 5 left) also gain accuracy
from increased depth (as shown on cifar-10), but are not as economical
as the bottleneck resnets. so the usage of bottleneck designs is mainly due
to practical considerations. we further note that the degradation problem
of plain nets is also witnessed for the bottleneck designs.

6

3x3, 641x1, 64relu1x1, 256relurelu3x3, 643x3, 64relurelu64-d256-d34-layer net with this 3-layer bottleneck block, resulting in
a 50-layer resnet (table 1). we use option b for increasing
dimensions. this model has 3.8 billion flops.

101-layer and 152-layer resnets: we construct 101-
layer and 152-layer resnets by using more 3-layer blocks
(table 1). remarkably, although the depth is signi   cantly
increased, the 152-layer resnet (11.3 billion flops) still
has lower complexity than vgg-16/19 nets (15.3/19.6 bil-
lion flops).

the 50/101/152-layer resnets are more accurate than
the 34-layer ones by considerable margins (table 3 and 4).
we do not observe the degradation problem and thus en-
joy signi   cant accuracy gains from considerably increased
depth. the bene   ts of depth are witnessed for all evaluation
metrics (table 3 and 4).
comparisons with state-of-the-art methods. in table 4
we compare with the previous best single-model results.
our baseline 34-layer resnets have achieved very compet-
itive accuracy. our 152-layer resnet has a single-model
top-5 validation error of 4.49%. this single-model result
outperforms all previous ensemble results (table 5). we
combine six models of different depth to form an ensemble
(only with two 152-layer ones at the time of submitting).
this leads to 3.57% top-5 error on the test set (table 5).
this entry won the 1st place in ilsvrc 2015.

4.2. cifar-10 and analysis

we conducted more studies on the cifar-10 dataset
[20], which consists of 50k training images and 10k test-
ing images in 10 classes. we present experiments trained
on the training set and evaluated on the test set. our focus
is on the behaviors of extremely deep networks, but not on
pushing the state-of-the-art results, so we intentionally use
simple architectures as follows.

the plain/residual architectures follow the form in fig. 3
(middle/right). the network inputs are 32  32 images, with
the per-pixel mean subtracted. the    rst layer is 3  3 convo-
lutions. then we use a stack of 6n layers with 3  3 convo-
lutions on the feature maps of sizes {32, 16, 8} respectively,
with 2n layers for each feature map size. the numbers of
   lters are {16, 32, 64} respectively. the subsampling is per-
formed by convolutions with a stride of 2. the network ends
with a global average pooling, a 10-way fully-connected
layer, and softmax. there are totally 6n+2 stacked weighted
layers. the following table summarizes the architecture:

output map size

# layers
#    lters

32  32
1+2n
16

16  16
2n
32

8  8
2n
64

when shortcut connections are used, they are connected
to the pairs of 3  3 layers (totally 3n shortcuts). on this
dataset we use identity shortcuts in all cases (i.e., option a),

method

maxout [10]

nin [25]
dsn [24]

# layers

# params

error (%)
9.38
8.81
8.22

8.39
7.54 (7.72  0.16)

fitnet [35]

highway [42, 43]
highway [42, 43]

resnet
resnet
resnet
resnet
resnet
resnet

19
19
32
20
32
44
56
110
1202

2.5m
2.3m
1.25m 8.80
0.27m 8.75
0.46m 7.51
0.66m 7.17
0.85m 6.97
1.7m
19.4m 7.93

6.43 (6.61  0.16)

table 6. classi   cation error on the cifar-10 test set. all meth-
ods are with data augmentation. for resnet-110, we run it 5 times
and show    best (mean  std)    as in [43].

so our residual models have exactly the same depth, width,
and number of parameters as the plain counterparts.

we use a weight decay of 0.0001 and momentum of 0.9,
and adopt the weight initialization in [13] and bn [16] but
with no dropout. these models are trained with a mini-
batch size of 128 on two gpus. we start with a learning
rate of 0.1, divide it by 10 at 32k and 48k iterations, and
terminate training at 64k iterations, which is determined on
a 45k/5k train/val split. we follow the simple data augmen-
tation in [24] for training: 4 pixels are padded on each side,
and a 32  32 crop is randomly sampled from the padded
image or its horizontal    ip. for testing, we only evaluate
the single view of the original 32  32 image.
we compare n = {3, 5, 7, 9}, leading to 20, 32, 44, and
56-layer networks. fig. 6 (left) shows the behaviors of the
plain nets. the deep plain nets suffer from increased depth,
and exhibit higher training error when going deeper. this
phenomenon is similar to that on id163 (fig. 4, left) and
on mnist (see [42]), suggesting that such an optimization
dif   culty is a fundamental problem.

fig. 6 (middle) shows the behaviors of resnets. also
similar to the id163 cases (fig. 4, right), our resnets
manage to overcome the optimization dif   culty and demon-
strate accuracy gains when the depth increases.

we further explore n = 18 that leads to a 110-layer
resnet. in this case, we    nd that the initial learning rate
of 0.1 is slightly too large to start converging5. so we use
0.01 to warm up the training until the training error is below
80% (about 400 iterations), and then go back to 0.1 and con-
tinue training. the rest of the learning schedule is as done
previously. this 110-layer network converges well (fig. 6,
middle). it has fewer parameters than other deep and thin

5with an initial learning rate of 0.1, it starts converging (<90% error)

after several epochs, but still reaches similar accuracy.

7

figure 6. training on cifar-10. dashed lines denote training error, and bold lines denote testing error. left: plain networks. the error
of plain-110 is higher than 60% and not displayed. middle: resnets. right: resnets with 110 and 1202 layers.

training data

07+12

07++12

test data
vgg-16

resnet-101

voc 07 test

voc 12 test

73.2
76.4

70.4
73.8

table 7. id164 map (%) on the pascal voc
2007/2012 test sets using baseline faster r-id98. see also ta-
ble 10 and 11 for better results.

metric
vgg-16

resnet-101

map@.5

map@[.5, .95]

41.5
48.4

21.2
27.2

table 8. id164 map (%) on the coco validation set
using baseline faster r-id98. see also table 9 for better results.

have similar training error. we argue that this is because of
over   tting. the 1202-layer network may be unnecessarily
large (19.4m) for this small dataset. strong id173
such as maxout [10] or dropout [14] is applied to obtain the
best results ([10, 25, 24, 35]) on this dataset. in this paper,
we use no maxout/dropout and just simply impose regular-
ization via deep and thin architectures by design, without
distracting from the focus on the dif   culties of optimiza-
tion. but combining with stronger id173 may im-
prove results, which we will study in the future.
4.3. id164 on pascal and ms coco
our method has good generalization performance on
other recognition tasks. table 7 and 8 show the object de-
tection baseline results on pascal voc 2007 and 2012
[5] and coco [26]. we adopt faster r-id98 [32] as the de-
tection method. here we are interested in the improvements
of replacing vgg-16 [41] with resnet-101. the detection
implementation (see appendix) of using both models is the
same, so the gains can only be attributed to better networks.
most remarkably, on the challenging coco dataset we ob-
tain a 6.0% increase in coco   s standard metric (map@[.5,
.95]), which is a 28% relative improvement. this gain is
solely due to the learned representations.

based on deep residual nets, we won the 1st places in
several tracks in ilsvrc & coco 2015 competitions: im-
agenet detection, id163 localization, coco detection,
and coco segmentation. the details are in the appendix.

figure 7. standard deviations (std) of layer responses on cifar-
10. the responses are the outputs of each 3  3 layer, after bn and
before nonlinearity. top: the layers are shown in their original
order. bottom: the responses are ranked in descending order.

networks such as fitnet [35] and highway [42] (table 6),
yet is among the state-of-the-art results (6.43%, table 6).
analysis of layer responses. fig. 7 shows the standard
deviations (std) of the layer responses. the responses are
the outputs of each 3  3 layer, after bn and before other
nonlinearity (relu/addition). for resnets, this analy-
sis reveals the response strength of the residual functions.
fig. 7 shows that resnets have generally smaller responses
than their plain counterparts. these results support our ba-
sic motivation (sec.3.1) that the residual functions might
be generally closer to zero than the non-residual functions.
we also notice that the deeper resnet has smaller magni-
tudes of responses, as evidenced by the comparisons among
resnet-20, 56, and 110 in fig. 7. when there are more
layers, an individual layer of resnets tends to modify the
signal less.
exploring over 1000 layers. we explore an aggressively
deep model of over 1000 layers. we set n = 200 that
leads to a 1202-layer network, which is trained as described
above. our method shows no optimization dif   culty, and
this 103-layer network is able to achieve training error
<0.1% (fig. 6, right).
its test error is still fairly good
(7.93%, table 6).

but there are still open problems on such aggressively
deep models. the testing result of this 1202-layer network
is worse than that of our 110-layer network, although both

8

0123456051020iter. (1e4)error (%)  plain-20plain-32plain-44plain-560123456051020iter. (1e4)error (%)  resnet-20resnet-32resnet-44resnet-56resnet-11056-layer20-layer110-layer20-layer4560151020iter. (1e4)error (%)  residual-110residual-1202020406080100123layer index (sorted by magnitude)std  plain-20plain-56resnet-20resnet-56resnet-110020406080100123layer index (original)std  plain-20plain-56resnet-20resnet-56resnet-110[28] g. mont  ufar, r. pascanu, k. cho, and y. bengio. on the number of

linear regions of deep neural networks. in nips, 2014.

[29] v. nair and g. e. hinton. recti   ed linear units improve restricted

id82s. in icml, 2010.

[30] f. perronnin and c. dance. fisher kernels on visual vocabularies for

image categorization. in cvpr, 2007.

[31] t. raiko, h. valpola, and y. lecun. deep learning made easier by

linear transformations in id88s. in aistats, 2012.

[32] s. ren, k. he, r. girshick, and j. sun. faster r-id98: towards
real-time id164 with region proposal networks. in nips,
2015.

[33] s. ren, k. he, r. girshick, x. zhang, and j. sun. id164

networks on convolutional feature maps. arxiv:1504.06066, 2015.

[34] b. d. ripley. pattern recognition and neural networks. cambridge

university press, 1996.

[35] a. romero, n. ballas, s. e. kahou, a. chassang, c. gatta, and

y. bengio. fitnets: hints for thin deep nets. in iclr, 2015.

[36] o. russakovsky, j. deng, h. su, j. krause, s. satheesh, s. ma,
id163

z. huang, a. karpathy, a. khosla, m. bernstein, et al.
large scale visual recognition challenge. arxiv:1409.0575, 2014.

[37] a. m. saxe, j. l. mcclelland, and s. ganguli. exact solutions to
the nonlinear dynamics of learning in deep linear neural networks.
arxiv:1312.6120, 2013.

[38] n. n. schraudolph. accelerated id119 by factor-centering

decomposition. technical report, 1998.

[39] n. n. schraudolph. centering neural network gradient factors. in
neural networks: tricks of the trade, pages 207   226. springer,
1998.

[40] p. sermanet, d. eigen, x. zhang, m. mathieu, r. fergus, and y. le-
cun. overfeat: integrated recognition, localization and detection
using convolutional networks. in iclr, 2014.

[41] k. simonyan and a. zisserman. very deep convolutional networks

for large-scale image recognition. in iclr, 2015.

[42] r. k. srivastava, k. greff, and j. schmidhuber. id199.

arxiv:1505.00387, 2015.

[43] r. k. srivastava, k. greff, and j. schmidhuber. training very deep

networks. 1507.06228, 2015.

[44] c. szegedy, w. liu, y. jia, p. sermanet, s. reed, d. anguelov, d. er-
han, v. vanhoucke, and a. rabinovich. going deeper with convolu-
tions. in cvpr, 2015.

[45] r. szeliski. fast surface interpolation using hierarchical basis func-

tions. tpami, 1990.

[46] r. szeliski. locally adapted hierarchical basis preconditioning. in

siggraph, 2006.

[47] t. vatanen, t. raiko, h. valpola, and y. lecun. pushing stochas-
tic gradient towards second-order methods   id26 learn-
in neural information
ing with transformations in nonlinearities.
processing, 2013.

[48] a. vedaldi and b. fulkerson. vlfeat: an open and portable library

of id161 algorithms, 2008.

[49] w. venables and b. ripley. modern applied statistics with s-plus.

1999.

[50] m. d. zeiler and r. fergus. visualizing and understanding convolu-

tional neural networks. in eccv, 2014.

references
[1] y. bengio, p. simard, and p. frasconi. learning long-term dependen-
cies with id119 is dif   cult. ieee transactions on neural
networks, 5(2):157   166, 1994.

[2] c. m. bishop. neural networks for pattern recognition. oxford

university press, 1995.

[3] w. l. briggs, s. f. mccormick, et al. a multigrid tutorial. siam,

2000.

[4] k. chat   eld, v. lempitsky, a. vedaldi, and a. zisserman. the devil
is in the details: an evaluation of recent feature encoding methods.
in bmvc, 2011.

[5] m. everingham, l. van gool, c. k. williams, j. winn, and a. zis-
serman. the pascal visual object classes (voc) challenge. ijcv,
pages 303   338, 2010.

[6] s. gidaris and n. komodakis. id164 via a multi-region &

semantic segmentation-aware id98 model. in iccv, 2015.

[7] r. girshick. fast r-id98. in iccv, 2015.
[8] r. girshick, j. donahue, t. darrell, and j. malik. rich feature hier-
archies for accurate id164 and semantic segmentation. in
cvpr, 2014.

[9] x. glorot and y. bengio. understanding the dif   culty of training

deep feedforward neural networks. in aistats, 2010.

[10] i. j. goodfellow, d. warde-farley, m. mirza, a. courville, and

y. bengio. maxout networks. arxiv:1302.4389, 2013.

[11] k. he and j. sun. convolutional neural networks at constrained time

cost. in cvpr, 2015.

[12] k. he, x. zhang, s. ren, and j. sun. spatial pyramid pooling in deep

convolutional networks for visual recognition. in eccv, 2014.

[13] k. he, x. zhang, s. ren, and j. sun. delving deep into recti   ers:
surpassing human-level performance on id163 classi   cation. in
iccv, 2015.

[14] g. e. hinton, n. srivastava, a. krizhevsky, i. sutskever, and
r. r. salakhutdinov. improving neural networks by preventing co-
adaptation of feature detectors. arxiv:1207.0580, 2012.

[15] s. hochreiter and j. schmidhuber. long short-term memory. neural

computation, 9(8):1735   1780, 1997.

[16] s. ioffe and c. szegedy. batch id172: accelerating deep
network training by reducing internal covariate shift. in icml, 2015.
[17] h. jegou, m. douze, and c. schmid. product quantization for nearest

neighbor search. tpami, 33, 2011.

[18] h. jegou, f. perronnin, m. douze, j. sanchez, p. perez, and
c. schmid. aggregating local image descriptors into compact codes.
tpami, 2012.

[19] y. jia, e. shelhamer, j. donahue, s. karayev, j. long, r. girshick,
s. guadarrama, and t. darrell. caffe: convolutional architecture for
fast feature embedding. arxiv:1408.5093, 2014.

[20] a. krizhevsky. learning multiple layers of features from tiny im-

ages. tech report, 2009.

[21] a. krizhevsky, i. sutskever, and g. hinton. id163 classi   cation

with deep convolutional neural networks. in nips, 2012.

[22] y. lecun, b. boser, j. s. denker, d. henderson, r. e. howard,
w. hubbard, and l. d. jackel. id26 applied to hand-
written zip code recognition. neural computation, 1989.

[23] y. lecun, l. bottou, g. b. orr, and k.-r. m  uller. ef   cient backprop.
in neural networks: tricks of the trade, pages 9   50. springer, 1998.
[24] c.-y. lee, s. xie, p. gallagher, z. zhang, and z. tu. deeply-

supervised nets. arxiv:1409.5185, 2014.

[25] m. lin, q. chen, and s. yan. network in network. arxiv:1312.4400,

2013.

[26] t.-y. lin, m. maire, s. belongie, j. hays, p. perona, d. ramanan,
p. doll  ar, and c. l. zitnick. microsoft coco: common objects in
context. in eccv. 2014.

[27] j. long, e. shelhamer, and t. darrell. fully convolutional networks

for semantic segmentation. in cvpr, 2015.

9

a. id164 baselines

in this section we introduce our detection method based
on the baseline faster r-id98 [32] system. the models are
initialized by the id163 classi   cation models, and then
   ne-tuned on the id164 data. we have experi-
mented with resnet-50/101 at the time of the ilsvrc &
coco 2015 detection competitions.

unlike vgg-16 used in [32], our resnet has no hidden
fc layers. we adopt the idea of    networks on conv fea-
ture maps    (noc) [33] to address this issue. we compute
the full-image shared conv feature maps using those lay-
ers whose strides on the image are no greater than 16 pixels
(i.e., conv1, conv2 x, conv3 x, and conv4 x, totally 91 conv
layers in resnet-101; table 1). we consider these layers as
analogous to the 13 conv layers in vgg-16, and by doing
so, both resnet and vgg-16 have conv feature maps of the
same total stride (16 pixels). these layers are shared by a
region proposal network (rpn, generating 300 proposals)
[32] and a fast r-id98 detection network [7]. roi pool-
ing [7] is performed before conv5 1. on this roi-pooled
feature, all layers of conv5 x and up are adopted for each
region, playing the roles of vgg-16   s fc layers. the    nal
classi   cation layer is replaced by two sibling layers (classi-
   cation and box regression [7]).

for the usage of bn layers, after pre-training, we com-
pute the bn statistics (means and variances) for each layer
on the id163 training set. then the bn layers are    xed
during    ne-tuning for id164. as such, the bn
layers become linear activations with constant offsets and
scales, and bn statistics are not updated by    ne-tuning. we
   x the bn layers mainly for reducing memory consumption
in faster r-id98 training.
pascal voc

following [7, 32], for the pascal voc 2007 test set,
we use the 5k trainval images in voc 2007 and 16k train-
val images in voc 2012 for training (   07+12   ). for the
pascal voc 2012 test set, we use the 10k trainval+test
images in voc 2007 and 16k trainval images in voc 2012
for training (   07++12   ). the hyper-parameters for train-
ing faster r-id98 are the same as in [32]. table 7 shows
the results. resnet-101 improves the map by >3% over
vgg-16. this gain is solely because of the improved fea-
tures learned by resnet.
ms coco

the ms coco dataset [26] involves 80 object cate-
gories. we evaluate the pascal voc metric (map @
iou = 0.5) and the standard coco metric (map @ iou =
.5:.05:.95). we use the 80k images on the train set for train-
ing and the 40k images on the val set for evaluation. our
detection system for coco is similar to that for pascal
voc. we train the coco models with an 8-gpu imple-
mentation, and thus the rpn step has a mini-batch size of

8 images (i.e., 1 per gpu) and the fast r-id98 step has a
mini-batch size of 16 images. the rpn step and fast r-
id98 step are both trained for 240k iterations with a learn-
ing rate of 0.001 and then for 80k iterations with 0.0001.

table 8 shows the results on the ms coco validation
set. resnet-101 has a 6% increase of map@[.5, .95] over
vgg-16, which is a 28% relative improvement, solely con-
tributed by the features learned by the better network. re-
markably, the map@[.5, .95]   s absolute increase (6.0%) is
nearly as big as map@.5   s (6.9%). this suggests that a
deeper network can improve both recognition and localiza-
tion.

b. id164 improvements

for completeness, we report the improvements made for
the competitions. these improvements are based on deep
features and thus should bene   t from residual learning.
ms coco
box re   nement. our box re   nement partially follows the it-
erative localization in [6]. in faster r-id98, the    nal output
is a regressed box that is different from its proposal box. so
for id136, we pool a new feature from the regressed box
and obtain a new classi   cation score and a new regressed
box. we combine these 300 new predictions with the orig-
inal 300 predictions. non-maximum suppression (nms) is
applied on the union set of predicted boxes using an iou
threshold of 0.3 [8], followed by box voting [6]. box re-
   nement improves map by about 2 points (table 9).
global context. we combine global context in the fast
r-id98 step. given the full-image conv feature map, we
pool a feature by global spatial pyramid pooling [12] (with
a    single-level    pyramid) which can be implemented as
   roi    pooling using the entire image   s bounding box as the
roi. this pooled feature is fed into the post-roi layers to
obtain a global context feature. this global feature is con-
catenated with the original per-region feature, followed by
the sibling classi   cation and box regression layers. this
new structure is trained end-to-end. global context im-
proves map@.5 by about 1 point (table 9).
multi-scale testing. in the above, all results are obtained by
single-scale training/testing as in [32], where the image   s
shorter side is s = 600 pixels. multi-scale training/testing
has been developed in [12, 7] by selecting a scale from a
feature pyramid, and in [33] by using maxout layers.
in
our current implementation, we have performed multi-scale
testing following [33]; we have not performed multi-scale
training because of limited time. in addition, we have per-
formed multi-scale testing only for the fast r-id98 step
(but not yet for the rpn step). with a trained model, we
compute conv feature maps on an image pyramid, where the
image   s shorter sides are s     {200, 400, 600, 800, 1000}.

10

training data
test data
map
baseline faster r-id98 (vgg-16)
baseline faster r-id98 (resnet-101)
+box re   nement
+context
+multi-scale testing
ensemble

coco train
coco val

@.5
41.5
48.4
49.9
51.1
53.8

@[.5, .95]

21.2
27.2
29.9
30.0
32.5

coco trainval
coco test-dev
@.5

@[.5, .95]

53.3
55.7
59.0

32.2
34.9
37.4

table 9. id164 improvements on ms coco using faster r-id98 and resnet-101.

net

vgg-16

resnet-101

data
07+12
07+12

map areo
system
tv
baseline
73.2 76.5 79.0 70.9 65.5 52.1 83.1 84.7 86.4 52.0 81.9 65.7 84.8 84.6 77.5 76.7 38.8 73.6 73.9 83.0 72.6
76.4 79.8 80.7 76.2 68.3 55.9 85.1 85.3 89.8 56.7 87.8 69.4 88.3 88.9 80.9 78.4 41.7 78.6 79.8 85.3 72.0
baseline
85.6 90.0 89.6 87.8 80.8 76.1 89.9 89.9 89.6 75.5 90.0 80.7 89.6 90.3 89.1 88.7 65.4 88.1 85.6 89.0 86.8
baseline+++ resnet-101 coco+07+12
table 10. detection results on the pascal voc 2007 test set. the baseline is the faster r-id98 system. the system    baseline+++   
include box re   nement, context, and multi-scale testing in table 9.

horse mbike person plant

cow table

bottle

sheep

chair

train

boat

bike

sofa

bird

dog

bus

car

cat

bird

bike

net

data

vgg-16

resnet-101

07++12
07++12

map areo
tv
system
70.4 84.9 79.8 74.3 53.9 49.8 77.5 75.9 88.5 45.6 77.1 55.3 86.9 81.7 80.9 79.6 40.1 72.6 60.9 81.2 61.5
baseline
baseline
73.8 86.5 81.6 77.2 58.0 51.0 78.6 76.6 93.2 48.6 80.4 59.0 92.1 85.3 84.8 80.7 48.1 77.3 66.5 84.7 65.6
baseline+++ resnet-101 coco+07++12 83.8 92.1 88.4 84.8 75.9 71.4 86.3 87.8 94.2 66.8 89.4 69.2 93.9 91.9 90.9 89.6 67.9 88.2 76.8 90.3 80.0
table 11. detection results on the pascal voc 2012 test set (http://host.robots.ox.ac.uk:8080/leaderboard/
displaylb.php?challengeid=11&compid=4). the baseline is the faster r-id98 system. the system    baseline+++    include
box re   nement, context, and multi-scale testing in table 9.

horse mbike person plant

cow table

bottle

sheep

chair

train

boat

sofa

dog

bus

car

cat

we select two adjacent scales from the pyramid following
[33]. roi pooling and subsequent layers are performed on
the feature maps of these two scales [33], which are merged
by maxout as in [33]. multi-scale testing improves the map
by over 2 points (table 9).
using validation data. next we use the 80k+40k trainval set
for training and the 20k test-dev set for evaluation. the test-
dev set has no publicly available ground truth and the result
is reported by the evaluation server. under this setting, the
results are an map@.5 of 55.7% and an map@[.5, .95] of
34.9% (table 9). this is our single-model result.
ensemble. in faster r-id98, the system is designed to learn
region proposals and also object classi   ers, so an ensemble
can be used to boost both tasks. we use an ensemble for
proposing regions, and the union set of proposals are pro-
cessed by an ensemble of per-region classi   ers. table 9
shows our result based on an ensemble of 3 networks. the
map is 59.0% and 37.4% on the test-dev set. this result
won the 1st place in the detection task in coco 2015.

pascal voc

we revisit the pascal voc dataset based on the above
model. with the single model on the coco dataset (55.7%
map@.5 in table 9), we    ne-tune this model on the pas-
cal voc sets. the improvements of box re   nement, con-
text, and multi-scale testing are also adopted. by doing so

googlenet [44] (ilsvrc   14)
our single model (ilsvrc   15)
our ensemble (ilsvrc   15)

val2

-

60.5
63.6

test
43.9
58.8
62.1

table 12. our results (map, %) on the id163 detection dataset.
our detection system is faster r-id98 [32] with the improvements
in table 9, using resnet-101.

we achieve 85.6% map on pascal voc 2007 (table 10)
and 83.8% on pascal voc 2012 (table 11)6. the result
on pascal voc 2012 is 10 points higher than the previ-
ous state-of-the-art result [6].

id163 detection

the id163 detection (det) task involves 200 object
categories. the accuracy is evaluated by map@.5. our
id164 algorithm for id163 det is the same
as that for ms coco in table 9. the networks are pre-
trained on the 1000-class id163 classi   cation set, and
are    ne-tuned on the det data. we split the validation set
into two parts (val1/val2) following [8]. we    ne-tune the
detection models using the det training set and the val1
set. the val2 set is used for validation. we do not use other
ilsvrc 2015 data. our single model with resnet-101 has

6http://host.robots.ox.ac.uk:8080/anonymous/3oj4oj.html,

submitted on 2015-11-26.

11

classi   cation

network

top-5 loc error
on predicted cls

method

loc

loc
method

network
vgg   s [41] vgg-16

testing

loc error
on gt cls
33.1 [41]

13.3
11.7

rpn
rpn
rpn

1-crop
resnet-101 1-crop
resnet-101 dense
resnet-101 dense
rpn+rid98 resnet-101 dense
rpn+rid98 ensemble
dense
table 13. localization error (%) on the id163 validation. in
the column of    loc error on gt class    ([41]), the ground truth
class is used. in the    testing    column,    1-crop    denotes testing
on a center crop of 224  224 pixels,    dense    denotes dense (fully
convolutional) and multi-scale testing.

resnet-101
resnet-101
ensemble

14.4
10.6
8.9

58.8% map and our ensemble of 3 models has 62.1% map
on the det test set (table 12). this result won the 1st place
in the id163 detection task in ilsvrc 2015, surpassing
the second place by 8.5 points (absolute).

c. id163 localization

the id163 localization (loc) task [36] requires to
classify and localize the objects. following [40, 41], we
assume that the image-level classi   ers are    rst adopted for
predicting the class labels of an image, and the localiza-
tion algorithm only accounts for predicting bounding boxes
based on the predicted classes. we adopt the    per-class re-
gression    (pcr) strategy [40, 41], learning a bounding box
regressor for each class. we pre-train the networks for im-
agenet classi   cation and then    ne-tune them for localiza-
tion. we train networks on the provided 1000-class ima-
genet training set.

our localization algorithm is based on the rpn frame-
work of [32] with a few modi   cations. unlike the way in
[32] that is category-agnostic, our rpn for localization is
designed in a per-class form. this rpn ends with two sib-
ling 1  1 convolutional layers for binary classi   cation (cls)
and box regression (reg), as in [32]. the cls and reg layers
are both in a per-class from, in contrast to [32]. speci   -
cally, the cls layer has a 1000-d output, and each dimension
is binary id28 for predicting being or not be-
ing an object class; the reg layer has a 1000  4-d output
consisting of box regressors for 1000 classes. as in [32],
our bounding box regression is with reference to multiple
translation-invariant    anchor    boxes at each position.

as in our id163 classi   cation training (sec. 3.4), we
randomly sample 224  224 crops for data augmentation.
we use a mini-batch size of 256 images for    ne-tuning. to
avoid negative samples being dominate, 8 anchors are ran-
domly sampled for each image, where the sampled positive
and negative anchors have a ratio of 1:1 [32]. for testing,
the network is applied on the image fully-convolutionally.
table 13 compares the localization results. following
[41], we    rst perform    oracle    testing using the ground truth
class as the classi   cation prediction. vgg   s paper [41] re-

12

overfeat [40] (ilsvrc   13)
googlenet [44] (ilsvrc   14)
vgg [41] (ilsvrc   14)
ours (ilsvrc   15)

-

26.9
8.9

top-5 localization err
val
30.0

test
29.9
26.7
25.3
9.0

table 14. comparisons of localization error (%) on the id163
dataset with state-of-the-art methods.

ports a center-crop error of 33.1% (table 13) using ground
truth classes. under the same setting, our rpn method us-
ing resnet-101 net signi   cantly reduces the center-crop er-
ror to 13.3%. this comparison demonstrates the excellent
performance of our framework. with dense (fully convolu-
tional) and multi-scale testing, our resnet-101 has an error
of 11.7% using ground truth classes. using resnet-101 for
predicting classes (4.6% top-5 classi   cation error, table 4),
the top-5 localization error is 14.4%.

the above results are only based on the proposal network
(rpn) in faster r-id98 [32]. one may use the detection
network (fast r-id98 [7]) in faster r-id98 to improve the
results. but we notice that on this dataset, one image usually
contains a single dominate object, and the proposal regions
highly overlap with each other and thus have very similar
roi-pooled features. as a result, the image-centric training
of fast r-id98 [7] generates samples of small variations,
which may not be desired for stochastic training. motivated
by this, in our current experiment we use the original r-
id98 [8] that is roi-centric, in place of fast r-id98.

our r-id98 implementation is as follows. we apply the
per-class rpn trained as above on the training images to
predict bounding boxes for the ground truth class. these
predicted boxes play a role of class-dependent proposals.
for each training image, the highest scored 200 proposals
are extracted as training samples to train an r-id98 classi-
   er. the image region is cropped from a proposal, warped
to 224  224 pixels, and fed into the classi   cation network
as in r-id98 [8]. the outputs of this network consist of two
sibling fc layers for cls and reg, also in a per-class form.
this r-id98 network is    ne-tuned on the training set us-
ing a mini-batch size of 256 in the roi-centric fashion. for
testing, the rpn generates the highest scored 200 proposals
for each predicted class, and the r-id98 network is used to
update these proposals    scores and box positions.

this method reduces the top-5 localization error to
10.6% (table 13). this is our single-model result on the
validation set. using an ensemble of networks for both clas-
si   cation and localization, we achieve a top-5 localization
error of 9.0% on the test set. this number signi   cantly out-
performs the ilsvrc 14 results (table 14), showing a 64%
relative reduction of error. this result won the 1st place in
the id163 localization task in ilsvrc 2015.

