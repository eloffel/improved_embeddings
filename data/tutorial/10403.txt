a sensitivity analysis of (and practitioners    guide to) convolutional

neural networks for sentence classi   cation

6
1
0
2

 
r
p
a
6

 

 
 
]
l
c
.
s
c
[
 
 

4
v
0
2
8
3
0

.

0
1
5
1
:
v
i
x
r
a

ye zhang

dept. of computer science
university of texas at austin
yezhang@utexas.edu

abstract

convolutional neural networks (id98s)
have recently achieved remarkably strong
performance on the practically impor-
tant task of sentence classi   cation (kim,
2014; kalchbrenner et al., 2014; johnson
and zhang, 2014). however, these mod-
els require practitioners to specify an ex-
act model architecture and set accompa-
nying hyperparameters, including the    l-
ter region size, id173 parameters,
and so on.
it is currently unknown how
sensitive model performance is to changes
in these con   gurations for the task of sen-
tence classi   cation. we thus conduct a
sensitivity analysis of one-layer id98s to
explore the effect of architecture com-
ponents on model performance; our aim
is to distinguish between important and
comparatively inconsequential design de-
cisions for sentence classi   cation. we
focus on one-layer id98s (to the exclu-
sion of more complex models) due to their
comparative simplicity and strong empiri-
cal performance, which makes it a modern
standard baseline method akin to support
vector machine (id166s) and logistic re-
gression. we derive practical advice from
our extensive empirical results for those
interested in getting the most out of id98s
for sentence classi   cation in real world
settings.
introduction

1
convolutional neural networks (id98s) have re-
cently been shown to achieve impressive results
on the practically important task of sentence cate-
gorization (kim, 2014; kalchbrenner et al., 2014;
wang et al., 2015; goldberg, 2015; iyyer et al.,
2015). id98s can capitalize on distributed repre-
sentations of words by    rst converting the tokens

byron c. wallace

ischool

university of texas at austin

byron.wallace@utexas.edu

comprising each sentence into a vector, forming a
matrix to be used as input (e.g., see fig. 1). the
models need not be complex to realize strong re-
sults: kim (2014), for example, proposed a simple
one-layer id98 that achieved state-of-the-art (or
comparable) results across several datasets. the
very strong results achieved with this compara-
tively simple id98 architecture suggest that it may
serve as a drop-in replacement for well-established
baseline models, such as id166 (joachims, 1998)
or id28. while more complex deep
learning models for text classi   cation will un-
doubtedly continue to be developed, those deploy-
ing such technologies in practice will likely be at-
tracted to simpler variants, which afford fast train-
ing and prediction times.

unfortunately, a downside to id98-based mod-
els     even simple ones     is that they require prac-
titioners to specify the exact model architecture to
be used and to set the accompanying hyperparam-
eters. to the uninitiated, making such decisions
can seem like something of a black art because
there are many free parameters in the model. this
is especially true when compared to, e.g., id166
and id28. furthermore, in practice
exploring the space of possible con   gurations for
this model is extremely expensive, for two rea-
sons: (1) training these models is relatively slow,
even using gpus. for example, on the sst-1
dataset (socher et al., 2013), it takes about 1 hour
to run 10-fold cross validation, using a similar
con   guration to that described in (kim, 2014).1
(2) the space of possible model architectures and
hyperparameter settings is vast. indeed, the simple
id98 architecture we consider requires, at a min-
imum, specifying: input word vector representa-
tions;    lter region size(s); the number of feature
maps; the activation function(s); the pooling strat-
egy; and id173 terms (dropout/l2).

1all experiments run with theano on an nvidia k20

gpu.

in practice,

tuning all of these parameters
is simply not feasible, especially because pa-
rameter estimation is computationally intensive.
emerging research has begun to explore hyperpa-
rameter optimization methods, including random
search (bengio, 2012), and bayesian optimiza-
tion (yogatama and smith, 2015; bergstra et al.,
2013). however, these sophisticated search meth-
ods still require knowing which hyperparameters
are worth exploring to begin with (and reasonable
ranges for each). furthermore, we believe it will
be some time before bayesian optimization meth-
ods are integrated into deployed, real-world sys-
tems.

in this work our aim is to identify empirically
the settings that practitioners should expend effort
tuning, and those that are either inconsequential
with respect to performance or that seem to have
a    best    setting independent of the speci   c dataset,
and provide a reasonable range for each hyperpa-
rameter. we take inspiration from previous empir-
ical analyses of neural models due to coates et al.
(2011) and breuel (2015), which investigated fac-
tors in unsupervised id171 and hyperpa-
rameter settings for stochastic id119
(sgd), respectively. here we report the results
of a large number of experiments exploring differ-
ent con   gurations of id98s run over nine sentence
classi   cation datasets. most previous work in this
area reports only mean accuracies calculated via
cross-validation. but there is substantial variance
in the performance of id98s, even on the same
folds and with model con   guration held constant.
therefore, in our experiments we perform replica-
tions of cross-validation and report accuracy/area
under curve (auc) score means and ranges over
these.

for those interested in only the punchlines,
we summarize our empirical    ndings and provide
practical guidance based on these in section 5.

2 background and preliminaries

deep and neural learning methods are now well
established in machine learning (lecun et al.,
2015; bengio, 2009). they have been especially
successful for image and speech processing tasks.
more recently, such methods have begun to over-
take traditional sparse,
linear models for nlp
(goldberg, 2015; bengio et al., 2003; mikolov et
al., 2013; collobert and weston, 2008; collobert
et al., 2011; kalchbrenner et al., 2014; socher et

al., 2013).

recently, id27s have been ex-
ploited for sentence classi   cation using id98 ar-
chitectures. kalchbrenner (2014) proposed a
id98 architecture with multiple convolution lay-
ers, positing latent, dense and low-dimensional
word vectors (initialized to random values) as in-
puts. kim (2014) de   ned a one-layer id98 archi-
tecture that performed comparably. this model
uses pre-trained word vectors as inputs, which
may be treated as static or non-static. in the for-
mer approach, word vectors are treated as    xed
inputs, while in the latter they are    tuned    for
a speci   c task. elsewhere, johnson and zhang
(2014) proposed a similar model, but swapped in
high dimensional    one-hot    vector representations
of words as id98 inputs. their focus was on clas-
si   cation of longer texts, rather than sentences (but
of course the model can be used for sentence clas-
si   cation).

the relative simplicity of kim   s architecture    
which is largely the same as that proposed by
johnson and zhang (2014), modulo the word vec-
tors     coupled with observed strong empirical per-
formance makes this a strong contender to sup-
plant existing text classi   cation baselines such as
id166 and id28. but in practice one
is faced with making several model architecture
decisions and setting various hyperparameters. at
present, very little empirical data is available to
guide such decisions; addressing this gap is our
aim here.
2.1 id98 architecture
we begin with a tokenized sentence which we
then convert to a sentence matrix, the rows of
which are word vector representations of each to-
ken. these might be, e.g., outputs from trained
id97 (mikolov et al., 2013) or glove (pen-
nington et al., 2014) models. we denote the di-
mensionality of the word vectors by d.
if the
length of a given sentence is s, then the dimension-
ality of the sentence matrix is s    d.2 following
collobert and weston (2008), we can then effec-
tively treat the sentence matrix as an    image   , and
perform convolution on it via linear    lters. in text
applications there is inherent sequential structure
to the data. because rows represent discrete sym-
bols (namely, words), it is reasonable to use    l-
ters with widths equal to the dimensionality of the

2we use the same zero-padding strategy as in (kim,

2014).

word vectors (i.e., d). thus we can simply vary
the    height    of the    lter, i.e., the number of adja-
cent rows considered jointly. we will refer to the
height of the    lter as the region size of the    lter.

suppose that there is a    lter parameterized by
the weight matrix w with region size h; w will
contain h    d parameters to be estimated. we de-
note the sentence matrix by a     rs  d, and use
a[i : j] to represent the sub-matrix of a from row
i to row j. the output sequence o     rs   h+1 of
the convolution operator is obtained by repeatedly
applying the    lter on sub-matrices of a:

oi = w    a[i : i + h     1],

(1)
where i = 1 . . . s     h + 1, and    is the dot prod-
uct between the sub-matrix and the    lter (a sum
over element-wise multiplications). we add a bias
term b     r and an activation function f to each
oi, inducing the feature map c     rs   h+1 for this
   lter:

ci = f (oi + b).

(2)

one may use multiple    lters for the same re-
gion size to learn complementary features from
the same regions. one may also specify multi-
ple kinds of    lters with different region sizes (i.e.,
   heights   ).

the dimensionality of the feature map gener-
ated by each    lter will vary as a function of the
sentence length and the    lter region size. a pool-
ing function is thus applied to each feature map to
induce a    xed-length vector. a common strategy
is 1-max pooling (boureau et al., 2010b), which
extracts a scalar from each feature map. together,
the outputs generated from each    lter map can be
concatenated into a    xed-length,    top-level    fea-
ture vector, which is then fed through a softmax
function to generate the    nal classi   cation. at this
softmax layer, one may apply    dropout    (hinton et
al., 2012) as a means of id173. this en-
tails randomly setting values in the weight vector
to 0. one may also impose an l2 norm constraint,
i.e., linearly scale the l2 norm of the vector to a
pre-speci   ed threshold when it exceeds this. fig.
1 provides a schematic illustrating the model ar-
chitecture just described.

a reasonable training objective to be minimized
is the categorical cross-id178 loss. the param-
eters to be estimated include the weight vector(s)
of the    lter(s), the bias term in the activation func-
tion, and the weight vector of the softmax func-
tion. in the    non-static    approach, one also tunes

the word vectors. optimization is performed us-
ing sgd and back-propagation (rumelhart et al.,
1988).

these are summarized as follows.

3 datasets
we use nine sentence classi   cation datasets in all;
seven of which were also used by kim (2014).
brie   y,
(1)
mr: sentence polarity dataset from (pang and
lee, 2005). (2) sst-1: stanford sentiment tree-
bank (socher et al., 2013). to make input rep-
resentations consistent across tasks, we only train
and test on sentences, in contrast to the use in
(kim, 2014), wherein models were trained on both
phrases and sentences. (3) sst-2: derived from
sst-1, but pared to only two classes. we again
only train and test models on sentences, excluding
phrases. (4) subj: subjectivity dataset (pang and
(5) trec: question classi   cation
lee, 2005).
(6) cr: customer
dataset (li and roth, 2002).
review dataset (hu and liu, 2004). (7) mpqa:
opinion polarity dataset (wiebe et al., 2005). ad-
ditionally, we use (8) opi: opinosis dataset,
which comprises sentences extracted from user re-
views on a given topic, e.g.    sound quality of ipod
nano   . there are 51 such topics and each topic
contains approximately 100 sentences (ganesan
et al., 2010). (9) irony (wallace et al., 2014): this
contains 16,006 sentences from reddit labeled as
ironic (or not). the dataset is imbalanced (rela-
tively few sentences are ironic). thus before train-
ing, we under-sampled negative instances to make
classes sizes equal.3 for this dataset we report the
area under curve (auc), rather than accuracy,
because it is imbalanced.

4 baseline models
to provide a point of reference for the id98 re-
sults, we    rst report the performance achieved us-
ing id166 for sentence classi   cation. as a base-
line, we used a linear kernel id166 exploiting uni-
and bi-gram features.4 we then used averaged
word vectors (from google id975 or glove6)
calculated over the words comprising the sentence
as features and used an rbf-kernel id166 as the
classi   er operating in this dense feature space. we

3empirically,

under-sampling

outperformed

over-

sampling in mitigating imbalance, see also wallace (2011).
4for this we used scikit-learn (pedregosa et al., 2011).
5https://code.google.com/p/id97/
6http://nlp.stanford.edu/projects/

glove/

figure 1: illustration of a id98 architecture for sentence classi   cation. we depict three    lter region sizes:
2, 3 and 4, each of which has 2    lters. filters perform convolutions on the sentence matrix and generate
(variable-length) feature maps; 1-max pooling is performed over each map, i.e., the largest number from
each feature map is recorded. thus a univariate feature vector is generated from all six maps, and these
6 features are concatenated to form a feature vector for the penultimate layer. the    nal softmax layer
then receives this feature vector as input and uses it to classify the sentence; here we assume binary
classi   cation and hence depict two possible output states.

also experimented with combining the uni-gram,
bi-gram and word vector features with a linear ker-
nel id166. we kept only the most frequent 30k n-
grams for all datasets, and tuned hyperparameters
via nested cross-fold validation, optimizing for ac-
curacy (auc for irony). for consistency, we used
the same pre-processing steps for the data as de-
scribed in previous work (kim, 2014). we report
means from 10-folds over all datasets in table 1.7
notably, even naively incorporating id97 em-
beddings into feature vectors usually improves re-
sults.

7note that parameter estimation for id166 via qp is deter-

ministic, thus we do not replicate the cross validation here.

4.1 baseline con   guration

we    rst consider the performance of a baseline
id98 con   guration. speci   cally, we start with the
architectural decisions and hyperparameters used
in previous work (kim, 2014) and described in
table 2. to contextualize the variance in per-
formance attributable to various architecture de-
cisions and hyperparameter settings, it is critical
to assess the variance due strictly to the parame-
ter estimation procedure. most prior work, unfor-
tunately, has not reported such variance, despite
a highly stochastic learning procedure. this vari-
ance is attributable to estimation via sgd, random
dropout, and random weight parameter initializa-
tion. holding all variables (including the folds)

i like thismovievery much!2 feature maps for each region size 6 univariate vectorsconcatenated together to form a single feature vector  sentence matrix           7    53 region sizes: (2,3,4)2    lters for each region sizetotally 6    ltersconvolution activation function 1-maxpooling 2 classessoftmax functionid173 in this layerd=5dataset

bowid166 wvid166 bowwvid166

description

mr
sst-1
sst-2
subj
trec

cr

mpqa

opi
irony

78.24
37.92
80.54
89.13
87.95
80.21
85.38
61.81
65.74

78.53
44.34
81.97
90.94
83.61
80.79
89.27
62.46
65.58

79.67
43.15
83.30
91.74
87.33
81.31
89.70
62.25
66.74

table 1: accuracy (auc for irony) achieved
by id166 with different feature sets. bowid166:
uni- and bi-gram features. wvid166: a naive
id97-based representation, i.e., the average
(300-dimensional) word vector for each sentence.
bowwvid166: concatenates bow vectors with the
average id97 representations.

constant, we show that the mean performance cal-
culated via 10-fold cross validation (cv) exhibits
relatively high variance over repeated runs. we
replicated cv experiments 100 times for each
dataset, so that each replication was a 10-fold cv,
wherein the folds were    xed. we recorded the av-
erage performance for each replication and report
the mean, minimum and maximum average accu-
racy (or auc) values observed over 100 replica-
tions of cv (that is, we report means and ranges
of averages calculated over 10-fold cv). this pro-
vides a sense of the variance we might observe
without any changes to the model. we did this for
both static and non-static methods. for all exper-
iments, we used the same preprocessing steps for
the data as in (kim, 2014). for sgd, we used the
adadelta update rule (zeiler, 2012), and set
the minibatch size to 50. we randomly selected
10% of the training data as the validation set for
early stopping.

fig. 2 provides density plots of the mean ac-
curacy of 10-fold cv over the 100 replications
for both methods on all datasets. for presenta-
tion clarity, in this    gure we exclude the sst-1,
opi and irony datasets, because performance was
substantially lower on these (results can be found
in the tables). note that we pre-processed/split
datasets differently than in some of the original
work to ensure consistency for our present anal-
ysis; thus results may not be directly comparable
to prior work. we emphasize that our aim here is
not to improve on the state-of-the-art, but rather
to explore the sensitivity of id98s with respect to
design decisions.

having established a baseline performance for
id98s, we now consider the effect of different ar-

input word vectors google id97
   lter region size

values

(3,4,5)
100
relu

0.5
3

1-max pooling

feature maps

activation function

pooling

dropout rate

l2 norm constraint

table 2: baseline con   guration.
   feature maps   
refers to the number of feature maps for each    lter
region size.    relu    refers to recti   ed linear unit
(maas et al., 2013), a commonly used activation
function in id98s.

figure 2: density curve of accuracy using static
and non-static id97-id98

chitecture decisions and hyperparameter settings.
to this end, we hold all other settings constant (as
per table 2) and vary only the component of in-
terest. for every con   guration that we consider,
we replicate the experiment 10 times, where each
replication again constitutes a run of 10-fold cv.8
we again report average cv means and associ-
ated ranges achieved over the replicated cv runs.
we performed experiments using both    static    and
   non-static    word vectors. the latter uniformly
outperformed the former, and so here we report
results only for the    non-static    variant.

4.2 effect of input word vectors
a nice property of sentence classi   cation models
that start with distributed representations of words
as inputs is the    exibility such architectures afford
to swap in different pre-trained word vectors dur-
ing model initialization. therefore, we    rst ex-
plore the sensitivity of id98s for sentence classi-
   cation with respect to the input representations
used. speci   cally, we replaced id97 with
glove representations. google id97 uses a
local context window model trained on 100 billion

8running 100 replications for every con   guration that we

consider was not computationally feasible.

0.780.800.820.840.860.880.900.920.94050100150200250300350mrcrsst-2subjmpqatrec0.780.800.820.840.860.880.900.920.94accuracy050100150200250300350400non-static id97static id97dataset non-static id97-id98 non-static glove-id98 non-static glove+id97 id98

mr
sst-1
sst-2
subj
trec

cr

mpqa

opi
irony

81.24 (80.69, 81.56)
47.08 (46.42,48.01)
85.49 (85.03, 85.90)
93.20 (92.97, 93.45)
91.54 (91.15, 91.92)
83.92 (82.95, 84.56)
89.32 (88.84, 89.73)
64.93 (64.23,65.58)
67.07 (65.60,69.00)

81.03 (80.68,81.48)
45.65 (45.09,45.94)
85.22 (85.04,85.48)
93.64 (93.51,93.77)
90.38 (90.19,90.59)
84.33 (84.00,84.67)
89.57 (89.31,89.78)
65.68 (65.29,66.19)
67.20 (66.45,67.96)

81.02 (80.75,81.32)
45.98 (45.49,46.65)
85.45 (85.03,85.82)
93.66 (93.39,93.87)
91.37 (91.13,91.62)
84.65 (84.21,84.96)
89.55 (89.22,89.88)
65.65 (65.15,65.98)
67.11 (66.66,68.50)

table 3: performance using non-static id97-id98, non-static glove-id98, and non-static
glove+id97 id98, respectively. each cell reports the mean (min, max) of summary performance
measures calculated over multiple runs of 10-fold cross-validation. we will use this format for all tables
involving replications

words from google news (mikolov et al., 2013),
while glove is a model based on global word-
word co-occurrence statistics (pennington et al.,
2014). we used a glove model trained on a cor-
pus of 840 billion tokens of web data. for both
id97 and glove we induce 300-dimensional
word vectors. we report results achieved using
glove representations in table 3. here we only
report non-static glove results (which again uni-
formely outperformed the static variant).

we also experimented with concatenating
id97 and glove representations,
thus cre-
ating 600-dimensional word vectors to be used
as input to the id98. pre-trained vectors may
not always be available for speci   c words (either
in id97 or glove, or both); in such cases,
we randomly initialized the corresponding sub-
vectors. results are reported in the    nal column
of table 3.

the relative performance achieved using glove
versus id97 depends on the dataset, and, un-
fortunately, simply concatenating these represen-
tations does necessarily seem helpful. practically,
our results suggest experimenting with different
pre-trained word vectors for new tasks.

we also experimented with using long, sparse
one-hot vectors as input word representations, in
the spirit of johnson and zhang (2014).
in this
strategy, each word is encoded as a one-hot vec-
tor, with dimensionality equal to the vocabulary
size. though this representation combined with
one-layer id98 achieves good results on docu-
ment classi   cation, it is still unknown whether
this is useful for sentence classi   cation. we keep
the other settings the same as in the basic con-
   guration, and the one-hot vector is    xed during
training. compared to using embeddings as in-
put to the id98, we found the one-hot approach

to perform poorly for sentence classi   cation tasks.
we believe that one-hot id98 may not be suit-
able for sentence classi   cation when one has a
small to modestly sized training dataset, likely
due to sparsity:
the sentences are perhaps too
brief to provide enough information for this high-
dimensional encoding. alternative one-hot archi-
tectures might be more appropriate for this sce-
nario. for example, johnson and zhang (johnson
and zhang, 2015) propose a semi-supervised id98
variant which    rst learns embeddings of small text
regions from unlabeled data, and then integrates
them into a supervised id98. we emphasize that
if training data is plentiful, learning embeddings
from scratch may indeed be best.

4.3 effect of    lter region size

region size

1
3
5
7
10
15
20
25
30

mr

77.85 (77.47,77.97)
80.48 (80.26,80.65)
81.13 (80.96,81.32)
81.65 (81.45,81.85)
81.43 (81.28,81.75)
81.26 (81.01,81.43)
81.06 (80.87,81.30)
80.91 (80.73,81.10)
80.91 (80.72,81.05)

table 4: effect of single    lter region size. due to
space constraints, we report results for only one
dataset here, but these are generally illustrative.

we    rst explore the effect of    lter region size
when using only one region size, and we set the
number of feature maps for this region size to 100
(as in the baseline con   guration). we consider re-
gion sizes of 1, 3, 5, 7, 10, 15, 20, 25 and 30, and
record the means and ranges over 10 replications
of 10-fold cv for each. we report results in ta-
ble 10 and fig. 3. because we are only interested
in the trend of the accuracy as we alter the region
size (rather than the absolute performance on each

multiple region size

(7)

(3,4,5)
(4,5,6)
(5,6,7)
(7,8,9)

(10,11,12)
(11,12,13)
(3,4,5,6)
(6,7,8,9)
(7,7,7)
(7,7,7,7)

accuracy (%)

81.65 (81.45,81.85)
81.24 (80.69, 81.56)
81.28 (81.07,81.56)
81.57 (81.31,81.80)
81.69 (81.27,81.93)
81.52 (81.27,81.87)
81.53 (81.35,81.76)
81.43 (81.10,81.61)
81.62 (81.38,81.72)
81.63 (81.33,82.08)
81.73 (81.33,81.94)

figure 3: effect of the region size (using only
one).

figure 4: effect of the number of feature maps.

task), we show only the percent change in accu-
racy (auc for irony) from an arbitrary baseline
point (here, a region size of 3).

from the results, one can see that each dataset
has its own optimal    lter region size. practically,
this suggests performing a coarse grid search over
a range of region sizes; the    gure here suggests
that a reasonable range for sentence classi   cation
might be from 1 to 10. however, for datasets com-
prising longer sentences, such as cr (maximum
sentence length is 105, whereas it ranges from 36-
56 on the other sentiment datasets used here), the
optimal region size may be larger.

we also explored the effect of combining dif-
ferent    lter region sizes, while keeping the num-
ber of feature maps for each region size    xed at
100. we found that combining several    lters with
region sizes close to the optimal single region size
can improve performance, but adding region sizes
far from the optimal range may hurt performance.
for example, when using a single    lter size, one
can observe that the optimal single region size for
the mr dataset is 7. we therefore combined sev-
eral different    lter region sizes close to this opti-
mal range, and compared this to approaches that

table 5: effect of    lter region size with several
region sizes on the mr dataset.

use region sizes outside of this range. from ta-
ble 5, one can see that using (5,6,7),and (7,8,9)
and (6,7,8,9)     sets near the best single region size
    produce the best results. the difference is es-
pecially pronounced when comparing to the base-
line setting of (3,4,5). note that even only using
a single good    lter region size (here, 7) results in
better performance than combining different sizes
(3,4,5). the best performing strategy is to sim-
ply use many feature maps (here, 400) all with re-
gion size equal to 7, i.e., the single best region size.
however, we note that in some cases (e.g., for the
trec dataset), using multiple different, but near-
optimal, region sizes performs best.

we provide another illustrative empirical result
using several region sizes on the trec dataset in
table 6. from the performance of single region
size, we see that the best single    lter region sizes
for trec are 3 and 5, so we explore the region
size around these values, and compare this to us-
ing multiple region sizes far away from these    op-
timal    values.

multiple region size

accuracy (%)

(3)
(5)

(2,3,4)
(3,4,5)
(4,5,6)
(7,8,9)

(14,15,16)
(2,3,4,5)
(3,3,3)
(3,3,3,3)

91.21 (90.88,91.52)
91.20 (90.96,91.43)
91.48 (90.96,91.70)
91.56 (91.24,91.81)
91.48 (91.17,91.68)
90.79 (90.57,91.26)
90.23 (89.81,90.51)
91.57 (91.25,91.94)
91.42 (91.11,91.65)
91.32 (90.53,91.55)

table 6: effect of    lter region size with several
region sizes using non-static id97-id98 on
trec dataset

here we see that (3,3,3) and (3,3,3,3) perform

13571015202530filter region size654321012change in accuracy (%) mrsst-1sst-2subjtreccrmpqaopiopi105010020040060010002000number of feature maps for each filter region size (log-scale)5432101change in accuracy (%)mrsst-1sst-2subjtreccrmpqaopiironyworse than (2,3,4) and (3,4,5). however, the result
still shows that a combination of region sizes near
the optimal single best region size outperforms us-
ing multiple region sizes far from the optimal sin-
gle region size. furthermore, we again see that a
single good region size (3) outperforms combin-
ing several suboptimal region sizes: (7,8,9) and
(14,15,16).

in light of these observations, we believe it ad-
visable to    rst perform a coarse line-search over a
single    lter region size to    nd the    best    size for
the dataset under consideration, and then explore
the combination of several region sizes nearby this
single best size, including combining both differ-
ent region sizes and copies of the optimal sizes.

4.4 effect of number of feature maps for

each    lter region size

we again hold other con   gurations constant, and
thus have three    lter region sizes: 3, 4 and 5. we
change only the number of feature maps for each
of these relative to the baseline of 100; we con-
sider values     {10, 50, 100, 200, 400, 600, 1000,
2000}. we report results in fig. 4.

the    best    number of feature maps for each    l-
ter region size depends on the dataset. however,
it would seem that increasing the number of maps
beyond 600 yields at best very marginal returns,
and often hurts performance (likely due to over-
   tting). another salient practical point is that it
takes a longer time to train the model when the
number of feature maps is increased. in practice,
the evidence here suggests perhaps searching over
a range of 100 to 600. note that this range is
only provided as a possible standard trick when
one is faced with a new similar sentence classi   ca-
tion problem; it is of course possible that in some
cases more than 600 feature maps will be bene-
   cial, but the evidence here suggests expending
the effort to explore this is probably not worth it.
in practice, one should consider whether the best
observed value falls near the border of the range
searched over; if so, it is probably worth explor-
ing beyond that border, as suggested in (bengio,
2012).

4.5 effect of activation function
we consider seven different id180 in
the convolution layer, including: relu (as per the
baseline con   guration), hyperbolic tangent (tanh),
sigmoid function (maas et al., 2013), softplus
function (dugas et al., 2001), cube function (chen

and manning, 2014), and tanh cube function (pei
et al., 2015). we use    iden    to denote the iden-
tity function, which means not using any activa-
tion function. we report results achieved using
different id180 in non-static id98 in
table 15.

for 8 out of 9 datasets, the best activation func-
tion is one of iden, relu and tanh. the softplus
function outperformedd these on only one dataset
(mpqa). sigmoid, cube, and tanh cube all con-
sistently performed worse than alternative activa-
tion functions. thus we do not report results for
these here. the performance of the tanh function
may be due to its zero centering property (com-
pared to sigmoid). relu has the merits of a
non-saturating form compared to sigmoid, and it
has been observed to accelerate the convergence
of sgd (krizhevsky et al., 2012). one interest-
ing result is that not applying any activation func-
tion (iden) sometimes helps. this indicates that on
some datasets, a linear transformation is enough to
capture the correlation between the word embed-
ding and the output label. however, if there are
multiple hidden layers, iden may be less suitable
than non-linear id180. practically,
with respect to the choice of the activation func-
tion in one-layer id98s, our results suggest exper-
imenting with relu and tanh, and perhaps also
iden.

4.6 effect of pooling strategy

we next investigated the effect of the pooling strat-
egy and the pooling region size. we    xed the    lter
region sizes and the number of feature maps as in
the baseline con   guration, thus changing only the
pooling strategy or pooling region size.

in the baseline con   guration, we performed 1-
max pooling globally over feature maps, inducing
a feature vector of length 1 for each    lter. how-
ever, pooling may also be performed over small
equal sized local regions rather than over the en-
tire feature map (boureau et al., 2011). each small
local region on the feature map will generate a sin-
gle number from pooling, and these numbers can
be concatenated to form a feature vector for one
feature map. the following step is the same as 1-
max pooling: we concatenate all the feature vec-
tors together to form a single feature vector for the
classi   cation layer. we experimented with local
region sizes of 3, 10, 20, and 30, and found that
1-max pooling outperformed all local max pooling

dataset

mr
sst-1
sst-2
subj
trec

cr

mpqa

opi
irony

tanh

81.28 (81.07, 81.52)
47.02 (46.31, 47.73)
85.43 (85.10, 85.85)
93.15 (92.93, 93.34)
91.18 (90.91, 91.47)
84.28 (83.90, 85.11)
89.48 (89.16, 89.84)
65.69 (65.16,66.40)
67.62 (67.18,68.27)

softplus

80.58 (80.17, 81.12)
46.95 (46.43, 47.45)
84.61 (84.19, 84.94)
92.43 (92.21, 92.61)
91.05 (90.82, 91.29)
83.67 (83.16, 84.26)
89.62 (89.45, 89.77)
64.77 (64.25,65.28)
66.20 (65.38,67.20)

iden

81.30 (81.09, 81.52)
46.73 (46.24,47.18)
85.26 (85.11, 85.45)
93.11 (92.92, 93.22)
91.11 (90.82, 91.34)
84.55 (84.21, 84.69)
89.57 (89.31, 89.88)
65.32 (64.78,66.09)
66.77 (65.90,67.47)

relu

81.16 (80.81, 83.38)
47.13 (46.39, 47.56)
85.31 (85.93, 85.66)
93.13 (92.93, 93.23)
91.54 (91.17, 91.84)
83.83 (83.18, 84.21)
89.35 (88.88, 89.58)
65.02 (64.53,65.45)
66.46 (65.99,67.17)

table 7: performance of different id180

con   gurations. this result held across all datasets.
we also considered a k-max pooling strategy
similar to (kalchbrenner et al., 2014), in which the
maximum k values are extracted from the entire
feature map, and the relative order of these values
is preserved. we explored the k     {5, 10, 15, 20},
and again found 1-max pooling fared best, consis-
tently outperforming k-max pooling.

next, we considered taking an average, rather
than the max, over regions (boureau et al., 2010a).
we held the rest of architecture constant. we ex-
perimented with local average pooling region sizes
{3, 10, 20, 30}. we found that average pool-
ing uniformly performed (much) worse than max
pooling, at least on the cr and trec datasets.
due to the substantially worse performance and
very slow running time observed under average
pooling, we did not complete experiments on all
datasets.

our analysis of pooling strategies shows that 1-
max pooling consistently performs better than al-
ternative strategies for the task of sentence clas-
si   cation. this may be because the location of
predictive contexts does not matter, and certain
id165s in the sentence can be more predictive
on their own than the entire sentence considered
jointly.

4.7 effect of id173
two common id173 strategies for id98s
are dropout and l2 norm constraints; we explore
the effect of these here.    dropout    is applied to the
input to the penultimate layer. we experimented
with varying the dropout rate from 0.0 to 0.9,    x-
ing the l2 norm constraint to 3, as per the baseline
con   guration. the results for non-static id98 are
shown in in fig. 5, with 0.5 designated as the base-
line. we also report the accuracy achieved when
we remove both dropout and the l2 norm con-
straint (i.e., when no id173 is performed),
denoted by    none   .

separately, we considered the effect of the

figure 5: effect of dropout rate. the accuracy
when the dropout rate is 0.9 on the opi dataset
is about 10% worse than baseline, and thus is not
visible on the    gure at this point.

l2 norm imposed on the weight vectors that
parametrize the softmax function. recall that the
l2 norm of a weight vector is linearly scaled to
a constraint c when it exceeds this threshold, so
a smaller c implies stronger id173. (like
dropout, this strategy is applied only to the penulti-
mate layer.) we show the relative effect of varying
c on non-static id98 in figure 6, where we have
   xed the dropout rate to 0.5; 3 is the baseline here
(again, arbitrarily).

figure 6: effect of the l2 norm constraint on
weight vectors.

none0.00.10.30.50.70.9dropout rate432101change in accuracy (%)mrsst-1sst-2subjtreccrmpqaopiirony123451015202530nonel2 norm constraint on weight vectors1.00.50.00.51.0change in accuracy (%)mrsst-1sst-2subjtreccrmpqaopiironyfrom figures 5 and 6, one can see that non-zero
dropout rates can help (though very little) at some
points from 0.1 to 0.5, depending on datasets. but
imposing an l2 norm constraint generally does not
improve performance much (except on opi), and
even adversely effects performance on at least one
dataset (cr).

we then also explored dropout rate effect when
increasing the number of feature maps. we in-
crease the number of feature maps for each    lter
size from 100 to 500, and set max l2 norm con-
straint as 3. the effect of dropout rate is shown
in fig. 7. we see that the effect of dropout rate

figure 7: effect of dropout rate when using 500
feature maps.

is almost the same as when the number of feature
maps is 100, and it does not help much. but we
observe that for the dataset sst-1, dropout rate ac-
tually helps when it is 0.7. referring to fig. 4, we
can see that when the number of feature maps is
larger than 100, it hurts the performance possibly
due to over   tting, so it is reasonable that in this
case dropout would mitigate this effect.

we also experimented with applying dropout
only to the convolution layer, but still setting the
max norm constraint on the classi   cation layer to
3, keeping all other settings exactly the same. this
means we randomly set elements of the sentence
matrix to 0 during training with id203 p, and
then multiplied p with the sentence matrix at test
time. the effect of dropout rate on the convolu-
tion layer is shown in fig. 8. again we see that
dropout on the convolution layer helps little, and
large dropout rate dramatically hurts performance.
to summarize, contrary to some of the existing
literature e (srivastava et al., 2014), we found that
dropout had little bene   cial effect on id98 perfor-
mance. we attribute this observation to the fact

figure 8: effect of dropout rate on the convolution
layer (the accuracy when the dropout rate is 0.9
on the opi dataset is not visible on the    gure at
this point, as in fig. 5)

that one-layer id98 has a smaller number param-
eters than multi-layer deep learning models. an-
other possible explanation is that using word em-
beddings helps to prevent over   tting (compared
to bag of words based encodings). however, we
are not advocating completely foregoing regular-
ization. practically, we suggest setting the dropout
rate to a small value (0.0-0.5) and using a rela-
tively large max norm constraint, while increasing
the number of feature maps to see whether more
features might help. when further increasing the
number of feature maps seems to degrade perfor-
mance, it is probably worth increasing the dropout
rate.

5 conclusions

we have conducted an extensive experimental
analysis of id98s for sentence classi   cation. we
conclude here by summarizing our main    ndings
and deriving from these practical guidance for re-
searchers and practitioners looking to use and de-
ploy id98s in real-world sentence classi   cation
scenarios.

5.1 summary of main empirical findings

    prior work has tended to report only the mean
performance on datasets achieved by models.
but this overlooks variance due solely to the
stochastic id136 procedure used. this can
be substantial: holding everything constant
(including the folds), so that variance is due
exclusively to the stochastic id136 proce-
dure, we    nd that mean accuracy (calculated
via 10 fold cross-validation) has a range of

none0.00.10.30.50.70.9dropout rate when feature map is 500432101change in accuracy (%)mrsst-1sst-2subjtreccrmpqaopiirony0.00.10.30.50.70.9dropout rate54321012change in accuracy (%)mrsst-1sst-2subjtreccrmpqaopiironyup to 1.5 points. and the range over the auc
achieved on the irony dataset is even greater
    up to 3.4 points (see table 3). more replica-
tion should be performed in future work, and
ranges/variances should be reported, to pre-
vent potentially spurious conclusions regard-
ing relative model performance.

    we    nd that, even when tuning them to the
task at hand, the choice of input word vector
representation (e.g., between id97 and
glove) has an impact on performance, how-
ever different representations perform better
for different tasks. at least for sentence clas-
si   cation, both seem to perform better than
using one-hot vectors directly. we note, how-
ever, that:
(1) this may not be the case if
one has a suf   ciently large amount of train-
ing data, and, (2) the recent semi-supervised
id98 model proposed by johnson and zhang
(johnson and zhang, 2015) may improve per-
formance, as compared to the simpler version
of the model considered here (i.e., proposed
in (johnson and zhang, 2014)).

    the    lter region size can have a large effect

on performance, and should be tuned.

    the number of feature maps can also play
an important role in the performance, and in-
creasing the number of feature maps will in-
crease the training time of the model.

    1-max pooling uniformly outperforms other

pooling strategies.

    id173 has relatively little effect on

the performance of the model.

5.2 speci   c advice to practitioners
drawing upon our empirical results, we provide
the following guidance regarding id98 architec-
ture and hyperparameters for practitioners looking
to deploy id98s for sentence classi   cation tasks.
    consider starting with the basic con   gura-
tion described in table 2 and using non-static
id97 or glove rather than one-hot vec-
tors. however, if the training dataset size
is very large, it may be worthwhile to ex-
plore using one-hot vectors. alternatively,
if one has access to a large set of unlabeled
in-domain data, (johnson and zhang, 2015)
might also be an option.

    line-search over the single    lter region size
to    nd the    best    single region size. a rea-
sonable range might be 1   10. however, for
datasets with very long sentences like cr, it
may be worth exploring larger    lter region
sizes. once this    best    region size is iden-
ti   ed, it may be worth exploring combining
multiple    lters using regions sizes near this
single best size, given that empirically multi-
ple    good    region sizes always outperformed
using only the single best region size.

    alter the number of feature maps for each    l-
ter region size from 100 to 600, and when this
is being explored, use a small dropout rate
(0.0-0.5) and a large max norm constraint.
note that increasing the number of feature
maps will increase the running time, so there
is a trade-off to consider. also pay atten-
tion whether the best value found is near the
border of the range (bengio, 2012).
if the
best value is near 600, it may be worth trying
larger values.

    consider different id180 if pos-
sible: relu and tanh are the best overall can-
didates. and it might also be worth trying
no activation function at all for our one-layer
id98.

    use 1-max pooling; it does not seem neces-
sary to expend resources evaluating alterna-
tive strategies.

    regarding id173: when increasing
the number of feature maps begins to reduce
performance, try imposing stronger regular-
ization, e.g., a dropout out rate larger than
0.5.

    when assessing the performance of a model
(or a particular con   guration thereof), it is
imperative to consider variance. therefore,
replications of the cross-fold validation pro-
cedure should be performed and variances
and ranges should be considered.

of course, the above suggestions are applicable
only to datasets comprising sentences with simi-
lar properties to the those considered in this work.
and there may be examples that run counter to our
   ndings here. nonetheless, we believe these sug-
gestions are likely to provide a reasonable start-
ing point for researchers or practitioners looking

to apply a simple one-layer id98 to real world
sentence classi   cation tasks. we emphasize that
we selected this simple one-layer id98 in light of
observed strong empirical performance, which po-
sitions it as a new standard baseline model akin to
bag-of-words id166 and id28. this
approach should thus be considered prior to im-
plementation of more sophisticated models.

we have attempted here to provide practical,
empirically informed guidance to help data sci-
ence practitioners    nd the best con   guration for
this simple model. we recognize that manual and
grid search over hyperparameters is sub-optimal,
and note that our suggestions here may also in-
form hyperparameter ranges to explore in random
search or bayesian optimization frameworks.

6 acknowledgments
this work was supported in part by the army re-
search of   ce (grant w911nf-14-1-0442) and by
the foundation for science and technology, por-
tugal
(grant utap-expl/eeiess/0031/2014).
this work was also made possible by the support
of the texas advanced computer center (tacc)
at ut austin.

we thank tong zhang and rie johnson for help-

ful feedback.

references
[bengio et al.2003] yoshua bengio, r  ejean ducharme,
pascal vincent, and christian janvin. 2003. a neu-
ral probabilistic language model. the journal of
machine learning research, 3:1137   1155.

[bengio2009] yoshua bengio. 2009. learning deep ar-
chitectures for ai. foundations and trends in ma-
chine learning, 2(1):1   127.

[bengio2012] yoshua bengio.

2012. practical rec-
ommendations for gradient-based training of deep
in neural networks: tricks of the
architectures.
trade, pages 437   478. springer.

[bergstra et al.2013] james bergstra, daniel yamins,
and david daniel cox. 2013. making a science of
model search: hyperparameter optimization in hun-
dreds of dimensions for vision architectures.

[boureau et al.2010a] y-lan boureau, francis bach,
yann lecun, and jean ponce. 2010a. learning
mid-level features for recognition. in computer vi-
sion and pattern recognition (cvpr), 2010 ieee
conference on, pages 2559   2566. ieee.

[boureau et al.2010b] y-lan boureau, jean ponce, and
yann lecun. 2010b. a theoretical analysis of fea-
in proceedings
ture pooling in visual recognition.

of the 27th international conference on machine
learning (icml-10), pages 111   118.

[boureau et al.2011] y-lan boureau, nicolas le roux,
francis bach, jean ponce, and yann lecun. 2011.
ask the locals: multi-way local pooling for im-
age recognition. in id161 (iccv), 2011
ieee international conference on, pages 2651   
2658. ieee.

[breuel2015] thomas m breuel. 2015. the effects of
hyperparameters on sgd training of neural networks.
arxiv preprint arxiv:1508.02788.

[chen and manning2014] danqi chen and christo-
pher d manning. 2014. a fast and accurate depen-
dency parser using neural networks. in proceedings
of the 2014 conference on empirical methods in
natural language processing (emnlp), volume 1,
pages 740   750.

[coates et al.2011] adam coates, andrew y ng, and
honglak lee. 2011. an analysis of single-layer
in in-
networks in unsupervised id171.
ternational conference on arti   cial intelligence and
statistics, pages 215   223.

[collobert and weston2008] ronan collobert and ja-
son weston. 2008. a uni   ed architecture for natu-
ral language processing: deep neural networks with
in proceedings of the 25th in-
multitask learning.
ternational conference on machine learning, pages
160   167. acm.

[collobert et al.2011] ronan collobert, jason weston,
l  eon bottou, michael karlen, koray kavukcuoglu,
and pavel kuksa. 2011. natural language process-
ing (almost) from scratch. the journal of machine
learning research, 12:2493   2537.

[dugas et al.2001] charles dugas, yoshua bengio,
franc  ois b  elisle, claude nadeau, and ren  e garcia.
2001. incorporating second-order functional knowl-
edge for better option pricing. advances in neural
information processing systems, pages 472   478.

[ganesan et al.2010] kavita ganesan, chengxiang
zhai, and jiawei han. 2010. opinosis: a graph-
based approach to abstractive summarization of
in proceedings of
highly redundant opinions.
the 23rd international conference on computa-
tional linguistics, pages 340   348. association for
computational linguistics.

[goldberg2015] yoav goldberg. 2015. a primer on
neural network models for natural language process-
ing. arxiv preprint arxiv:1510.00726.

[hinton et al.2012] geoffrey e hinton, nitish srivas-
tava, alex krizhevsky, ilya sutskever, and rus-
lan r salakhutdinov. 2012. improving neural net-
works by preventing co-adaptation of feature detec-
tors. arxiv preprint arxiv:1207.0580.

[hu and liu2004] minqing hu and bing liu. 2004.
mining and summarizing customer reviews. in pro-
ceedings of the tenth acm sigkdd international
conference on knowledge discovery and data min-
ing, pages 168   177. acm.

[iyyer et al.2015] mohit iyyer, varun manjunatha, jor-
dan boyd-graber, and hal daum  e iii. 2015. deep
unordered composition rivals syntactic methods for
text classi   cation.

[joachims1998] thorsten joachims. 1998. text cate-
gorization with support vector machines: learning
with many relevant features. springer.

[johnson and zhang2014] rie

and tong
zhang. 2014. effective use of word order for text
categorization with convolutional neural networks.
arxiv preprint arxiv:1412.1058.

johnson

2015.

[johnson and zhang2015] rie

and tong
zhang.
semi-supervised convolutional
neural networks for text categorization via region
in advances in neural information
embedding.
processing systems, pages 919   927.

johnson

[kalchbrenner et al.2014] nal kalchbrenner, edward
grefenstette, and phil blunsom. 2014. a convo-
lutional neural network for modelling sentences. in
proceedings of the 52nd annual meeting of the as-
sociation for computational linguistics (volume 1:
long papers), pages 655   665, baltimore, maryland,
june. association for computational linguistics.

[kim2014] yoon kim.

2014. convolutional neural
networks for sentence classi   cation. arxiv preprint
arxiv:1408.5882.

[krizhevsky et al.2012] alex

krizhevsky,

ilya
sutskever, and geoffrey e hinton.
im-
agenet classi   cation with deep convolutional neural
in advances in neural
information
networks.
processing systems, pages 1097   1105.

2012.

[lecun et al.2015] yann lecun, yoshua bengio, and
geoffrey hinton. 2015. deep learning. nature,
521(7553):436   444.

[li and roth2002] xin li and dan roth. 2002. learn-
the
ing question classi   ers.
19th international conference on computational
linguistics-volume 1, pages 1   7. association for
computational linguistics.

in proceedings of

[maas et al.2013] andrew l maas, awni y hannun,
and andrew y ng. 2013. recti   er nonlinearities
improve neural network acoustic models. in proc.
icml, volume 30.

[mikolov et al.2013] tomas mikolov, ilya sutskever,
kai chen, greg s corrado, and jeff dean. 2013.
distributed representations of words and phrases
in advances in neural
and their compositionality.
information processing systems, pages 3111   3119.

[pang and lee2005] bo pang and lillian lee. 2005.
seeing stars: exploiting class relationships for senti-
ment categorization with respect to rating scales. in
proceedings of the acl.

[pedregosa et al.2011] f. pedregosa, g. varoquaux,
a. gramfort, v. michel, b. thirion, o. grisel,
m. blondel, p. prettenhofer, r. weiss, v. dubourg,
j. vanderplas, a. passos, d. cournapeau,
m. brucher, m. perrot, and e. duchesnay. 2011.
scikit-learn: machine learning in python. journal
of machine learning research, 12:2825   2830.

[pei et al.2015] wenzhe pei, tao ge, and baobao
chang. 2015. an effective neural network model
in proc. of
for graph-based id33.
acl.

[pennington et al.2014] jeffrey pennington, richard
socher, and christopher d manning. 2014. glove:
global vectors for word representation. proceedings
of the empiricial methods in natural language pro-
cessing (emnlp 2014), 12:1532   1543.

[rumelhart et al.1988] david e rumelhart, geoffrey e
hinton, and ronald j williams. 1988. learning rep-
resentations by back-propagating errors. cognitive
modeling, 5:3.

[socher et al.2013] richard socher, alex perelygin,
jean y wu, jason chuang, christopher d manning,
andrew y ng, and christopher potts. 2013. recur-
sive deep models for semantic compositionality over
a sentiment treebank. in proceedings of the confer-
ence on empirical methods in natural language pro-
cessing (emnlp), volume 1631, page 1642. cite-
seer.

[srivastava et al.2014] nitish srivastava, geoffrey hin-
ton, alex krizhevsky, ilya sutskever, and ruslan
salakhutdinov. 2014. dropout: a simple way to
prevent neural networks from over   tting. the jour-
nal of machine learning research, 15(1):1929   
1958.

[wallace et al.2011] byron c wallace, kevin small,
carla e brodley, and thomas a trikalinos. 2011.
in data mining (icdm),
class imbalance, redux.
2011 ieee 11th international conference on, pages
754   763. ieee.

[wallace et al.2014] byron c wallace, laura kertz
do kook choe, and eugene charniak. 2014. hu-
mans require context to infer ironic intent (so com-
puters probably do, too). in proceedings of the an-
nual meeting of the association for computational
linguistics (acl), pages 512   516.

[wang et al.2015] peng wang, jiaming xu, bo xu,
chenglin liu, heng zhang, fangyuan wang, and
hongwei hao. 2015. semantic id91 and con-
volutional neural network for short text categoriza-
in proceedings of the 53rd annual meet-
tion.
ing of the association for computational linguistics
and the 7th international joint conference on natu-
ral language processing (volume 2: short papers),

pages 352   357, beijing, china, july. association for
computational linguistics.

[wiebe et al.2005] janyce wiebe, theresa wilson, and
claire cardie. 2005. annotating expressions of
opinions and emotions in language. language re-
sources and evaluation, 39(2-3):165   210.

[yogatama and smith2015] dani

and
noah a smith. 2015. bayesian optimization of text
representations. arxiv preprint arxiv:1503.00693.

yogatama

[zeiler2012] matthew d zeiler.

2012. adadelta:
an adaptive learning rate method. arxiv preprint
arxiv:1212.5701.

appendix

dataset average length maximum length

mr
sst-1
sst-2
subj
trec

cr

mpqa

20
18
19
23
10
19
3

56
53
53
120
37
105
36

table 8: average length and maximum length of
the 7 datasets

dataset

mr
sst-1
sst-2
subj
trec

cr

mpqa

bow-lg wv-lg bow+wv-lg
78.24
40.91
81.06
89.00
87.93
77.59
83.60

77.65
43.60
81.30
90.88
77.42
80.79
88.30

79.68
43.09
83.23
91.84
89.23
80.39
89.14

table 9: performance of id28

mr
sst-1
sst-2
subj
trec

dataset one-hot vector id98
77.83 (76.56,78.45)
41.96 (40.29,43.46)
79.80 (78.53,80.52)
91.14 (90.38,91.53)
88.28 (87.34,89.30)
78.22 (76.67,80.00)
83.94 (82.94,84.31)

mpqa

cr

table 14: performance of one-hot vector id98

pooling region

3
10
20
30
all

cr

81.01 (80.73,81.28)
80.74 (80.36,81.09)
80.69 (79.72,81.32)
81.13 (80.16,81.76)
80.17 (79.97,80.84)

trec

88.89 (88.67,88.97)
88.10 (87.82,88.47)
86.45 (85.65,86.42)
84.95 (84.65,85.14)
83.30 (83.11,83.57)

table 17: performance of local average pooling
region size using non-static id97-id98 (   all   
means average pooling over the whole feature map
resulting in one number)

region size

mr

1
3
5
7
10
15
20
25
30

77.85 (77.47,77.97)
80.48 (80.26,80.65)
81.13 (80.96,81.32)
81.65 (81.45,81.85)
81.43 (81.28,81.75)
81.26 (81.01,81.43)
81.06 (80.87,81.30)
80.91 (80.73,81.10)
80.91 (80.72,81.05)

sst-1

44.91 (44.42,45.37)
46.64 (46.21,47.07)
47.02 (46.74,47.40)
46.98 (46.70,47.37)
46.90 (46.50,47.56)
46.66 (46.13,47.23)
46.20 (45.40,46.72)
46.17 (45.20,46.92)
46.02 (45.21,46.54)

sst-2

82.59(82.20,82.80)
84.74 (84.47,85.00)
85.31 (85.04,85.71)
85.57 (85.16,85.90)
85.60 (85.33,85.90)
85.33 (84.96,85.74)
85.02 (84.94,85.24)
84.91 (84.49,85.39)
84.94 (84.63,85.25)

subj

91.23 (90.96,91.48)
92.71 (92.52,92.93)
92.89 (92.64,93.07)
92.95 (92.72,93.19)
92.90 (92.71,93.10)
92.82 (92.61,92.98)
92.72(92.47,92.87)
92.75 (92.45,92.96)
92.70 (92.50,92.90)

trec

85.82 (85.41,86.12)
91.21 (90.88,91.52)
91.20 (90.96,91.43)
90.77 (90.53,91.15)
90.29 (89.89,90.52)
90.05 (89.68,90.28)
90.01 (89.84,90.50)
89.99 (89.66,90.40)
89.90 (89.58,90.13)

cr

80.15 (79.27,80.89)
81.01 (80.64,81.53)
81.78 (80.75,82.52)
82.16 (81.70,82.87)
82.53 (81.58,82.92)
82.49 (81.61,83.06)
82.62 (82.16,83.03)
82.87 (82.21,83.45)
83.01 (82.44,83.38)

mpqa

88.53 (88.29,88.86)
89.04 (88.71,89.27)
89.20 (88.99,89.37)
89.32 (89.17,89.41)
89.23 (89.03,89.52)
89.25 (89.03,89.44)
89.16 (88.92,89.28)
89.16 (88.99,89.45)
89.15 (88.93,89.41)

table 10: effect of single    lter region size using non-static id98.

mr

79.22 (79.02,79.57)
80.27 (79.94,80.51)
80.35 (80.05,80.65)
80.25 (79.89,80.60)
80.02 (79.68,80.17)
79.59 (79.36,79.75)
79.33 (78.76,79.75)
79.05 (78.91,79.21)
79.04 (78.86,79.30)

sst-1

45.46 (44.88,45.96)
46.18 (45.74,46.52)
46.18 (45.69,46.63)
45.96 (45.44,46.55)
45.65 (45.08,46.09)
45.19 (44.67,45.62)
45.02 (44.15,45.77)
44.61 (44.05,45.53)
44.66 (44.42,44.91)

sst-2

83.24 (82.93,83.67)
84.37 (83.96,94.70)
84.38 (84.04,84.61)
84.24 (83.40,84.59)
83.90 (83.40,84.37)
83.64 (83.32,83.95)
83.30 (83.03,83.60)
83.24 (82.82,83.70)
83.09 (82.61,83.42)

subj

91.97 (91.64,92.17)
92.83 (92.58,93.06)
92.54 (92.44,92.68)
92.50 (92.33,92.68)
92.31 (92.19,92.50)
92.02 (91.86,92.23)
91.87 (91.70,91.99)
91.95 (91.59,92.16)
91.85 (91.74,92.00)

trec

85.86 (85.54,86.13)
90.33 (90.05,90.62)
90.06 (89.84,90.26)
89.44 (89.07,89.84)
88.81(88.53,89.03)
88.41 (87.96,88.71)
88.46 (88.21,88.85)
88.23 (87.57,88.56)
88.41 (87.98,88.67)

cr

80.24 (79.64,80.62)
80.71 (79.72,81.37)
81.11 (80.54,81.55)
81.53 (81.09,82.05)
81.19 (80.89,81.61)
81.36 (80.72,82.04)
81.42 (81.03,81.90)
81.16 (80.69,81.57)
81.28 (80.96,81.55)

mpqa

88.25 (88.04,88.63)
89.37 (89.25,89.67)
89.50 (89.33,89.65)
89.44 (89.26,89.68)
89.26 (88.96,89.60)
89.27 (89.04,89.49)
89.28 (88.90, 89.42)
89.24 (88.87,89.42)
89.13 (88.91,89.33)

1
3
5
7
10
15
20
25
30

table 11: effect of single    lter region size using static id98.

mr
sst-1
sst-2
subj
trec

cr

mpqa

10

80.47 (80.14,80.99)
45.90 (45.14,46.41)
84.26 (83.93,84.73)
92.24 (91.74,92.43)
90.64 (90.19,90.86)
79.95 (79.36,80.41)
89.02 (88.89,89.19)

50

81.25 (80.90,81.56)
47.06 (46.58,47.59)
85.23 (84.86,85.57)
93.07 (92.94,93.28)
91.40 (91.12,91.59)
83.19 (82.32,83.50)
89.21 (88.97,89.41)

100

81.17 (81.00,81.38)
47.09 (46.50,47.66)
85.50 (85.31,85.66)
93.19 (93.08,93.45)
91.54 (91.17,91.90)
83.86 (83.52,84.15)
89.21 (88.90,89.51)

200

81.31 (81.00,81.60)
47.09 (46.34,47.50)
85.53 (85.24,85.69)
93.29 (93.07,93.38)
91.54 (91.23,91.71)
84.30 (83.80,84.64)
89.50 (89.27,89.68)

400

81.41 (81.21,81.61)
46.87 (46.41,47.43)
85.56 (85.27,85.79)
93.24 (92.96,93.39)
91.52 (91.30,91.70)
84.44 (84.14,85.02)
89.57 (89.13,89.81)

600

81.38 (81.09, 81.68)
46.84 (46.29,47.47)
85.70 (85.57,85.93)
93.34 (93.22,93.44)
91.50 (91.23,91.71)
84.62 (84.31,84.94)
89.66 (89.35,89.90)

1000

81.30 (81.15,81.39)
46.58 (46.26,47.14)
85.75 (85.53,86.01)
93.32 (93.17,93.49)
91.44 (91.26,91.56)
84.58 (84.35,84.85)
89.55 (89.22,89.73)

2000

81.40 (81.13,81.61)
46.75 (45.87,47.67)
85.74 (85.49,86.02)
93.34 (93.05,93.49)
91.54 (91.28,91.75)
84.47 (83.84,85.03)
89.66 (89.47,89.94)

table 12: performance of number of feature maps for each    lter using non-static id97-id98

mr
sst-1
sst-2
subj
trec

cr

mpqa

10

79.38 (78.88, 79.82)
45.62 (45.28,46.01)
83.38 (82.65,83.68)
91.84 (91.30,92.02)
89.02 (88.62,89.31)
79.40 (78.76,80.03)
89.28 (89.04,89.45)

50

80.49 (80.16, 80.87)
46.33 (46.00,46.69)
84.71 (84.46,85.27)
92.75 (92.61,92.88)
90.51 (90.26, 90.82)
82.57 (82.05,83.31)
89.53 (89.31,89.72)

100

80.60 (80.27,80.85)
46.21 (45.68,46.85)
84.89 (84.56,85.16)
92.89 (92.66,93.06)
90.62 (90.09,90.82)
83.48 (82.99,84.06)
89.55 (89.18,89.81)

200

80.76 (80.48,81.00)
46.23 (45.70, 46.99)
84.92 (84.81,85.18)
92.88 (92.75,92.97)
90.73 (90.48,90.99)
83.83 (83.51,84.26)
89.73 (89.62,89.85)

400

80.80 (80.56,81.11)
46.10 (45.71,46.59)
84.98 (84.66,85.18)
92.91 (92.75,93.01)
90.72 (90.43,90.89)
83.95 (83.36,84.60)
89.80 (89.65,89.96)

600

80.79 (80.68,80.86)
46.20 (45.85,46.55)
84.99 (84.29,85.44)
92.88 (92.75,93.03)
90.70 (90.51,91.03)
83.96 (83.49, 84.47)
89.84 (89.74,90.02)

1000

80.90 (80.67,81.16)
46.56 (46.26,46.92)
84.90 (84.66,85.05)
92.89 (92.74,93.05)
90.71 (90.46,90.94)
83.95 (83.40,84.44)
89.72 (89.57,89.88)

2000

80.84 (80.38,81.27)
45.93 (45.57,46.27)
84.97 (84.79,85.14)
92.89 (92.64,93.11)
90.70 (90.53,90.87)
83.81 (83.30,84.28)
89.82 (89.52,89.97)

table 13: effect of number of feature maps for each    lter using static id97-id98

mr
sst-1
sst-2
subj
trec

cr

mpqa

sigmoid

80.51 (80.22, 80.77)
45.83 (45.44, 46.31)
84.51 (84.36, 84.63)
92.00 (91.87, 92.22)
89.64 (89.38, 89.94)
82.60 (81.77, 83.05)
89.56 (89.43, 89.78)

tanh

81.28 (81.07, 81.52)
47.02 (46.31, 47.73)
85.43 (85.10, 85.85)
93.15 (92.93, 93.34)
91.18 (90.91, 91.47)
84.28 (83.90, 85.11)
89.48 (89.16, 89.84)

softplus

80.58 (80.17, 81.12)
46.95 (46.43, 47.45)
84.61 (84.19, 84.94)
92.43 (92.21, 92.61)
91.05 (90.82, 91.29)
83.67 (83.16, 84.26)
89.62 (89.45, 89.77)

iden

81.30 (81.09, 81.52)
46.73 (46.24,47.18)
85.26 (85.11, 85.45)
93.11 (92.92, 93.22)
91.11 (90.82, 91.34)
84.55 (84.21, 84.69)
89.57 (89.31, 89.88)

relu

81.16 (80.81, 83.38)
47.13 (46.39, 47.56)
85.31 (85.93, 85.66)
93.13 (92.93, 93.23)
91.54 (91.17, 91.84)
83.83 (83.18, 84.21)
89.35 (88.88, 89.58)

cube

80.39 (79.94,80.83)
45.80 (45.27,46.51)
85.28 (85.15,85.55)
93.01 (93.21,93.43)
90.98 (90.58,91.47)
84.16 (84.47,84.88)
88.66 (88.55,88.77)

tahn-cube

81.22 (80.93,81.48)
46.85 (46.13,47.46)
85.24 (84.98,85.51)
92.91 (93.13,93.29)
91.34 (90.97,91.73)
83.89 (84.34,84.89)
89.45 (89.27,89.62)

table 15: performance of different id180 using non-static id97-id98

sigmoid

mr
trec

79.23 (79.11, 79.36)
85.81 (85.65, 85.99)
81.14 (80.57, 82.01)
cr
45.25 (44.65, 45.86)
sst-1
83.07 (82.48, 83.54)
sst-2
subj
91.56 (91.39, 91.71)
mpqa 89.43 (89.27, 89.56)

tanh

80.73 (80.29, 81.04)
90.25 (89.92, 90.44)
83.51 (82.91,83.95)
45.98 (45.68, 46.44)
84.65 (84.36, 85.00)
92.75 (92.60, 92.95)
89.75 (89.64, 89.86)

softplus

80.05 (79.76, 80.37)
89.50 (89.36, 89.97)
83.28 (82.67, 83.88)
46.76 (46.41, 47.45)
84.01 (83.57, 84.40)
92.20 (92.08, 92.32)
89.45 (89.30, 89.56)

iden

80.63 (80.26, 81.04)
90.36 (90.23, 90.45)
83.82 (83.50, 84.15)
46.01 (45.60, 46.32)
84.71 (84.40, 85.07)
92.71 (92.51, 92.89)
89.75 (89.56, 89.87)

relu

80.65 (80.44, 81.00)
90.23 (89.85, 90.63)
83.51 (82.54, 83.85)
46.25 (45.70, 46.98)
84.70 (84.31, 85.20)
92.83 (92.67, 92.95)
89.66 (89.44, 90.00)

table 16: performance of different activation function using static id97-id98

1 (1-max)

mr
sst-1
sst-2
subj
trec

81.25 (81.00,81.47)
47.24 (46.90,47.65)
85.53 (85.26,85.80)
93.18 (93.09,93.31)
91.53 (91.26,91.78)
83.81 (83.44,84.37)
mpqa 89.39 (89.14, 89.58)

cr

5

80.83 (80.69,80.91)
46.63 (46.31,47.12)
84.61(84.47,84.90)
92.49 (92.33,92.61)
89.93 (89.75,90.09)
82.70 (82.14,83.11)
89.36 (89.17,89.57)

10

80.05 (79.69,80.41)
46.04 (45.27,46.61)
84.09 (83.94,84.22)
92.66 (92.50,92.79)
89.73 (89.61,89.83)
82.46 (82.17,82.76)
89.14 (89.00,89.45)

15

80.11 (79.89,80.36)
45.91 (45.16,46.49)
84.02 (83.57,84.28)
92.52 (92.33,92.96)
89.49(89.31,89.65)
82.26 (81.86, 82.90)
89.31 (89.18,89.48)

20

80.05 (79.72,80.25)
45.31 (44.90,45.63)
84.04 (83.74,84.34)
92.58 (92.50,92.83)
89.05(88.85,89.34)
82.09 (81.74,82.34)
88.93 (88.82,89.06)

table 18: performance of global k-max pooling using non-static id97-id98

max,3

mr
sst-1
sst-2
subj
trec

79.75 (79.47,80.03)
44.98 (44.06,45.68)
83.69(83.46,84.07)
92.60 (92.28,92.76)
90.29 (89.93,90.61)
81.72 (81.21,82.20)
mpqa 89.15 (88.83,89.47)

cr

max,10

80.20 (80.02,80.35)
46.10(45.37,46.84)
84.63 (84.44,84.88)
92.87 (92.69,93.17)
91.42 (91.16,91.71)
82.71 (82.06,83.30)
89.39 (89.14,89.56)

max,20

80.68 (80.14,81.21)
46.75 (46.35,47.36)
85.18 (84.64,85.59)
93.06 (92.81,93.19)
91.52 (91.23,91.72)
83.44(83.06,83.90)
89.30 (89.16,89.60)

max,30

80.99 (80.65,81.30)
47.02 (46.59,47.59)
85.38 (85.31,85.49)
93.13 (92.79,93.32)
91.47 (91.15,91.64)
83.70 (83.31,84.25)
89.37 (88.99,89.61)

max,all (1-max)
81.28 (81.16,81.54)
47.00 (46.54,47.26)
85.50 (85.31,85.83)
93.20 (93.00,93.36)
91.56 (91.67,91.88)
83.93 (83.48,84.39)
89.39 (89.04,89.73)

mr
sst-1
sst-2
subj
trec

cr

mpqa

mr
sst-1
sst-2
subj
trec

cr

mpqa

mr
sst-1
sst-2
subj
trec

cr

mpqa

table 19: performance of local max pooling using non-static id97-id98

none

81.15 (80.95,81.34)
46.30 (45.81,47.09)
85.42 (85.13,85.23)
93.23 (93.09,93.37)
91.38 (91.18,91.59)
84.36 (84.06,84.70)
89.30 (88.91,89.68)

0.0

81.24 (80.82, 81.63 )
45.84 (45.13 ,46.43 )
85.53 (85.12 ,85.88 )
93.21 (93.09 ,93.31 )
91.39 (91.13 ,91.66 )
84.04 (82.91, 84.84 )
89.30 (89.01, 89.56 )

0.1

81.22 (80.97 ,81.61 )
46.10 (45.68, 46.36 )
85.69 (85.32, 86.06 )
93.27 (93.12 ,93.45 )
91.41 (91.26, 91.63 )
84.22 (83.47, 84.60 )
89.41 (89.19, 89.64 )

0.3

81.30 (81.03 ,81.48 )
46.61 (46.13, 47.04 )
85.58 (85.30, 85.76 )
93.28 (93.06, 93.39 )
91.50 (91.22 ,91.76 )
84.09 (83.72, 84.51 )
89.40 (89.18, 89.77 )

0.5

81.33 (81.02, 81.74 )
47.09 (46.32, 47.66 )
85.62 (85.25, 85.92 )
93.14 (93.01, 93.32 )
91.54 (91.41, 91.68 )
83.92 (83.12, 84.34 )
89.25 (88.96, 89.60 )

0.7

81.16 (80.83, 81.57 )
47.19 (46.88 ,47.46 )
85.41 (85.18, 85.65 )
92.94 (92.77 ,93.08 )
91.45 (91.17, 91.77 )
83.42 (82.87, 83.97 )
89.24 (88.98, 89.50 )

0.9

80.70 (80.36, 80.89)
45.85 (45.50, 46.42 )
84.49 (84.35, 84.82 )
92.03 (91.80 ,92.24 )
88.83 (88.53 ,89.19 )
80.78 (80.35, 81.34 )
89.06 (88.93, 89.26 )

table 20: effect of dropout rate using non-static id97-id98

none

80.19(79.95,80.39)
45.11 (44.57,45.64)
84.58 (84.24,84.87)
92.88 (92.58,93.03)
90.55 (90.26,90.94)
83.53 (82.96,84.15)
89.51 (89.42,89.67)

0.0

80.37 (80.03, 80.66 )
45.40 (45.00 ,45.72 )
84.70 (84.34, 84.96 )
92.82 (92.57 ,93.14 )
90.69 (90.36 ,90.93 )
83.46 (83.03 ,84.04 )
89.36 (89.12 89.63 )

0.1

80.54 (80.13, 80.90 )
45.08 (44.45, 45.70 )
84.63 (84.41 ,84.95 )
92.81 (92.71, 92.90 )
90.84 (90.67, 91.06 )
83.60 (83.22 ,83.87 )
89.52 (89.32 89.68 )

0.3

80.46 (80.20, 80.63 )
45.94 (45.55, 46.45 )
84.80 (84.54, 84.99 )
92.89 (92.64, 93.05 )
90.75 (90.56, 90.95 )
83.63 (83.03, 84.08 )
89.55 (89.28 89.77 )

0.5

80.66 (80.34, 81.10 )
46.41 (45.89, 46.92 )
84.95 (84.52, 85.29 )
92.86 (92.77, 93.04 )
90.71 (90.46, 91.10 )
83.38 (82.70, 83.67 )
89.53 (89.37 89.79 )

0.7

80.70 (80.31, 80.95 )
46.87 (46.60 ,47.24 )
84.82 (84.61 ,85.15 )
92.71 (92.51 ,92.93 )
89.99 (89.67,90.16 )
83.32 (82.72 ,84.07 )
89.52 (89.29 89.70 )

0.9

79.88 (79.57, 80.06 )
45.37 (45.18, 45.65 )
83.66 (83.45, 83.89 )
91.60 (91.50, 91.79 )
85.32 (85.01, 85.57 )
80.67 (80.12, 81.01 )
88.91 (88.76 89.12 )

table 21: effect of dropout rate using static id97-id98

none

81.29 (81.05 81.55 )
46.52 (46.32 46.75 )
85.56 (85.20 86.05 )
93.38 (93.17 93.48 )
91.27 (91.17 91.49 )
84.87 (84.58 85.26 )
89.56 (89.31 89.71 )

0.0

81.48 (81.29 81.83 )
46.25 (45.87 46.88 )
85.82 (85.69 85.97 )
93.29 (93.00 93.54 )
91.53 (91.34 91.78 )
85.01 (84.63 85.49 )
89.52 (89.39 89.73 )

0.1

81.31 (81.09 81.62 )
46.59 (46.21 47.14 )
85.89 (85.63 86.00 )
93.38 (93.20 93.46 )
91.46 (91.40 91.52 )
84.72 (84.01 85.26 )
89.49 (89.27 89.83 )

0.3

81.50 (81.36 81.73 )
46.58 (46.19 47.24 )
85.85 (85.69 86.05 )
93.37 (93.30 93.44 )
91.63 (91.47 91.75 )
84.56 (84.28 84.79 )
89.59 (89.40 89.84 )

0.5

81.23 (80.91 81.41 )
46.80 (46.31 47.43 )
85.69 (85.61 85.86 )
93.29 (93.23 93.37 )
91.54 (91.42 91.74 )
84.42 (84.08 84.81 )
89.43 (89.16 89.54 )

0.7

81.21 (80.94 81.53 )
47.41 (47.07 48.04 )
85.52 (85.31 85.66 )
93.13 (93.04 93.22 )
91.27 (91.14 91.34 )
84.40 (84.08 84.65 )
89.62 (89.52 89.78 )

0.9

80.72 (80.47 80.95)
47.05 (46.50 47.44)
84.78 (84.58 84.95 )
92.32 (92.22 92.45 )
89.95 (89.80 90.26 )
82.69 (82.25 83.06 )
89.04 (88.92 89.15 )

table 22: effect of dropout rate when feature map is 500 using non-static id97-id98

mr
sst-1
sst-2
subj
trec

cr

mpqa

0.0

81.16 (80.80 81.57 )
45.97 (45.65 46.43 )
85.50 (85.46 85.54 )
93.21 (93.13 93.31 )
91.41 (91.22 91.66 )
84.21 (83.81 84.62 )
89.40 (89.15 89.56 )

0.1

81.19 (80.98 81.46 )
46.19 (45.71 46.64 )
85.62 (85.56 85.72 )
93.19 (93.07 93.34 )
91.62 (91.51 91.70 )
83.88 (83.54 84.11 )
89.45 (89.26 89.60 )

0.3

81.13 (80.58 81.58 )
46.28 (45.83 46.93 )
85.47 (85.19 85.58 )
93.20 (93.03 93.39 )
91.56 (91.46 91.68 )
83.97 (83.73 84.16 )
89.14 (89.08 89.20 )

0.5

81.08 (81.01 81.13 )
46.34 (46.04 46.98 )
85.35 (85.06 85.52 )
92.67 (92.40 92.98 )
91.41 (91.01 91.64 )
83.97 (83.75 84.18 )
88.86 (88.70 89.05 )

0.7

81.06 (80.49 81.48 )
44.22 (43.87 44.78 )
85.02 (84.64 85.31 )
91.27 (91.16 91.43 )
91.03 (90.82 91.23 )
83.47 (82.86 83.72 )
87.88 (87.71 88.18 )

0.9

80.05 (79.92 80.37)
43.15 (42.94 43.32)
84.14 (83.86 84.51)
88.46 (88.19 88.62)
86.63 (86.15 86.90)
79.79 (78.89 80.38 )
83.96 (83.76 84.12)

table 23: effect of dropout rate on convolution layer using non-static id97-id98

1
2
3
4
5
10
15
20
25
30
none

mr

81.02 (80.75 ,81.29)
81.33 (81.04 ,81.71)
81.29 (80.96, 81.59)
81.38 (81.21, 81.68)
81.22 (81.03, 81.49)
81.19 (80.94 ,81.42)
81.12 (80.87, 81.29)
81.13 (80.64, 81.33)
81.22 (80.82, 81.66)
81.19 (80.79 ,81.43)
80.19(79.95,80.39)

sst-1

46.93 (46.57, 47.33)
47.11 (46.77, 47.43)
47.29 (46.90 ,47.82)
46.91 (46.22 ,47.38)
46.93 (46.44 ,47.38)
46.74 (46.19, 47.12)
46.91 (46.58 ,47.48)
46.96 (46.62 ,47.31)
47.02 (46.73, 47.67)
46.98 (46.63 ,47.59)
46.30 (45.81,47.09)

sst-2

85.02 (84.76,85.22)
85.40 (84.98,85.67)
85.47 (85.17,85.77)
85.33 (85.25,85.72)
85.46 (84.98,85.73)
85.41 (85.04,85.83)
85.47 (85.23,85.74)
85.46 (85.17,85.64)
85.42 (85.16,85.78)
85.48 (85.27,85.79)
85.42 (85.13,85.23)

subj

92.49 (92.35 92.63)
92.93 (92.82 93.15)
93.21 (93.03 93.37)
93.08 (92.96 93.22)
93.14 (92.90 93.33)
93.11 (92.99 93.32)
93.15 (92.99 93.29)
93.10 (92.98 93.19)
93.09 (92.95 93.25)
93.06 (92.84 93.43)
93.23 (93.09,93.37)

trec

90.90 (90.62 91.20)
91.44 (91.20 91.60)
91.44 (91.18 91.68)
91.56 (91.26 91.90)
91.58 (91.39 91.87)
91.58 (91.29 91.81)
91.58 (91.37 91.84)
91.54 (91.28 91.73)
91.45 (91.22 91.62)
91.55 (91.26 91.84)
91.38 (91.18,91.59)

cr

83.06 (82.50 83.42)
84.00 (83.57 84.34)
83.89 (83.24 84.47)
84.00 (83.21 84.60)
83.99 (83.73 84.31)
83.94 (83.04 84.61)
83.92 (83.40 84.54)
84.09 (83.59 84.53)
83.91 (83.24 84.40)
83.94 (83.02 84.35)
84.36 (84.06,84.70)

mpqa

89.17 (88.97 89.36)
89.31 (89.17 89.54)
89.18 (88.84 89.40)
89.27 (89.11 89.41)
89.33 (89.02 89.55)
89.22 (89.01 89.40)
89.30 (88.93 89.66)
89.28 (88.92 89.43)
89.33 (89.05 89.61)
89.26 (89.10 89.54)
89.30 (88.91,89.68)

table 24: effect of constraint on l2 norm using non-static id97-id98

1
2
3
4
5
10
15
20
25
30
none

mr

81.02 (80.75 ,81.29)
81.33 (81.04 ,81.71)
81.29 (80.96, 81.59)
81.38 (81.21, 81.68)
81.22 (81.03, 81.49)
81.19 (80.94 ,81.42)
81.12 (80.87, 81.29)
81.13 (80.64, 81.33)
81.22 (80.82, 81.66)
81.19 (80.79 ,81.43)
80.19(79.95,80.39)

sst-1

46.93 (46.57, 47.33)
47.11 (46.77, 47.43)
47.29 (46.90 ,47.82)
46.91 (46.22 ,47.38)
46.93 (46.44 ,47.38)
46.74 (46.19, 47.12)
46.91 (46.58 ,47.48)
46.96 (46.62 ,47.31)
47.02 (46.73, 47.67)
46.98 (46.63 ,47.59)
45.11 (44.57,45.64)

sst-2

85.02 (84.76,85.22)
85.40 (84.98,85.67)
85.47 (85.17,85.77)
85.33 (85.25,85.72)
85.46 (84.98,85.73)
85.41 (85.04,85.83)
85.47 (85.23,85.74)
85.46 (85.17,85.64)
85.42 (85.16,85.78)
85.48 (85.27,85.79)
84.58 (84.24,84.87)

subj

92.49 (92.35 92.63)
92.93 (92.82 93.15)
93.21 (93.03 93.37)
93.08 (92.96 93.22)
93.14 (92.90 93.33)
93.11 (92.99 93.32)
93.15 (92.99 93.29)
93.10 (92.98 93.19)
93.09 (92.95 93.25)
93.06 (92.84 93.43)
92.88 (92.58,93.03)

trec

90.90 (90.62 91.20)
91.44 (91.20 91.60)
91.44 (91.18 91.68)
91.56 (91.26 91.90)
91.58 (91.39 91.87)
91.58 (91.29 91.81)
91.58 (91.37 91.84)
91.54 (91.28 91.73)
91.45 (91.22 91.62)
91.55 (91.26 91.84)
90.55 (90.26,90.94)

cr

83.06 (82.50 83.42)
84.00 (83.57 84.34)
83.89 (83.24 84.47)
84.00 (83.21 84.60)
83.99 (83.73 84.31)
83.94 (83.04 84.61)
83.92 (83.40 84.54)
84.09 (83.59 84.53)
83.91 (83.24 84.40)
83.94 (83.02 84.35)
83.53 (82.96,84.15)

mpqa

89.17 (88.97 89.36)
89.31 (89.17 89.54)
89.18 (88.84 89.40)
89.27 (89.11 89.41)
89.33 (89.02 89.55)
89.22 (89.01 89.40)
89.30 (88.93 89.66)
89.28 (88.92 89.43)
89.33 (89.05 89.61)
89.26 (89.10 89.54)
89.51 (89.42,89.67)

table 25: effect of constraint on l2-norms using static id97-id98

