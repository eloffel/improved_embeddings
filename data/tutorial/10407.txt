2
1
0
2

 
l
u
j
 

3

 
 
]
e
n
.
s
c
[
 
 

1
v
0
8
5
0

.

7
0
2
1
:
v
i
x
r
a

improving neural networks by preventing

co-adaptation of feature detectors

g. e. hinton   , n. srivastava, a. krizhevsky, i. sutskever and r. r. salakhutdinov

department of computer science, university of toronto,
6 king   s college rd, toronto, ontario m5s 3g4, canada

   to whom correspondence should be addressed; e-mail: hinton@cs.toronto.edu

when a large feedforward neural network is trained on a small training set,
it typically performs poorly on held-out test data. this    over   tting    is greatly
reduced by randomly omitting half of the feature detectors on each training
case. this prevents complex co-adaptations in which a feature detector is only
helpful in the context of several other speci   c feature detectors. instead, each
neuron learns to detect a feature that is generally helpful for producing the
correct answer given the combinatorially large variety of internal contexts in
which it must operate. random    dropout    gives big improvements on many
benchmark tasks and sets new records for speech and object recognition.

a feedforward, arti   cial neural network uses layers of non-linear    hidden    units between
its inputs and its outputs. by adapting the weights on the incoming connections of these hidden
units it learns feature detectors that enable it to predict the correct output when given an input
vector (1). if the relationship between the input and the correct output is complicated and the
network has enough hidden units to model it accurately, there will typically be many different
settings of the weights that can model the training set almost perfectly, especially if there is
only a limited amount of labeled training data. each of these weight vectors will make different
predictions on held-out test data and almost all of them will do worse on the test data than on
the training data because the feature detectors have been tuned to work well together on the
training data but not on the test data.

over   tting can be reduced by using    dropout    to prevent complex co-adaptations on the
training data. on each presentation of each training case, each hidden unit is randomly omitted
from the network with a id203 of 0.5, so a hidden unit cannot rely on other hidden units
being present. another way to view the dropout procedure is as a very ef   cient way of perform-
ing model averaging with neural networks. a good way to reduce the error on the test set is to
average the predictions produced by a very large number of different networks. the standard

1

way to do this is to train many separate networks and then to apply each of these networks to
the test data, but this is computationally expensive during both training and testing. random
dropout makes it possible to train a huge number of different networks in a reasonable time.
there is almost certainly a different network for each presentation of each training case but all
of these networks share the same weights for the hidden units that are present.

we use the standard, stochastic id119 procedure for training the dropout neural
networks on mini-batches of training cases, but we modify the penalty term that is normally
used to prevent the weights from growing too large. instead of penalizing the squared length
(l2 norm) of the whole weight vector, we set an upper bound on the l2 norm of the incoming
weight vector for each individual hidden unit. if a weight-update violates this constraint, we
renormalize the weights of the hidden unit by division. using a constraint rather than a penalty
prevents weights from growing very large no matter how large the proposed weight-update is.
this makes it possible to start with a very large learning rate which decays during learning,
thus allowing a far more thorough search of the weight-space than methods that start with small
weights and use a small learning rate.

at test time, we use the    mean network    that contains all of the hidden units but with their
outgoing weights halved to compensate for the fact that twice as many of them are active.
in practice, this gives very similar performance to averaging over a large number of dropout
networks. in networks with a single hidden layer of n units and a    softmax    output layer for
computing the probabilities of the class labels, using the mean network is exactly equivalent
to taking the geometric mean of the id203 distributions over labels predicted by all 2n
possible networks. assuming the dropout networks do not all make identical predictions, the
prediction of the mean network is guaranteed to assign a higher log id203 to the correct
answer than the mean of the log probabilities assigned by the individual dropout networks (2).
similarly, for regression with linear output units, the squared error of the mean network is
always better than the average of the squared errors of the dropout networks.

we initially explored the effectiveness of dropout using mnist, a widely used benchmark
for machine learning algorithms. it contains 60,000 28x28 training images of individual hand
written digits and 10,000 test images. performance on the test set can be greatly improved by
enhancing the training data with transformed images (3) or by wiring knowledge about spatial
transformations into a convolutional neural network (4) or by using generative pre-training to
extract useful features from the training images without using the labels (5). without using any
of these tricks, the best published result for a standard feedforward neural network is 160 errors
on the test set. this can be reduced to about 130 errors by using 50% dropout with separate l2
constraints on the incoming weights of each hidden unit and further reduced to about 110 errors
by also dropping out a random 20% of the pixels (see    gure 1).

dropout can also be combined with generative pre-training, but in this case we use a small
learning rate and no weight constraints to avoid losing the feature detectors discovered by the
pre-training. the publically available, pre-trained deep belief net described in (5) got 118 errors
when it was    ne-tuned using standard back-propagation and 92 errors when    ne-tuned using
50% dropout of the hidden units. when the publically available code at url was used to pre-

2

fig. 1: the error rate on the mnist test set for a variety of neural network architectures trained
with id26 using 50% dropout for all hidden layers. the lower set of lines also
use 20% dropout for the input layer. the best previously published result for this task using
id26 without pre-training or weight-sharing or enhancements of the training set is
shown as a horizontal line.

train a deep id82    ve times, the unrolled network got 103, 97, 94, 93 and 88
errors when    ne-tuned using standard id26 and 83, 79, 78, 78 and 77 errors when
using 50% dropout of the hidden units. the mean of 79 errors is a record for methods that do
not use prior knowledge or enhanced training sets (for details see appendix a).

we then applied dropout to timit, a widely used benchmark for recognition of clean speech
with a small vocabulary. id103 systems use id48 (id48s) to
deal with temporal variability and they need an acoustic model that determines how well a frame
of coef   cients extracted from the acoustic input    ts each possible state of each hidden markov
model. recently, deep, pre-trained, feedforward neural networks that map a short sequence of
frames into a id203 distribution over id48 states have been shown to outperform tradional
gaussian mixture models on both timit (6) and a variety of more realistic large vocabulary
tasks (7, 8).

figure 2 shows the frame classi   cation error rate on the core test set of the timit bench-
mark when the central frame of a window is classi   ed as belonging to the id48 state that is
given the highest id203 by the neural net. the input to the net is 21 adjacent frames with an
advance of 10ms per frame. the neural net has 4 fully-connected hidden layers of 4000 units per

3

fig. 2: the frame classi   cation error rate on the core test set of the timit benchmark. com-
parison of standard and dropout    netuning for different network architectures. dropout of 50%
of the hidden units and 20% of the input units improves classi   cation.

layer and 185    softmax    output units that are subsequently merged into the 39 distinct classes
used for the benchmark. dropout of 50% of the hidden units signi   cantly improves classi   ca-
tion for a variety of different network architectures (see    gure 2). to get the frame recognition
rate, the class probabilities that the neural network outputs for each frame are given to a decoder
which knows about transition probabilities between id48 states and runs the viterbi algorithm
to infer the single best sequence of id48 states. without dropout, the recognition rate is 22.7%
and with dropout this improves to 19.7%, which is a record for methods that do not use any
information about speaker identity.

cifar-10 is a benchmark task for object recognition. it uses 32x32 downsampled color
images of 10 different object classes that were found by searching the web for the names of the
class (e.g. dog) or its subclasses (e.g. golden retriever). these images were labeled by hand
to produce 50,000 training images and 10,000 test images in which there is a single dominant
object that could plausibly be given the class name (9) (see    gure 3). the best published error
rate on the test set, without using transformed data, is 18.5% (10). we achieved an error rate of
16.6% by using a neural network with three convolutional hidden layers interleaved with three
   max-pooling    layers that report the maximum activity in local pools of convolutional units.
these six layers were followed by one locally-connected layer (for details see appendix d) .
using dropout in the last hidden layer gives an error rate of 15.6%.

id163 is an extremely challenging object recognition dataset consisting of thousands of
high-resolution images of thousands of classes of object (11). in 2010, a subset of 1000 classes
with roughly 1000 examples per class was the basis of an object recognition competition in

4

fig. 3: ten examples of the class    bird    from the cifar-10 test set illustrating the variety
of types of bird, viewpoint, lighting and background. the neural net gets all but the last two
examples correct.

which the winning entry, which was actually an average of six separate models, achieved an
error rate of 47.2% on the test set. the current state-of-the-art result on this dataset is 45.7%
(12). we achieved comparable performance of 48.6% error using a single neural network with
   ve convolutional hidden layers interleaved with    max-pooling    layer followed by two globally
connected layers and a    nal 1000-way softmax layer. all layers had l2 weight constraints on
the incoming weights of each hidden unit. using 50% dropout in the sixth hidden layer reduces
this to a record 42.4% (for details see appendix e).

for the id103 dataset and both of the object recognition datasets it is necessary
to make a large number of decisions in designing the architecture of the net. we made these
decisions by holding out a separate validation set that was used to evaluate the performance of
a large number of different architectures and we then used the architecture that performed best
with dropout on the validation set to assess the performance of dropout on the real test set.

the reuters dataset contains documents that have been labeled with a hierarchy of classes.
we created training and test sets each containing 201,369 documents from 50 mutually exclu-
sive classes. each document was represented by a vector of counts for 2000 common non-stop
words, with each count c being transformed to log(1 + c). a feedforward neural network with
2 fully connected layers of 2000 hidden units trained with id26 gets 31.05% error
on the test set. this is reduced to 29.62% by using 50% dropout (appendix c).

we have tried various dropout probabilities and almost all of them improve the generaliza-
tion performance of the network. for fully connected layers, dropout in all hidden layers works
better than dropout in only one hidden layer and more extreme probabilities tend to be worse,
which is why we have used 0.5 throughout this paper. for the inputs, dropout can also help,

fig. 4: some id163 test cases with the probabilities of the best 5 labels underneath. many
of the top 5 labels are quite plausible.

5

though it it often better to retain more than 50% of the inputs. it is also possible to adapt the
individual dropout id203 of each hidden or input unit by comparing the average perfor-
mance on a validation set with the average performance when the unit is present. this makes
the method work slightly better. for datasets in which the required input-output mapping has a
number of fairly different regimes, performance can probably be further improved by making
the dropout probabilities be a learned function of the input, thus creating a statistically ef   cient
   mixture of experts    (13) in which there are combinatorially many experts, but each parameter
gets adapted on a large fraction of the training data.

dropout is considerably simpler to implement than bayesian model averaging which weights
each model by its posterior id203 given the training data. for complicated model classes,
like feedforward neural networks, bayesian methods typically use a id115
method to sample models from the posterior distribution (14). by contrast, dropout with a
id203 of 0.5 assumes that all the models will eventually be given equal importance in the
combination but the learning of the shared weights takes this into account. at test time, the fact
that the dropout decisions are independent for each unit makes it very easy to approximate the
combined opinions of exponentially many dropout nets by using a single pass through the mean
net. this is far more ef   cient than averaging the predictions of many separate models.

a popular alternative to bayesian model averaging is    id112    in which different models
are trained on different random selections of cases from the training set and all models are given
equal weight in the combination (15). id112 is most often used with models such as decision
trees because these are very quick to    t to data and very quick at test time (16). dropout allows
a similar approach to be applied to feedforward neural networks which are much more powerful
models. dropout can be seen as an extreme form of id112 in which each model is trained on
a single case and each parameter of the model is very strongly regularized by sharing it with
the corresponding parameter in all the other models. this is a much better regularizer than the
standard method of shrinking parameters towards zero.

a familiar and extreme case of dropout is    naive bayes    in which each input feature is
trained separately to predict the class label and then the predictive distributions of all the features
are multiplied together at test time. when there is very little training data, this often works much
better than logistic classi   cation which trains each input feature to work well in the context of
all the other features.

finally, there is an intriguing similarity between dropout and a recent theory of the role of
sex in evolution (17). one possible interpretation of the theory of mixability articulated in (17)
is that sex breaks up sets of co-adapted genes and this means that achieving a function by using
a large set of co-adapted genes is not nearly as robust as achieving the same function, perhaps
less than optimally, in multiple alternative ways, each of which only uses a small number of
co-adapted genes. this allows evolution to avoid dead-ends in which improvements in    tness
require co- ordinated changes to a large number of co-adapted genes. it also reduces the proba-
bility that small changes in the environment will cause large decreases in    tness a phenomenon
which is known as    over   tting    in the    eld of machine learning.

6

references and notes
1. d. e. rumelhart, g. e. hinton, r. j. williams, nature 323, 533 (1986).
2. g. e. hinton, neural computation 14, 1771 (2002).
3. l. m. g. d. c. ciresan, u. meier, j. schmidhuber, neural computation 22, 3207 (2010).
4. y. b. y. lecun, l. bottou, p. haffner, proceedings of the ieee 86, 2278 (1998).
5. g. e. hinton, r. salakhutdinov, science 313, 504 (2006).

6. a. mohamed, g. dahl, g. hinton, ieee transactions on audio, speech, and language

processing, 20, 14 (2012).

7. g. dahl, d. yu, l. deng, a. acero, ieee transactions on audio, speech, and language

processing, 20, 30 (2012).

8. n. jaitly, p. nguyen, a. senior, v. vanhoucke, an application of pretrained deep neu-
ral networks to large vocabulary conversational id103, tech. rep. 001,
department of computer science, university of toronto (2012).

9. a. krizhevsky, learning multiple layers of features from tiny images, tech. rep. 001, de-

partment of computer science, university of toronto (2009).

10. a. coates, a. y. ng, icml (2011), pp. 921   928.

11. j. deng, et al., cvpr09 (2009).

12. j. sanchez, f. perronnin, cvpr11 (2011).
13. s. j. n. r. a. jacobs, m. i. jordan, g. e. hinton, neural computation 3, 79 (1991).

14. r. m. neal, bayesian learning for neural networks, lecture notes in statistics no. 118

(springer-verlag, new york, 1996).

15. l. breiman, machine learning 24, 123 (1996).
16. l. breiman, machine learning 45, 5 (2001).
17. j. d. a. livnat, c. papadimitriou, m. w. feldman, pnas 105, 19803 (2008).

18. r. r. salakhutdinov, g. e. hinton, arti   cial intelligence and statistics (2009).
19. d. d. lewis, t. g. r. y. yang, journal of machine learning 5, 361 (2004).

20. we thank n. jaitly for help with timit, h. larochelle, r. neal, k. swersky and c.k.i.
williams for helpful discussions, and nserc, google and microsoft research for funding.
geh and rrs are members of the canadian institute for advanced research.

7

a experiments on mnist
a.1 details for dropout training
the mnist dataset consists of 28    28 digit images - 60,000 for training and 10,000 for testing.
the objective is to classify the digit images into their correct digit class. we experimented with
neural nets of different architectures (different number of hidden units and layers) to evaluate
the sensitivity of the dropout method to these choices. we show results for 4 nets (784-800-
800-10, 784-1200-1200-10, 784-2000-2000-10, 784-1200-1200-1200-10). for each of these
architectures we use the same dropout rates - 50% dropout for all hidden units and 20% dropout
for visible units. we use stochastic id119 with 100-sized minibatches and a cross-
id178 objective function. an exponentially decaying learning rate is used that starts at the
value of 10.0 (applied to the average gradient in each minibatch). the learning rate is multiplied
by 0.998 after each epoch of training. the incoming weight vector corresponding to each hidden
unit is constrained to have a maximum squared length of l. if, as a result of an update, the
squared length exceeds l, the vector is scaled down so as to make it have a squared length
of l. using cross validation we found that l = 15 gave best results. weights are initialzed
to small random values drawn from a zero-mean normal distribution with standard deviation
0.01. momentum is used to speed up learning. the momentum starts off at a value of 0.5 and
is increased linearly to 0.99 over the    rst 500 epochs, after which it stays at 0.99. also, the
learning rate is multiplied by a factor of (1-momentum). no weight decay is used. weights
were updated at the end of each minibatch. training was done for 3000 epochs. the weight
update takes the following form:

   wt = pt   wt   1     (1     pt) t(cid:104)   wl(cid:105)
wt = wt   1 +    wt,

where,

 t =  0f t

pt =

(cid:40) t
t pi + (1     t
pf

t )pf

t < t
t     t

with  0 = 10.0, f = 0.998, pi = 0.5, pf = 0.99, t = 500. while using a constant learning
rate also gives improvements over standard id26, starting with a high learning rate
and decaying it provided a signi   cant boost in performance. constraining input vectors to
have a    xed length prevents weights from increasing arbitrarily in magnitude irrespective of the
learning rate. this gives the network a lot of opportunity to search for a good con   guration in
the weight space. as the learning rate decays, the algorithm is able to take smaller steps and
   nds the right step size at which it can make learning progress. using a high    nal momentum
distributes gradient information over a large number of updates making learning stable in this
scenario where each gradient computation is for a different stochastic network.

8

a.2 details for dropout    netuning
apart from training a neural network starting from random weights, dropout can also be used
to    netune pretrained models. we found that    netuning a model using dropout with a small
learning rate can give much better performace than standard id26    netuning.

deep belief nets - we took a neural network pretrained using a deep belief network (5).
it had a 784-500-500-2000 architecture and was trained using greedy layer-wise contrastive
divergence learning 1. instead of    ne-tuning it with the usual id26 algorithm, we
used the dropout version of it. dropout rate was same as before : 50% for hidden units and 20%
for visible units. a constant small learning rate of 1.0 was used. no constraint was imposed on
the length of incoming weight vectors. no weight decay was used. all other hyper-parameters
were set to be the same as before. the model was trained for 1000 epochs with stochstic gradient
descent using minibatches of size 100. while standard back propagation gave about 118 errors,
dropout decreased the errors to about 92.

deep id82s - we also took a pretrained deep id82 (18) 2
(784-500-1000-10) and    netuned it using dropout-id26. the model uses a 1784 -
500 - 1000 - 10 architecture (the extra 1000 input units come from the mean-   eld activations
of the second layer of hidden units in the dbm, see (18) for details). all    netuning hyper-
parameters were set to be the same as the ones used for a deep belief network. we were able
to get a mean of about 79 errors with dropout whereas usual    netuning gives about 94 errors.

a.3 effect on features
one reason why dropout gives major improvements over id26 is that it encourages
each individual hidden unit to learn a useful feature without relying on speci   c other hidden
units to correct its mistakes. in order to verify this and better understand the effect of dropout on
id171, we look at the    rst level of features learned by a 784-500-500 neural network
without any generative pre-training. the features are shown in figure 5. each panel shows 100
random features learned by each network. the features that dropout learns are simpler and look
like strokes, whereas the ones learned by standard id26 are dif   cult to interpret.
this con   rms that dropout indeed forces the discriminative model to learn good features which
are less co-adapted and leads to better generalization.

b experiments on timit

the timit acoustic-phonetic continuous speech corpus is a standard dataset used for eval-
uation of automatic id103 systems. it consists of recordings of 630 speakers of 8
dialects of american english each reading 10 phonetically-rich sentences. it also comes with

1for code see http://www.cs.toronto.edu/  hinton/matlabforsciencepaper.html
2 for code see http://www.utstat.toronto.edu/  rsalakhu/dbm.html

9

(a)

(b)

fig. 5: visualization of features learned by    rst layer hidden units for (a) backprop and (b)
dropout on the mnist dataset.

the word and phone-level transcriptions of the speech. the objective is to convert a given speech
signal into a transcription sequence of phones. this data needs to be pre-processed to extract
input features and output targets. we used kaldi, an open source code library for speech 3, to
pre-process the dataset so that our results can be reproduced exactly. the inputs to our networks
are log    lter bank responses. they are extracted for 25 ms speech windows with strides of 10
ms.

each dimension of the input representation was normalized to have mean 0 and variance 1.
minibatches of size 100 were used for both pretraining and dropout    netuning. we tried several
network architectures by varying the number of input frames (15 and 31), number of layers in
the neural network (3, 4 and 5) and the number of hidden units in each layer (2000 and 4000).
figure 6 shows the validation error curves for a number of these combinations. using dropout
consistently leads to lower error rates.

b.1 pretraining
for all our experiments on timit, we pretrain the neural network with a deep belief net-
work (5). since the inputs are real-valued, the    rst layer was pre-trained as a gaussian rbm.

3http://kaldi.sourceforge.net

10

(a)

(b)

fig. 6: frame classi   cation error and cross-id178 on the (a) training and (b) validation set
as learning progresses. the training error is computed using the stochastic nets.

11

visible biases were initialized to zero and weights to random numbers sampled from a zero-
mean normal distribution with standard deviation 0.01. the variance of each visible unit was
set to 1.0 and not learned. learning was done by minimizing contrastive divergence. momen-
tum was used to speed up learning. momentum started at 0.5 and was increased linearly to 0.9
over 20 epochs. a learning rate of 0.001 on the average gradient was used (which was then
multiplied by 1-momentum). an l2 weight decay of 0.001 was used. the model was trained
for 100 epochs.
all subsequent layers were trained as binary rbms. a learning rate of 0.01 was used. the
visible bias of each unit was initialized to log(p/(1     p)) where p was the mean activation of
that unit in the dataset. all other hyper-parameters were set to be the same as those we used for
the gaussian rbm. each layer was trained for 50 epochs.

b.2 dropout finetuning
the pretrained rbms were used to initialize the weights in a neural network. the network
was then    netuned with dropout-id26. momentum was increased from 0.5 to 0.9
linearly over 10 epochs. a small constant learning rate of 1.0 was used (applied to the average
gradient on a minibatch). all other hyperparameters are the same as for mnist dropout    ne-
tuning. the model needs to be run for about 200 epochs to converge. the same network was
also    netuned with standard id26 using a smaller learning rate of 0.1, keeping all
other hyperparameters

figure 6 shows the frame classi   cation error and cross-id178 objective value on the train-
ing and validation sets. we compare the performance of dropout and standard backpropaga-
tion on several network architectures and input representations. dropout consistently achieves
lower error and cross-id178. it signi   cantly controls over   tting, making the method robust
to choices of network architecture. it allows much larger nets to be trained and removes the
need for early stopping. we also observed that the    nal error obtained by the model is not very
sensitive to the choice of learning rate and momentum.

c experiments on reuters

reuters corpus volume i (rcv1-v2) (19) is an archive of 804,414 newswire stories that have
been manually categorized into 103 topics4. the corpus covers four major groups: corpo-
rate/industrial, economics, government/social, and markets. sample topics include energy mar-
kets, accounts/earnings, government borrowings, disasters and accidents, interbank markets,
legal/judicial, production/services, etc. the topic classes form a tree which is typically of
depth three.

we took the dataset and split it into 63 classes based on the the 63 categories at the second-
level of the category tree. we removed 11 categories that did not have any data and one category

4the corpus is available at http://www.ai.mit.edu/projects/jmlr/papers/volume5/lewis04a/lyrl2004 rcv1v2 readme.htm

12

that had only 4 training examples. we also removed one category that covered a huge chunk
(25%) of the examples. this left us with 50 classes and 402,738 documents. we divided the
documents into equal-sized training and test sets randomly. each document was represented
using the 2000 most frequent non-stopwords in the dataset.

(a)

(b)

fig. 7: classi   cation error rate on the (a) training and (b) validation sets of the reuters dataset
as learning progresses. the training error is computed using the stochastic nets.

we trained a neural network using dropout-id26 and compared it with standard
id26. we used a 2000-2000-1000-50 architecture. the training hyperparameters are
same as that in mnist dropout training (appendix a.1). training was done for 500 epochs.

figure 7 shows the training and test set errors as learning progresses. we show two nets
- one with a 2000-2000-1000-50 and another with a 2000-1000-1000-50 architecture trained
with and without dropout. as in all previous datasets discussed so far, we obtain signi   cant
improvements here too. the learning not only results in better generalization, but also proceeds
smoothly, without the need for early stopping.

d tiny images and cifar-10
the tiny images dataset contains 80 million 32    32 color images collected from the web. the
images were found by searching various image search engines for english nouns, so each image
comes with a very unreliable label, which is the noun that was used to    nd it. the cifar-10
dataset is a subset of the tiny images dataset which contains 60000 images divided among ten
classes5. each class contains 5000 training images and 1000 testing images. the classes are

5the cifar dataset is available at http://www.cs.toronto.edu/   kriz/cifar.html.

13

airplane, automobile, bird, cat, deer, dog, frog, horse, ship, and truck. the cifar-10 dataset
was obtained by    ltering the tiny images dataset to remove images with incorrect labels. the
cifar-10 images are highly varied, and there is no canonical viewpoint or scale at which
the objects appear. the only criteria for including an image were that the image contain one
dominant instance of a cifar-10 class, and that the object in the image be easily identi   able
as belonging to the class indicated by the image label.

e id163

id163 is a dataset of millions of labeled images in thousands of categories. the images
were collected from the web and labelled by human labellers using amazon   s mechanical turk
crowd-sourcing tool. in 2010, a subset of roughly 1000 images in each of 1000 classes was the
basis of an object recognition competition, a part of the pascal visual object challenge. this
is the version of id163 on which we performed our experiments. in all, there are roughly
1.3 million training images, 50000 validation images, and 150000 testing images. this dataset
is similar in spirit to the cifar-10, but on a much bigger scale. the images are full-resolution,
and there are 1000 categories instead of ten. another difference is that the id163 images
often contain multiple instances of id163 objects, simply due to the sheer number of object
classes. for this reason, even a human would have dif   culty approaching perfect accuracy on
this dataset. for our experiments we resized all images to 256    256 pixels.

f convolutional neural networks

our models for cifar-10 and id163 are deep, feed-forward convolutional neural networks
(id98s). feed-forward neural networks are models which consist of several layers of    neurons   ,
where each neuron in a given layer applies a linear    lter to the outputs of the neurons in the
previous layer. typically, a scalar bias is added to the    lter output and a nonlinear activation
function is applied to the result before the neuron   s output is passed to the next layer. the linear
   lters and biases are referred to as weights, and these are the parameters of the network that are
learned from the training data.

id98s differ from ordinary neural networks in several ways. first, neurons in a id98 are
organized topographically into a bank that re   ects the organization of dimensions in the input
data. so for images, the neurons are laid out on a 2d grid. second, neurons in a id98 apply    l-
ters which are local in extent and which are centered at the neuron   s location in the topographic
organization. this is reasonable for datasets where we expect the dependence of input dimen-
sions to be a decreasing function of distance, which is the case for pixels in natural images.
in particular, we expect that useful clues to the identity of the object in an input image can be
found by examining small local neighborhoods of the image. third, all neurons in a bank apply
the same    lter, but as just mentioned, they apply it at different locations in the input image. this
is reasonable for datasets with roughly stationary statistics, such as natural images. we expect

14

that the same kinds of structures can appear at all positions in an input image, so it is reasonable
to treat all positions equally by    ltering them in the same way. in this way, a bank of neurons
in a id98 applies a convolution operation to its input. a single layer in a id98 typically has
multiple banks of neurons, each performing a convolution with a different    lter. these banks of
neurons become distinct input channels into the next layer. the distance, in pixels, between the
boundaries of the receptive    elds of neighboring neurons in a convolutional bank determines
the stride with which the convolution operation is applied. larger strides imply fewer neurons
per bank. our models use a stride of one pixel unless otherwise noted.

one important consequence of this convolutional shared-   lter architecture is a drastic re-
duction in the number of parameters relative to a neural net in which all neurons apply different
   lters. this reduces the net   s representational capacity, but it also reduces its capacity to over   t,
so dropout is far less advantageous in convolutional layers.

f.1 pooling
id98s typically also feature    pooling    layers which summarize the activities of local patches
of neurons in convolutional layers. essentially, a pooling layer takes as input the output of a
convolutional layer and subsamples it. a pooling layer consists of pooling units which are laid
out topographically and connected to a local neighborhood of convolutional unit outputs from
the same bank. each pooling unit then computes some function of the bank   s output in that
neighborhood. typical functions are maximum and average. pooling layers with such units
are called max-pooling and average-pooling layers, respectively. the pooling units are usually
spaced at least several pixels apart, so that there are fewer total pooling units than there are
convolutional unit outputs in the previous layer. making this spacing smaller than the size of
the neighborhood that the pooling units summarize produces overlapping pooling. this variant
makes the pooling layer produce a coarse coding of the convolutional unit outputs, which we
have found to aid generalization in our experiments. we refer to this spacing as the stride
between pooling units, analogously to the stride between convolutional units. pooling layers
introduce a level of local translation invariance to the network, which improves generalization.
they are the analogues of complex cells in the mammalian visual cortex, which pool activities
of multiple simple cells. these cells are known to exhibit similar phase-invariance properties.

f.2 local response id172
our networks also include response id172 layers. this type of layer encourages com-
petition for large activations among neurons belonging to different banks. in particular, the
activity ai
x,y of a neuron in bank i at position (x, y) in the topographic organization is divided
by

        

(aj

x,y)2

      1 +   

i+n/2(cid:88)

j=i   n/2

15

where the sum runs over n    adjacent    banks of neurons at the same position in the topographic
organization. the ordering of the banks is of course arbitrary and determined before training
begins. response id172 layers implement a form of lateral inhibition found in real
neurons. the constants n,   , and    are hyper-parameters whose values are determined using a
validation set.

x,y) where zi

x,y = max(0, zi

f.3 neuron nonlinearities
all of the neurons in our networks utilize the max-with-zero nonlinearity. that is, their output
x,y is the total input to the neuron (equivalently,
is computed as ai
the output of the neuron   s linear    lter added to the bias). this nonlinearity has several advan-
tages over traditional saturating neuron models, including a signi   cant reduction in the training
time required to reach a given error rate. this nonlinearity also reduces the need for contrast-
id172 and similar data pre-processing schemes, because neurons with this nonlinearity
do not saturate     their activities simply scale up when presented with unusually large input
values. consequently, the only data pre-processing step which we take is to subtract the mean
activity from each pixel, so that the data is centered. so we train our networks on the (centered)
raw rgb values of the pixels.

f.4 objective function
our networks maximize the multinomial id28 objective, which is equivalent to
minimizing the average across training cases of the cross-id178 between the true label distri-
bution and the model   s predicted label distribution.

f.5 weight initialization
we initialize the weights in our model from a zero-mean normal distribution with a variance set
high enough to produce positive inputs into the neurons in each layer. this is a slightly tricky
point when using the max-with-zero nonlinearity. if the input to a neuron is always negative,
no learning will take place because its output will be uniformly zero, as will the derivative
of its output with respect to its input. therefore it   s important to initialize the weights from
a distribution with a suf   ciently large variance such that all neurons are likely to get positive
inputs at least occasionally.
in practice, we simply try different variances until we    nd an
initialization that works. it usually only takes a few attempts. we also    nd that initializing the
biases of the neurons in the hidden layers with some positive constant (1 in our case) helps get
learning off the ground, for the same reason.

16

f.6 training
we train our models using stochastic id119 with a batch size of 128 examples and
momentum of 0.9. therefore the update rule for weight w is

vi+1 = 0.9vi +   <

wi+1 = wi + vi+1

   e
   wi

>i

where i is the iteration index, v is a momentum variable,   is the learning rate, and <    e
>i
   wi
is the average over the ith batch of the derivative of the objective with respect to wi. we use
the publicly available cuda-convnet package to train all of our models on a single nvidia
gtx 580 gpu. training on cifar-10 takes roughly 90 minutes. training on id163 takes
roughly four days with dropout and two days without.

f.7 learning rates
we use an equal learning rate for each layer, whose value we determine heuristically as the
largest power of ten that produces reductions in the objective function. in practice it is typically
of the order 10   2 or 10   3. we reduce the learning rate twice by a factor of ten shortly before
terminating training.

g models for cifar-10

our model for cifar-10 without dropout is a id98 with three convolutional layers. pooling
layers follow all three. all of the pooling layers summarize a 3  3 neighborhood and use a stride
of 2. the pooling layer which follows the    rst convolutional layer performs max-pooling, while
the remaining pooling layers perform average-pooling. response id172 layers follow
the    rst two pooling layers, with n = 9,    = 0.001, and    = 0.75. the upper-most pooling
layer is connected to a ten-unit softmax layer which outputs a id203 distribution over class
labels. all convolutional layers have 64    lter banks and use a    lter size of 5    5 (times the
number of channels in the preceding layer).

our model for cifar-10 with dropout is similar, but because dropout imposes a strong
id173 on the network, we are able to use more parameters. therefore we add a fourth
weight layer, which takes its input from the third pooling layer. this weight layer is locally-
connected but not convolutional. it is like a convolutional layer in which    lters in the same bank
do not share weights. this layer contains 16 banks of    lters of size 3    3. this is the layer in
which we use 50% dropout. the softmax layer takes its input from this fourth weight layer.

17

h models for id163
our model for id163 with dropout is a id98 which is trained on 224  224 patches randomly
extracted from the 256    256 images, as well as their horizontal re   ections. this is a form of
data augmentation that reduces the network   s capacity to over   t the training data and helps
generalization. the network contains seven weight layers. the    rst    ve are convolutional,
while the last two are globally-connected. max-pooling layers follow the    rst, second, and
   fth convolutional layers. all of the pooling layers summarize a 3    3 neighborhood and use a
stride of 2. response-id172 layers follow the    rst and second pooling layers. the    rst
convolutional layer has 64    lter banks with 11    11    lters which it applies with a stride of 4
pixels (this is the distance between neighboring neurons in a bank). the second convolutional
layer has 256    lter banks with 5    5    lters. this layer takes two inputs. the    rst input to
this layer is the (pooled and response-normalized) output of the    rst convolutional layer. the
256 banks in this layer are divided arbitrarily into groups of 64, and each group connects to a
unique random 16 channels from the    rst convolutional layer. the second input to this layer
is a subsampled version of the original image (56    56), which is    ltered by this layer with a
stride of 2 pixels. the two maps resulting from    ltering the two inputs are summed element-
wise (they have exactly the same dimensions) and a max-with-zero nonlinearity is applied to
the sum in the usual way. the third, fourth, and    fth convolutional layers are connected to
one another without any intervening pooling or id172 layers, but the max-with-zero
nonlinearity is applied at each layer after linear    ltering. the third convolutional layer has 512
   lter banks divided into groups of 32, each group connecting to a unique random subset of 16
channels produced by the (pooled, normalized) outputs of the second convolutional layer. the
fourth and    fth convolutional layers similarly have 512    lter banks divided into groups of 32,
each group connecting to a unique random subset of 32 channels produced by the layer below.
the next two weight layers are globally-connected, with 4096 neurons each. in these last two
layers we use 50% dropout. finally, the output of the last globally-connected layer is fed to a
1000-way softmax which produces a distribution over the 1000 class labels. we test our model
by averaging the prediction of the net on ten 224    224 patches of the 256    256 input image:
the center patch, the four corner patches, and their horizontal re   ections. even though we make
ten passes of each image at test time, we are able to run our system in real-time.

our model for id163 without dropout is similar, but without the two globally-connected

layers which create serious over   tting when used without dropout.

in order to achieve state-of-the-art performance on the validation set, we found it necessary
to use the very complicated network architecture described above. fortunately, the complexity
of this architecture is not the main point of our paper. what we wanted to demonstrate is that
dropout is a signi   cant help even for the very complex neural nets that have been developed
by the joint efforts of many groups over many years to be really good at object recognition.
this is clearly demonstrated by the fact that using non-convolutional higher layers with a lot of
parameters leads to a big improvement with dropout but makes things worse without dropout.

18

