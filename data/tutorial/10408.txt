easy-first id33 with hierarchical tree lstms

eliyahu kiperwasser

computer science department

bar-ilan university
ramat-gan, israel

yoav goldberg

computer science department

bar-ilan university
ramat-gan, israel

6
1
0
2

 

y
a
m
6
2

 

 
 
]
l
c
.
s
c
[
 
 

2
v
5
7
3
0
0

.

3
0
6
1
:
v
i
x
r
a

elikip@gmail.com

yoav.goldberg@gmail.com

abstract

we suggest a compositional vector represen-
tation of parse trees that relies on a recursive
combination of recurrent-neural network en-
coders. to demonstrate its effectiveness, we
use the representation as the backbone of a
greedy, bottom-up dependency parser, achiev-
ing very strong accuracies for english and
chinese, without relying on external word
embeddings. the parser   s implementation is
available for download at the    rst author   s
webpage.

introduction

1
dependency-based syntactic representations of sen-
tences are central to many language processing tasks
(k  bler et al., 2008). dependency parse-trees en-
code not only the syntactic structure of a sentence
but also many aspects of its semantics.

a recent trend in nlp is concerned with en-
coding sentences as a vectors (   sentence embed-
dings   ), which can then be used for further pre-
diction tasks. recurrent neural networks (id56s)
(elman, 1990), and in particular methods based on
the lstm architecture (hochreiter and schmidhu-
ber, 1997), work very well for modeling sequences,
and constantly obtain state-of-the-art results on both
language-modeling and prediction tasks (see, e.g.
(mikolov et al., 2010)).

several works attempt to extend recurrent neu-
ral networks to work on trees (see section 8 for a
brief overview), giving rise to the so-called recursive
neural networks (goller and k  chler, 1996; socher
et al., 2010). however, id56s

do not cope well with trees with arbitrary branch-
ing factors     most work require the encoded trees to
be binary-branching, or have a    xed maximum arity.
other attempts allow arbitrary branching factors, in
the expense of ignoring the order of the modi   ers.

in contrast, we propose a tree-encoding that nat-
urally supports trees with arbitrary branching fac-
tors, making it particularly appealing for depen-
dency trees. our tree encoder uses recurrent neural
networks as a building block: we model the left and
right sequences of modi   ers using id56s, which are
composed in a recursive manner to form a tree (sec-
tion 3). we use our tree representation for encoding
the partially-build parse trees in a greedy, bottom-up
dependency parser which is based on the easy-   rst
transition-system of goldberg and elhadad (2010).
using the hierarchical tree lstm representa-
tion, and without using any external embeddings,
our parser achieves parsing accuracies of 92.6 uas
and 90.2 las on the ptb (stanford dependencies)
and 86.1 uas and 84.4 las on the chinese tree-
bank, while relying on greedy decoding.

to the best of our knowledge, this is the    rst work
to demonstrate competitive parsing accuracies for
full-scale parsing while relying solely on recursive,
compositional tree representations, and without us-
ing a reranking framework. we discuss related work
in section 8.

while the parsing experiments demonstrate the
suitability of our representation for capturing the
structural elements in the parse tree that are useful
for predicting parsing decisions, we are interested in
exploring the use of the id56-based compositional
vector representation of parse trees also for seman-

tic tasks such as id31 (socher et al.,
2013b; tai et al., 2015), sentence similarity judge-
ments (marelli et al., 2014) and id123
(bowman et al., 2015).

2 background and notation
2.1 dependency-based representation
a dependency-based syntactic representation is cen-
tered around syntactic modi   cation relations be-
tween head words and modi   er words. the result
are trees in which each node is a word in the sen-
tence, and every node except for one designated root
node has a parent node. a dependency tree over
a sentence with n words w1, . . . , wn can be repre-
sented as a list of n pairs of the form (h, m), where
0     h     n and 1     m     n. each such pair rep-
resents an edge in the tree in which h is the index
of a head word (including the special root node
0), and m is the index of a modi   er word. in or-
der for the dependency trees to be useful for actual
downstream language processing tasks, each edge is
labeled with a syntactic relation. the tree represen-
tation then becomes a list of triplets (h, m, (cid:96)), where
1     (cid:96)     l is the index of a dependency relation out
of a designated set of l syntactic relations.

dependency trees tend to be relatively shallow,
with some nodes having many children. looking
at trees in the ptb training set we    nd that 94% of
the trees have a height of at most 10, and 49% of the
trees a height of at most 6. in terms of width, 93%
of the trees have at least one node with an arity of 4
or more, and 56% of the trees have at least one node
with an arity of 6 or more.

2.2 recurrent networks and lstms
recurrent neural networks (id56s),    rst proposed
by elman (1990) are statistical learners for model-
ing sequential data. in this work, we use the id56
abstraction as a building block, and recursively com-
bine several id56s to obtain our tree representa-
tion. we brie   y describe the id56 abstraction be-
low. for further detail on id56s, the reader is re-
ferred to sources such as (goldberg, 2015; bengio
et al., 2015; cho, 2015).

the id56 abstraction is a function rn n that
takes in a sequence of inputs vectors x1, . . . , xn
(xi     rdin), and produces a sequence of state vec-

tors (also called output vectors) y1, . . . , yn (yi    
rdout). each yi is conditioned on all the inputs
x1, . . . , xi preceding it.
ignoring the intermediate
outputs y1, . . . , yn   1, the id56 can be thought of as
encoding the sequence x1, . . . , xn into a    nal state
yn. our notation in this paper follows this view.

the id56 is de   ned recursively using two func-

tions:1

rn n (s0, x1, . . . , xn) = yn = o(sn)
si = n (si   1, xi)

here, a function n takes as input a vector xi and
a state vector si   1 and returns as output a new state
si. one can then extract an output vector yi from si
using the function o (the function o is usually the
identity function, or a function that returns a subset
of the elements in si).

taking an algorithmic perspective, one can view
the id56 as a state object with three operations:
s = id56.initial() returns a new initial state,
s.advance(x) takes an input vector and returns
a new state, and s.output() returns the output
vector for the current state. when clear from the
context, we abbreviate and use the state   s name (s)
instead of s.output() to refer to the output vec-
tor at the state.

the functions n and o de   ning the id56 are pa-
rameterized by parameters    (matrices and vectors),
which are trained from data. speci   cally, one is usu-
ally interested in using some of the outputs yi for
making predictions. the id56 is trained such that
the encoding yi is good for the prediction task. that
is, the id56 learns which aspects of the sequence
x1, . . . , xi are informative for the prediction.

we use subscripts (i.e. rn nl, rn nr) to indi-
cate different id56s, that is, id56s that have differ-
ent sets of parameters.

speci   c instantiations of n and o yield differ-
ent recurrent network mechanisms. in this work we
use the long short term memory (lstm) variant
(hochreiter and schmidhuber, 1997) which is shown
to be a very capable sequence learner. however, our
algorithm and encoding method do not rely on any
speci   c property of the lstm architecture, and the

1we follow the notation of goldberg (2015), with the excep-
tion of taking the output of the id56 to be a single vector rather
than a sequence, and renaming r to n.

lstm can be transparently switched for any other
id56 variant.

3 tree representation
we now describe our method for representing a
tree as a d-dimensional vector. we assume trees in
which the children are ordered and there are kl     0
children before the parent node (left children) and
kr     0 children after it (right children). such
trees correspond well to dependency tree structures.
we refer to the parent node as a head, and to its
children as modi   ers. for a node t, we refer to
its left modi   ers as t.l1, t.l2, . . . , t.lkl and its right
modi   ers as t.r1, t.r2, . . . , t.rkr the indices of the
modi   er are always from the parent outward, that
is t.l1 is the left modi   er closest to the head t:

the gist of the idea is to treat the modi   ers of a
node as a sequence, and encode this sequence us-
ing an id56. we separate left-modi   ers from right-
modi   ers, and use two id56s:
the    rst id56 en-
codes the sequence of left-modi   ers from the head
outwards, and the second id56 the sequence of
right-modi   ers from the head outwards. the    rst
input to each id56 is the vector representation of
the head word, and the last input is the vector rep-
resentation of the left-most or the right-most modi-
   er. the node   s representation is then a concatena-
tion of the id56 encoding of the left-modi   ers with
the id56 encoding of the right-modi   ers. the en-
coding is recursive: the representation for each of
the modi   er nodes is computed in a similar fashion.

more formally, consider a node t. let i(t) be
the sentence index of the word corresponding to the
head node t, and let vi be a vector corresponding
to the ith word in the sentence (this vector captures
information such as the word form and its part of

speech tag, and will be discussed shortly). the vec-
tor encoding of a node enc(t)     rdenc is then de-
   ned as follows:
enc(t) =g(w e    (el(t)     er(t)) + be)
el(t) =rn nl(vi(t), enc(t.l1), . . . , enc(t.lkl))
er(t) =rn nr(vi(t), enc(t.r1), . . . , enc(t.rkr ))

first, the sequences consisting of the head-vector
vi(t) followed by left-modi   ers and the head-vector
followed by right-modi   ers are encoded using two
id56s, rn nl and rn nr, resulting in id56 states
el(t)     rdout and er(t)     rdout. then,
the
id56 states are concatenated, resulting in a 2dout-
dimensional vector (el(t)     er(t)), which is reduced
back to d-dimensions using a linear transformation
followed by a non-linear activation function g. the
recursion stops at leaf nodes, for which:

enc(leaf) =g(w e    (el(leaf)     er(leaf)) + be)
el(leaf) =rn nl(vi(leaf))
er(leaf) =rn nr(vi(leaf))

figure 1 shows the network used for encoding the
sentence    the black fox who really likes apples did
not jump over a lazy dog yesterday   .

3.1 representing words
in the discussion above we assume a vector repre-
sentation vi associated with the ith sentence word.
what does vi look like? a sensible approach would
be to take vi to be a function of the word-form and
the part-of-speech (pos) tag of the ith word, that is:

vi = g(w v    (wi     pi) + bv)

where wi and pi are the embedded vectors of the
word-form and pos-tag of the ith word.

this encodes each word in isolation, disregarding
its context. the context of a word can be very in-
formative regarding its meaning. one way of incor-
porating context is the bidirectional id56 (schuster
and paliwal, 1997). bidirectional id56s are shown
to be an effective representation for sequence tag-
ging (irsoy and cardie, 2014). bidirectional id56s

tt.r1t.r2t.r3t.r4t.l1t.l2t.l3trlt.r1rt.r2rt.r3rt.r4rtt.l1lt.l2lt.l3lenc(t)id56rid56lconcatenateandcompressfigure 1: network for encoding the sentence    the black fox who really likes apples did not jump over a lazy dog
yesterday   . top: the network structure: boxed nodes represent lstm cells, where l are cells belonging to the left-
modi   ers sequence model rn nl, and r to the right-modi   ers sequence model rn nr. circle nodes represent a
concatenation followed by a linear transformation and a non-linearity. bottom: the dependency parse of the sentence.

represent a word in the sentence using a concate-
nation of the end-states of two id56s, one running
from the beginning of the sentence to the word and
the other running from the end to the word. the re-
sult is a vector representation for each word which
captures not only the word but also its context.

we adopt the bidirectional lstm scheme to en-
rich our node vector representation, and for an n-
words sentence compute the vector representations
vi as follows:

(cid:48)

i =g(w v    (wi     pi) + bv)
v
(cid:48)
2, . . . , v
fi =lst mf (v
i)
(cid:48)
n   1, . . . , v
bi =lst mb(v
vi =(fi     bi)

1, v
n, v

(cid:48)
(cid:48)

(cid:48)

(cid:48)

i)

we plug this word representation as word vectors,
allowing each word vector vi to capture informa-
tion regarding the word form and pos-tag, as well
as the sentential context it appears in. the bi-
lstm encoder is trained jointly with the rest of the
network towards the parsing objective, using back-
propagation.

embedding vectors the word and pos embed-
dings wi and pi are also trained together with the
network. for the id27s, we experiment
with random initialization, as well as with initializa-
tion using pre-trained id27s. our main
goal in this work is not to provide top parsing accu-
racies, but rather to evaluate the ability of the pro-
posed compositional architecture to learn and cap-
ture the structural cues that are needed for accurate
parsing. thus, we are most interested in the random
initialization setup: what can the network learn from
the training corpus alone, without relying on exter-
nal resources.

however, the ability to perform semi-supervised
learning by initializing the word-embeddings with
vectors that are pre-trained on large amount of unan-
notated data is an appealing property of the neural-
network approaches, and we evaluate our parser also
in this semi-supervised setup. when using pre-
trained id27s, we follow (dyer et al.,
2015) and use embedding vectors which are trained
using positional context (ling et al., 2015), as these

theblackfoxwhoreallylikesapplesdidnotjumpoveralazydogyesterdaylrlrlrlrlrlrlrlrlrlllllrlrrlrrlrllrrlrrlrrlltheblackreallyfoxlfoxrwholwhorlikesllikesrjumpljumproverloverrdogldogrtheblackfoxwhoreallylikesappleswhoreallylikesapplesreallylikesapplesoveralazydogapplesalazydogdidnotalazyyesterdaytheblackfoxwhoreallylikesapplesdidnotjumpoveralazydogyesterdaywere shown to work better than traditional skip-
gram vectors for syntactic tasks such as part-of-
speech tagging and parsing.

3.2 a note on the head-outward generation

why did we choose to encode the children from the
head outward, and not the other way around? the
head outward generation order is needed to facili-
tate incremental tree construction and allowing for
ef   cient parsing, as we show in section 4 below. be-
side the ef   ciency considerations, using the head-
outward encoding puts more emphasis on the outer-
most dependants, which are known to be the most in-
formative for predicting parse structure.2 we rely on
the id56 capability of extracting information from
arbitrary positions in the sequence to incorporate in-
formation about the head word itself, which appears
in the beginning of the sequence. this seem to work
well, which is expected considering that the aver-
age maximal number of siblings in one direction in
the ptb is 4.1, and lstms were demonstrated to
capture much longer-range interactions. still, when
using the tree encoding in a situation where the tree
is fully speci   ed in advance, i.e. for sentence classi-
   cation, sentence similarity or translation tasks, us-
ing a head-inward generation order (or even a bi-
directional id56) may prove to work better. we
leave this line of inquiry to future work.

the head-outward modi   er generation approach
has a long history in the parsing literature, and goes
back to at least eisner (1996) and collins (1997).
in contrast to previous work in which each modi-
   er could condition only on a    xed small number
of modi   ers preceding it, and in which the left- and
right- sequences of modi   ers were treated as inde-
pendent from one another for computational ef   -
ciency reasons, our approach allows the model to
access information from the entirety of both the left
and the right sequences jointly.

2features in transition-based dependency parsers often look
at the current left-most and right-most dependents of a given
node, and almost never look further than the second left-most
or second right-most dependents. second-order graph based
dependency parsers (mcdonald, 2006; eisner, 2000) also con-
dition on the current outermost dependent when generating its
sibling.

4 parsing algorithm
we now turn to explain how to parse using the tree
encoder de   ned above. we begin by describing our
bottom-up parsing algorithm, and then show how the
encoded vector representation can be built and main-
tained throughout the parsing process.

4.1 bottom-up parsing
we follow a (projective) bottom-up parsing strategy,
similar to the easy-   rst parsing algorithm of gold-
berg and elhadad (2010).

the main data-structure in the parser is a list of
partially-built parse trees we call pending. for a
sentence with words w1, . . . , wn, the pending list
is initialized with n nodes, where pending[i] corre-
sponds to word wi. the algorithm then chooses two
neighbouring trees in the pending list pending[i]
and pending[i + 1] and either attaches the root of
pending[i + 1] as the right-most modi   er of the root
of pending[i], or attaches the root of pending[i] as
the left-most modi   er of the root of pending[i + 1].
the tree which was treated as modi   er is then re-
moved from the pending list, shortening it by one.
the process ends after n     1 steps, at which we re-
main with a single tree in the pending list, which is
taken to be the output parse tree. the parsing pro-
cess is described in algorithm 1.

algorithm 1 parsing
1: input: sentence w = w1, . . . , wn
2: for i     1, . . . , n do
pend[i].id     i
3:
4: arcs     []
5: while |pend| > 1 do
6: a     {(i, d) | 1     i < |pend|, d     {l, r}}
i, d     select(a)
7:
if d = l then
8:
9:
10:
11:
12:
13:
14:
15: return arcs

m, h     pend[i], pend[i + 1]
pend.remove(i)
h, m     pend[i], pend[i + 1]
pend.remove(i + 1)

arcs.append(h.id, m.id)

else

this parsing algorithm is both sound and com-
plete with respect to the class of projective depen-

dency trees (goldberg and elhadad, 2010). the al-
gorithm depends on non-deterministic choices of an
index in the pending list and an attachment direc-
tion (line 7). when parsing in practice, the non-
deterministic choice will be replaced by using a
trained classi   er to assign a score to each index-
direction pair, and selecting the highest scoring pair.
we discuss the scoring function in section 4.4, and
the training algorithm in section 5.

4.2 bottom-up tree-encoding

we would like the scoring function to condition on
the vector encodings of the subtrees it aims to con-
nect. algorithm 2 shows how to maintain the vec-
tor encodings together with the parsing algorithm, so
that at every stage in the parsing process each item
pending[i] is associated with a vector encoding of
the corresponding tree.

algorithm 2 parsing while maintaining tree repre-
sentations
1: input: sentence w = w1, . . . , wn
2: input: vectors vi corresponding to words wi
3: arcs     []
4: for i     1, . . . , n do
pend[i].id     i
5:
pend[i].el     rn nl.init().append(vi)
6:
pend[i].er     rn nr.init().append(vi)
7:
8: while |pend| > 1 do
9: a     {(i, d) | 1     i < |pend|, d     {l, r}}
i, d     select(a)
10:
if d = l then
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24: return arcs

m, h     pend[i], pend[i + 1]
m.c = m.el     m.er
m.enc = g(w (m.c) + b)
h.el.append(m.enc)
pend.remove(i)
h, m     pend[i], pend[i + 1]
m.c = m.el     m.er
m.enc = g(w (m.c) + b)
h.er.append(m.enc)
pend.remove(i + 1)

arcs.add(h.id, m.id)

else

4.3 labeled tree representation
the tree representation described above does not ac-
count for the relation labels (cid:96) the parsing algorithm
assigns each edge. in cases the tree is fully speci   ed
in advance, the relation of each word to its head can
be added to the word representations vi. however,
in the context of parsing, the labels become known
only when the modi   er is attached to its parent. we
thus extend the tree representation by concatenating
the node vector representation with a vector repre-
sentation assigned to the label connecting the sub-
tree to its parent. formally, only the    nal enc(t)
equation changes:

enc(t) = g(w e    (el     er     (cid:96)) + be)

where (cid:96) is a learned embedding vector associated
with the given label.

4.4 scoring function
the parsing algorithm relies on a function select(a)
for choosing the action to take at each stage. we
model this function as:

select(a) = argmax(i,d,(cid:96))   ascore(pend, i, d, (cid:96))
where score(.) is a learned function whose job is
to assign scores to possible actions to re   ect their
quality.
ideally, it will not only score correct ac-
tions above incorrect ones, but also more con   dent
(easier) actions above less con   dent ones, in order
to minimize error propagation in the greedy parsing
process.

when scoring a possible attachment between a
head h and a modi   er m with relation (cid:96), the scor-
ing function should attempt to re   ect the following
pieces of information:
    are the head words of h and m compatible un-
    is the modi   er m compatible with the already
existing modi   ers of h? in other words, is m a
good subtree to connect as an outer-most mod-
i   er in the subtree h?
    is m complete, in the sense that it already ac-

der relation l?

quired all of its own modi   ers?

to this end, the scoring function looks at a window
of k subtrees to each side of the head-modi   er pair
(pend[i     k], . . . , pend[i + 1 + k]) where the neigh-
bouring subtrees are used for providing hints regard-
ing possible additional modi   ers of m and h that are

yet to be acquired. we use k = 2 in our experi-
ments, for a total of 6 subtrees in total. this win-
dow approach is also used in the easy-first parser
of goldberg and elhadad (goldberg and elhadad,
2010) and works that extend it (tratz and hovy,
2011; ma et al., 2012; ma et al., 2013). how-
ever, unlike the previous work, which made use of
extensive feature engineering and rich feature func-
tions aiming at extracting the many relevant linguis-
tic sub-structures from the 6 subtrees and their inter-
actions, we provide the scoring function solely with
the vector-encoding of the 6 subtrees in the window.
modeling the labeled attachment score is more
dif   cult than modeling the unlabeled score and is
prone to more errors. moreover, picking the label
for an attachment will cause less cascading error in
contrast to picking the wrong attachment, which will
necessarily preclude the parser from reaching the
correct tree structure. in order to partially overcome
this issue, our scoring function is a sum of two auxil-
iary scoring function, one scoring unlabeled and the
other scoring labeled attachments. the unlabeled at-
tachment score term in the sum functions as a fall-
back which makes it easier for a parser to predict the
attachment direction even when there is no suf   cient
certainty as to the label.

score(pend, i, d, (cid:96)) = scoreu (pend, i, d)

+ scorel(pend, i, d, (cid:96))

each of scoreu and scorel are modeled as multi-
layer id88s:

scoreu (pend, i, d) = m lpu (xi)[d]
scorel(pend, i, d, (cid:96)) = m lpl(xi)[(d, (cid:96))]
xi = pend[i     2].c                pend[i + 3].c

where m lpu and m lpl are standard multi-
layer id88 classi   ers with one hidden layer
(m lpx (x) = w 2g(w 1x + b1) + b2) and have out-
put layers with size 2 and 2l respectively, [.] is an
indexing operation, and we assume the values of d
and (d, (cid:96)) are mapped to integer values.

4.5 computational complexity
the easy-first
in
o(n log n) time (goldberg and elhadad, 2010).

algorithm works

parsing

the parser in this works differ by three aspects:
running a bi-lstm encoder prior
to parsing
(o(n)); maintaining the tree representation during
parsing (lines 11   22 in algorithm 2) which take a
constant time at each parsing step; and local scoring
using an mlp rather than a linear classi   er (again, a
constant-time operation). thus, the parser maintains
the o(n log n) complexity of the easy-first parser.

5 training algorithm
5.1 loss and parameter updates
at each step of the parsing process we select the
highest scoring action (i, d, (cid:96)). the goal of training
is to set the score function such that correct actions
are scored above incorrect ones. we use a margin-
based objective, aiming to maximize the margin be-
tween the highest scoring correct action and the set
of incorrect actions. formally, we de   ne a hinge loss
for each parsing step as follows:
max{0, 1   max(i,d,(cid:96))   gscore(pend, i, d, (cid:96))

+max(i(cid:48),d(cid:48),(cid:96)(cid:48))   a\gscore(pend, i, d, (cid:96))}

where a is the set of all possible actions and g is
the set of correct actions at the current stage.

as the scoring function depends on vector-
encodings of the all the trees in the window, and
each tree-encoding depends on the network   s pa-
rameters, each parameter update will invalidate all
the vector encodings, requiring a re-computation of
the entire network. we thus sum the local losses
throughout the parsing process, and update the pa-
rameter with respect to the sum of the losses at sen-
tence boundaries. since we are using hinge loss the
gradients will become sparser as the training pro-
gresses. fewer non-zero gradient could translate to
unreliable updates. in order to increase gradient sta-
bility and training speed, we use a variation of mini-
batch in which we update the parameters only after
50 errors were made. this assures us a suf   cient
number of gradients for every update thus minimiz-
ing the effect of gradient instability. the gradients
of the entire network with respect to the sum of the
losses are calculated using the id26 al-
gorithm. initial experiments with an sgd optimizer
showed very instable results. we settled instead on
using the adam optimizer (kingma and ba, 2014)

which worked well without requiring    ddling with
learning rates.
5.2 error-exploration and dynamic oracle

training

at each stage in the training process, the parser as-
signs scores to all the possible actions (i, d, (cid:96))     a.
it then selects an action, applies it, and moves to the
next step. which action should be chosen? a sensi-
ble option is to de   ne g as the set of actions that can
lead to the gold tree, and following the highest scor-
ing actions in this set. however, using training in
this manner tends to suffer from error propagation at
test time. the parser sees only states that result from
following correct actions. the lack of examples con-
taining errors in the training phase makes it hard for
the parser to infer the best action given partly erro-
neous trees. in order to cope with this, we follow
the error exploration training strategy, in which we
let the parser follow the highest scoring action in a
during training even if this action is incorrect, expos-
ing it to states that result from erroneous decisions.
this strategy requires de   ning the set g such that
the correct actions to take are well-de   ned also for
states that cannot lead to the gold tree. such a set
g is called a dynamic oracle. error-exploration and
dynamic-oracles were introduced by goldberg and
nivre (2012).
the dynamic oracle a dynamic-oracle for the
easy-   rst parsing system we use is presented in
(goldberg and nivre, 2013a). brie   y, the dynamic-
oracle version of g de   nes the set of gold actions as
the set of actions which does not increase the num-
ber of erroneous attachments more than the mini-
mum possible (given previous erroneous actions).
the number of erroneous attachments is increased
in three cases: (1) connecting a modi   er to its head
prematurely. once the modi   er is attached it is re-
moved from the pending list and therefore can no
longer acquire any of its own modi   ers; (2) connect-
ing a modi   er to an erroneous head, when the cor-
rect head is still on the pending list; (3) connecting
a modi   er to a correct head, but an incorrect label.

dealing with cases (2) and (3) is trivial. to deal
with (1), we consider as correct only actions in
which the modi   er is complete. to ef   ciently iden-
tify complete modi   ers we hold a counter for each
word which is initialized to the number of modi   ers

the word has in the gold tree. when applying an
attachment the counter of the modi   er   s gold head
word is decreased. when the counter reaches 0, the
sub-tree rooted at that word has no pending modi-
   ers, and is considered complete.
aggressive exploration we found that even when
using error-exploration, after one iteration the model
remembers the training set quite well, and does not
make enough errors to make error-exploration effec-
tive. in order to expose the parser to more errors,
we employ a cost augmentation scheme: we some-
times follow incorrect actions also if they score be-
low correct actions. speci   cally, when the score of
the correct action is greater than that of the wrong
action but the difference is smaller than the margin
constant, we chose to follow the wrong action with
id203 paug (we use paug = 0.1 in our experi-
ments). pseudocode for the entire training algorithm
is given in the supplementary material.

5.3 out-of-vocabulary items and word-dropout
due to the sparsity of natural language, we are likely
to encounter at test time a substantial number of
the words that did not appear in the training data
(oov words). oov words are likely even when
pre-training the word representations on a large un-
annotated corpora. a common approach is to desig-
nate a special    unknown-word    symbol, whose as-
sociated vector will be used as the word representa-
tion whenever an oov word is encountered at test
time. in order to train the unknown-word vector, a
possible approach is to replace all the words appear-
ing in the training corpus less than a certain num-
ber of times with the unknown-word symbol. this
approach give a good vector representation for un-
known words but in the expense of ignoring many
of the words from the training corpus.

we instead propose a variant of the word-dropout
approach (iyyer et al., 2015). during training,
we replace a word with the unknown-word symbol
with id203 that is inversely proportional to fre-
quency of the word. formally, we replace a word
w appearing #(w) times in the training corpus with
the unknown symbol with a id203:

punk(w) =

  

#(w) +   

using this approach we learn a vector representa-
tion for unknown words with minimal impact on the
training of sparse words.

6

implementation details

our python implementation will be made available
at the    rst author   s website. we use the pyid98
wrapper of the id98 library3 for building the com-
putation graph of the network, computing the gradi-
ents using automatic differentiation, and performing
parameter updates. we noticed the error on the de-
velopment set does not improve after 20 iterations
over the training set, therefore, we ran the train-
ing for 20 iterations. the sentences where shuf   ed
between iterations. non-projective sentences were
skipped during training. we use the default parame-
ters initialization, step sizes and id173 val-
ues provided by the pyid98 toolkit. the hyper-
parameters of the    nal networks used for all the re-
ported experiments are detailed in table 1.

id27 dimension
pos tag embedding dimension
relation embedding dimension

hidden units in scoreu
hidden units in scorel
lstm dimensions (tree)

lstm layers (tree)
bi-lstm dimensions

bi-lstm layers
mini-batch size

   (for word dropout)

paug (for exploration training)

g

100
25
25
100
100
200
2

100+100

2
50
0.25
0.1
tanh

table 1: hyper-parameter values used in experiments

weiss et al (2015) stress the importance of care-
ful hyperparameter tuning for achieving top accu-
racy in neural network based parser. we did not
follow this advice and made very few attempts at
hyper-parameter tuning, using manual hill climbing
until something seemed to work with reasonable ac-
curacy, and then sticking with it for the rest of the
experiments.

3https://github.com/clab/id98/tree/

master/pyid98

7 experiments and results

we evaluated our parsing model to english and chi-
nese data. for comparison purposes we followed the
setup of (dyer et al., 2015).

data for english, we used the stanford depen-
dency (sd) (de marneffe and manning, 2008) con-
version of the id32 (marcus et al., 1993),
using the standard train/dev/test splitswith the same
predicted pos-tags as used in (dyer et al., 2015;
chen and manning, 2014). this dataset contains a
few non-projective trees. punctuation symbols are
excluded from the evaluation.

for chinese, we use the penn chinese treebank
5.1 (ctb5), using the train/test/dev splits of (zhang
and clark, 2008; dyer et al., 2015) with gold part-
of-speech tags, also following (dyer et al., 2015;
chen and manning, 2014).

when using external id27s, we also

use the same data as (dyer et al., 2015).4

in several

con   guration.

tree-encoding,

con   gurations we

the baseline parser,

experimental
evaluated
bot-
the parser
not
tomupparser is
using the
and instead repre-
senting each item in pending solely by the
vector-representation (word and pos) of its head
word.
bottomupparser+htlstm is using
our hierarchical tree lstm representation.
bottomupparser+htlstm+bi-lstm is
the
hierarchical tree lstm where we additionally use
a bi-lstm encoding for the head words. finally,
we added external, pre-trained id27s
to the bottomupparser+htlstm+bi-lstm
setup. we also evaluated the    nal parsers in a    pos
setup, in which we did not feed the parser with any
pos-tags.

results results for english and chinese are pre-
sented in tables 2 and 3 respectively. for compar-
ison, we also show the results of the stack-lstm
transition-based parser model of dyer et al (2015),
which we consider to be a state-of-the-art greedy
model which is also very competitive with search-
based models, with and without pre-trained embed-
dings, and with and without pos-tags.

4we thank dyer et al for sharing their data with us.

bottomupparser
+htlstm
+bi-lstm input
+external embeddings

dyer et al (2015) no external
dyer et al (2015) w/ external
c&m (2014) w/ external
bottomup+all   pos
dyer et al (2015)    pos

test

dev
uas las uas las
78.6
83.3
89.8
92.4
90.2
93.0
93.3
90.9
90.0
92.7
90.9
93.2
89.6
92.2
92.9
90.6
90.3
93.1

79.0
90.1
90.5
90.8
90.4
90.9
89.7
90.5
90.4

82.7
92.0
92.6
93.0
92.4
93.1
91.8
92.9
92.7

table 2: english parsing results (sd)

bottomupparser
+htlstm
+bi-lstm
+external embeddings

dyer et al (2015) no external
dyer et al (2015) w/ external
c&m (2014) no external
bottomup+all    pos
dyer et al (2015)    pos

test

dev
uas las uas las
76.3
79.3
84.7
86.2
86.2
84.4
85.5
87.2
84.1
86.3
85.7
87.2
84.0
82.4
79.5
82.9
82.8
79.1

77.1
84.5
84.5
85.7
84.7
85.9
82.4
80.0
79.8

78.8
86.2
86.1
87.1
85.7
87.2
83.9
82.6
82.2

table 3: chinese parsing results (ctb5)

the trends are consistent across the two lan-
guages. the baseline bottom-up parser performs
very poorly. this is expected, as only the head-
word of each subtree is used for prediction. when
adding the tree-encoding, results jump to near state-
of-the-art accuracy, suggesting that the composed
vector representation is indeed successful in captur-
ing predictive structural information. replacing the
head-words with their bi-lstm encodings results
in another increase in accuracy for english, outper-
forming the dyer et al (s-lstm no external) mod-
els on the test-set. adding the external pre-trained
embeddings further improve the results for both our
parser and dyer et al   s model, closing the gap be-
tween them. when pos-tags are not provided as
input, the numbers for both parsers drop. the drop
is small for english and large for chinese, and our
parser seem to suffer a little less than the dyer et al
model.

importance of the dynamic oracle we also eval-
uate the importance of using the dynamic oracle and
error-exploration training, and    nd that they are in-
deed important for achieving high parsing accura-

cies with our model (table 4).

english

chinese

rand
rand-nodyn
ext
ext-nodyn

uas las uas las
84.5
93.0
92.2
84.1
85.7
93.3
92.7
85.1

86.2
85.7
87.2
86.6

90.5
89.8
90.8
90.4

effect of

the error-exploration training
table 4:
(dynamic-oracle) on dev set accuracy in english and chi-
nese. rand: random initialization. ext: pre-trained ex-
ternal embeddings.

when training without error-exploration (that is,
the parser follows only correct actions during train-
ing and not using the dynamic aspect of the ora-
cle), accuracies of unseen sentences drop by be-
tween 0.4 and 0.8 accuracy points (average 0.58).
this is consistent with previous work on training
with error-exploration and dynamic oracles (gold-
berg and nivre, 2013b), showing that the technique
is not restricted to models trained with sparse linear
models.

comparison to other state-of-the-art parsers
our main point of comparison is the model of dyer
et al, which was chosen because it is (a) a very strong
parsing model; and (b) is the closest to ours in the lit-
erature: a greedy parsing model making heavy use
of lstms. to this end, we tried to make the com-
parison to dyer et al as controlled as possible, using
the same dependency annotation schemes, as well
as the same predicted pos-tags and the pre-trained
embeddings (when applicable).

it is also informative to position our results with
respect to other state-of-the-art parsing results re-
ported in the literature, as we do in table 5. here,
some of the comparisons are less direct:
some
of the results use different dependency annotation
schemes5, as well as different predicted pos-tags,
and different pre-trained id27s. while
the numbers are not directly comparable, they do
give a good reference as to the expected range of

5our english parsing experiments use the stanford depen-
dencies scheme, while other work use less informative depen-
dency relations which are based on the penn2malt converter,
using the yamada and matsumoto head rules. from our expe-
rience, this conversion is somewhat easier to parse, resulting in
numbers which are about 0.3-0.4 points higher than stanford
dependencies.

ptb-ym ptb-sd ctb
86.0

   

system
zhangnivre11
martins13
pei15
this work
weiss15
weiss15
pei15
lezuidema14
zhu15
this work

method

transition (beam)
graph, 3rd order+
graph, 2nd order
easyfirst (greedy)
transition (greedy)
transition (beam)
graph, 2nd order
reranking /blend
reranking /blend
easyfirst (greedy)

representation

emb

   
   
   
   

large feature set (sparse)
large feature set (sparse)
large feature set (dense)
rec-lstm encoding
large feature set (dense)
large feature set (dense)
large feature set (dense)

yes
yes
yes
inside-outside recursive net yes
yes
yes

recursive conv-net
rec-lstm encoding

92.9
92.8
92.99

   
   
   

93.29
93.12
93.83

   

runtime
o(n)+
o(n4)
o(n3)

o(n)
o(n)+
o(n3)
o(n3)
o(n)+

86.1 o(n log n)

85.71
87.1 o(n log n)

   
   

   
   
   
   

93.07

   

92.6
93.19
93.99

   

93.84

   

93.0

table 5: parsing results (uas) of various state-of-the-art parsing systems on the english and chinese datasets. the systems
that use embeddings use different pre-trained embeddings. english results use predicted pos tags (different systems use different
taggers), while chinese results use gold pos tags. ptb-ym: english ptb, yamada and matsumoto head rules. ptb-sd: english
ptb, stanford dependencies (different systems may use different versions of the stanford converter. ctb: chinese treebank.
reranking /blend in method column indicates a reranking system where the reranker score is interpolated with the base-parser   s
score. the reranking systems    runtimes are those of the base parsers they use. o(n)+ indicates a linear-time system with a large
multiplicative constant. the different systems and the numbers reported from them are taken from: zhangnivre11: (zhang and
nivre, 2011); martins13: (martins et al., 2013); weiss15 (weiss et al., 2015); pei15: (pei et al., 2015); lezuidema14 (le and
zuidema, 2014); zhu15: (zhu et al., 2015).

state-of-the-art parsing results. our system   s en-
glish parsing results are in range of state-of-the-art
and the chinese parsing results surpass it. these
numbers are achieved while using a greedy, bottom
up parsing method without any search, and while
relying solely on the compositional tree representa-
tions.
8 related work
we survey two lines of related work: methods for
encoding trees as vectors, and methods for parsing
with vector representations.

the popular approach for encoding trees as vec-
tors is using id56s (goller and
k  chler, 1996; socher et al., 2010; tai et al., 2015).
id56s represent the vector of
a parent node in a tree as a function of its chil-
dren nodes. however, the functions are usually re-
stricted to having a    xed maximum arity (usually
two) (socher et al., 2010; tai et al., 2015; socher,
2014). while trees can be binarized to cope with the
arity restriction, doing so result in deep trees which
in turn lead to the vanishing gradient problem when
training. to cope with the vanishing gradients, (tai
et al., 2015) enrich the composition function with
a gating mechanism similar to that of the lstm,
resulting in the so-called tree-lstm model. an-
other approach is to allow arbitrary arities but ignor-
ing the sequential nature of the modi   ers, e.g. by
using a bag-of-modi   ers representation or a convo-

lutional layer (tai et al., 2015; zhu et al., 2015). in
contrast, our tree encoding method naturally allows
for arbitrary branching trees by relying on the well
established lstm sequence model, and using it as
a black box. very recently, (zhang et al., 2015) pro-
posed an id56-based tree encoding which is similar
to ours in encoding the sequence of modi   ers as an
id56. unlike our bottom-up encoder, their method
works top-down, and is therefor not readily applica-
ble for parsing. on the other hand the top-down ap-
proach is well suited for generation. in future work,
it could be interesting to combine the bottom-up and
top-down approaches in an encoder-decoder frame-
work (sutskever et al., 2014; kiros et al., 2015).
work by dyer et al (2016), that was submitted in
parallel to ours, introduces a similar lstm-based
representation of syntactic constituents in the con-
text of phrase-grammar parsing.

in terms of parsing with vector representations,
there are four dominant approaches: search based
parsers that use local features that are fed to a
neural-network classi   er (pei et al., 2015; durrett
and klein, 2015); greedy transition based parsers
that use local features that are fed into a neural-
network classi   er (chen and manning, 2014; weiss
et al., 2015), sometimes coupled with a node com-
position function (dyer et al., 2015; watanabe and
sumita, 2015); bottom up parsers that rely solely
on recursively combined vector encodings of sub-

trees (socher et al., 2010; stenetorp, 2013; socher
et al., 2013a); and parse-reranking approaches that
   rst produced a k-best list of parses using a tradi-
tional parsing technique, and then scores the trees
based on a recursive vector encoding of each node
(le and zuidema, 2014; le and zuidema, 2015; zhu
et al., 2015).

our parser is a greedy, bottom up parser that rely
on compositional vector encodings of subtrees as
its sole set of features. unlike the re-ranking ap-
proaches, we do not rely on an external parser to
provide k-best lists. unlike the bottom-up parser in
(socher et al., 2010) who only parses sentences of
up to 15 words and the parser of (stenetorp, 2013)
who achieves very low parsing accuracies, we parse
arbitrary sentences with near state-of-the-art accu-
racy. unlike the bottom up parser in (socher et al.,
2013a) we do not make use of a grammar. the parser
of (weiss et al., 2015) obtains exceptionally high re-
sults using local features and no composition func-
tion. the greedy version of their parser uses exten-
sive tuning of hyper-parameters and network depth
in order to squeeze every possible bit of accuracy.
adding id125 on top of that further improves
results. due to our much more limited resources,
we did not perform a methodological search over
hyper-parameters, and explored only a tiny space of
the possible hyper-parameters, and our parser does
not perform search. finally, perhaps closest to our
approach is the greedy, transition-based parser of
(dyer et al., 2015) that also works in a bottom-
up fashion, and incorporates an lstm encoding of
the input tokens and hierarchical vector composi-
tion into its scoring mechanism. indeed, that parser
obtains similar scores to ours, although we obtain
somewhat better results when not using pre-trained
embeddings. we differ from the parser of dyer et
al by having a more elaborate vector-composition
function, relying solely on the compositional repre-
sentations, and performing fully bottom-up parsing
without being guided by a stack-and-buffer control
structure.
9 conclusions and future work
we suggest a compositional vector representation of
parse trees that relies on a recursive combination of
recurrent-neural network encoders, and demonstrate
its effectiveness by integrating it in a bottom-up

easy-   rst parser. future extensions in terms of pars-
ing include the addition of id125, handling
of unknown-words using character-embeddings, and
adapting the algorithm to constituency trees. we
also plan to establish the effectiveness of our hierar-
chical tree-lstm encoder by applying it to more
semantic vector representation tasks, i.e.
training
tree representation for capturing sentiment (socher
et al., 2013b; tai et al., 2015), semantic sentence
similarity (marelli et al., 2014) or textual id136
(bowman et al., 2015).
acknowledgements this research is supported by
the intel collaborative research institute for com-
putational intelligence (icri-ci) and the israeli sci-
ence foundation (grant number 1555/15).

references
yoshua bengio, ian j. goodfellow, and aaron courville.
2015. deep learning. book in preparation for mit
press.

samuel r. bowman, gabor angeli, christopher potts,
and christopher d. manning. 2015. a large anno-
tated corpus for learning natural language id136.
in proceedings of the 2015 conference on empirical
methods in natural language processing (emnlp).
association for computational linguistics.

danqi chen and christopher manning. 2014. a fast and
accurate dependency parser using neural networks.
in proceedings of the 2014 conference on empirical
methods in natural language processing (emnlp),
pages 740   750, doha, qatar, october. association for
computational linguistics.

kyunghyun cho.

2015.

derstanding
arxiv:1511.07916 [cs, stat], november.

distributed

with

natural language un-
representation.

michael collins. 1997. three generative, lexicalised
models for statistical parsing. in proceedings of the
35th annual meeting of the association for computa-
tional linguistics, pages 16   23, madrid, spain, july.
association for computational linguistics.

marie-catherine de marneffe and christopher d. man-
ning. 2008. stanford dependencies manual. techni-
cal report, stanford university.

greg durrett and dan klein. 2015. neural crf pars-
ing. in proceedings of the 53rd annual meeting of the
association for computational linguistics and the 7th
international joint conference on natural language
processing (volume 1: long papers), pages 302   312,
beijing, china, july. association for computational
linguistics.

chris dyer, miguel ballesteros, wang ling, austin
matthews, and noah a. smith. 2015. transition-
based id33 with stack long short-
in proceedings of the 53rd annual
term memory.
meeting of the association for computational linguis-
tics and the 7th international joint conference on nat-
ural language processing (volume 1: long papers),
pages 334   343, beijing, china, july. association for
computational linguistics.

chris dyer, adhiguna kuncoro, miguel ballesteros, and
noah a smith. 2016. recurrent neural network gram-
in proceedings of the 2016 conference of the
mars.
north american chapter of the association for com-
putational linguistics: human language technolo-
gies. association for computational linguistics.

jason m. eisner. 1996. three new probabilistic models
for id33: an exploration. in coling
1996 volume 1: the 16th international conference on
computational linguistics.

jason eisner. 2000. bilexical grammars and their cubic-
time parsing algorithms. advances in probabilistic
and other parsing technologies.

jeffrey l. elman. 1990. finding structure in time. cog-

nitive science, 14(2):179   211, march.

yoav goldberg and michael elhadad. 2010. an ef-
   cient algorithm for easy-first non-directional de-
pendency parsing. in human language technologies:
the 2010 annual conference of the north american
chapter of the association for computational linguis-
tics, pages 742   750, los angeles, california, june.
association for computational linguistics.

yoav goldberg and joakim nivre. 2012. a dynamic or-
in proc. of coling

acle for the arc-eager system.
2012.

yoav goldberg and joakim nivre.

train-
ing deterministic parsers with non-deterministic ora-
cles. transactions of the association for computa-
tional linguistics, 1.

2013a.

yoav goldberg and joakim nivre.

2013b. training
deterministic parsers with non-deterministic oracles.
transactions of the association for computational
linguistics, 1(0):403   414, october.

yoav goldberg.

a primer on neural
network models for natural language processing.
arxiv:1510.00726 [cs], october.

2015.

christoph goller and andreas k  chler. 1996. learning
task-dependent distributed representations by back-
in in proc. of the
propagation through structure.
iid98-96, pages 347   352. ieee.

sepp hochreiter and j  rgen schmidhuber. 1997. long
short-term memory. neural computation, 9(8):1735   
1780.

ozan irsoy and claire cardie. 2014. opinion mining
in proceed-
with deep recurrent neural networks.
ings of the 2014 conference on empirical methods in
natural language processing (emnlp), pages 720   
728, doha, qatar, october. association for computa-
tional linguistics.

mohit iyyer, varun manjunatha, jordan boyd-graber,
and hal daum   iii. 2015. deep unordered com-
position rivals syntactic methods for text classi   ca-
tion. in proceedings of the 53rd annual meeting of the
association for computational linguistics and the 7th
international joint conference on natural language
processing (volume 1: long papers), pages 1681   
1691, beijing, china, july. association for computa-
tional linguistics.

diederik kingma and jimmy ba.

2014. adam: a
method for stochastic optimization. arxiv:1412.6980
[cs], december.

ryan kiros, yukun zhu, ruslan r salakhutdinov,
richard zemel, raquel urtasun, antonio torralba,
and sanja fidler. 2015. skip-thought vectors.
in
c. cortes, n. d. lawrence, d. d. lee, m. sugiyama,
and r. garnett, editors, advances in neural infor-
mation processing systems, pages 3294   3302. curran
associates, inc.

phong le and willem zuidema.

sandra k  bler, ryan mcdonald, and joakim nivre.
2008. id33. synthesis lectures on hu-
man language technologies, 2(1):1   127, december.
2014. the inside-
outside id56 model for depen-
dency parsing. in proceedings of the 2014 conference
on empirical methods in natural language process-
ing (emnlp), pages 729   739, doha, qatar, october.
association for computational linguistics.

phong le and willem zuidema. 2015. the forest con-
volutional network: compositional distributional se-
mantics with a neural chart and without binarization.
in proceedings of the 2015 conference on empiri-
cal methods in natural language processing, pages
1155   1164, lisbon, portugal, september. association
for computational linguistics.

wang ling, chris dyer, alan w black, and isabel
2015. two/too simple adaptations of
trancoso.
in proceedings of
id97 for syntax problems.
the 2015 conference of the north american chapter
of the association for computational linguistics: hu-
man language technologies, pages 1299   1304, den-
ver, colorado. association for computational linguis-
tics.

ji ma, tong xiao, jingbo zhu, and feiliang ren. 2012.
easy-first chinese id52 and dependency
in proceedings of coling 2012, pages
parsing.
1731   1746, mumbai, india, december. the coling
2012 organizing committee.

ji ma, jingbo zhu, tong xiao, and nan yang. 2013.
easy-first id52 and id33 with
in proceedings of the 51st annual
id125.
meeting of the association for computational linguis-
tics (volume 2: short papers), pages 110   114, so   a,
bulgaria, august. association for computational lin-
guistics.

mitchell p. marcus, beatrice santorini, and mary ann
marchinkiewicz. 1993. building a large annotated
corpus of english: the id32. computa-
tional linguistics, 19.

marco marelli, luisa bentivogli, marco baroni, raf-
faella bernardi, stefano menini, and roberto zampar-
elli. 2014. semeval-2014 task 1: evaluation of com-
positional distributional semantic models on full sen-
tences through semantic relatedness and textual entail-
ment. in proceedings of the 8th international work-
shop on semantic evaluation (semeval 2014), pages
1   8, dublin, ireland, august. association for compu-
tational linguistics and dublin city university.

andre martins, miguel almeida, and noah a. smith.
2013. turning on the turbo: fast third-order non-
in proceedings of the 51st
projective turbo parsers.
annual meeting of the association for computational
linguistics (volume 2: short papers), pages 617   622,
so   a, bulgaria, august. association for computa-
tional linguistics.

ryan mcdonald. 2006. discriminative training and
spanning tree algorithms for id33.
ph.d. thesis, university of pennsylvania.

tomas mikolov, martin kara     t, lukas burget, jan
re-
cernocky, and sanjeev khudanpur.
current neural network based language model.
in
interspeech 2010, 11th annual conference of
the international speech communication association,
makuhari, chiba, japan, september 26-30, 2010,
pages 1045   1048.

2010.

wenzhe pei, tao ge, and baobao chang. 2015. an ef-
fective neural network model for graph-based de-
pendency parsing. in proceedings of the 53rd annual
meeting of the association for computational linguis-
tics and the 7th international joint conference on nat-
ural language processing (volume 1: long papers),
pages 313   322, beijing, china, july. association for
computational linguistics.

m. schuster and kuldip k. paliwal. 1997. bidirectional
recurrent neural networks. ieee transactions on sig-
nal processing, 45(11):2673   2681, november.

richard socher, christopher manning, and andrew ng.
2010. learning continuous phrase representations
and syntactic parsing with recursive neural net-
in proceedings of the deep learning and
works.
unsupervised id171 workshop of {nips}
2010, pages 1   9.

richard socher, john bauer, christopher d. manning,
and ng andrew y. 2013a. parsing with composi-
in proceedings of the 51st
tional vector grammars.
annual meeting of the association for computational
linguistics (volume 1: long papers), pages 455   465,
so   a, bulgaria, august. association for computa-
tional linguistics.

richard socher, alex perelygin, jean wu, jason chuang,
christopher d. manning, andrew ng, and christo-
pher potts. 2013b. recursive deep models for se-
mantic compositionality over a sentiment treebank.
in proceedings of the 2013 conference on empiri-
cal methods in natural language processing, pages
1631   1642, seattle, washington, usa, october. as-
sociation for computational linguistics.

richard socher. 2014. recursive deep learning for
natural language processing and id161.
ph.d. thesis, stanford university, august.

pontus stenetorp. 2013. transition-based dependency
in deep
parsing using id56s.
learning workshop at the 2013 conference on neural
information processing systems (nips), lake tahoe,
nevada, usa, december.

ilya sutskever, oriol vinyals, and quoc v le. 2014.
sequence to sequence learning with neural networks.
in advances in neural information processing systems,
pages 3104   3112.

2015.

kai sheng tai, richard socher, and christopher d. man-
ning.
improved semantic representations
from tree-structured long short-term memory net-
in proceedings of the 53rd annual meet-
works.
ing of the association for computational linguistics
and the 7th international joint conference on natu-
ral language processing (volume 1: long papers),
pages 1556   1566, beijing, china, july. association
for computational linguistics.

stephen tratz and eduard hovy. 2011. a fast, effective,
non-projective, semantically-enriched parser. in proc.
of emnlp.

taro watanabe and eiichiro sumita. 2015. transition-
based neural constituent parsing. in proceedings of
the 53rd annual meeting of the association for com-
putational linguistics and the 7th international joint
conference on natural language processing (volume
1: long papers), pages 1169   1179, beijing, china,
july. association for computational linguistics.

david weiss, chris alberti, michael collins, and slav
petrov. 2015. structured training for neural network
transition-based parsing. in proceedings of the 53rd
annual meeting of the association for computational
linguistics and the 7th international joint conference
on natural language processing (volume 1: long pa-
pers), pages 323   333, beijing, china, july. associa-
tion for computational linguistics.

yue zhang and stephen clark.

2008. a tale of
two parsers: investigating and combining graph-based
and transition-based id33 using beam-
search. in proc. of emnlp.

yue zhang and joakim nivre. 2011. transition-based
id33 with rich non-local features.
in
proceedings of the 49th annual meeting of the asso-
ciation for computational linguistics: human lan-
guage technologies, pages 188   193.

xingxing zhang, liang lu, and mirella lapata. 2015.
tree recurrent neural networks with application to lan-
guage modeling. arxiv preprint arxiv:1511.00060.

chenxi zhu, xipeng qiu, xinchi chen, and xuanjing
huang. 2015. a re-ranking model for dependency
parser with recursive convolutional neural network.
in proceedings of the 53rd annual meeting of the as-
sociation for computational linguistics and the 7th
international joint conference on natural language
processing (volume 1: long papers), pages 1159   
1168, beijing, china, july. association for computa-
tional linguistics.

appendix: training algorithm pseudocode

algorithm 3 training on annotated corpus
1: input: sentences w1, . . . , wm
2: input: tree annotations t 1, . . . , t m
3: input: number of epochs to train
4: v     initializev ectors()
5: loss     []
6: for epoch     {1, . . . , epochs} do
7:
8:

for s, t     {(w1, t 1), . . . , (wm, t m)} do

loss     t rainsentence (s, v [w1, . . . , wn], t, loss)
if |loss| > 50 then

sumloss     sum(loss)
call adam to minimize sumloss
loss     []

9:
10:
11:
12:

(see algorithm 4, training of a single sentence, on next page.)

algorithm 4 training on a single sentence with dynamic oracle algorithm
1: function trainsentence(w, v, t, loss)
2:
3:
4:
5:

input: sentence w = w1, . . . , wn
input: vectors vi corresponding to inputs wi
input: annotated tree t in the form of (h, m, rel) triplets
input: list loss to which loss expressions are added
for i     1, . . . , n do
unassigned[i]     |children(wi)|
pend[i].id     i
pend[i].el     rn nl.init().append(vi)
pend[i].er     rn nr.init().append(vi)

while |pend| > 1 do
g, w     {} ,{}
for (i, d, rel)     {1     i < |pend|, d     {l, r}, rel     relations} do

if d = l then m, h     pend[i], pend[i + 1]
else m, h     pend[i + 1], pend[i]

if unassigned[m.id] (cid:54)= 0        (cid:96)(cid:54)=rel(h, m, (cid:96))     t then

w.append((h, m, rel))

else g.append((h, m, rel))

hg, mg, relg     argmax(i,d,(cid:96))   gscore(pend, i, d, (cid:96))
hw , mw , relw     argmax(i,d,(cid:96))   w score(pend, i, d, (cid:96))
scoreg     score(hg, mg, relg)
scorew     score(hw , mw , relw )
if scoreg     scorew < 0 then
else if scoreg     scorew > 1     random() < paug then

h, m, rel, score     hw , mw , relw , scorew
h, m, rel, score     hg, mg, relg, scoreg
h, m, rel, score     hw , mw , relw , scorew
loss.append(1     scoreg + score)

if scoreg     score < 1 then

else

m.c = m.el     m.er
m.enc = g(w (m.c     rel) + b)
if h.id < m.id then h.el.append(m.enc)
else h.er.append(m.enc)
unassigned[tp arent(m).id]     unassigned[tp arent(m).id]     1
pend.remove(m)

35:
36:
37: return loss

6:
7:
8:
9:
10:

11:
12:

13:
14:
15:

16:
17:
18:

19:
20:
21:
22:

23:
24:
25:
26:
27:
28:
29:
30:

31:
32:
33:
34:

