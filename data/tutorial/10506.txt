6
1
0
2

 

y
a
m
7
2

 

 
 
]
e
n
.
s
c
[
 
 

3
v
9
0
0
5
0

.

9
0
5
1
:
v
i
x
r
a

on the expressive power of deep learning: a tensor analysis

nadav cohen
or sharir
amnon shashua
the hebrew university of jerusalem

cohennadav@cs.huji.ac.il
or.sharir@cs.huji.ac.il
shashua@cs.huji.ac.il

abstract

it has long been conjectured that hypotheses spaces suitable for data that is compositional in
nature, such as text or images, may be more ef   ciently represented with deep hierarchical networks
than with shallow ones. despite the vast empirical evidence supporting this belief, theoretical
justi   cations to date are limited. in particular, they do not account for the locality, sharing and
pooling constructs of convolutional networks, the most successful deep learning architecture to
date. in this work we derive a deep network architecture based on arithmetic circuits that inherently
employs locality, sharing and pooling. an equivalence between the networks and hierarchical
tensor factorizations is established. we show that a shallow network corresponds to cp (rank-1)
decomposition, whereas a deep network corresponds to hierarchical tucker decomposition. using
tools from measure theory and matrix algebra, we prove that besides a negligible set, all functions
that can be implemented by a deep network of polynomial size, require exponential size in order to
be realized (or even approximated) by a shallow network. since log-space computation transforms
our networks into simnets, the result applies directly to a deep learning architecture demonstrating
promising empirical performance. the construction and theory developed in this paper shed new
light on various practices and ideas employed by the deep learning community.
keywords: deep learning, expressive power, arithmetic circuits, tensor decompositions

1. introduction
the expressive power of neural networks is achieved through depth. there is mounting empirical
evidence that for a given budget of resources (e.g. neurons), the deeper one goes, the better the
eventual performance will be. however, existing theoretical arguments that support this empirical
   nding are limited. there have been many attempts to theoretically analyze function spaces gen-
erated by network architectures, and their dependency on network depth and size. the prominent
approach for justifying the power of depth is to show that deep networks can ef   ciently express
functions that would require shallow networks to have super-polynomial size. we refer to such
scenarios as instances of depth ef   ciency. unfortunately, existing results dealing with depth ef   -
ciency (e.g. hastad (1986); h  astad and goldmann (1991); delalleau and bengio (2011); martens
and medabalimi (2014)) typically apply to speci   c network architectures that do not resemble ones
commonly used in practice. in particular, none of these results apply to convolutional networks
(lecun and bengio (1995)), which represent the most empirically successful and widely used deep
learning architecture to date. a further limitation of current results is that they merely show ex-
istence of depth ef   ciency (i.e. of functions that are ef   ciently realizable with a certain depth but
cannot be ef   ciently realized with shallower depths), without providing any information as to how
frequent this property is. these shortcomings of current theory are the ones that motivated our work.

c(cid:13) n. cohen, o. sharir & a. shashua.

cohen sharir shashua

the architectural features that specialize convolutional networks compared to classic feed-
forward fully-connected networks are threefold. the    rst feature, locality, refers to the connection
of a neuron only to neighboring neurons in the preceding layer, as opposed to having the entire
layer drive it. in the context of image processing (the most common application of convolutional
networks), locality is believed to re   ect the inherent compositional structure of data     the closer
pixels are in an image, the more likely they are to be correlated. the second architectural feature of
convolutional networks is sharing, which means that different neurons in the same layer, connected
to different neighborhoods in the preceding layer, share the same weights. sharing, which together
with locality gives rise to convolution, is motivated by the fact that in natural images, the semantic
meaning of a pattern often does not depend on its location (i.e. two identical patterns appearing in
different locations of an image often convey the same semantic content). finally, the third archi-
tectural idea of convolutional networks is pooling, which is essentially an operator that decimates
layers, replacing neural activations in a spatial window by a single value (e.g. their maximum or
average). in the context of images, pooling induces invariance to translations (which often do not
affect semantic content), and in addition is believed to create a hierarchy of abstraction in the pat-
terns neurons respond to. the three architectural elements of locality, sharing and pooling, which
have facilitated the great success of convolutional networks, are all lacking in existing theoretical
studies of depth ef   ciency.

in this paper we introduce a convolutional arithmetic circuit architecture that incorporates lo-
cality, sharing and pooling. arithmetic circuits (also known as sum-product networks, poon and
domingos (2011)) are networks with two types of nodes: sum nodes, which compute a weighted
sum of their inputs, and product nodes, computing the product of their inputs. we use sum nodes to
implement convolutions (locality with sharing), and product nodes to realize pooling. the models
we arrive at may be viewed as convolutional networks with product pooling and linear point-wise ac-
tivation. they are attractive on three accounts. first, as discussed in app. e, convolutional arithmetic
circuits are equivalent to simnets, a new deep learning architecture that has recently demonstrated
promising empirical results on various image recognition benchmarks (cohen et al. (2016)). sec-
ond, as we show in sec. 3, convolutional arithmetic circuits are realizations of hierarchical tensor
decompositions (see hackbusch (2012)), opening the door to various mathematical and algorithmic
tools for their analysis and implementation. third, the depth ef   ciency of convolutional arithmetic
circuits, which we analyze in sec. 4, was shown in the subsequent work of cohen and shashua
(2016) to be superior to the depth ef   ciency of the popular convolutional recti   er networks, namely
convolutional networks with recti   ed linear (relu) activation and max or average pooling.

employing machinery from measure theory and matrix algebra, made available through their
connection to hierarchical tensor decompositions, we prove a number of fundamental results con-
cerning the depth ef   ciency of our convolutional arithmetic circuits. our main theoretical result
(thm. 1 and corollary 2) states that besides a negligible (zero measure) set, all functions that can
be realized by a deep network of polynomial size, require exponential size in order to be realized,
or even approximated, by a shallow network. when translated to the viewpoint of tensor decom-
positions, this implies that almost all tensors realized by hierarchical tucker (ht) decomposition
(hackbusch and k  uhn (2009)) cannot be ef   ciently realized by the classic cp (rank-1) decompo-
sition. to the best of our knowledge, this result is unknown to the tensor analysis community, in
which the advantage of ht over cp is typically demonstrated through speci   c examples of tensors
that can be ef   ciently realized by the former and not by the latter. following our main result, we
present a generalization (thm. 3 and corollary 4) that compares networks of arbitrary depths, show-

2

on the expressive power of deep learning: a tensor analysis

ing that the amount of resources one has to pay in order to maintain representational power while
trimming down layers of a network grows double exponentially w.r.t. the number of layers cut off.
we also characterize cases in which dropping a single layer bears an exponential price.

the remainder of the paper is organized as follows. in sec. 2 we brie   y review notations and
mathematical background required in order to follow our work. this is followed by sec. 3, which
presents our convolutional arithmetic circuits and establishes their equivalence with tensor decom-
positions. our theoretical analysis is covered in sec. 4. finally, sec. 5 concludes. in order to keep
the manuscript at a reasonable length, we defer our detailed survey of related work to app. d, cov-
ering works on the depth ef   ciency of boolean circuits, arithmetic circuits and neural networks, as
well as different applications of tensor analysis in the    eld of deep learning.

2. preliminaries
we begin by establishing notational conventions that will be used throughout the paper. we denote
vectors using bold typeface, e.g. v     rs. the coordinates of such a vector are referenced with
regular typeface and a subscript, e.g. vi     r. this is not to be confused with bold typeface and a
subscript, e.g. vi     rs, which represents a vector that belongs to some sequence. tensors (multi-
dimensional arrays) are denoted by the letters    a    and    b    in calligraphic typeface, e.g. a,b    
rm1          mn . a speci   c entry in a tensor will be referenced with subscripts, e.g. ad1...dn     r.
superscripts will be used to denote individual objects within a collection. for example, v(i) stands
for vector i and ay stands for tensor y. in cases where the collection of interest is indexed by
multiple coordinates, we will have multiple superscripts referencing individual objects, e.g. al,j,  
will stand for vector (l, j,   ). as shorthand for the cartesian product of the euclidean space rs with
itself n times, we will use the notation (rs)n . finally, for a positive integer k we use the shorthand
[k] to denote the set {1, . . . , k}.

we now turn to establish a baseline, i.e. to present basic de   nitions and results, in the broad and
comprehensive    eld of tensor analysis. we list here only the essentials required in order to follow
the paper, referring the interested reader to hackbusch (2012) for a more complete introduction to
the    eld 1. the most straightforward way to view a tensor is simply as a multi-dimensional array:
ad1,...,dn     r where i     [n ], di     [mi]. the number of indexing entries in the array, which are
also called modes, is referred to as the order of the tensor. the term dimension stands for the number
of values an index can take in a particular mode. for example, the tensor a appearing above has
order n and dimension mi in mode i, i     [n ]. the space of all possible con   gurations a can take
is called a tensor space and is denoted, quite naturally, by rm1          mn .
a central operator in tensor analysis is the tensor product, denoted    . this operator intakes
two tensors a and b of orders p and q respectively, and returns a tensor a     b of order p + q,
de   ned by: (a     b)d1...dp +q
= ad1...dp    bdp +1...dp +q. notice that in the case p = q = 1, the
tensor product reduces to an outer product between vectors. speci   cally, v    u     the tensor product
between u     rm1 and v     rm2, is no other than the rank-1 matrix vu(cid:62)     rm1  m2. in this
i=1 v(i) to denote the joint tensor product v(1)            v(n ).
context, we will often use the shorthand    n
i=1 v(i) are called pure or elementary, and are regarded as having rank-1
(assuming v(i) (cid:54)= 0    i). it is not dif   cult to see that any tensor can be expressed as a sum of rank-1
1. the de   nitions we give are concrete special cases of the more abstract algebraic de   nitions given in hackbusch

tensors of the form    n

(2012). we limit the discussion to these special cases since they suf   ce for our needs and are easier to grasp.

3

cohen sharir shashua

tensors:

z(cid:88)

a =

z                v(n )
v(1)

z

, v(i)

z     rmi

(1)

z=1

a representation as above is called a candecomp/parafac decomposition of a, or in short,
a cp decomposition 2. the cp-rank of a is de   ned as the minimum number of terms in a cp
decomposition, i.e. as the minimal z for which eq. 1 can hold. notice that for a tensor of order 2,
i.e. a matrix, this de   nition of cp-rank coincides with that of standard matrix rank.
a symmetric tensor is one that is invariant to permutations of its indices. formally, a ten-
sor a of order n which is symmetric will have equal dimension m in all modes, and for ev-
ery permutation    : [n ]     [n ] and indices d1. . .dn     [m ], the following equality will hold:
ad  (1)...d  (n ) = ad1...dn . note that for a vector v     rm , the tensor    n
i=1 v     rm          m is
symmetric. moreover, every symmetric tensor may be expressed as a linear combination of such
z=1   z    vz                vz. this is referred to as a symmetric cp
decomposition, and the symmetric cp-rank is the minimal z for which such a decomposition exists.
since a symmetric cp decomposition is in particular a standard cp decomposition, the symmetric
cp-rank of a symmetric tensor is always greater or equal to its standard cp-rank. note that for the
case of symmetric matrices (order-2 tensors) the symmetric cp-rank and the original cp-rank are
always equal.

(symmetric rank-1) tensors: a =(cid:80)z

a repeating concept in this paper is that of measure zero. more broadly, our analysis is framed
in measure theoretical terms. while an introduction to the    eld is beyond the scope of the paper (the
interested reader is referred to jones (2001)), it is possible to intuitively grasp the ideas that form the
basis to our claims. when dealing with subsets of a euclidean space, the standard and most natural
measure in a sense is called the lebesgue measure. this is the only measure we consider in our
analysis. a set of (lebesgue) measure zero can be thought of as having zero    volume    in the space
of interest. for example, the interval between (0, 0) and (1, 0) has zero measure as a subset of the
2d plane, but has positive measure as a subset of the 1d x-axis. an alternative way to view a zero
measure set s follows the property that if one draws a random point in space by some continuous
distribution, the id203 of that point hitting s is necessarily zero. a related term that will be
used throughout the paper is almost everywhere, which refers to an entire space excluding, at most,
a set of zero measure.

3. convolutional arithmetic circuits
we consider the task of classifying an instance x = (x1, . . . , xn ), xi     rs, into one of the
categories y := {1, . . . , y }. representing instances as collections of vectors is natural in many
applications. in the case of image processing for example, x may correspond to an image, and
x1 . . . xn may correspond to vector arrangements of (possibly overlapping) patches around pix-
els. as customary, classi   cation is carried out through maximization of per-label score func-
tions {hy}y   y, i.e. the predicted label for the instance x will be the index y     y for which the
score value hy(x) is maximal. our attention is thus directed to functions over the instance space
x := {(x1, . . . , xn ) : xi     rs} = (rs)n . we de   ne our hypotheses space through the following
2. cp decomposition is regarded as the classic and most basic tensor decomposition, dating back to the beginning of

the 20   th century (see kolda and bader (2009) for a historic survey).

4

on the expressive power of deep learning: a tensor analysis

figure 1: cp model     convolutional arithmetic circuit implementing cp (rank-1) decomposition.

representation of score functions:

hy (x1, . . . , xn ) =

m(cid:88)

d1...dn =1

ay

d1,...,dn

n(cid:89)

i=1

f  di

(xi)

(2)

product functions {(x1, . . . , xn ) (cid:55)    (cid:81)n

f  1. . .f  m : rs     r are referred to as representation functions, selected from a parametric family
f = {f   : rs     r}       . natural choices for this family are wavelets, radial basis functions (gaus-
sians), and af   ne functions followed by point-wise activation (neurons). the coef   cient tensor ay
has order n and dimension m in each mode. its entries correspond to a basis of m n point-wise
(xi)}d1...dn   [m ]. we will often consider    xed lin-
early independent representation functions f  1. . .f  m . in this case the point-wise product functions
are linearly independent as well (see app. c.1), and we have a one to one correspondence between
score functions and coef   cient tensors. to keep the manuscript concise, we defer the derivation of
our hypotheses space (eq. 2) to app. c, noting here that it arises naturally from the notion of tensor
products between l2 spaces.

i=1 f  di

our eventual aim is to realize score functions hy with a layered network architecture. as a
   rst step along this path, we notice that hy(x1, . . . , xn ) is fully determined by the activations of
the m representation functions f  1. . .f  m on the n input vectors x1. . .xn . in other words, given
{f  d(xi)}d   [m ],i   [n ], the score hy(x1, . . . , xn ) is independent of the input. it is thus natural to con-
sider the computation of these m  n numbers as the    rst layer of our networks. this layer, referred
to as the representation layer, may be conceived as a convolutional operator with m channels, each
corresponding to a different function applied to all input vectors (see    g. 1).
once we have constrained our score functions to have the structure depicted in eq. 2, learning
a classi   er reduces to estimation of the parameters   1. . .  m , and the coef   cient tensors a1. . .ay .
the computational challenge is that the latter tensors are of order n (and dimension m in each
mode), having an exponential number of entries (m n each). in the next subsections we utilize
tensor decompositions (factorizations) to address this computational challenge, and show how they
are naturally realized by convolutional arithmetic circuits.

5

            ,direpidf      xinputrepresentation1x1 convglobal poolingdense (output)hidden layerixmzzy            ,,,,:ziconvizrepi   a            1,nipoolzconviz                     ,:youtypool   axcohen sharir shashua

z(cid:88)

z=1

3.1. shallow network as a cp decomposition of ay
the most straightforward way to factorize a tensor is through a cp (rank-1) decomposition (see
sec. 2). consider a joint cp decomposition for the coef   cient tensors {ay}y   y:

ay =

z    az,1                az,n
ay

(3)

where ay     rz for y     y (ay
z stands for entry z of ay), and az,i     rm for i     [n ], z     [z]. the
decomposition is joint in the sense that the same vectors az,i are shared across all classes y. clearly,
if we set z = m n this model is universal, i.e. any tensors a1. . .ay may be represented.

substituting our cp decomposition (eq. 3) into the expression for the score functions in eq. 2,

we obtain:

hy(x) =

(cid:32) m(cid:88)

n(cid:89)

z(cid:88)

ay
z

(cid:33)

az,i
d f  d(xi)

z=1

i=1

d=1

from this we conclude that the network illustrated in    g. 1 implements a classi   er (score functions)
under the cp decomposition in eq. 3. we refer to this network as cp model. the network consists
of a representation layer followed by a single hidden layer, which in turn is followed by the output.
the hidden layer begins with a 1    1 conv operator, which is simply a 3d convolution with z
channels and receptive    eld 1   1. the convolution may operate without coef   cient sharing, i.e. the
   lters that generate feature maps by sliding across the previous layer may have different coef   cients
at different spatial locations. this is often referred to in the deep learning community as a locally-
connected operator (see taigman et al. (2014)). to obtain a standard convolutional operator, simply
enforce coef   cient sharing by constraining the vectors az,i in the cp decomposition (eq. 3) to be
equal to each other for different values of i (this setting is discussed in sec. 3.3). following conv
operator, the hidden layer includes global product pooling. feature maps generated by conv are
reduced to singletons through multiplication of their entries, creating a vector of dimension z. this
vector is then mapped into the y network outputs through a    nal dense linear layer.

to recap, cp model (   g. 1) is a shallow (single hidden layer) convolutional arithmetic circuit
that realizes the cp decomposition (eq. 3). it is universal, i.e. it can realize any coef   cient tensors
with large enough size (z). unfortunately, since the cp-rank of a generic tensor is exponential in
its order (see hackbusch (2012)), the size required for cp model to be universal is exponential (z
exponential in n).
3.2. deep network as a hierarchical decomposition of ay
in this subsection we present a deep network that corresponds to the recently introduced hierar-
chical tucker tensor decomposition (hackbusch and k  uhn (2009)), which we refer to in short as
ht decomposition. the network, dubbed ht model, is universal. speci   cally, any set of tensors
ay represented by cp model can be represented by ht model with only a polynomial penalty in
terms of resources. the advantage of ht model, as we show in sec. 4, is that in almost all cases
it generates tensors that require an exponential size in order to be realized, or even approximated,
by cp model. put differently, if one draws the weights of ht model by some continuous distribu-
tion, with id203 one, the resulting tensors cannot be approximated by a polynomial cp model.
informally, this implies that ht model is exponentially more expressive than cp model.

6

on the expressive power of deep learning: a tensor analysis

figure 2: ht model     convolutional arithmetic circuit implementing hierarchical decomposition.

ht model is based on the hierarchical tensor decomposition in eq. 4, which is a special case
of the ht decomposition as presented in hackbusch and k  uhn (2009) (in the latter   s terminology,
we restrict the matrices al,j,   to be diagonal). our construction and theoretical results apply to the
general ht decomposition as well, with the specialization done merely to bring forth a network that
resembles current convolutional networks 3.

  1,j,   =
      

  l,j,   =
      
  l   1,j,   =

ay =

  =1

r0(cid:88)
rl   1(cid:88)
rl   2(cid:88)
rl   1(cid:88)

  =1

  =1

  =1

a0,2j   1,       a0,2j,  

a1,j,  
  

(cid:124)
(cid:123)(cid:122)
(cid:125)
     l   1,2j   1,  
al,j,  
order 2l   1
(cid:124)
(cid:123)(cid:122)
(cid:124) (cid:123)(cid:122) (cid:125)
     l   1,1,  
al,y

al   1,j,  

  

      l   1,2j,  
order 2l   1

(cid:124) (cid:123)(cid:122) (cid:125)
(cid:123)(cid:122)
(cid:124)
(cid:125)
(cid:124) (cid:123)(cid:122) (cid:125)

  l   2,2j   1,  

      l   1,2,  
order n
2

order n
4

order n
2

      l   2,2j,  
order n
4

(cid:125)

(4)

the decomposition in eq. 4 recursively constructs the coef   cient tensors {ay}y   [y ] by assem-
bling vectors {a0,j,  }j   [n ],     [r0] into tensors {  l,j,  }l   [l   1],j   [n/2l],     [rl] in an incremental fashion.
the index l stands for the level in the decomposition, j represents the    location    within level l, and
   corresponds to the individual tensor in level l and location j. rl is referred to as level-l rank,
and is de   ned to be the number of tensors in each location of level l (we denote for completeness
rl := y ). the tensor   l,j,   has order 2l, and we assume for simplicity that n     the order of ay,
is a power of 2 (this is merely a technical assumption also made in hackbusch and k  uhn (2009), it
does not limit the generality of our analysis).
the parameters of the decomposition are the    nal level weights {al,y     rrl   1}y   [y ], the in-
termediate levels    weights {al,j,       rrl   1}l   [l   1],j   [n/2l],     [rl], and the    rst level vectors {a0,j,      
2l    rl   1    rl + y    rl   1 individual parame-

rm}j   [n ],     [r0]. this totals at n    m    r0 +(cid:80)l   1

l=1

n

3. if we had not constrained al,j,   to be diagonal, pooling operations would involve entries from different channels.

7

            ,direpidf      xinputrepresentation1x1 convpooling1x1 convpoolingdense (output)hidden layer 0hidden layer l-1(l=log2n)ixm0r0r1lr   1lr   y            0,,0,,,:jconvjrepj         a                  00'21,2,',jjjpooljconvj                                    11'1,2',lljpoolconvj                                 ,1,:lyloutypool      axcohen sharir shashua

ters, and if we assume equal ranks r := r0 =        = rl   1, the number of parameters becomes
n    m    r + n    r2 + y    r.

the hierarchical decomposition (eq. 4) is universal, i.e. with large enough ranks rl it can rep-
resent any tensors. moreover, it is a super-set of the cp decomposition (eq. 3). that is to say,
all tensors representable by a cp decomposition having z components are also representable by a
hierarchical decomposition with ranks r0 = r1 =        = rl   1 = z 4. note that this comes with
a polynomial penalty     the number of parameters increases from n    m    z + z    y in the cp
decomposition, to n    m    z + z    y + n    z2 in the hierarchical decomposition. however, as we
show in sec. 4, the gain in expressive power is exponential.
plugging the expression for ay in our hierarchical decomposition (eq. 4) into the score function
hy given in eq. 2, we obtain the network displayed in    g. 2     ht model. this network includes a
representation layer followed by l = log2 n hidden layers which in turn are followed by the output.
as in the shallow cp model (   g. 1), the hidden layers consist of 1    1 conv operators followed by
product pooling. the difference is that instead of a single hidden layer collapsing the entire spatial
structure through global pooling, hidden layers now pool over size-2 windows, decimating feature
maps by a factor of two (no overlaps). after l = log2 n such layers feature maps are reduced to
singletons, and we arrive at a 1d structure with rl   1 nodes. this is then mapped into y network
outputs through a    nal dense linear layer. we note that the network   s size-2 pooling windows (and
the resulting number of hidden layers l = log2 n) correspond to the fact that our hierarchical
decomposition (eq. 4) is based on a full binary tree over modes, i.e. it combines (through tensor
product) two tensors at a time. we focus on this setting solely for simplicity of presentation, and
since it is the one presented in hackbusch and k  uhn (2009). our analysis (sec. 4) could easily be
adapted to hierarchical decompositions based on other trees (taking tensor products between more
than two tensors at a time), and that would correspond to networks with different pooling window
sizes and resulting depths.
ht model (   g. 2) is conceptually divided into two parts. the    rst is the representation layer,
transforming input vectors x1. . .xn into n  m real-valued scalars {f  d(xi)}i   [n ],d   [m ]. the sec-
ond and main part of the network, which we view as an    id136    engine, is the convolutional
arithmetic circuit that takes the n  m measurements produced by the representation layer, and ac-
cordingly computes y class scores at the output layer.
to recap, we have now a deep network (   g. 2), which we refer to as ht model, that computes
the score functions hy (eq. 2) with coef   cient tensors ay hierarchically decomposed as in eq. 4.
the network is universal in the sense that with enough channels rl, any tensors may be represented.
moreover, the model is a super-set of the shallow cp model presented in sec. 3.1. the question of
depth ef   ciency now naturally arises. in particular, we would like to know if there are functions that
may be represented by a polynomially sized deep ht model, yet require exponential size from the
shallow cp model. the answer, as described in sec. 4, is that almost all functions realizable by ht
model meet this property. in other words, the set of functions realizable by a polynomial cp model
has measure zero in the space of functions realizable by a given polynomial ht model.

4. to see this, simply assign the    rst level vectors a0,j,   with cp   s basis vectors, the last level weights with cp   s

per-class weights, and the intermediate levels    weights with indicator vectors.

8

on the expressive power of deep learning: a tensor analysis

3.3. shared coef   cients for convolution
the 1    1 conv operator in our networks (see    g. 1 and 2) implements a local linear transformation
with coef   cients generally being location-dependent. in the special case where coef   cients do not
depend on location, i.e. remain    xed across space, the local linear transformation becomes a stan-
dard convolution. we refer to this setting as coef   cient sharing. sharing is a widely used structural
constraint, one of the pillars behind the successful convolutional network architecture. in the con-
text of image processing (prominent application of convolutional networks), sharing is motivated by
the observation that in natural images, the semantic content of a pattern often does not depend on its
location. in this subsection we explore the effect of sharing on the expressiveness of our networks,
or more speci   cally, on the coef   cient tensors ay they can represent.
for cp model, coef   cient sharing amounts to setting az := az,1 =        = az,n in the cp

decomposition (eq. 3), transforming the latter to a symmetric cp decomposition:

z(cid:88)

z=1

ay =

(cid:124)
(cid:125)
z    az                az
ay

(cid:123)(cid:122)

n times

, az     rm , ay     rz

cp model with sharing is not universal (not all tensors ay are representable, no matter how large z
is allowed to be)     it can only represent symmetric tensors.
in the case of ht model, sharing amounts to applying the following constraints on the hierarchi-
cal decomposition in eq. 4: al,   := al,1,   =        = al,n/2l,   for every l = 0. . .l     1 and    = 1. . .rl.
note that in this case universality is lost as well, but nonetheless generated tensors are not limited
to be symmetric, already demonstrating an expressive advantage of deep models over shallow ones.
in sec. 4 we take this further by showing that the shared ht model is exponentially more expressive
than cp model, even if the latter is not constrained by sharing.

4. theorems of network capacity
the    rst contribution of this paper, presented in sec. 3, is the equivalence between deep learning
architectures successfully employed in practice, and tensor decompositions. namely, we showed
that convolutional arithmetic circuits as in    g. 2, which are in fact simnets that have demonstrated
promising empirical performance (see app. e), may be formulated as hierarchical tensor decompo-
sitions. as a second contribution, we make use of the established link between arithmetic circuits
and tensor decompositions, combining theoretical tools from these two worlds, to prove results that
are of interest to both deep learning and tensor analysis communities. this is the focus of the current
section.

the fundamental theoretical result proven in this paper is the following:

theorem 1 let ay be a tensor of order n and dimension m in each mode, generated by the
recursive formulas in eq. 4. de   ne r := min{r0, m}, and consider the space of all possible
con   gurations for the parameters of the composition     {al,j,  }l,j,  . in this space, the generated
tensor ay will have cp-rank of at least rn/2 almost everywhere (w.r.t. lebesgue measure). put
differently, the con   gurations for which the cp-rank of ay is less than rn/2 form a set of measure
zero. the exact same result holds if we constrain the composition to be    shared   , i.e. set al,j,      
al,   and consider the space of {al,  }l,   con   gurations.

from the perspective of deep learning, thm. 1 leads to the following corollary:

9

cohen sharir shashua

corollary 2 given linearly independent representation functions {f  d}d   [m ], randomizing the
weights of ht model (sec. 3.2) by a continuous distribution induces score functions hy that with
id203 one, cannot be approximated arbitrarily well (in l2 sense) by a cp model (sec. 3.1)
with less than min{r0, m}n/2 hidden channels. this result holds even if we constrain ht model
with weight sharing (sec. 3.3) while leaving cp model in its general form.

that is to say, besides a negligible set, all functions that can be realized by a polynomially sized
ht model (with or without weight sharing), require exponential size in order to be realized, or even
approximated, by cp model. most of the previous works relating to depth ef   ciency (see app. d)
merely show existence of functions that separate depths (i.e. that are ef   ciently realizable by a deep
network yet require super-polynomial size from shallow networks). corollary 2 on the other hand
establishes depth ef   ciency for almost all functions that a deep network can implement. equally
importantly, it applies to deep learning architectures that are being successfully employed in practice
(simnets     see app. e).

adopting the viewpoint of tensor analysis, thm. 1 states that besides a negligible set, all tensors
realized by ht (hierarchical tucker) decomposition cannot be represented by the classic cp (rank-
1) decomposition if the latter has less than an exponential number of terms 5. to the best of our
knowledge, this result has never been proved in the tensor analysis community.
in the original
paper introducing ht decomposition (hackbusch and k  uhn (2009)), as a motivating example, the
authors present a speci   c tensor that is ef   ciently realizable by ht decomposition while requiring
an exponential number of terms from cp decomposition 6. our result strengthens this motivation
considerably, showing that it is not just one speci   c tensor that favors ht over cp, but rather, almost
all tensors realizable by ht exhibit this preference. taking into account that any tensor realized by
cp can also be realized by ht with only a polynomial penalty in the number of parameters (see
sec. 3.2), this implies that in an asymptotic sense, ht decomposition is exponentially more ef   cient
than cp decomposition.

4.1. proof sketches
the complete proofs of thm. 1 and corollary 2 are given in app. b. we provide here an outline of
the main tools employed and arguments made along these proofs.

to prove thm. 1 we combine approaches from the worlds of circuit complexity and tensor de-
compositions. the    rst class of machinery we employ is matrix algebra, which has proven to be a
powerful source of tools for analyzing the complexity of circuits. for example, arithmetic circuits
have been analyzed through what is called the partial derivative matrix (see raz and yehudayoff
(2009)), and for boolean circuits a widely used tool is the communication matrix (see karchmer
(1989)). we gain access to matrix algebra by arranging tensors that take part in the cp and ht
decompositions as matrices, a process often referred to as matricization. with matricization, the
tensor product translates to the kronecker product, and the properties of the latter become readily
available. the second tool-set we make use of is measure theory, which prevails in the study of ten-
sor decompositions, but is much less frequent in analyses of circuit complexity. in order to frame

5. as stated in sec. 3.2, the decomposition in eq. 4 to which thm. 1 applies is actually a special case of ht decomposition
as introduced in hackbusch and k  uhn (2009). however, the theorem and its proof can easily be adapted to account
for the general case. we focus on the special case merely because it corresponds to convolutional arithmetic circuit
architectures used in practice.

6. the same motivating example is given in a more recent textbook introducing tensor analysis (hackbusch (2012)).

10

on the expressive power of deep learning: a tensor analysis

a problem in measure theoretical terms, one obviously needs to de   ne a measure space of inter-
est. for tensor decompositions, the straightforward space to focus on is that of the decomposition
variables. for general circuits on the other hand, it is often unclear if de   ning a measure space is
at all appropriate. however, when circuits are considered in the context of machine learning they
are usually parameterized, and de   ning a measure space on top of these parameters is an effective
approach for studying the prevalence of various properties in hypotheses spaces.

our proof of thm. 1 traverses through the following path. we begin by showing that matricizing
a rank-1 tensor produces a rank-1 matrix. this implies that the matricization of a tensor generated by
a cp decomposition with z terms has rank at most z. we then turn to show that the matricization
of a tensor generated by the ht decomposition in eq. 4 has rank at least min{r0, m}n/2 almost
everywhere. this is done through induction over the levels of the decomposition (l = 1. . .l). for
the    rst level (l = 1), we use a combination of measure theoretical and id202ic arguments
to show that the generated matrices have maximal rank (min{r0, m}) almost everywhere. for the
induction step, the facts that under matricization tensor product translates into kronecker product,
and that the latter increases ranks multiplicatively 7, imply that matricization ranks in the current
level are generally equal to those in the previous level squared. measure theoretical claims are then
made to ensure that this indeed takes place almost everywhere.

to prove corollary 2 based on thm. 1, we need to show that the inability of cp model to realize a
tensor generated by ht model, implies that the former cannot approximate score functions produced
by the latter. in general, the set of tensors expressible by a cp decomposition is not topologically
closed 8, which implies that a-priori, it may be that cp model can approximate tensors generated
by ht model even though it cannot realize them. however, since the proof of thm. 1 was achieved
through separation of matrix rank, distances are indeed positive and cp model cannot approximate
ht model   s tensors almost always. to translate from tensors to score functions, we simply note
that in a    nite-dimensional hilbert space convergence in norm implies convergence in coef   cients
under any basis. therefore, in the space of score functions (eq. 2) convergence in norm implies
(xi)}d1...dn   [m ]. that is to

convergence in coef   cients under the basis {(x1, . . . , xn )(cid:55)   (cid:81)n

i=1 f  di

say, it implies convergence in coef   cient tensors.

4.2. generalization
thm. 1 and corollary 2 compare the expressive power of the deep ht model (sec. 3.2) to that of
the shallow cp model (sec. 3.1). one may argue that such an analysis is lacking, as it does not
convey information regarding the importance of each individual layer. in particular, it does not shed
light on the advantage of very deep networks, which at present provide state of the art recognition
accuracy, compared to networks of more moderate depth. for this purpose we present a generaliza-
tion, specifying the amount of resources one has to pay in order to maintain representational power
while layers are incrementally cut off from a deep network. for conciseness we defer this analysis
to app. a, and merely state here our    nal conclusions. we    nd that the representational penalty is
double exponential w.r.t. the number of layers removed. in addition, there are certain cases where
the removal of even a single layer leads to an exponential in   ation, falling in line with the suggestion
of bengio (2009).
7. if (cid:12) denotes the kronecker product, then for any matrices a and b: rank(a(cid:12)b) = rank(a)  rank(b).
8. hence the de   nition of border rank, see hackbusch (2012).

11

cohen sharir shashua

5. discussion
in this work we address a fundamental issue in deep learning     the expressive ef   ciency of depth.
there have been many attempts to theoretically analyze this question, but from a practical machine
learning perspective, existing results are limited. most of the results apply to very speci   c types of
networks that do not resemble ones used in practice, and none of the results account for the locality-
sharing-pooling paradigm which forms the basis for convolutional networks     the most successful
deep learning architecture to date. in addition, current analyses merely show existence of depth
ef   ciency, i.e. of functions that are ef   ciently realizable by deep networks but not by shallow ones.
the practical implications of such    ndings are arguably slight, as a-priori, it may be that only a
small fraction of the functions realizable by deep networks enjoy depth ef   ciency, and for all the
rest shallow networks suf   ce.

our aim in this paper was to develop a theory that facilitates an analysis of depth ef   ciency for
networks that incorporate the widely used structural ingredients of locality, sharing and pooling.
we consider the task of classi   cation into one of a    nite set of categories y = {1. . .y }. our
instance space is de   ned to be the cartesian product of n vector spaces, in compliance with the
common practice of representing natural data through ordered local structures (e.g. images through
patches). each of the n vectors that compose an instance is represented by a descriptor of length m,
generated by running the vector through m    representation    functions. as customary, classi   cation
is achieved through maximization of score functions hy, one for every category y     y. each score
function is a linear combination over the m n possible products that may be formed by taking one
descriptor entry from every input vector. the coef   cients for these linear combinations conveniently
reside in tensors ay of order n and dimension m along each axis. we construct networks that
compute score functions hy by decomposing (factorizing) the coef   cient tensors ay. the resulting
networks are convolutional arithmetic circuits that incorporate locality, sharing and pooling, and
operate on the n  m descriptor entries generated from the input.

we show that a shallow (single hidden layer) network realizes the classic cp (rank-1) tensor
decomposition, whereas a deep network with log2 n hidden layers realizes the recently introduced
hierarchical tucker (ht) decomposition (hackbusch and k  uhn (2009)). our fundamental result,
presented in thm. 1 and corollary 2, states that randomizing the weights of a deep network by some
continuous distribution will lead, with id203 one, to score functions that cannot be approx-
imated by a shallow network if the latter   s size is not exponential (in n). we extend this result
(thm. 3 and corollary 4) by deriving analogous claims that compare two networks of any depths, not
just deep vs. shallow.

to further highlight the connection between our networks and ones used in practice, we show
(app. e) that translating convolution and product pooling computations to log-space (for numerical
stability) gives rise to simnets     a recently proposed deep learning architecture which has been
shown to produce state of the art accuracy in computationally limited settings (cohen et al. (2016)).

besides the central line of our work discussed above, the construction and theory presented in
this paper shed light on various conjectures and practices employed by the deep learning community.
first, with respect to the pooling operation, our analysis points to the possibility that perhaps it has
more to do with factorization of computed functions than it does with translation invariance. this
may serve as an explanation for the fact that pooling windows in state of the art convolutional
networks are typically very small (see for example simonyan and zisserman (2014)), often much
smaller than the radius of translation one would like to be invariant to. indeed, in our framework, as

12

on the expressive power of deep learning: a tensor analysis

we show in app. a, pooling over large windows and trimming down a network   s depth may bring to
an exponential decrease in expressive ef   ciency.

the second point our theory sheds light on is sharing. as discussed in sec. 3.3, introducing
weight sharing to a shallow network (cp model) considerably limits its expressive power. the net-
work can only represent symmetric tensors, which in turn means that it is location invariant w.r.t.
input vectors (patches). in the case of a deep network (ht model) the limitation posed by sharing is
not as strict. generated tensors need not be symmetric, implying that the network is capable of mod-
eling location     a crucial ability in almost any real-world task. the above    ndings suggest that the
sharing constraint is increasingly limiting as a network gets shallower, to the point where it causes
complete ignorance to location. this could serve as an argument supporting the empirical success
of deep convolutional networks     they bind together the statistical and computational advantages of
sharing with many layers that mitigate its expressive limitations.
lastly, our construction advocates locality, or more speci   cally, 1    1 receptive    elds. recent
convolutional networks providing state of the art recognition performance (e.g. lin et al. (2014);
szegedy et al. (2015)) make extensive use of 1    1 linear transformations, proving them to be
very successful in practice. in view of our model, such 1    1 operators factorize tensors while
providing universality with a minimal number of parameters. it seems reasonable to conjecture that
for this task of factorizing coef   cient tensors, larger receptive    elds are not signi   cantly helpful,
as they lead to redundancy which may deteriorate performance in presence of limited training data.
investigation of this conjecture is left for future work.

acknowledgments
amnon shashua would like to thank tomaso poggio and shai s. shwartz for illuminating discus-
sions during the preparation of this manuscript. we would also like to thank tomer galanti, tamir
hazan and lior wolf for commenting on draft versions of the paper. the work is partly funded by
intel grant icri-ci no. 9-2012-6133 and by isf center grant 1790/12. nadav cohen is supported
by a google fellowship in machine learning.

references
animashree anandkumar, rong ge, daniel hsu, sham m kakade, and matus telgarsky. tensor decom-
positions for learning latent variable models. journal of machine learning research, 15(1):2773   2832,
2014.

richard bellman, richard ernest bellman, richard ernest bellman, and richard ernest bellman. introduc-

tion to matrix analysis, volume 960. siam, 1970.

yoshua bengio. learning deep architectures for ai. foundations and trends in machine learning, 2(1):

1   127, 2009.

monica bianchini and franco scarselli. on the complexity of neural network classi   ers: a comparison
between shallow and deep architectures. neural networks and learning systems, ieee transactions on,
25(8):1553   1565, 2014.

joan bruna and st  ephane mallat. invariant scattering convolution networks. ieee tpami, 2012.

richard caron and tim traynor. the zero set of a polynomial. wsmr report 05-02, 2005.

13

cohen sharir shashua

nadav cohen and amnon shashua. simnets: a generalization of convolutional networks. advances in

neural information processing systems (nips), deep learning workshop, 2014.

nadav cohen and amnon shashua. convolutional recti   er networks as generalized tensor decompositions.

international conference on machine learning (icml), 2016.

nadav cohen, or sharir, and amnon shashua. deep simnets. ieee conference on id161 and

pattern recognition (cvpr), 2016.

g cybenko. approximation by superpositions of a sigmoidal function. mathematics of control, signals and

systems, 2(4):303   314, 1989.

olivier delalleau and yoshua bengio. shallow vs. deep sum-product networks.

information processing systems, pages 666   674, 2011.

in advances in neural

ronen eldan and ohad shamir. the power of depth for feedforward neural networks. arxiv preprint

arxiv:1512.03965, 2015.

f girosi and t poggio. networks and the best approximation property. biological cybernetics, 63(3):169   

176, 1990.

w hackbusch and s k  uhn. a new scheme for the tensor representation. journal of fourier analysis and

applications, 15(5):706   722, 2009.

wolfgang hackbusch. tensor spaces and numerical tensor calculus, volume 42 of springer series in

computational mathematics. springer science & business media, berlin, heidelberg, february 2012.

benjamin d haeffele and ren  e vidal. global optimality in tensor factorization, deep learning, and be-

yond. corr abs/1202.2745, cs.na, 2015.

andr  as hajnal, wolfgang maass, pavel pudl  ak, m  arl  o szegedy, and gy  orgy tur  an. threshold circuits of
bounded depth. in foundations of computer science, 1987., 28th annual symposium on, pages 99   110.
ieee, 1987.

johan hastad. almost optimal lower bounds for small depth circuits. in proceedings of the eighteenth annual

acm symposium on theory of computing, pages 6   20. acm, 1986.

johan h  astad and mikael goldmann. on the power of small-depth threshold circuits. computational com-

plexity, 1(2):113   129, 1991.

kurt hornik, maxwell b stinchcombe, and halbert white. multilayer feedforward networks are universal

approximators. neural networks, 2(5):359   366, 1989.

brian hutchinson, li deng, and dong yu. tensor deep stacking networks. ieee trans. pattern anal. mach.

intell. (), 35(8):1944   1957, 2013.

majid janzamin, hanie sedghi, and anima anandkumar. beating the perils of non-convexity: guaranteed

training of neural networks using tensor methods. corr abs/1506.08473, 2015.

frank jones. lebesgue integration on euclidean space. jones & bartlett learning, 2001.

mauricio karchmer. communication complexity a new approach to circuit depth. 1989.

tamara g kolda and brett w bader. tensor decompositions and applications. siam review (), 51(3):

455   500, 2009.

14

on the expressive power of deep learning: a tensor analysis

vadim lebedev, yaroslav ganin, maksim rakhuba, ivan v oseledets, and victor s lempitsky. speeding-up
convolutional neural networks using fine-tuned cp-decomposition. corr abs/1202.2745, cs.cv, 2014.

yann lecun and yoshua bengio. convolutional networks for images, speech, and time series. the handbook

of brain theory and neural networks, 3361(10), 1995.

min lin, qiang chen, and shuicheng yan. network in network.

representations, 2014.

international conference on learning

roi livni, shai shalev-shwartz, and ohad shamir. on the computational ef   ciency of training neural net-

works. advances in neural information processing systems, 2014.

wolfgang maass, georg schnitger, and eduardo d sontag. a comparison of the computational power of

sigmoid and boolean threshold circuits. springer, 1994.

james martens and venkatesh medabalimi. on the expressive ef   ciency of sum product networks. arxiv

preprint arxiv:1411.7717, 2014.

james martens, arkadev chattopadhya, toni pitassi, and richard zemel. on the representational ef   ciency
of restricted id82s. in advances in neural information processing systems, pages 2877   
2885, 2013.

guido f montufar, razvan pascanu, kyunghyun cho, and yoshua bengio. on the number of linear regions
of deep neural networks. in advances in neural information processing systems, pages 2924   2932, 2014.

alexander novikov, anton rodomanov, anton osokin, and dmitry vetrov. putting mrfs on a tensor train.

icml, pages 811   819, 2014.

razvan pascanu, guido montufar, and yoshua bengio. on the number of id136 regions of deep feed

forward networks with piece-wise linear activations. arxiv preprint arxiv, 1312, 2013.

allan pinkus. approximation theory of the mlp model in neural networks. acta numerica, 8:143   195,

january 1999.

hoifung poon and pedro domingos. sum-product networks: a new deep architecture. in id161

workshops (iccv workshops), 2011 ieee international conference on, pages 689   690. ieee, 2011.

ran raz and amir yehudayoff. lower bounds and separations for constant depth multilinear circuits. com-

putational complexity, 18(2):171   207, 2009.

benjamin rossman, rocco a servedio, and li-yang tan. an average-case depth hierarchy theorem for

boolean circuits. arxiv preprint arxiv:1504.03398, 2015.

walter rudin. functional analysis. international series in pure and applied mathematics, 1991.

thomas serre, lior wolf, and tomaso poggio. object recognition with features inspired by visual cortex.

cvpr, 2:994   1000, 2005.

hendra setiawan, zhongqiang huang, jacob devlin, thomas lamar, rabih zbib, richard m schwartz, and
john makhoul. id151 features with multitask tensor networks. proceedings of
the 53rd annual meeting of the association for computational linguistics and the 7th international joint
conference on natural language processing of the asian federation of natural language processing,
cs.cl, 2015.

amir shpilka and amir yehudayoff. arithmetic circuits: a survey of recent results and open questions.

foundations and trends in theoretical computer science, 5(3   4):207   388, 2010.

15

cohen sharir shashua

karen simonyan and andrew zisserman. very deep convolutional networks for large-scale image recogni-

tion. arxiv preprint arxiv:1409.1556, 2014.

michael sipser. borel sets and circuit complexity. acm, new york, new york, usa, december 1983.

richard socher, danqi chen, christopher d manning, and andrew y ng. reasoning with neural tensor
networks for knowledge base completion. advances in neural information processing systems, pages
926   934, 2013.

le song, mariya ishteva, ankur p parikh, eric p xing, and haesun park. hierarchical tensor decomposition

of latent tree id114. icml, pages 334   342, 2013.

maxwell stinchcombe and halbert white. universal approximation using feedforward networks with non-
international joint conference on neural networks, pages

sigmoid hidden layer id180.
613   617 vol.1, 1989.

christian szegedy, wei liu, yangqing jia, pierre sermanet, scott reed, dragomir anguelov, dumitru erhan,

vincent vanhoucke, and andrew rabinovich. going deeper with convolutions. cvpr, 2015.

yaniv taigman, ming yang, marc   aurelio ranzato, and lior wolf. deepface: closing the gap to human-
in cvpr    14: proceedings of the 2014 ieee conference on

level performance in face veri   cation.
id161 and pattern recognition. ieee computer society, june 2014.

matus telgarsky. representation bene   ts of deep feedforward networks. arxiv preprint arxiv:1509.08101,

2015.

y yang and d b dunson. bayesian conditional tensor factorizations for high-dimensional classi   cation.

journal of the american statistical, 2015.

dong yu, li deng, and frank seide. large vocabulary id103 using deep tensor neural

networks. interspeech, pages 6   9, 2012.

daniel zoran and yair weiss.    natural images, gaussian mixtures and dead leaves   . advances in neural

information processing systems, pages 1745   1753, 2012.

16

on the expressive power of deep learning: a tensor analysis

appendix a. generalized theorem of network capacity
in sec. 4 we presented our fundamental theorem of network capacity (thm. 1 and corollary 2), showing that
besides a negligible set, all functions that can be realized by a polynomially sized ht model (with or without
weight sharing), require exponential size in order to be realized, or even approximated, by cp model. in
terms of network depth, cp and ht models represent the extremes     the former has only a single hidden
layer achieved through global pooling, whereas the latter has l = log2 n hidden layers achieved through
minimal (size-2) pooling windows. it is of interest to generalize the fundamental result by establishing a
comparison between networks of intermediate depths. this is the focus of the current appendix.

we begin by de   ning a truncated version of the hierarchical tensor decomposition presented in eq. 4:

a0,2j   1,       a0,2j,  

a1,j,  
  

al,j,  
  

(cid:124)

(cid:123)(cid:122)

  l   1,2j   1,  
order 2l   1

      l   1,2j,  
order 2l   1

(cid:123)(cid:122)

(cid:125)

(cid:125)

(cid:124)

r0(cid:88)
rl   1(cid:88)

  =1

  1,j,   =

...
  l,j,   =

...
a =

  =1

rlc   1(cid:88)

  =1

alc
  

2l   lc+1   

j=1

(cid:124)

(cid:123)(cid:122)

  lc   1,j,  
order 2lc   1

(cid:125)

(5)

the only difference between this decomposition and the original is that instead of completing the full process
with l := log2 n levels, we stop after lc   l. at this point remaining tensors are binded together to form
the    nal order-n tensor. the corresponding network will simply include a premature global pooling stage
that shrinks feature maps to 1    1, and then a    nal linear layer that performs classi   cation. as before, we
consider a shared version of the decomposition in which al,j,       al,  . notice that this construction realizes
a continuum between cp and ht models, which correspond to the extreme cases lc = 1 and lc = l
respectively.

l=0

the following theorem, a generalization of thm. 1, compares a truncated decomposition having l1 levels,
to one with l2 < l1 levels that implements the same tensor, quantifying the penalty in terms of parameters:
theorem 3 let a(1) and a(2) be tensors of order n and dimension m in each mode, generated by
the truncated recursive formulas in eq. 5, with l1 and l2 levels respectively. denote by {r(1)
and
the composition ranks of a(1) and a(2) respectively. assuming w.l.o.g. that l1 > l2, we de   ne
{r(2)
l }l2   1
l2   1, m}, and consider the space of all possible con   gurations for the parameters of
r := min{r(1)
0 , ..., r(1)
a(1)   s composition     {a(1),l,j,  }l,j,  . in this space, almost everywhere (w.r.t. lebesgue measure), the gener-
l2   1     (r)2l   l2 if one wishes that a(2) be equal to a(1). put differently, the
ated tensor a(1) requires that r(2)
con   gurations for which a(1) can be realized by a(2) with r(2)
l2   1 < (r)2l   l2 form a set of measure zero. the
exact same result holds if we constrain the composition of a(1) to be    shared   , i.e. set a(1),l,j,       a(1),l,  
and consider the space of {a(1),l,  }l,   con   gurations.

l }l1   1

l=0

in analogy with corollary 2, we obtain the following generalization:

corollary 4 suppose we are given linearly independent representation functions f  1. . .f  m , and consider
two networks that correspond to the truncated hierarchical tensor decomposition in eq. 5, with l1 and l2
hidden layers respectively. assume w.l.o.g. that l1 > l2, i.e. that network 1 is deeper than network 2, and
de   ne r to be the minimal number of channels across the representation layer and the    rst l2 hidden layers
of network 1. then, if we randomize the weights of network 1 by a continuous distribution, we obtain, with

17

cohen sharir shashua

id203 one, score functions hy that cannot be approximated arbitrarily well (in l2 sense) by network 2
if the latter has less than (r)2l   l2 channels in its last hidden layer. the result holds even if we constrain
network 1 with weight sharing while leaving network 2 in its general form.

proofs of thm. 3 and corollary 4 are given in app. b. hereafter, we brie   y discuss some of their impli-
cations. first, notice that we indeed obtain a generalization of the fundamental theorem of network capacity
(thm. 1 and corollary 2), which corresponds to the extreme case l1 = l and l2 = 1. second, note that for the
baseline case of l1 = l, i.e. a full-depth network has generated the target score function, approximating this
with a truncated network draws a price that grows double exponentially w.r.t. the number of missing layers.
third, and most intriguingly, we see that when l1 is considerably smaller than l, i.e. when a signi   cantly
truncated network is suf   cient to model our problem, cutting off even a single layer leads to an exponential
price, and this price is independent of l1. such scenarios of exponential penalty for trimming down a single
layer were discussed in bengio (2009), but only in the context of speci   c functions realized by networks that
do not resemble ones used in practice (see h  astad and goldmann (1991) for an example of such result). we
prove this in a much broader, more practical setting, showing that for convolutional arithmetic circuit (sim-
net     see app. e) architectures, almost any function realized by a signi   cantly truncated network will exhibit
this behavior. the issue relates to empirical practice, supporting the common methodology of designing net-
works that go as deep as possible. speci   cally, it encourages extending network depth by pooling over small
regions, avoiding signi   cant spatial decimation that brings network termination closer.

we conclude this appendix by stressing once more that our construction and theoretical approach are
not limited to the models covered by our theorems (cp model, ht model, truncated ht model). these are
merely exemplars deemed most appropriate for initial analysis. the fundamental and generalized theorems
of network capacity are similar in spirit, and analogous theorems for networks with different pooling window
sizes and depths (corresponding to different tensor decompositions) may easily be derived.

appendix b. proofs
b.1. proof of theorems 1 and 3
our proof of thm. 1 and 3 relies on basic knowledge in measure theory, or more speci   cally, lebesgue
measure spaces. we do not provide here a comprehensive background on this    eld (the interested reader is
referred to jones (2001)), but rather supplement the brief discussion given in sec. 2, with a list of facts we
will be using which are not necessarily intuitive:

    a union of countably (or    nitely) many sets of zero measure is itself a set of zero measure.
    if p is a polynomial over d variables that is not identically zero, the set of points in rd in which it

vanishes has zero measure (see caron and traynor (2005) for a short proof of this).

    if s     rd1 has zero measure, then s    rd2     rd1+d2, and every set contained within, have zero

measure as well.

in the above, and in the entirety of this paper, the only measure spaces we consider are euclidean spaces
equipped with lebesgue measure. thus when we say that a set of d-dimensional points has zero measure, we
mean that its lebesgue measure in the d-dimensional euclidean space is zero.
moving on to some preliminaries from matrix and tensor theory, we denote by [a] the matricization of
an order-n tensor a (for simplicity, n is assumed to be even), where rows correspond to odd modes and
columns correspond to even modes. namely, if a     rm1          mn , the matrix [a] has m1  m3   . . .  mn   1
rows and m2  m4   . . .  mn columns, rearranging the entries of the tensor such that ad1...dn is stored in row
j=i+1 m2j. to distinguish
from the tensor product operation    , we denote the kronecker product between matrices by (cid:12). speci   cally,
for two matrices a     rm1  m2 and b     rn1  n2, a (cid:12) b is the matrix in rm1n1  m2n2 that holds aijbkl
in row index (i     1)n1 + k and column index (j     1)n2 + l. the basic relation that binds together tensor

j=i+1 m2j   1 and column index 1+(cid:80)n/2

i=1(d2i   1   1)(cid:81)n/2

i=1(d2i   1)(cid:81)n/2

index 1+(cid:80)n/2

18

on the expressive power of deep learning: a tensor analysis

  1. . .  r and tensors with the same size a1. . .ar: [(cid:80)r

product, matricization and kronecker product is [a     b] = [a] (cid:12) [b], where a and b are tensors of even
i=1   iai] =(cid:80)r
orders. two additional facts we will make use of are that the matricization is a linear operator (i.e. for scalars
i=1   i[ai]), and less trivially, that for
any matrices a and b, the rank of a (cid:12) b is equal to rank(a)    rank(b) (see bellman et al. (1970) for a
proof). these two facts, along with the basic relation laid out above, lead to the conclusion that:
(cid:125)(cid:124)
2i   1v(z)(cid:62)
v(z)
2i   1     v(z)
v(z)

2l/2(cid:89)

rank

rank

(cid:123)
(cid:105)

(cid:122)
(cid:104)

(cid:104)

(cid:105)

= 1

=

2i

2i

and thus:

(cid:34) z(cid:88)

rank

  zv(z)

1                v(z)

2l

z=1

z=1

2l

1                v(z)
v(z)
(cid:35)
z(cid:88)

= rank

  z

i=1

(cid:104)

1                v(z)
v(z)

2l

(cid:105)     z(cid:88)

z=1

(cid:104)

rank

(cid:105)

= z

1                v(z)
v(z)

2l

in words, an order-2l tensor given by a cp-decomposition (see sec. 2) with z terms, has matricization with
rank at most z. thus, to prove that a certain order-2l tensor has cp-rank of at least r, it suf   ces to show
that its matricization has rank of at least r.

we now state and prove two lemmas that will be needed for our proofs of thm. 1 and 3.

lemma 5 let m, n     n, and de   ne the following mapping taking x     r2m n +n to three matrices:
a(x)     rm  n , b(x)     rm  n and d(x)     rn  n . a(x) simply holds the    rst m n elements of x, b(x)
holds the following m n elements of x, and d(x) is a diagonal matrix that holds the last n elements of x on
its diagonal. de   ne the product matrix u (x) := a(x)d(x)b(x)(cid:62)     rm  m , and consider the set of points
x for which the rank of u (x) is different from r := min{m, n}. this set of points has zero measure. the
result will also hold if the points x reside in rm n +n , and the same elements are used to assign a(x) and
b(x) (a(x)     b(x)).
proof obviously rank(u (x))     r for all x, so it remains to show that rank(u (x))     r for all x but a
set of zero measure. let ur(x) be the top-left r    r sub-matrix of u (x). if ur(x) is non-singular then of
course rank(u (x))     r as required. it thus suf   ces to show that the set of points x for which det ur(x) = 0
has zero measure. now, det ur(x) is a polynomial in the entries of x, and so it either vanishes on a set of
zero measure, or it is the zero polynomial (see caron and traynor (2005)). all that is left is to disqualify
the latter option, and that can be done by    nding a speci   c point x0 for which det ur(x0) (cid:54)= 0. indeed,
we may choose x0 such that d(x0) is the identity matrix and a(x0), b(x0) hold 1 on their main diagonal
and 0 otherwise. this selection implies that ur(x0) is the identity matrix, and in particular det ur(x0) (cid:54)= 0.

lemma 6 assume we have p continuous mappings from rd to rm  n taking the point y to the matri-
ces a1(y). . .ap(y). assume that under these mappings, the points y for which every i     [p] satis   es
rank(ai(y)) < r form a set of zero measure. de   ne a mapping from rp    rd to rm  n given by
i=1 xi    ai(y). then, the points (x, y) for which rank(a(x, y)) < r form a

(x, y) (cid:55)    a(x, y) := (cid:80)p

set of zero measure.
proof denote s := {(x, y) : rank(a(x, y)) < r}     rp    rd. we would like to show that this set has zero
measure. we    rst note that since a(x, y) is a continuous mapping, and the set of matrices a     rm  n which
have rank less than r is closed, s is a closed set and in particular measurable. our strategy for computing its
measure will be as follows. for every y     rd we de   ne the marginal set sy := {x : rank(a(x, y)) < r}    
rp. we will show that for every y but a set of zero measure, the measure of sy is zero. an application of
fubini   s theorem will then prove the desired result.

19

cohen sharir shashua

let c be the set of points y     rd for which    i     [p] : rank(ai(y)) < r. by assumption, c has zero
measure. we now show that for y0     rd \ c, the measure of sy0 is zero. by the de   nition of c there exists
an i     [p] such that rank(ai(y0))     r. w.l.o.g., we assume that i = 1, and that the top-left r    r sub-matrix
of a1(y0) is non-singular. regarding y0 as    xed, the determinant of the top-left r   r sub-matrix of a(x, y0)
is a polynomial in the elements of x. it is not the zero polynomial, as setting x1 = 1, x2 =        = xp = 0
yields a(x, y0) = a1(y0), and the determinant of the latter   s top-left r    r sub-matrix is non-zero. as a
non-zero polynomial, the determinant of the top-left r    r sub-matrix of a(x, y0) vanishes only on a set of
zero measure (caron and traynor (2005)). this implies that indeed the measure of sy0 is zero.
we introduce a few notations towards our application of fubini   s theorem. first, the symbol 1 will be
used to represent indicator functions, e.g. 1s is the function from rp    rd to r that receives 1 on s and 0
elsewhere. second, we use a subscript of n     n to indicate that the corresponding set is intersected with the
hyper-rectangle of radius n. for example, sn stands for the intersection between s and [   n, n]p+d, and rd
stands for the intersection between rd and [   n, n]d (which is equal to the latter). all the sets we consider
are measurable, and those with subscript n have    nite measure. we may thus apply fubini   s theorem to get:

(cid:90)
(cid:90)
implies that both integrals in the last expression vanish, and thus(cid:82) 1sn = 0. finally, we use the monotone
convergence theorem to compute(cid:82) 1s:
(cid:90)

recall that the set c     rd has zero measure, and for every y /    c the measure of sy     rp is zero. this

(x,y)   rp+d

1sn =

1sy =

1sy +

1s =

y   rd

y   rd

y   rd

x   rp

x   rp

x   rp

n   c

(cid:90)

(cid:90)

(cid:90)

(cid:90)

(cid:90)

(cid:90)

(cid:90)

(cid:90)

n\c

1sy

(x,y)

n

n

n

n

n

n

1s =

n       1sn = lim
lim
n      

1sn = lim

n       0 = 0

this shows that indeed our set of interest s has zero measure.

with all preliminaries and lemmas in place, we turn to prove thm. 1, establishing an exponential ef   ciency

of ht decomposition (eq. 4) over cp decomposition (eq. 3).
proof [of theorem 1] we begin with the case of an    unshared    composition, i.e. the one given in eq. 4 (as
opposed to the    shared    setting of al,j,       al,  ). denoting for convenience   l,1,1 := ay and rl = 1, we
will show by induction over l = 1, ..., l that almost everywhere (at all points but a set of zero measure)
w.r.t. {al,j,  }l,j,  , all cp-ranks of the tensors {  l,j,  }j   [n/2l],     [rl] are at least r2l/2. in accordance with our
discussion in the beginning of this subsection, it suf   ces to consider the matricizations [  l,j,  ], and show that
these all have ranks greater or equal to r2l/2 almost everywhere.

for the case l = 1 we have:

r0(cid:88)

  =1

  1,j,   =

a0,2j   1,       a0,2j,  

a1,j,  
  

w.r.t. (cid:0){a0,2j   1,  }  ,{a0,2j,  }  , a1,j,  (cid:1). to see that this holds almost everywhere w.r.t. {al,j,  }l,j,  , one

denote by a     rm  r0 the matrix with columns {a0,2j   1,  }r0
  =1, by b     rm  r0 the matrix with columns
  =1, and by d     rr0  r0 the diagonal matrix with a1,j,   on its diagonal. then, we may write
{a0,2j,  }r0
[  1,j,  ] = adb(cid:62), and according to lemma 5 the rank of [  1,j,  ] equals r := min{r0, m} almost everywhere
should merely recall that for any dimensions d1, d2     n, if the set s     rd1 has zero measure, so does
any subset of s    rd2     rd1+d2. a    nite union of zero measure sets has zero measure, thus the fact that
rank[  1,j,  ] = r holds almost everywhere individually for any j     [n/2] and        [r1], implies that it holds
almost everywhere jointly for all j and   . this proves our inductive hypothesis (unshared case) for l = 1.
]     r2l   1/2 for all j(cid:48)     [n/2l   1] and   (cid:48)     [rl   1]. for
assume now that almost everywhere rank[  l   1,j(cid:48),  (cid:48)
some speci   c choice of j     [n/2l] and        [rl] we have:

  l,j,   =

     l   1,2j   1,         l   1,2j,   =    [  l,j,  ] =
al,j,  

[  l   1,2j   1,  ] (cid:12) [  l   1,2j,  ]

al,j,  
  

rl   1(cid:88)

rl   1(cid:88)

  =1

  =1

20

on the expressive power of deep learning: a tensor analysis

are at least r2l   1/2    r2l   1/2 = r2l/2. writing [  l,j,  ] = (cid:80)rl   1

denote m   := [  l   1,2j   1,  ](cid:12)[  l   1,2j,  ] for    = 1. . .rl   1. by our inductive assumption, and by the general
property rank(a (cid:12) b) = rank(a)  rank(b), we have that almost everywhere the ranks of all matrices m  
   m  , and noticing that {m  } do not
depend on al,j,  , we turn our attention to lemma 6. the lemma tells us that rank[  l,j,  ]     r2l/2 almost
everywhere. since a    nite union of zero measure sets has zero measure, we conclude that almost everywhere
rank[  l,j,  ]     r2l/2 holds jointly for all j     [n/2l] and        [rl]. this completes the proof of the theorem in
the unshared case.

  =1 al,j,  

  

proving the theorem in the shared case may be done in the exact same way, except that for l = 1 one

needs the version of lemma 5 for which a(x) and b(x) are equal.

we now head on to prove thm. 3, which is a generalization of thm. 1. the proof will be similar in nature
to that of thm. 1, yet slightly more technical. in short, the idea is to show that in the generic case, expressing
a(1) as a sum of tensor products between tensors of order 2l2   1 requires at least rn/2l2 terms. since a(2) is
expressed as a sum of rl2   1 such terms, demanding a(2) = a(1) implies rl2   1     rn/2l2 .
to gain technical advantage and utilize known results from matrix theory (as we did when proving
thm. 1), we introduce a new tensor    squeezing    operator   . for q     n,   q is an operator that receives a
tensor with order divisible by q, and returns the tensor obtained by merging together the latter   s modes in
groups of size q. speci   cally, when applied to the tensor a     rm1          mc  q (c     n),   q returns a ten-
sor of order c which holds ad1...dc  q in the location de   ned by the following index for every mode t     [c]:
j=i+1 mj+q(t   1). notice that when applied to a tensor of order q,   q returns a
vector. also note that if a and b are tensors with orders divisible by q, and    is a scalar, we have the desirable
properties:

i=1(di+q(t   1)     1)(cid:81)q

1 +(cid:80)q

      q(a     b) =   q(a)       q(b)
      q(  a + b) =     q(a) +   q(b)

i

  (z)
n/2l2   1, where   (z)

for the sake of our proof we are interested in the case q = 2l2   1, and denote for brevity    :=   2l2   1.

as stated above, we would like to show that in the generic case, expressing a(1) as(cid:80)z
decomposition gives:   (a(1)) =(cid:80)z

1               
are tensors of order 2l2   1, implies z     rn/2l2 . applying    to both sides of such a
) are now vectors. thus,
to prove thm. 3 it suf   ces to show that in the generic case, the cp-rank of   (a(1)) is at least rn/2l2 , or
alternatively, that the rank of the matricization [  (a(1))] is at least rn/2l2 . this will be our strategy in the
following proof:
proof [of theorem 3] in accordance with the above discussion, it suf   ces to show that in the generic case
rank[  (a(1))]     rn/2l2 . to ease the path for the reader, we reformulate the problem using slightly simpler
notations. we have an order-n tensor a with dimension m in each mode, generated as follows:

1 )                  (  (z)

n/2l2   1), where   (  (z)

z=1   (  (z)

z=1   (z)

i

r0(cid:88)
rl   1(cid:88)

  =1

  1,j,   =

...
  l,j,   =

...
a =

  =1

rl1   1(cid:88)

  =1

a0,2j   1,       a0,2j,  

a1,j,  
  

al,j,  
  

(cid:124)

(cid:123)(cid:122)

  l   1,2j   1,  
order 2l   1

      l   1,2j,  
order 2l   1

(cid:123)(cid:122)

(cid:125)

(cid:125)

(cid:124)

(cid:124)

(cid:123)(cid:122)

  l1   1,j,  
order 2l1   1

(cid:125)

al1,1,1
  

2l   l1+1   

j=1

21

cohen sharir shashua

where:

    l1     l := log2 n
    r0, ..., rl1   1     n>0
    a0,j,       rm for j     [n ] and        [r0]
    al,j,       rrl   1 for l     [l1     1], j     [n/2l] and        [rl]
    al1,1,1     rrl1   1

let l2 be a positive integer smaller than l1, and let    be the tensor squeezing operator that merges groups
of 2l2   1 modes. de   ne r := min{r0, ..., rl2   1, m}. with [  ] being the matricization operator de   ned
in the beginning of the appendix, our task is to prove that rank[  (a)]     rn/2l2 almost everywhere w.r.t.
{al,j,  }l,j,  . we also consider the case of shared parameters     al,j,       al,  , where we would like to show
that the same condition holds almost everywhere w.r.t. {al,  }l,  .
our strategy for proving the claim is inductive. we show that for l = l2. . .l1     1, almost everywhere
it holds that for all j and all   : rank[  (  l,j,  )]     r2l   l2 . we then treat the special case of l = l1, showing
that indeed rank[  (a)]     rn/2l2 . we begin with the setting of unshared parameters (al,j,  ), and afterwards
attend the scenario of shared parameters (al,  ) as well.
our    rst task is to treat the case l = l2, i.e. show that rank[  (  l2,j,  )]     r almost everywhere jointly
for all j and all    (there is actually no need for the matricization [  ] here, as   (  l2,j,  ) are already matrices).
since a union of    nitely many zero measure sets has zero measure, it suf   ces to show that this condition
holds almost everywhere when speci   c j and    are chosen. denote by ei a vector holding 1 in entry i and 0
elsewhere, by 0 a vector of zeros, and by 1 a vector of ones. suppose that for every j we assign a0,j,   to be
e   when        r and 0 otherwise. suppose also that for all 1     l     l2     1 and all j we set al,j,   to be e  
when        r and 0 otherwise. finally, assume we set al2,j,   = 1 for all j and all   . these settings imply that
for every j, when        r we have   l2   1,j,   =    2l2   2
(e       e  ), i.e. the tensor   l2   1,j,   holds 1 in location
(  , ...,   ) and 0 elsewhere. if    > r then   l2   1,j,   is the zero tensor. we conclude from this that there are
indices 1     i1 < ... < ir     m l2   1 such that   (  l2   1,j,  ) = ei   for        r, and that for    > r we have
  (  l2   1,j,  ) = 0. we may thus write:

j=1

(cid:32)rl2   1(cid:88)

(cid:33)

rl2   1(cid:88)

  (  l2,j,  ) =   

  l2   1,2j   1,         l2   1,2j,  

=

  (  l2   1,2j   1,  )     (  l2   1,2j,  ) =

  =1

  =1

  =1

now, since i1. . .ir are different from each other, the matrix   (  l2,j,  ) has rank r. this however does not
prove our inductive hypothesis for l = l2. we merely showed a speci   c parameter assignment for which
it holds, and we need to show that it is met almost everywhere. to do so, we consider an r    r sub-matrix
of   (  l2,j,  ) which is non-singular under the speci   c parameter assignment we de   ned. the determinant
of this sub-matrix is a polynomial in the elements of {al,j,  }l,j,   which we know does not vanish with the
speci   c assignments de   ned. thus, this polynomial vanishes at subset of {al,j,  }l,j,   having zero measure
(see caron and traynor (2005)). that is to say, the sub-matrix of   (  l2,j,  ) has rank r almost everywhere,
and thus   (  l2,j,  ) has rank at least r almost everywhere. this completes our treatment of the case l = l2.
we now turn to prove the propagation of our inductive hypothesis. let l     {l2 + 1, ..., l1     1}, and
assume that our inductive hypothesis holds for l     1. speci   cally, assume that almost everywhere w.r.t.
{al,j,  }l,j,  , we have that rank[  (  l   1,j,  )]     r2l   1   l2 jointly for all j     [n/2l   1] and all        [rl   1].
we would like to show that almost everywhere, rank[  (  l,j,  )]     r2l   l2 jointly for all j     [n/2l] and all
       [rl]. again, the fact that a    nite union of zero measure sets has zero measure implies that we may
prove the condition for speci   c j     [n/2l] and        [rl]. applying the squeezing operator    followed by

22

r(cid:88)

ei   e(cid:62)

i  

on the expressive power of deep learning: a tensor analysis

matricization [  ] to the recursive expression for   l,j,  , we get:

[  (  l,j,  )] =

=

     l   1,2j   1,         l   1,2j,  
al,j,  

=

[  (  l   1,2j   1,  )] (cid:12) [  (  l   1,2j,  )]

(cid:34)
(cid:32)rl   1(cid:88)
rl   1(cid:88)

  =1

  

al,j,  
  

  =1

(cid:33)(cid:35)

(cid:35)
     (  l   1,2j   1,  )       (  l   1,2j,  )
al,j,  

(cid:34)rl   1(cid:88)

  =1

for    = 1. . .rl   1, denote the matrix [  (  l   1,2j   1,  )] (cid:12) [  (  l   1,2j,  )] by m  . the fact that the kronecker
product multiplies ranks, along with our inductive assumption, imply that almost everywhere rank(m  )    
r2l   1   l2    r2l   1   l2 = r2l   l2 . noting that the matrices m   do not depend on al,j,  , we apply lemma 6
and conclude that almost everywhere rank[  (  l,j,  )]     r2l   l2 , which completes the prove of the inductive
propagation.
next, we treat the special case l = l1. we assume now that almost everywhere rank[  (  l1   1,j,  )]    
r2l1   1   l2 jointly for all j and all   . again, we apply the squeezing operator    followed by matricization [  ],
this time to both sides of the expression for a:

rl1   1(cid:88)

  =1

[  (a)] =

al1,1,1
  

2l   l1+1(cid:12)

j=1

[  (  l1   1,j,  )]

j=1

j=1

rank(m  )    (cid:81)2l   l1+1

as before, denote m   := (cid:12)2l   l1+1
[  (  l1   1,j,  )] for    = 1. . .rl1   1. using again the multiplicative
rank property of the kronecker product along with our inductive assumption, we get that almost everywhere
r2l1   1   l2 = rl   l2. noticing that {m  }     [rl1   1] do not depend on al1,1,1, we
apply lemma 6 for the last time and get that almost everywhere (w.r.t. {al,j,  }l,j,  ), the rank of [  (a)] is at
least rl   l2. this completes our proof in the case of unshared parameters.
proving the theorem in the case of shared parameters (al,j,       al,  ) can be done in the exact same way
as above. in fact, all one has to do is omit the references to j and the proof will apply. notice in particular
that the speci   c parameter assignment we de   ned to handle l = l2 was completely symmetric, i.e. it did not
include any dependence on j.

b.2. proof of corollaries 2 and 4
corollaries 2 and 4 are a direct continuation of thm. 1 and 3 respectively. in the theorems, we have shown
that almost all coef   cient tensors generated by a deep network cannot be realized by a shallow network if
the latter does not meet a certain minimal size requirement. the corollaries take this further, by stating that
given linearly independent representation functions f  1. . .f  m , not only is ef   cient realization of coef   cient
tensors generally impossible, but also ef   cient approximation of score functions. to prove this extra step,
we recall from the proofs of thm. 1 and 3 (app. b.1) that in order to show separation between the coef   cient
tensor of a deep network and that of a shallow network, we relied on matricization rank. speci   cally, we
derived constants rd, rs     n, rd > rs, such that the matricization of a deep network   s coef   cient tensor
had rank greater or equal to rd, whereas the matricization of a shallow network   s coef   cient tensor had rank
smaller or equal to rs. given this observation, corollaries 2 and 4 readily follow from lemma 7 below (the
lemma relies on basic concepts and results from the topic of l2 hilbert spaces     see app. c.1 for a brief
discussion on the matter).
lemma 7 let f  1. . .f  m   l2(rs) be a set of linearly independent functions, and denote by t the (eu-
clidean) space of tensors with order n and dimension m in each mode. for a given tensor a     t , denote

23

cohen sharir shashua

by h(a) the function in l2(cid:0)(rs)n(cid:1) de   ned by:

(x1, . . . , xn )

h(a)
(cid:55)   

m(cid:88)

d1,...,dn =1

n(cid:89)

i=1

ad1...dn

f  di

(xi)

let {a  }            t be a family of tensors, and a    be a certain target tensor that lies outside the family.
assume that for all           we have rank([a  ]) < rank([a   ]), where [  ] is the matricization operator

de   ned in app. b.1. then, the distance in l2(cid:0)(rs)n(cid:1) between h(a   ) and {h(a  )}        is strictly positive,

i.e. there exists an   > 0 such that:

(cid:90) (cid:12)(cid:12)h(a  )     h(a   )(cid:12)(cid:12)2

>  

             :

i=1 f  di

the coef   cient tensor of h(t) under this basis, i.e. a(t)     t is de   ned by:

{(cid:81)n
quence of functions that lie in the span of {(cid:81)n

(xi)}d1...dn   [m ] are linearly independent in l2(cid:0)(rs)n(cid:1) (see app. c.1). let (h(t))   

proof the fact that {f  d (x)}d   [m ] are linearly independent in l2(rs) implies that the product functions
t=1 be a se-
(xi)}d1...dn   [m ], and for every t     n denote by a(t)
m(cid:88)
t=1 converges to h(a   ) in l2(cid:0)(rs)n(cid:1):
(cid:90) (cid:12)(cid:12)(cid:12)h(t)     h(a   )
(cid:12)(cid:12)(cid:12)2

assume that (h(t))   

h(t) (x1, . . . , xn ) =

n(cid:89)

i=1 f  di

d1,...,dn =1

a(t)

d1,...,dn

f  di

(xi)

= 0

i=1

lim
t      

in a    nite-dimensional hilbert space, convergence in norm implies convergence in representation coef   cients
under any preselected basis. we thus have:

   d1. . .dn     [m ] : a(t)

t                   a   

to show that the distance in l2(cid:0)(rs)n(cid:1) between h(a   ) and {h(a  )}        is strictly positive, it suf   ces to

this means in particular that in the tensor space t , a    lies in the closure of {a(t)}   
t=1. accordingly, in order
show that the distance in t between a    and {a  }        is strictly positive, or equivalently, that the distance
between the matrix [a   ] and the family of matrices {[a  ]}        is strictly positive. this however is a direct
implication of the assumption              : rank([a  ]) < rank([a   ]).

d1,...,dn

d1,...,dn

appendix c. derivation of hypotheses space
in order to keep the body of the paper at a reasonable length, the presentation of our hypotheses space (eq. 2)
in sec. 3 did not provide the grounds for its de   nition. in this appendix we derive the hypotheses space step by
step. after establishing basic preliminaries on the topic of l2 spaces, we utilize the notion of tensor products
between such spaces to reach a universal representation as in eq. 2 but with m        . we then make use
of empirical studies characterizing the statistics of natural images, to argue that in practice a moderate value
of m (m        (100)) suf   ces.

c.1. preliminaries on l2 spaces
when dealing with functions over scalars, vectors or collections of vectors, we consider l2 spaces, or more
formally, the hilbert spaces of lebesgue measurable square-integrable real functions equipped with standard

24

on the expressive power of deep learning: a tensor analysis

(point-wise) addition and scalar multiplication, as well as the inner-product de   ned by integral over point-
wise multiplication. the topic of l2 function spaces lies at the heart of functional analysis, and requires basic
for our purposes, it suf   ces to view an l2 space as a vector space of all functions f satisfying(cid:82) f 2 <    .
knowledge in measure theory. we present here the bare necessities required to follow this appendix, referring
the interested reader to rudin (1991) for a more comprehensive introduction.
this vector space is in   nite dimensional, and a set of functions f     l2 is referred to as total if the closure of
and coef   cients c1. . .ck     r such that(cid:82) |(cid:80)k
its span covers the entire space, i.e. if for any function g     l2 and   > 0, there exist functions f1. . .fk     f
i=1 ci    fi     g|2 <  . f is regarded as linearly independent
(cid:80)k
if all of its    nite subsets are linearly independent, i.e. for any f1. . .fk     f, fi (cid:54)= fj, and c1. . .ck     r, if
i=1 ci    fi = 0 then c1 =        = ck = 0. a non-trivial result states that l2 spaces in general must contain
total and linearly independent sets, and moreover, for any s     n, l2(rs) contains a countable set of this type.
it seems reasonable to draw an analogy between total and linearly independent sets in l2 space, and bases
in a    nite dimensional vector space. while this analogy is indeed appropriate from our perspective, total and
linearly independent sets are not to be confused with bases for l2 spaces, which are typically de   ned to be
orthonormal.
it can be shown (see for example hackbusch (2012)) that for any natural numbers s and n, if {fd(x)}d   n
i=1 fdi(xi)}d1...dn   n, the in-
duced point-wise product functions on (rs)n , form a set which is total or linearly independent, respectively,

is a total or a linearly independent set in l2(rs), then {(x1, . . . , xn ) (cid:55)    (cid:81)n
in l2(cid:0)(rs)n(cid:1). as we now brie   y outline, this result actually emerges from a deep relation between tensor

products and hilbert spaces. the de   nitions given in sec. 2 for a tensor, tensor space, and tensor product, are
actually concrete special cases of much deeper, abstract algebraic concepts. a more formal line of presenta-
tion considers multiple vector spaces v1. . .vn , and de   nes their tensor product space v1            vn to be a
speci   c quotient space of the space freely generated by their cartesian product set. for every combination of
vectors v(i)     vi, i     [n ], there exists a corresponding element v(1)            v(n ) in the tensor product space,
and moreover, elements of this form span the entire space. if v1. . .vn are hilbert spaces, it is possible to
equip v1            vn with a natural inner-product operation, thereby turning it too into a hilbert space. it may
   }       vi, i     [n ], are total or linearly independent, elements of the form
then be shown that if the sets {v(i)
  n are total or linearly independent, respectively, in v1            vn . finally, when the under-
  1                v(n )
v(1)
i=1 fi(xi) from

lying hilbert spaces are l2(rs), the point-wise product mapping f1(x)            fn (x) (cid:55)   (cid:81)n
the tensor product space(cid:0)l2(rs)(cid:1)   n

:= l2(rs)            l2(rs) to l2(cid:0)(rs)n(cid:1), induces an isomorphism of

hilbert spaces.

c.2. construction
recall from sec. 3 that our instance space is de   ned as x := (rs)n , in accordance with the common prac-
tice of representing natural data through ordered local structures (for example images are often represented
through small patches around their pixels). we classify instances into categories y := {1. . .y } via maxi-
mization of per-label score functions {hy : (rs)n     r}y   y. our hypotheses space h is de   ned to be the
in app. c.1 we stated that if {fd(x)}d   n is a total set in l2(rs), i.e. if every function in l2(rs) can
be arbitrarily well approximated by a linear combination of a    nite subset of {fd(x)}d   n, then the point-

subset of l2(cid:0)(rs)n(cid:1) from which score functions may be taken.
i=1 fdi(xj)}d1,...,dn   n form a total set in l2(cid:0)(rs)n(cid:1). accordingly, in a
wise products {(x1, . . . , xn ) (cid:55)   (cid:81)n
universal hypotheses space h = l2(cid:0)(rs)n(cid:1), any score function hy may be arbitrarily well approximated by

   nite linear combinations of such point-wise products. a possible formulation of this would be as follows.
assume we are interested in  -approximation of the score function hy, and consider a formal tensor ay
having n modes and a countable in   nite dimension in each mode i     [n ], indexed by di     n. then, there
exists such a tensor, with all but a    nite number of entries set to zero, for which:

hy (x1, . . . , xn )     (cid:88)

d1...dn   n

25

n(cid:89)

i=1

ay

d1,...,dn

fdi(xi)

(6)

cohen sharir shashua

given that the set of functions {fd(x)}d   n   l2(rs) is total, eq. 6 de   nes a universal hypotheses space.
there are many possibilities for choosing a total set of functions. wavelets are perhaps the most obvious
choice, and were indeed used in a deep network setting by bruna and mallat (2012). the special case of
gabor wavelets has been claimed to induce features that resemble representations in the visual cortex (serre
et al. (2005)). two options we pay special attention to due to their importance in practice are:

    gaussians (with diagonal covariance):

(7)

where    = (       rs,   2     rs

++).

    neurons:

f  (x) = n(cid:0)x;   , diag(  2)(cid:1)
f  (x) =   (cid:0)x(cid:62)w + b(cid:1)

(8)
where    = (w     rs, b     r) and    is a point-wise non-linear activation such as threshold   (z) =
1 [z > 0], recti   ed linear unit (relu)   (z) = max{z, 0} or sigmoid   (z) = 1/(1 + e   z).

in both cases, there is an underlying parametric family of functions f = {f   : rs     r}        of which
a countable total subset may be chosen. the fact that gaussians as above are total in l2(rs) has been
proven in girosi and poggio (1990), and is a direct corollary of the stone-weierstrass theorem. to achieve
countability, simply consider gaussians with rational parameters (mean and variances). in practice, the choice
of gaussians (with diagonal covariance) give rises to a    similarity    operator as described by the simnet
architecture (cohen and shashua (2014); cohen et al. (2016)). for the case of neurons we must restrict the
domain rs to some bounded set, otherwise the functions are not integrable. this however is not a limitation
in practice, and indeed neurons are widely used across many application domains. the fact that neurons
are total has been proven in cybenko (1989) and hornik et al. (1989) for threshold and sigmoid activations.
more generally, it has been proven in stinchcombe and white (1989) for a wide class of id180,
including linear combinations of relu. see pinkus (1999) for a survey of such results. for countability, we
may again restrict parameters (weights and bias) to be rational.
that it is
possible to choose f  1. . .f  m     f that will suf   ce in order to represent score functions required for natural
tasks. moreover, we claim that m need not be large (e.g. on the order of 100). our argument relies on
statistical properties of natural images, and is fully detailed in app. c.3. it implies that under proper choice of
(xi)}d1,...,dn   [m ]
spans the score functions of interest, and we may de   ne for each label y a tensor ay of order n and dimension
m in each mode, such that:

{f  d (x)}d   [m ], the    nite set of point-wise product functions {(x1, . . . , xn ) (cid:55)   (cid:81)n

in the case of gaussians and neurons, we argue that a    nite set of functions suf   ces, i.e.

i=1 f  di

hy (x1, . . . , xn ) =

ay

d1,...,dn

f  di

(xi)

(2)

d1,...,dn =1

i=1

(xi)}d1,...,dn   [m ]   l2(cid:0)(rs)n(cid:1) (see app. c.1), and a score function hy uniquely determines the

which is exactly the hypotheses space presented in sec. 3. notice that if {f  d (x)}d   [m ]   l2(rs) are linearly
(cid:81)n
independent (there is no reason to choose them otherwise), then so are the product functions {(x1, . . . , xn ) (cid:55)   
coef   cient tensor ay. in other words, two score functions hy,1 and hy,2 are identical if and only if their
coef   cient tensors ay,1 and ay,2 are the same.

i=1 f  di

c.3. finite function bases for classi   cation of natural data
in app. c.2 we laid out the framework of classifying instances in the space x := {(x1, . . . , xn ) : xi     rs} =
(rs)n into labels y := {1, . . . , y } via maximization of per-label score functions hy : x     r:

  y(x1, . . . , xn ) = argmax

y   y

hy(x1, . . . , xn )

26

m(cid:88)

n(cid:89)

on the expressive power of deep learning: a tensor analysis

where hy(x1, . . . , xn ) is of the form:

hy (x1, . . . , xn ) =

m(cid:88)

d1,...,dn =1

ay

d1,...,dn

n(cid:89)

i=1

f  di

(xi)

(2)

and {f  }d   [m ] are selected from a parametric family of functions f = {f   : rs     r}       . for universality,
i.e. for the ability of score functions hy to approximate any function in l2(x ) as m        , we required that it
be possible to choose a countable subset of f that is total in l2(rs). we noted that the families of gaussians
(eq. 7) and neurons (eq. 8) meet this requirement.
in this subsection we formalize our argument that a    nite value for m is suf   cient when x represents
natural data, and in particular, natural images. based on empirical studies characterizing the statistical prop-
erties of natural images, and in compliance with the number of channels in a typical convolutional network
layer, we    nd that m on the order of 100 typically suf   ces.

let d be a distribution of labeled instances (x,   y) over x    y (we use bar notation to distinguish the
label   y from the running index y), and dx be the induced marginal distribution of instances x over x . we
would like to show, given particular assumptions on d, that there exist functions f  1, . . . , f  m     f and
tensors a1, . . . ,ay of order n and dimension m in each mode, such that the score functions hy de   ned in
eq. 2 achieve low classi   cation error:

(cid:20)

(cid:20)

(cid:21)(cid:21)

l0   1d (h1, . . . , hy ) := e(x,  y)   d

  y (cid:54)= argmax

1

hy(x)

y   y

1 [  ] here stands for the indicator function, taking the value 1 when its argument is true, and 0 otherwise.

y}y   y be a set of    ground truth    score functions for which optimal prediction is achieved, or more

let {h   

speci   cally, for which the expected hinge-loss (upper bounds the 0-1 loss) is minimal:

(h   

1, . . . , h   

y ) = argmin

h(cid:48)
1,...,h(cid:48)

y :x   r

lhinged

(h(cid:48)

1, . . . , h(cid:48)
y )

where:

lhinged

(h(cid:48)

1, . . . , h(cid:48)

y ) := e(x,  y)   d

y(x)(cid:9)     h(cid:48)

  y(x)

(cid:21)

(cid:20)

max
y   y

(cid:8)1 [y (cid:54)=   y] + h(cid:48)
y(x)(cid:12)(cid:12)(cid:21)
(cid:12)(cid:12)hy(x)     h   

(cid:20)

max
y   y

y in the sense

(11)
we refer to e as the score approximation error obtained by hy. the 0-1 loss of hy with respect to the labeled
example (x,   y)     x    y is bounded as follows:

our strategy will be to select score functions hy of the format given in eq. 2, that approximate h   
of low expected maximal absolute difference:
e := ex   dx
(cid:21)
(cid:8)1 [y (cid:54)=   y] + h   
(cid:8)1 [y (cid:54)=   y] + h   
(cid:8)1 [y (cid:54)=   y] + h   

y(x)(cid:9)     h   
y   y {1 [y (cid:54)=   y] + hy(x)}     h  y(x)
(cid:8)hy(x)     h   
y(x)(cid:9)     h   
y(x) + hy(x)     h   
(cid:8)(cid:12)(cid:12)hy(x)     h   
y(x)(cid:9)     h   

y(x)(cid:9) + h   
y(x)(cid:12)(cid:12)(cid:9)

  y(x)     h  y(x)

  y(x)     h  y(x)

y   y
= max
y   y
    max
y   y
    max
y   y

  y(x) + 2 max
y   y

  y (cid:54)= argmax

  y(x) + max
y   y

  y(x) + h   

    max

hy(x)

(cid:20)

1

taking expectation of the    rst and last terms above with respect to (x,   y)     d, and recalling the de   nitions
given in eq. 9, 10 and 11, we get:

l0   1d (h1, . . . , hy )     lhinged

27

(h   

1, . . . , h   

y ) + 2e

(9)

(10)

cohen sharir shashua

in words, the classi   cation error of the score functions hy is bounded by the optimal expected hinge-loss
plus a term equal to twice their score approximation error. recall that we did not constrain the optimal score
functions h   
y in any way. thus, assuming a label is deterministic given an instance, the optimal expected
hinge-loss is essentially zero, and the classi   cation error of hy is dominated by their score approximation
error e (eq. 11). our problem thus translates to showing that hy can be selected such that e is small.
at this point we introduce our main assumption on the distribution d, or more speci   cally, on the
marginal distribution of instances dx . according to various studies, in natural settings, the marginal dis-
tribution of individual vectors in x , e.g. of small patches in images, may be relatively well captured by a
gaussian mixture model (gmm) with a moderate number (on the order of 100 or less) of distinct compo-
nents. for example, it was shown in zoran and weiss (2012) that natural image patches of size 2  2, 4  4,
8  8 or 16  16, can essentially be modeled by gmms with 64 components (adding more components barely
improved the log-likelihood). this complies with the common belief that a moderate number of low-level
templates suf   ces in order to model the vast majority of local image patches. following this line, we model
the marginal distribution of xi with a gmm having m components with means   1. . .  m     rs. we assume
that the components are well localized, i.e. that their standard deviations are small compared to the distances
between means, and also compared to the variation of the target functions h   
y. in the context of images for
example, the latter two assumptions imply that a local patch can be unambiguously assigned to a template,
and that the assignment of patches to templates determines the class of an image. returning to general in-
stances x, their id203 mass will be concentrated in distinct regions of the space x , in which for every
i     [n ], the vector xi lies near   ci for some ci     [m ]. the score functions h   
y are approximately constant
in each such region. it is important to stress here that we do not assume statistical independence of xi   s, only
that their possible values can be quantized into m templates   1, . . . ,   m .
under our idealized assumptions on dx , the expectation in the score approximation error e can be

(cid:20)

discretized as follows:

e := ex   dx

max
y   y

(cid:12)(cid:12)hy(x)     h   

y(x)(cid:12)(cid:12)(cid:21)

=

m(cid:88)

(cid:12)(cid:12)hy(mc1,...,cn )     h   

y(mc1,...,cn )(cid:12)(cid:12)

pc1,...,cn max
y   y

c1,...,cn =1

c1,...,cn

pc1,...,cn = 1).

i     [n ] (pc1,...,cn   0, (cid:80)

(12)
where mc1,...,cn := (  c1, . . . ,   cn ) and pc1,...,cn stands for the id203 that xi lies near   ci for every
we now turn to show that f  1. . .f  m can be chosen to separate gmm components, i.e. such that for
every c, d     [m ], f  d (  c) (cid:54)= 0 if and only if c = d. if the functions f   are gaussians (eq. 7), we can simply
set the mean of f  d to   d, and its standard deviations to be low enough such that the function effectively
vanishes at   c when c (cid:54)= d. if f   are neurons (eq. 8), an additional requirement is needed, namely that the
gmm component means   1. . .  m be linearly separable. in other words, we require that for every d     [m ],
there exist wd     rs and bd     r for which w(cid:62)
d   c + bd is positive if c = d and negative otherwise. this may
seem like a strict assumption at    rst glance, but notice that the dimension s is often as large, or even larger,
then the number of components m. in addition, if input vectors xi are normalized to unit length (a standard
practice with image patches for example),   1. . .  m will also be normalized, and thus linear separability is
trivially met. assuming we have linear separability, one may set   d = (wd, bd), and for threshold or relu
activations we indeed get f  d (  c) (cid:54)= 0        c = d. with sigmoid activations, we may need to scale (wd, bd)
so that w(cid:62)
given in eq. 2, we get the following convenient form for hy(mc1,...,cn ):

d   c + bd (cid:28) 0 when c(cid:54)=d, and that would ensure that in this case f  d (  c) effectively vanishes.

assuming we have chosen f  1. . .f  m to separate gmm components, and plugging-in the format of hy

assigning the coef   cient tensors through the following rule:

n(cid:89)

(  ci )

f  ci

c1,...,cn

hy(mc1,...,cn ) = ay
(cid:81)n
y(mc1,...,cn )
h   
(  ci)
i=1 f  ci

c1,...,cn

ay

i=1

=

28

on the expressive power of deep learning: a tensor analysis

implies:

hy(mc1,...,cn ) = h   

y(mc1,...,cn )

for every y     y and c1. . .cn     [m ]. plugging this into eq. 12, we get a score approximation error of zero.
to recap, we have shown that when the parametric functions f   are gaussians (eq. 7) or neurons (eq. 8),
not only are the score functions hy given in eq. 2 universal when m         (see app. c.2), but they can also
achieve zero classi   cation error (eq. 9) with a moderate value of m (on the order of 100) if the underlying
data distribution d is    natural   . in this context, d is regarded as natural if it satis   es two conditions. the
   rst, which is rather mild, requires that a label be completely determined by the instance. for example, an
image will belong to one category with id203 one, and to the rest of the categories with id203
zero. the second condition, which is far more restrictive, states that input vectors composing an instance
can be quantized into a moderate number (m) of templates. the assumption that natural images exhibit this
property is based on various empirical studies where it is shown to hold approximately. since it does not hold
exactly, our analysis is approximate, and its implication in practice is that the classi   cation error introduced
by constraining score functions to have the format given in eq. 2, is negligible compared to other sources of
error (factorization of the coef   cient tensors,    niteness of training data and dif   culty in optimization).

appendix d. related work
the classic approach for theoretically analyzing the power of depth focused on investigation of the com-
putational complexity of boolean circuits. an early result, known as the    exponential ef   ciency of depth   ,
may be summarized as follows: for every integer k, there are boolean functions that can be computed by a
circuit comprising alternating layers of and and or gates which has depth k and polynomial size, yet if one
limits the depth to k     1 or less, an exponentially large circuit is required. see sipser (1983) for a formal
statement of this classic result. recently, rossman et al. (2015) have established a somewhat stronger result,
showing cases where not only are polynomially wide shallow boolean circuits incapable of exact realization,
but also of approximation (i.e. of agreeing with the target function on more than a speci   ed fraction of input
combinations). other classical results are related to threshold circuits, a class of models more similar to
contemporary neural networks than boolean circuits. namely, they can be viewed as neural networks where
each neuron computes a weighted sum of its inputs (possibly including bias), followed by threshold activation
(  (z) = 1[z     0]). for threshold circuits, the main known result in our context is the existence of functions
that separate depth 3 from depth 2 (see hajnal et al. (1987) for a statement relating to exact realization, and
the techniques in maass et al. (1994); martens et al. (2013) for extension to approximation).

more recent studies focus on arithmetic circuits (shpilka and yehudayoff (2010)), whose nodes typically
compute either a weighted sum or a product of their inputs 9 (besides their role in studying expressiveness,
deep networks of this class have been shown to support provably optimal training livni et al. (2014)). a spe-
cial case of this are the sum-product networks (spns) presented in poon and domingos (2011). spns are
a class of deep generative models designed to ef   ciently compute id203 density functions. their sum-
mation weights are typically constrained to be non-negative (such an arithmetic circuit is called monotone),
and in addition, in order for them to be valid (i.e. to be able to compute id203 density functions), addi-
tional architectural constraints are needed (e.g. decomposability and completeness). the most widely known
theoretical arguments regarding the ef   ciency of depth in spns were given in delalleau and bengio (2011).
in this work, two speci   c families of spns were considered, both comprising alternating sum and product
layers     a family f whose nodes form a full binary tree, and a family g with n nodes per layer (excluding
the output), each connected to n     1 nodes in the preceding layer. the authors show that functions imple-
mented by these networks require an exponential number of nodes in order to be realized by shallow (single

9. there are different de   nitions for arithmetic circuits in the literature. we adopt the de   nition given in martens and
medabalimi (2014), under which an arithmetic circuit is a directed acyclic graph, where nodes with no incoming
edges correspond to inputs, nodes with no outgoing edges correspond to outputs, and the remaining nodes are either
labeled as    sum    or as    product   . a product node computes the product of its child nodes. a sum node computes a
weighted sum of its child nodes, where the weights are parameters linked to its incoming edges.

29

cohen sharir shashua

hidden-layer networks). the limitations of this work are twofold. first, as the authors note themselves, it only
analyzes the ability of shallow networks to realize exactly functions generated by deep networks, and does
not provide any result relating to approximation. second, the speci   c spn families considered in this work
are not universal hypothesis classes and do not resemble networks used in practice. recently, martens and
medabalimi (2014) proved that there exist functions which can be ef   ciently computed by decomposable and
complete (d&c) spns of depth d + 1, yet require a d&c spn of depth d or less to have super-polynomial
size for exact realization. this analysis only treats approximation in the limited case of separating depth 4
from depth 3 (d&c) spns. additionally, it only deals with speci   c separating functions, and does not con-
vey information regarding how frequent these are. in other words, according to this analysis, it may be that
almost all functions generated by deep networks can be ef   ciently realized by shallow networks, and there
are only few pathological functions for which this does not hold. a further limitation of this analysis is that
for general d, the separation between depths d + 1 and d is based on a multilinear circuit result by raz and
yehudayoff (2009), that translates into a network that once again does not follow the common practices of
deep learning.

there have been recent attempts to analyze the ef   ciency of network depth in other settings as well.
the most commonly used type of neural networks these days includes neurons that compute a weighted
sum of their inputs (with bias) followed by recti   ed linear unit (relu) activation (  (z) = max{0, z}).
pascanu et al. (2013) and montufar et al. (2014) study the number of linear regions that may be expressed
by such networks as a function of their depth and width, thereby showing existence of functions separating
deep from shallow (depth 2) networks. telgarsky (2015) shows a simple construction of a depth d width 2
relu network that operates on one-dimensional inputs, realizing a function that cannot be approximated by
relu networks of depth o(d/ log d) and width polynomial in d. eldan and shamir (2015) provides functions
expressible by relu networks of depth 3 and polynomial width, which can only be approximated by a depth
2 network if the latter   s width is exponential. the result in this paper applies not only to relu activation,
but also to the standard sigmoid (  (z) = 1/(1 + e   z)), and more generally, to any universal activation (see
assumption 1 in eldan and shamir (2015)). bianchini and scarselli (2014) also considers different types of
activations, studying the topological complexity (through betti numbers) of decision regions as a function of
network depth, width and activation type. the results in this paper establish the existence of deep vs. shallow
separating functions only for the case of polynomial activation. while the above works do address more
conventional neural networks, they do not account for the structure of convolutional networks     the most
successful deep learning architectures to date, and more importantly, they too prove only existence of some
separating functions, without providing any insight as to how frequent these are.

we are not the    rst to incorporate ideas from the    eld of tensor analysis into deep learning. socher
et al. (2013), yu et al. (2012), setiawan et al. (2015), and hutchinson et al. (2013) all proposed different
neural network architectures that include tensor-based elements, and exhibit various advantages in terms of
expressiveness and/or ease of training. in janzamin et al. (2015), an alternative algorithm for training neu-
ral networks is proposed, based on tensor decomposition and fourier analysis, with proven generalization
bounds. in novikov et al. (2014), anandkumar et al. (2014), yang and dunson (2015) and song et al. (2013),
algorithms for tensor decompositions are used to estimate parameters of different id114. no-
tably, song et al. (2013) uses the relatively new hierarchical tucker decomposition (hackbusch and k  uhn
(2009)) that we employ in our work, with certain similarities in the formulations. the works differ consider-
ably in their objectives though: while song et al. (2013) focuses on the proposal of a new training algorithm,
our purpose in this work is to analyze the expressive ef   ciency of networks and how that depends on depth.
recently, lebedev et al. (2014) modeled the    lters in a convolutional network as four dimensional tensors,
and used the cp decomposition to construct an ef   cient and accurate approximation. another work that draws
a connection between tensor analysis and deep learning is the recent study presented in haeffele and vidal
(2015). this work shows that with suf   ciently large neural networks, no matter how training is initialized,
there exists a local optimum that is accessible with id119, and this local optimum is approximately
equivalent to the global optimum in terms of objective value.

30

on the expressive power of deep learning: a tensor analysis

appendix e. computation in log-space with simnets
a practical issue one faces when implementing arithmetic circuits is the numerical instability of the product
operation     a product node with a large number of inputs is easily susceptible to numerical over   ow or
under   ow. a common solution to this is to perform the computations in log-space, i.e. instead of computing
activations we compute their log. this requires the activations to be non-negative to begin with, and alters
i log   i. a

the sum and product operations as follows. a product simply turns into a sum, as log(cid:81)
sum becomes what is known as log-sum-exp or softmax: log(cid:80)

i   i =(cid:80)

i   i = log(cid:80)

turning to our networks, the requirement that all activations be non-negative does not limit their univer-
sality. the reason for this is that the functions f   are non-negative in both cases of interest     gaussians (eq. 7)
and neurons (eq. 8). in addition, one can always add a common offset to all coef   cient tensors ay, ensuring
they are positive without affecting classi   cation. non-negative decompositions (i.e. decompositions with all
weights holding non-negative values) can then be found, leading all network activations to be non-negative.
in general, non-negative tensor decompositions may be less ef   cient than unconstrained decompositions, as
there are cases where a non-negative tensor supports an unconstrained decomposition that is smaller than its
minimal non-negative decomposition. nevertheless, as we shall soon see, these non-negative decompositions
translate into a proven architecture, which was demonstrated to achieve comparable performance to state of
the art convolutional networks, thus in practice the deterioration in ef   ciency does not seem to be signi   cant.
na    vely implementing cp or ht model (   g. 1 or 2 respectively) in log-space translates to log activation
following the locally connected linear transformations (convolutions if coef   cients are shared, see sec. 3.3),
to product pooling turning into sum pooling, and to exp activation following the pooling. however, applying
exp and log activations as just described, without proper handling of the inputs to each computational layer,
would not result in a numerically stable computation 10.

i exp(log   i).

the simnet architecture (cohen and shashua (2014); cohen et al. (2016)) naturally brings forth a nu-
merically stable implementation of our networks. the architecture is based on two ingredients     a    exible
similarity measure and the mex operator:

       1

n

(cid:88)

j

      

mex  (x, b) :=

1
  

log

exp(  (xj + bj))

the similarity layer, capable of computing both the common convolutional operator as well as weighted
lp norm, may realize the representation by computing log f  (xi), whereas mex can naturally implement
both log-sum-exp and sum-pooling (lim     0 mex  (x, 0) = meanj{xj}) in a numerically stable manner.

not only are simnets capable of correctly and ef   ciently implementing our networks, but they have
already been demonstrated (cohen et al. (2016)) to perform as well as state of the art convolutional networks
on several image recognition benchmarks, and outperform them when computational resources are limited.

however can be easily corrected by de   ning c := maxi log   i, and computing log(cid:80)

10. na    ve implementation of softmax is not numerically stable, as it involves storing   i = exp(log   i) directly. this
i exp(log   i     c) + c. the
result is identical, but now we only exponentiate negative numbers (no over   ow), with at least one of these numbers
equal to zero (no under   ow).

31

