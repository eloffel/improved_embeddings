embedding lexical features via low-rank tensors

harbin institute of technology

mo yu   

ibm watson

6
1
0
2

 
r
p
a
2

 

 
 
]
l
c
.
s
c
[
 
 

1
v
1
6
4
0
0

.

4
0
6
1
:
v
i
x
r
a

yum@us.ibm.com

raman arora

johns hopkins university
arora@cs.jhu.edu

abstract

modern nlp models rely heavily on engi-
neered features, which often combine word
and contextual information into complex lexi-
cal features. such combination results in large
numbers of features, which can lead to over-
   tting. we present a new model that repre-
sents complex lexical features   comprised of
parts for words, contextual information and
labels   in a tensor that captures conjunction
information among these parts. we apply low-
rank tensor approximations to the correspond-
ing parameter tensors to reduce the parame-
ter space and improve prediction speed. fur-
thermore, we investigate two methods for han-
dling features that include id165s of mixed
lengths. our model achieves state-of-the-art
results on tasks in id36, pp-
attachment, and preposition disambiguation.

introduction

1
statistical nlp models usually rely on hand-
designed features, customized for each task. these
features typically combine lexical and contextual in-
formation with the label to be scored.
in relation
extraction, for example, there is a parameter for the
presence of a speci   c relation occurring with a fea-
ture conjoining a word type (lexical) with depen-
dency path information (contextual).
in measur-
ing phrase semantic similarity, a word type is con-
joined with its position in the phrase to signal its
role. figure 1b shows an example in dependency
parsing, where multiple types (words) are conjoined
with pos tags or distance information.

   paper submitted during mo yu   s phd study at hit.

mark dredze

hltcoe

johns hopkins university
mdredze@cs.jhu.edu

matthew r. gorid113y

carnegie mellon university
mgorid113y@cs.cmu.edu

to avoid model over-   tting that often results from
features with lexical components, several smoothed
lexical representations have been proposed and
shown to improve performance on various nlp
tasks; for instance, id27s (bengio et al.,
2006) help improve ner, id33 and
id14 (miller et al., 2004; koo et
al., 2008; turian et al., 2010; sun et al., 2011; roth
and woodsend, 2014; hermann et al., 2014).

however, using only id27s is not suf-
   cient to represent complex lexical features (e.g.   
in figure 1c). in these features, the same word em-
bedding conjoined with different non-lexical prop-
erties may result in features indicating different la-
bels; the corresponding lexical feature representa-
tions should take the above interactions into consid-
eration. such important interactions also increase
the risk of over-   tting as feature space grows ex-
ponentially, yet how to capture these interactions in
representation learning remains an open question.

to address the above problems,1 we propose a
general and uni   ed approach to reduce the feature
space by constructing low-dimensional feature rep-
resentations, which provides a new way of combin-
ing id27s, traditional non-lexical prop-
erties, and label information. our model exploits
the inner structure of features by breaking the fea-
ture into multiple parts: lexical, non-lexical and (op-
tional) label. we demonstrate that the full feature is
an outer product among these parts. thus, a param-
eter tensor scores each feature to produce a predic-
tion. our model then reduces the number of param-

1our paper only focuses on lexical features, as non-lexical

features usually suffer less from over-   tting.

figure 1: an example of lexical features used in id33. to predict the    pmod    arc (the dashed one)
between    see    and    with    in (a), we may rely on lexical features in (b). here p, c, g are indices of the word    with   ,
its child (   telescope   ) and a candidate head. figure (c) shows what the    fth feature (  ) is like, when the candidate is
   see   . as is common in multi-class classi   cation tasks, each template generates a different feature for each label y.
thus a feature    = wg     wc     u     y is the conjunction of the four parts. figure (d) is the one-hot representation of
  , which is equivalent to the outer product (i.e. a 4-way tensor) among the four one-hot vectors. v(x) = 1 means the
vector v has a single non-zero element in the x position.

eters by approximating the parameter tensor with a
low-rank tensor:
the tucker approximation of yu
et al. (2015) but applied to each embedding type
(view), or the canonical/parallel-factors decompo-
sition (cp). our models use fewer parameters than
previous work that learns a separate representation
for each feature (ando and zhang, 2005; yang and
eisenstein, 2015). cp approximation also allows for
much faster prediction, going from a method that is
cubic in rank and exponential in the number of lex-
ical parts, to a method linear in both. furthermore,
we consider two methods for handling features that
rely on id165s of mixed lengths.

our model makes the following contributions

when contrasted with prior work:

lei et al. (2014) applied cp to combine different
views of features. compared to their work, our us-
age of cp-decomposition is different in the applica-
tion to id171: (1) we focus on dimension-
ality reduction of existing, well-veri   ed features,
while lei et al. (2014) generates new features (usu-
ally different from ours) by combining some    atom   
features. thus their work may ignore some useful
features; it relies on binary features as supplemen-
tary but our model needs not. (2) lei et al. (2014)   s
factorization relies on views with explicit meanings,
e.g. head/modi   er/arc in id33, mak-
ing it less general. therefore its applications to tasks
like id36 are less obvious.

compared to our previous work (gorid113y et al.,
2015; yu et al., 2015), this work allows for higher-
order interactions, mixed-length id165 features,

lower-rank representations. we also demonstrate the
strength of our new model via applications to new
tasks.

the resulting method learns smoothed feature
representations combining lexical, non-lexical and
label information, achieving state-of-the-art perfor-
mance on several tasks: id36, preposi-
tion semantics and pp-attachment.

2 notation and de   nitions
we begin with some background on notation and
de   nitions. let t     rd1          dk be a k-way ten-
sor (i.e., a tensor with k views).
in this paper,
we consider the tensor k-mode product, i.e. mul-
tiplying a tensor t     rd1          dk by a matrix x    
rdk  j (or a vector if j = 1) in mode (view) k.
the product is denoted by t   k x and is of size
d1              dk   1    j    dk+1              dk. element-
wise, we have
(t   k x)i1...ik   1 j ik+1...ik =

ti1...ik...ik xikj,

dk(cid:88)ik=1

for j = 1, . . . , j. a mode-k    ber ti1...ik   1   ik+1...ik
of t is the dk dimensional vector obtained by    xing
all but the kth index. the mode-k unfolding t(k) of
t is the dk   (cid:81)i(cid:54)=k di matrix obtained by concate-
nating all the(cid:81)i(cid:54)=k di mode-k    bers along columns.
given two matrices w1     rd1  r1, w2     rd2  r2,
we write w1     w2 to denote the kronecker product
between w1 and w2 (outer product for vectors). we
de   ne the frobenius product (matrix dot product)
a (cid:12) b = (cid:80)i,j aijbij between two matrices with

1 0 1 0    =wg    wc     u    	
 y    see       pmod       telescope    postag(g+1) =   dt    telescope see with pmod? a a    girl  word(c)   word(g) word(c)   postag(g) word(p)   word(g) word(c)   postag(g+1) word(c)   word(g)   postag(g+1) word(c)   word(g)   distance(g, p)     c p g 0 bcctswlmodelprf1prf1prf1headembid98(wsize=1)+localfeaturesid98(wsize=3)+localfeaturesfctlocalonlyfctglobal60.6942.3949.9256.4134.4542.7841.9531.7736.16fctglobal(brown)63.1539.5848.6662.4536.4746.0554.9529.9338.75fctglobal(id138)59.0044.7950.9260.2039.6047.7750.9534.1840.92pet(plankandmoschitti,2013)51.240.645.351.037.843.435.432.834.0bow(plankandmoschitti,2013)57.237.145.057.531.841.041.127.232.7best(plankandmoschitti,2013)55.343.148.554.138.144.739.935.837.8table7:performanceonace2005testsets.the   rstpartofthetableshowstheperformanceofdifferentmodelsondifferentsourcesofentitytypes,where   g   meansthatthegoldtypesareusedand   p   meansthatweareusingthepredictedtypes.thesecondpartofthetableshowstheresultsunderthelow-resourcesetting,wheretheentitytypesareunknown.devmrrtestmrrmodelfine-tuning1,00010,000100,0001,00010,000100,000sum-46.9535.2930.6952.6341.1937.32sumy50.8136.8132.9257.2345.0141.23bestrecursivenn(d=50)y45.6730.8627.0554.8439.2535.49bestrecursivenn(d=200)y48.9733.5031.1353.5940.5038.57fctn47.5335.5831.3154.3341.9639.10fcty51.2236.7633.5961.1146.9944.31fct+lm-49.4337.4632.2253.5642.6339.44fct+lm+supervisedy53.8237.4834.4365.4749.4445.65joint56.5341.4136.4568.5251.6546.53table8:performanceonthesemanticsimilaritytaskwithppdbdata.appendix1:featuresusedinfct7.1overallperformancesonace2005sum(ab)6=sum(ba)(7)2n2|v|n(8)aa0ofb0b(9)aba0ofb0(10)t f e)relations(11)f   e[f:e]fctid98@`@r@`@t=@`@r@r@tl1,l2@l@r=@l1@r+@l2@rs(l,e1,e2,s;t)=nxi=1s(l,ewi,fwi)=nxi=1tl fwi ewi(12)@`@t=nxi=1@`@r   fwi   ewi,(13)v2(wc)=1 v3(u)=1 v4(y)=1 0 v1(wg)=1 1 0 0 1 0 0 (a) (b) (c) (d) the same sizes; and de   ne element-wise (hadamard)
multiplication a     b between vectors with the same
sizes.

tucker decomposition: tucker decomposition
represents a d1    d2    . . .    dk tensor t as:

t = g   1 w1   2 w2 . . .   k wk

(1)

where each   i is the tensor i-mode product and
each wi is a ri    di matrix. tensor g with size
r1    r2    . . .    rk is called the core tensor. we
say that t has a tucker rank (r(1), r(2), . . . , r(k)),
where r(i) = rank(t(i)) is the rank of mode-i un-
folding. to simplify learning, we de   ne the tucker
rank as r(i)=rank(g(i)), which can be bounded sim-
ply by the dimensions of g, i.e. r(i)     ri; this allows
us to enforce a rank constraint on t simply by re-
stricting the dimensions ri of g, as described in   6.
cp decomposition: cp decomposition represents
a d1  d2  . . .  dk tensor t as a sum of rank-one
tensors (i.e. a sum of outer products of k vectors):

t =

r(cid:88)j=1

w1[j, :]     w2[j, :]     . . .     wk[j, :]

(2)

where each wi is an r    di matrix and wi[j, :] is the
vector of its j-th row. for cp decomposition, the
rank r of a tensor t is de   ned to be the number of
rank-one tensors in the decomposition. cp decom-
position can be viewed as a special case of tucker
decomposition in which r1 = r2 = . . . = rk = r
and g is a superdiagonal tensor.

3 factorization of lexical features
suppose we have feature    that includes information
from a label y, multiple lexical items w1, . . . , wn
and non-lexical property u. this feature can be fac-
torized as a conjunction of each part:    = y     u    
w1   . . .   wn. the feature    res when all (n+2) parts
   re in the instance (re   ected by the     symbol in   ).
the one-hot representation of    can then be viewed
as a tensor e   = y    u    w1              wn, where each
feature part is also represented as a one-hot vector.2
figure 1d illustrates this case with two lexical parts.
given an input instance x and its associated la-
bel y, we can extract a set of features s(x, y). in

2u, y, wi denote one-hot vectors instead of symbols.

a traditional log-linear model, we view the instance
x as a bag-of-features, i.e. a feature vector f (x, y).
each dimension corresponds to a feature   , and has
value 1 if        s(x, y). then the log-linear model
scores the instance as s(x, y; w) = wt f (x, y) =
(cid:80)     s(x,y) s(  ; w), where w is the parameter vec-
tor. we can re-write s(x, y; w) based on the factor-
ization of the features using tensor multiplication; in
which w becomes a parameter tensor t :
s(x, y; w) = s(x, y;t ) = (cid:88)     s(x,y)

s(  ;t )

(3)

here each    has the form (y, u, w1, . . . , wn), and

(4)

s(  ;t ) = t   l y   f u   w1 w1...   wn wn.
note that one-hot vectors wi of words themselves
are large (|wi| > 500k), thus the above formulation
with parameter tensor t can be very large, making
parameter estimation dif   cult. instead of estimating
only the values of the dimensions which appear in
training data as in traditional methods, we will re-
duce the size of tensor t via a low-rank approxima-
tion. with different approximation methods, (4) will
have different equivalent forms, e.g. (6), (7) in   4.1.
optimization objective: the id168 (cid:96) for
training the log-linear model uses (3) for scores, e.g.,
exp{s(x,y;t )}
the log-loss (cid:96)(x, y;t ) =     log
.
y(cid:48)   l exp{s(x,y(cid:48);t )}
learning can be formulated as the following opti-
mization problem:

(cid:80)

(5)

t

minimize:

(cid:96)(x, y;t )

(cid:88)(x,y)   d
subject to:          
rank(t )     (r1, r2, ..., rn+2)
(tucker-form)
rank(t )     r
(cp-form)

where the constraints on rank(t ) depend on the cho-
sen tensor approximation method (  2).
the above framework has some advantages: first,
as discussed in   1 and here, we hope the represen-
tations capture rich interactions between different
parts of the lexical features; the low-rank tensor ap-
proximation methods keep the most important inter-
action information of the original tensor, while sig-
ni   cantly reducing its size. second, the low-rank
structure will encourage weight-sharing among lex-
ical features with similar decomposed parts, leading

to better model generalization. note that there are
examples where features have different numbers of
multiple lexical parts, such as both unigram and bi-
gram features in pp-attachment. we will use two
different methods to handle these features (  5).
factorization)
remarks
compared to prior work, e.g.
(lei et al., 2014;
lei et al., 2015), the proposed factorization has the
following advantages:

(advantages of our

1. parameter explosion when mapping a view
with lexical properties to its representation vec-
tor (as will be discussed in 4.3): our factoriza-
tion allows the model to treat id27s
as inputs to the views of lexical parts, dramati-
cally reducing the parameters. prior work can-
not do this since its views are mixtures of lexi-
cal and non-lexical properties. note that lei et
al. (2014) uses embeddings by concatenating
them to speci   c views, which increases dimen-
sionality, but the improvement is limited.

2. no weight-sharing among conjunctions with
same lexical property,
like the child-word
   word(c)    and its conjunction with head-postag
   word(c)     word(g)    in figure 1(b). the fac-
torization in prior work treats them as indepen-
dent features, greatly increasing the dimension-
ality. our factorization builds representations
of both features based on the embedding of
   word(c)   , thus utilizing their connections and
reducing the dimensionality.

the above advantages are also key to overcome the
problems of prior work mentioned at the end of   1.
4 feature representations via low-rank

tensor approximations

using one-hot encodings for each of the parts of fea-
ture    results in a very large tensor. this section
shows how to compute the score in (4) without con-
structing the full feature tensor using two tensor ap-
proximation methods (  4.1 and   4.2).
we begin with some intuition. to score the orig-
inal (full rank) tensor representation of   , we need
a parameter tensor t of size d1    d2    . . .    dn+2,
where d3 =        = dn+2 = |v | is the vocabulary
size, n is the number of lexical parts in the feature

and d1 = |l| and d2 = |f| are the number of
different labels and non-lexical properties, respec-
tively.
(  5 will handle n varying across features.)
our methods reduce the tensor size by embedding
each part of    into a lower dimensional space, where
we represent each label, non-lexical property and
words with an r1, r2, r3, . . . , rn+2 dimensional vec-
tor respectively (ri (cid:28) di,    i). these embedded
features can then be scored by much smaller ten-
sors. we denote the above transformations as ma-
trices wl     rr1  d1, wf     rr2  d2, wi     rri+2  di+2
for i = 1, . . . , n, and write corresponding low-
dimensional hidden representations as h(l)
y = wly,
u = wf u and h(i)
h(f )
in our methods, the above transformations of em-
beddings are parts of low-rank tensors as in (5),
so the embeddings of non-lexical properties and la-
bels can be trained simultaneously with the low-rank
tensors. note that for one-hot input encodings the
transformation matrices are essentially lookup ta-
bles, making the computation of these transforma-
tions suf   ciently fast.

w = wiw.

4.1 tucker form
for our    rst approximation, we assume that tensor
t has a low-rank tucker decomposition: t = g   l
wl   f wf   w1 w1   w2          wn wn. we can then
express the scoring function (4) for a feature    =
(y, u, w1, . . . wn) with n-lexical parts, as:

s(y, u, w1,       , wn; g, wl, wf ,{wi}n
= g   l h(l)

u   w1 h(1)

y   f h(f )

w1          wn h(n)
wn ,

i=1)

(6)

u

, h(l)

which amounts to    rst projecting u, y, and wi (for
all i) to lower dimensional vectors h(f )
y , h(i)
wi ,
and then weighting these hidden representations us-
ing the    attened core tensor g. the low-dimensional
representations and the corresponding weights are
learned jointly using a discriminative (supervised)
criterion. we call the model based on this repre-
sentation the low-rank feature representation with
tucker form, or lrfrn-tucker.

4.2 cp form
for the tucker approximation the number of param-
eters in (6) scale exponentially with the number of
lexical parts. for instance, suppose each h(i)
wi has di-

mensionality r, then |g|     rn. to address scalabil-
ity and further control the complexity of our tensor
based model, we approximate the parameter tensor
using cp decomposition as in (2), resulting in the
following scoring function:
s(y, u, w1,       , wn; wl, wf ,{wi}n

r(cid:88)j=1(cid:16)h(l)

y     h(f )

u     h(1)

i=1) =
wn(cid:17)j
w1                h(n)

.

(7)

we call this model low-rank feature representa-
tion with cp form (lrfrn-cp).

4.3 pre-trained id27s
one of the computational and statistical bottlenecks
in learning these lrfrn models is the vocabulary
size; the number of parameters to learn in each ma-
trix wi scales linearly with |v | and would require
very large sets of labeled training data. to alle-
viate this problem, we use pre-trained continuous
id27s (mikolov et al., 2013) as input
embeddings rather than the one-hot word encodings.
we denote the m-dimensional id27s by
ew; so the transformation matrices wi for the lexical
parts are of size ri    m where m (cid:28) |v |.
we note that when suf   ciently large labeled data
is available, our model allows for    ne-tuning the
pre-trained id27s to improve the expres-
sive strength of the model, as is common with deep
network models.

remarks our lrfrs introduce embeddings for
non-lexical properties and labels, making them bet-
ter suit the common setting in nlp: rich linguistic
properties; and large label sets such as open-domain
tasks (hoffmann et al., 2010). the lrfr-cp better
suits id165 features, since when n increases 1, the
only new parameters are the corresponding wi. it is
also very ef   cient during prediction (o(nr)), since
the cost of transformations can be ignored with the
help of look-up tables and pre-computing.

5 learning representations for id165

lexical features of mixed lengths

for features with n lexical parts, we can train an
lrfrn model to obtain their representations. how-
ever, we often have features of varying n (e.g. both
unigrams (n=1) and bigrams (n=2) as in figure 1).

we require representations for features with arbi-
trary different n simultaneously.

we propose two solutions. the    rst is a straight-
forward solution based on our framework, which
handles each n with a (n+2)-way tensor. this strat-
egy is commonly used in nlp, e.g. taub-tabib et
al. (2015) have different id81s for differ-
ent order of dependency features. the second is an
approximation method which aims to use a single
tensor to handle all ns.

multiple low-rank tensors suppose that we
can divide the feature set s(x, y) into subsets
s1(x, y), s2(x, y), . . . , sn(x, y) which correspond
to features with one lexical part (unigram features),
two lexical parts (bigram features), . . . and n lexi-
cal parts (id165 features), respectively. to handle
these types of features, we modify the training ob-
jective as follows:

where the score of a training instance (x, y) is de-

t1,t2,       ,tn (cid:88)(x,y)   d
(cid:96)(x, y;t1,t2, . . . , ...tn),
i=1(cid:80)     si(x,y) s(  ;ti). we
   ned as s(x, y;t ) =(cid:80)n
use the tucker form low-rank tensor for t1, and the
cp form for ti (   i > 1). we refer to this method as
lrfr1-tucker & lrfr2-cp.

minimize

(8)

word clusters alternatively, to handle different
numbers of lexical parts, we replace some lexical
parts with discrete word clusters. let c(w) denote
the word cluster (e.g.
from brown id91) for
word w. for bigram features we have:
s(y, u, w1, w2;t )
= s(y, u   c(w1), w2;t ) + s(y, u   c(w2), w1;t )
= t   l y   f (u     c(w1))   w ew2

+ t   l y   f (u     c(w2))   w ew1

(9)
where for each word we have introduced an addi-
tional set of non-lexical properties that are conjunc-
tions of word clusters and the original non-lexical
properties. this allows us to reduce an id165
feature representation to a unigram representation.
the advantage of this method is that it uses a sin-
gle low-rank tensor to score features with different
numbers of lexical parts. this is particularly helpful
when we have very limited labeled data. we denote
this method as lrfr1-brown, since we use brown
clusters in practice. in the experiments we use the

tucker form for lrfr1-brown.

6 parameter estimation
the goal of learning is to    nd a tensor t that solves
problem (5). note that this is a non-convex objec-
tive, so compared to the convex objective in a tradi-
tional log-linear model, we are trading better fea-
ture representations with the cost of a harder op-
timization problem. while stochastic gradient de-
scent (sgd) is a natural choice for learning rep-
resentations in large data settings, problem (5) in-
volves rank constraints, which require an expensive
proximal operation to enforce the constraints at each
iteration of sgd. we seek a more ef   cient learning
algorithm. note that we    xed the size of each trans-
formation matrix wi     rri  di so that the smaller
dimension (ri < di) matches the upper bound on the
rank. therefore, the rank constants are always sat-
is   ed through a run of sgd and we in essence have
an unconstrained optimization problem. note that in
this way we do not guarantee orthogonality and full-
rank of the learned transformation matrices. these
properties are assumed in general, but are not neces-
sary according to (kolda and bader, 2009).

the gradients are computed via the chain-rule.
we use adagrad (duchi et al., 2011) and apply l2
id173 on all wis and g, except for the case
of ri=di, where we will start with wi = i and reg-
ularize with (cid:107)wi - i(cid:107)2. we use early-stopping on a
development set.

7 experimental settings
we evaluate lrfr on three tasks: id36,
pp attachment and preposition disambiguation (see
table 1 for a task summary). we include detailed
feature templates in table 2.

pp-attachment and id36 are two
fundamental nlp tasks, and we test our models on
the largest english data sets. the preposition disam-
biguation task was designed for compositional se-
mantics, which is an important application of deep
learning and distributed representations. on all
these tasks, we compare to the state-of-the-art.

we use the same id27s in belinkov et
al. (2014) on pp-attachment for a fair comparison.
for the other experiments, we use the same 200-d
id27s in yu et al. (2015).

id36 we use the english portion
of the ace 2005 id36 dataset (walker
et al., 2006). following yu et al. (2015), we use both
gold entity spans and types, train the model on the
news domain and test on the broadcast conversation
domain. to highlight the impact of training data size
we evaluate with all 43,518 relations (entity mention
pairs) and a reduced training set of the    rst 10,000
relations. we report precision, recall, and f1.

we compare to two baseline methods: 1) a log-
linear model with a rich binary feature set from sun
et al. (2011) and zhou et al. (2005) as described
in yu et al. (2015) (baseline); 2) the embedding
model (fcm) of gorid113y et al. (2015), which uses
rich linguistic features for id36. we
use the same feature templates and evaluate on    ne-
grained relations (sub-types, 32 labels) (yu et al.,
2015). this will evaluate how lrfr can utilize non-
lexical linguistic features.

pp-attachment we consider
the prepositional
phrase (pp) attachment
task of belinkov et al.
(2014),3 where for each pp the correct head (verbs
or nouns) must be selected from content words be-
fore the pp (within a 10-word window). we formu-
late the task as a ranking problem, where we opti-
mize the score of the correct head from a list of can-
didates with varying sizes.

pp-attachment suffers from data sparsity because
of bi-lexical features, which we will model with
methods in   5. belikov et al. show that rich fea-
tures     pos, id138 and verbnet     help this task.
the combination of these features give a large num-
ber of non-lexical properties, for which embeddings
of non-lexical properties in lrfr should be useful.
we extract a dev set from section 22 of the ptb
following the description in belinkov et al. (2014).

preposition disambiguation we consider
the
preposition disambiguation task proposed by ritter
et al. (2014). the task is to determine the spatial re-
lationship a preposition indicates based on the two
objects connected by the preposition. for example,
   the apple on the refrigerator    indicates the    support
by horizontal surface    relation, while    the apple on
the branch    indicates the    support from above    re-
lation. since the meaning of a preposition depends

3

http://groups.csail.mit.edu/rbg/code/pp

task
id36
pp-attachment
preposition disambiguation

benchmark
yu et al. (2015)

belinkov et al. (2014)

ritter et al. (2014)

dataset
ace 2005

wsj

ritter et al. (2014)

32
-
6

1,213 / 607

264

9/3

numbers on each view

#labels (d1)

#non-lexical features (d2)

table 1: statistics of each task. pp-attachment and preposition disambiguation have both unigram and bigram fea-
tures. therefore we list the numbers of non-lexical properties for both types.

set
heademb

context
in-between
on-path
set
bag of words
word-position
preposition

template

{i[i = h1], i[i = h2]} (head of m1/m2)
i[i = h1/h2    1] (left/right token of wh1/h2 )
i[i > h1]&i[i < h2]&{  , th1 , th2 , th1 &th2}

&{  , th1 , th2 , th1 &th2}

i[wi     p ] &{  , th1 , th2 , th1 &th2}

template

w, p & w (w is wm or wh)

wm, wh, wm & wh

p, p & wm, p & wh, p & wm & wh

set

bag of words

distance

prep
pos

nextpos
verbnet

id138

template

w (w is wm or wh), wm&wh

dis(wh, wm) & {wm, wh, wm&wh}

wp & {wm, wh, wm&wh}
t(wh) & {wm, wh, wm&wh}
t(wh+1) & {wm, wh, wm&wh}
p = {p(wh)} & {wm, wh, wm&wh}
i[wp     p ] & {wm, wh, wm&wh}
rh = {r(wh)} & {wm, wh, wm&wh}
rm = {r(wm)} & {wm, wh, wm&wh}

table 2: up-left: unigram lexical features (only showing non-lexical parts) for id36 (from yu et
al. (2014)). we denote the two target entities as m1, m2 (with head indices h1, h2, ne types th1, th2), and their
dependency path as p . right: uni/bi-gram feature for pp-attachment: each feature is de   ned on tuple (wm, wp,
wh), where wp is the preposition word, wm is the child of the preposition, and wh is a candidate head of wp. t(w):
pos tag of word w; p(w): a preposition collocation of verb w from verbnet; r(w): the root hypernym of word
w in id138. dis(  ,  ): the number of candidate heads between two words. down-left: uni/bi-gram feature for
preposition disambiguation (for each preposition word p, its modi   er noun wm and head noun wh). since the
sentences are different from each other on only p, wm and wh, we ignore the words on the other positions.

on the combination of both its head and child word,
we expect conjunctions between these word embed-
dings to help, i.e. features with two lexical parts.

we include three baselines: point-wise addition
(sum) (mitchell and lapata, 2010), concatena-
tion (ritter et al., 2014), and an id166 based on hand-
crafted features in table 2. ritter et al. show that the
   rst two methods beat other compositional models.

hyperparameters
are all tuned on the dev set.
the chosen values are learning rate    = 0.05 and the
weight of l2 regularizer    = 0.005 for lrfr, except
for the third lrfr in table 3 which has    = 0.05.
we select the rank of lrfr-tucker with a grid
search from the following values: r1 = {10, 20, d1},
r2 = {20, 50, d2} and r3 = {50, 100, 200}. for
lrfr-cp, we select r = {50, 100, 200}. for the
pp-attachement task there is no r1 since it uses a
ranking model. for the preposition disambiguation
we do not choose r1 since the number of labels is
small.

8 results
id36 all lrfr-tucker models
improve over baseline and fcm (table 3), making

these the best reported numbers for this task. how-
ever, lrfr-cp does not work as well on the features
with only one lexical part. the tucker-form does a
better job of capturing interactions between differ-
ent views.
in the limited training setting, we    nd
that lrfr-cp does best.

additionally, the primary advantage of the cp
approximation is its reduction in the number of
model parameters and running time. we report each
model   s running time for a single pass on the de-
velopment set. the lrfr-cp is by far the fastest.
the    rst three lrfr-tucker models are slightly
slower than fcm, because they work on dense non-
lexical property embeddings while fcm bene   ts
from sparse vectors.

pp-attachment table 4 shows that lrfr (89.6
and 90.3) improves over the previous best stan-
dalone system hpcd (88.7) by a large margin, with
exactly the same resources. belinkov et al. (2014)
also reported results of parsers and parser re-rankers,
which can access to additional resources (complete
parses for training and complete sentences as in-
puts) so it is unfair to compare them with the stan-
dalone systems like hpcd and our lrfr. nonethe-

method
baseline
fcm
lrfr1-tucker
lrfr1-tucker
lrfr1-tucker
lrfr1-tucker
lrfr1-cp

r2
-

r3
-

r1
-

parameters

full set (|d|=43,518) reduced set (|d|=10,000)
p
60.2
32/n 264/n 200/n 62.9
32/n
200/y 62.1
200/n 63.5
32/n
200/y 62.4
20/y
57.4
32/y
50/y
61.3

f1
55.3
55.4
57.0
56.6
56.1
54.8
55.5

r
51.2
49.6
52.7
51.1
51.0
52.4
50.7

20/y
20/y
20/y
20/y
200/y

61.6
51.5
52.8
52.1
49.7
58.3

37.1
40.8
40.1
41.2
46.1
41.6

46.3
45.5
45.6
46.0
47.8
48.6

f1
-

r
-

p
-

prediction
time (ms)

-

2,242
3,076
2,972
2,538
1,198
502

table 3: results on test for id36. y(es)/n(o) indicates whether embeddings are updated during training.

system
id166 (belinkov et al., 2014)
hpcd (belinkov et al., 2014)
lrfr1-tucker & lrfr2-cp
lrfr1-brown
rbg (lei et al., 2014)
charniak-rs (mcclosky et al., 2006)
rbg + hpcd (combined model)

resources used

distance, word, embedding, clusters, pos, id138, verbnet

distance, embedding, pos, id138, verbnet
distance, embedding, pos, id138, verbnet

distance, embedding, clusters, pos, id138, verbnet

dependency parser

dependency parser + re-ranker

dependency parser + distance, embedding, pos, id138, verbnet

acc
86.0
88.7
90.3
89.6
88.4
88.6
90.1

table 4: pp-attachment test accuracy. the baseline results are from belinkov et al. (2014).

less lrfr1-tucker & lrfr2-cp (90.3) still out-
performs the state-of-the-art parser rbg (88.4), re-
ranker charniak-rs (88.6), and the combination of
the state-of-the-art parser and compositional model
rbg + hpcd (90.1). thus, even with fewer re-
sources, lrfr becomes the new best system.

not shown in the table: we also tried lrfr1-
tucker & lrfr2-cp with postag features only
(89.7), and with grand-head-modi   er conjunctions
removed (89.3) . note that compared to lrfr,
rbg bene   ts from binary features, which also ex-
ploit grand-head-modi   er structures. yet the above
reduced models still work better than rbg (88.4)
without using additional resources.4 moreover, the
results of lrfr can still be potentially improved by
combining with binary features. the above results
show the advantage of our factorization method,
which allows for utilizing pre-trained word embed-
dings, and thus can bene   t from semi-supervised
learning.

preposition disambiguation lrfr improves (ta-
ble 5) over the best methods (sum and concate-
nation) in ritter et al. (2014) as well as the id166

method
id166 - lexical features
sum
concatenation
lrfr1-tucker & lrfr2-cp
lrfr1-brown
lrfr1-brown - control

accuracy

85.09
80.55
86.73
87.82
88.18
84.18

table 5: accuracy for spatial classi   cation of pps.

based on the original lexical features (85.1). in this
task lrfr1-brown better represents the unigram
and bigram lexical features, compared to the usage
of two low-rank tensors (lrfr1-tucker & lrfr2-
cp). this may be because lrfr1-brown has fewer
parameters, which is better for smaller training sets.
we also include a control setting (lrfr1-brown
- control), which has a full rank parameter ten-
sor with the same inputs on each view as lrfr1-
brown, but represented as one hot vectors without
transforming to the hidden representations hs. this
is equivalent to an id166 with the compound cluster
features as in koo et al. (2008). it performs much
worse than lrfr1-brown, showing the advantage
of using id27s and low-rank tensors.

4still this is not a fair comparison since we have differ-
ent training objectives. using rbg   s factorization and training
with our objective will give a fair comparison and we leave it to
future work.

summary for unigram lexical features, lrfrn-
tucker achieves better results than lrfrn-cp.
however, in settings with fewer training examples,

features with more lexical parts (id165s), or when
faster predictions are advantageous, lrfrn-cp does
best as it has fewer parameters to estimate. for n-
grams of variable length, lrfr1-tucker & lrfr2-
cp does best. in settings with fewer training exam-
ples, lrfr1-brown does best as it has only one
parameter tensor to estimate.

9 related work
id84 for complex features
is a standard technique to address high-dimensional
features, including pca, alternating structural op-
timization (ando and zhang, 2005), denoising au-
toencoders (vincent et al., 2008), and feature em-
beddings (yang and eisenstein, 2015). these meth-
ods treat features as atomic elements and ignore the
inner structure of features, so they learn separate em-
bedding for each feature without shared parameters.
as a result, they still suffer from large parameter
spaces when the feature space is very huge.5

another line of research studies the inner struc-
tures of lexical features: e.g. koo et al. (2008),
turian et al. (2010), sun et al. (2011), nguyen and
grishman (2014), roth and woodsend (2014), and
hermann et al. (2014) used pre-trained word embed-
dings to replace the lexical parts of features ; sriku-
mar and manning (2014), gorid113y et al. (2015)
and yu et al. (2015) propose splitting lexical fea-
tures into different parts and employing tensors to
perform classi   cation. the above can therefore be
seen as special cases of our model that only embed
a certain part (view) of the complex features. this
restriction also makes their model parameters form
a full rank tensor, resulting in data sparsity and high
computational costs when the tensors are large.
composition models (deep learning) build rep-
resentations for structures based on their component
id27s (collobert et al., 2011; bordes et
al., 2012; socher et al., 2012; socher et al., 2013b).
when using only id27s, these models
achieved successes on several nlp tasks, but some-
times fail to learn useful syntactic or semantic pat-
terns beyond the strength of combinations of word

5for example, a state-of-the-art dependency parser (zhang
and mcdonald, 2014) extracts about 10 million features; in this
case, learning 100-dimensional feature embeddings involves es-
timating approximately a billion parameters.

embeddings, such as the dependency relation in fig-
ure 1(a). to tackle this problem, some work de-
signed their model structures according to a speci   c
kind of linguistic patterns, e.g. dependency paths
(ma et al., 2015; liu et al., 2015), while a recent
trend enhances compositional models with linguis-
tic features. for example, belinkov et al. (2014)
concatenate embeddings with linguistic features be-
fore feeding them to a neural network; socher et
al. (2013a) and hermann and blunsom (2013) en-
hanced id56s by re   ning the
transformation matrices with linguistic features (e.g.
phrase types). these models are similar to ours in
the sense of learning representations based on lin-
guistic features and embeddings.

low-rank tensor models for nlp aim to handle
the conjunction among different views of features
(cao and khudanpur, 2014; lei et al., 2014; chen
and manning, 2014). yu and dredze (2015) pro-
posed a model to compose phrase embeddings from
words, which has an equivalent form of our cp-
based method under certain restrictions. our work
applies a similar idea to exploiting the inner struc-
ture of complex features, and can handle id165
features with different ns. our factorization (  3) is
general and easy to adapt to new tasks. more impor-
tantly, it makes the model bene   t from pre-trained
id27s as shown by the pp-attachment
results.

10 conclusion

we have presented lrfr, a feature representation
model that exploits the inner structure of complex
lexical features and applies a low-rank tensor to ef   -
ciently score features with this representation. lrfr
attains the state-of-the-art on several tasks, includ-
ing id36, pp-attachment, and preposi-
tion disambiguation. we make our implementation
available for general use.6

acknowledgements
a major portion of this work was done when my
was visiting md and ra at jhu. this research was
supported in part by nsf grant iis-1546482.

6https://github.com/gorov/lowrankfcm

references
[ando and zhang2005] rie kubota ando and tong
zhang. 2005. a framework for learning predictive
structures from multiple tasks and unlabeled data. the
journal of machine learning research, 6.

[belinkov et al.2014] yonatan belinkov, tao lei, regina
barzilay, and amir globerson. 2014. exploring com-
positional architectures and word vector representa-
tions for prepositional phrase attachment. transac-
tions of the association for computational linguistics,
2.

[bengio et al.2006] yoshua bengio, holger schwenk,
jean-s  ebastien sen  ecal, fr  ederic morin, and jean-luc
gauvain. 2006. neural probabilistic language models.
in innovations in machine learning. springer.

[bordes et al.2012] antoine bordes, xavier glorot, ja-
son weston, and yoshua bengio. 2012. a seman-
tic matching energy function for learning with multi-
relational data. machine learning.

[cao and khudanpur2014] yuan cao and sanjeev khu-
in
danpur. 2014. online learning in tensor space.
proceedings of the 52nd annual meeting of the associ-
ation for computational linguistics (volume 1: long
papers).

[chen and manning2014] danqi chen and christopher
2014. a fast and accurate dependency
in proceedings of

manning.
parser using neural networks.
emnlp.

[collobert et al.2011] ronan collobert, jason weston,
l  eon bottou, michael karlen, koray kavukcuoglu,
and pavel kuksa. 2011. natural language processing
(almost) from scratch. jmlr, 12.

[duchi et al.2011] john duchi, elad hazan, and yoram
singer. 2011. adaptive subgradient methods for on-
line learning and stochastic optimization. the journal
of machine learning research, 12.

[gorid113y et al.2015] matthew r. gorid113y, mo yu, and
mark dredze. 2015.
improved id36
with feature-rich compositional embedding models.
in proceedings of the 2015 conference on empirical
methods in natural language processing.

[hermann and blunsom2013] karl moritz hermann and
phil blunsom. 2013. the role of syntax in vector
space models of id152. in associa-
tion for computational linguistics.

[hermann et al.2014] karl moritz hermann, dipanjan
das, jason weston, and kuzman ganchev. 2014. se-
mantic frame identi   cation with distributed word rep-
resentations. in proceedings of the 52nd annual meet-
ing of the association for computational linguistics
(volume 1: long papers).

[hoffmann et al.2010] raphael

congle
zhang, and daniel s. weld. 2010. learning 5000

hoffmann,

the 48th
relational extractors.
annual meeting of the association for computational
linguistics.

in proceedings of

[kolda and bader2009] tamara g kolda and brett w
bader. 2009. tensor decompositions and applications.
siam review, 51(3).

[koo et al.2008] terry koo, xavier carreras, and michael
collins. 2008. simple semi-supervised dependency
parsing. in proceedings of acl.

[lei et al.2014] tao lei, yu xin, yuan zhang, regina
barzilay, and tommi jaakkola. 2014. low-rank ten-
in proceed-
sors for scoring dependency structures.
ings of the 52nd annual meeting of the association for
computational linguistics (volume 1: long papers).
[lei et al.2015] tao lei, yuan zhang, llu    s m`arquez,
alessandro moschitti, and regina barzilay.
2015.
high-order low-rank tensors for semantic role label-
in proceedings of the 2015 conference of the
ing.
north american chapter of the association for com-
putational linguistics: human language technolo-
gies.

[liu et al.2015] yang liu, furu wei, sujian li, heng
ji, ming zhou, and houfeng wang.
2015. a
dependency-based neural network for relation classi-
   cation. in proceedings of the 53rd annual meeting
of the association for computational linguistics and
the 7th international joint conference on natural lan-
guage processing (volume 2: short papers).

[ma et al.2015] mingbo ma, liang huang, bowen zhou,
and bing xiang. 2015. dependency-based convo-
lutional neural networks for sentence embedding. in
proceedings of the 53rd annual meeting of the associ-
ation for computational linguistics and the 7th inter-
national joint conference on natural language pro-
cessing (volume 2: short papers).

[mcclosky et al.2006] david mcclosky, eugene char-
niak, and mark johnson. 2006. effective self-training
for parsing. in proceedings of the main conference on
human language technology conference of the north
american chapter of the association of computa-
tional linguistics.

[mikolov et al.2013] tomas mikolov, ilya sutskever, kai
chen, greg s corrado, and jeff dean. 2013. dis-
tributed representations of words and phrases and their
compositionality. in advances in neural information
processing systems, pages 3111   3119.

[miller et al.2004] scott miller, jethran guinness, and
alex zamanian. 2004. name tagging with word clus-
in proceedings of
ters and discriminative training.
hlt-naacl.

[mitchell and lapata2010] jeff mitchell and mirella la-
pata. 2010. composition in distributional models of
semantics. cognitive science, 34(8).

ace 2005 multilingual training corpus. linguistic
data consortium, philadelphia.

[yang and eisenstein2015] yi yang and jacob eisenstein.
2015. unsupervised multi-id20 with
feature embeddings. in proceedings of the 2015 con-
ference of the north american chapter of the asso-
ciation for computational linguistics: human lan-
guage technologies, pages 672   682, denver, col-
orado, may   june. association for computational lin-
guistics.

[yu and dredze2015] mo yu and mark dredze. 2015.
learning composition models for phrase embeddings.
transactions of the association for computational
linguistics, 3.

[yu et al.2015] mo yu, matthew r. gorid113y, and mark
dredze.
2015. combining id27s and
feature embeddings for    ne-grained relation extrac-
in north american chapter of the association
tion.
for computational linguistics (naacl).

[zhang and mcdonald2014] hao zhang and ryan mc-
donald. 2014. enforcing structural diversity in cube-
pruned id33. in proceedings of acl.

[zhou et al.2005] guodong zhou, jian su, jie zhang, and
min zhang. 2005. exploring various knowledge in
id36. in proceedings of acl.

[nguyen and grishman2014] thien huu nguyen and
ralph grishman. 2014. employing word representa-
tions and id173 for id20 of rela-
tion extraction. in association for computational lin-
guistics (acl).

[ritter et al.2014] samuel ritter, cotie long, denis pa-
perno, marco baroni, matthew botvinick, and adele
goldberg. 2014. leveraging preposition ambiguity to
assess representation of semantic interaction in cdsm.
in nips workshop on learning semantics.

[roth and woodsend2014] michael roth and kristian
woodsend. 2014. composition of word representa-
tions improves semantic role labelling. in proceedings
of emnlp.

socher,

[socher et al.2012] richard

brody huval,
christopher d. manning, and andrew y. ng. 2012.
semantic compositionality through recursive matrix-
in proceedings of emnlp-conll
vector spaces.
2012.

[socher et al.2013a] richard

john bauer,
christopher d manning, and andrew y ng. 2013a.
parsing with compositional vector grammars.
in
proceedings of acl.

socher,

[socher et al.2013b] richard socher, alex perelygin,
jean wu, jason chuang, christopher d. manning, an-
drew ng, and christopher potts. 2013b. recursive
deep models for semantic compositionality over a sen-
timent treebank. in proceedings of emnlp.

srikumar

[srikumar and manning2014] vivek

and
christopher d manning. 2014. learning distributed
representations for structured output prediction.
in
advances in neural information processing systems.
[sun et al.2011] ang sun, ralph grishman, and satoshi
sekine. 2011. semi-supervised id36
with large-scale word id91. in proceedings of the
49th annual meeting of the association for computa-
tional linguistics: human language technologies.

[taub-tabib et al.2015] hillel taub-tabib, yoav gold-
berg, and amir globerson. 2015. template kernels
in proceedings of the 2015
for id33.
conference of the north american chapter of the as-
sociation for computational linguistics: human lan-
guage technologies.

[turian et al.2010] joseph turian, lev ratinov,

and
yoshua bengio. 2010. word representations: a simple
and general method for semi-supervised learning. in
association for computational linguistics.

[vincent et al.2008] pascal vincent, hugo larochelle,
yoshua bengio, and pierre-antoine manzagol. 2008.
extracting and composing robust features with denois-
ing autoencoders. in proceedings of the 25th interna-
tional conference on machine learning.
[walker et al.2006] christopher walker,

stephanie
strassel, julie medero, and kazuaki maeda. 2006.

