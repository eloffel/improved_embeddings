to appear in ieee transactions on visualization and computer graphics

lstmvis: a tool for visual analysis of hidden state dynamics in

recurrent neural networks

hendrik strobelt, sebastian gehrmann, hanspeter p   ster, and alexander m. rush

    harvard school of engineering and applied sciences    

7
1
0
2

 
t
c
o
0
3

 

 
 
]
l
c
.
s
c
[
 
 

2
v
1
6
4
7
0

.

6
0
6
1
:
v
i
x
r
a

fig. 1. the lstmvis user interface. the user interactively selects a range of text specifying a hypothesis about the model in the
select view (a). this range is then used to match similar hidden state patterns displayed in the match view (b). the selection is made
by specifying a start-stop range in the text (c) and an activation threshold (t) which leads to a selection of hidden states (blue lines).
the start-stop range can be further constrained using the pattern plot (d). the meta-tracks below depict extra information per word
position like pos (e1) or the top k predictions (e2). the tool can then match this selection with similar hidden state patterns in the
data set of varying lengths (f), providing insight into the representations learned by the model. the match view additionally includes
user-de   ned meta-data encoded as heatmaps (g1,g2). the color of one heatmap (g2) can be mapped (h) to the word matrix (f) which
allows the user to see patterns that lead to further re   nement of the selection hypothesis. navigation aids provide convenience (i1, i2).

abstract    recurrent neural networks, and in particular long short-term memory (lstm) networks, are a remarkably effective tool for
sequence modeling that learn a dense black-box hidden representation of their sequential input. researchers interested in better
understanding these models have studied the changes in hidden state representations over time and noticed some interpretable
patterns but also signi   cant noise. in this work, we present lstmvis, a visual analysis tool for recurrent neural networks with a
focus on understanding these hidden state dynamics. the tool allows users to select a hypothesis input range to focus on local state
changes, to match these states changes to similar patterns in a large data set, and to align these results with structural annotations
from their domain. we show several use cases of the tool for analyzing speci   c hidden state properties on dataset containing nesting,
phrase structure, and chord progressions, and demonstrate how the tool can be used to isolate patterns for further statistical analysis.
we characterize the domain, the different stakeholders, and their goals and tasks. long-term usage data after putting the tool online
revealed great interest in the machine learning community.

1 introduction
in recent years, deep neural networks have become a central modeling
tool for many arti   cial cognition tasks, such as image recognition,
id103, and text classi   cation. these models all share a
common property in that they utilize a hidden feature representation of
their input, not pre-speci   ed by the user, which is learned for the task
at hand. these hidden representations have proven to be very effective
for classi   cation. however, the black-box nature of these learned

    hs     contact: hendrik@strobelt.com
    sg, hp, ar     contact: {gehrmann, p   ster,rush}@seas.harvard.edu.

1

representations make the models themselves dif   cult to interpret. so
while it is possible for users to produce high-performing systems, it is
dif   cult for them to analyze what the system has learned.

while all deep neural networks utilize hidden features, different
model structures have shown to be effective for different tasks. stan-
dard deep neural networks (dnns) learn    xed-size features, whereas
convolutional neural networks (id98s), dominant in image recognition,
will learn a task-speci   c    lter-bank to produce spatial feature maps. in
this work, we focus on deep neural network architectures known as
recurrent neural networks (id56s) that produce a time-series of hidden
feature-state representations.

id56s [7] have proven to be an effective general-purpose approach

cabde1e2fg1g2hi1i2tthese representations over time as the hidden state dynamics produced
by the model.

throughout this work, we will assume that we are given a sequence
of words w1, . . . ,wt for time 1 to t . these might consist of english
words that we want to translate or a sentence whose sentiment we would
like to detect, or even some other symbolic input such as musical notes
or code. additionally, we will assume that we have a mapping from
each word into vector representation x1, . . . ,xt . this representation
can either be a standard    xed mapping, such as id97 [23], or can
be learned with the rest of the model.

formally, id56s are a class of neural networks that sequentially
map input word vectors x1 . . .xt to a sequence of hidden feature-state
representations h1, . . . ,ht . this is achieved by learning the weights of
a neural network id56, which is applied recursively at each time-step
t     1 . . .t :

ht     id56(xt,ht   1)

this function takes input vector xt and a hidden state vector ht   1 and
gives a new hidden state vector ht. each hidden state vector ht is in
rd. these vectors, and particularly how they change over time, will
be the main focus of this work. we are interested in each c     {1 . . .d}
and in particular the change of a single hidden state ht,c as t varies.

the model learns these hidden states to represent the features of
the input words. as such, they can be learned for any modeling tasks
utilizing discrete sequential input. one notable application is id56
id38 [22, 33], a core task in natural language processing.
in id38, at time t the pre   x of words w1, . . . ,wt is taken
as input and the goal is to model the distribution over the next word
p(wt+1|w1, . . . ,wt ). an id56 is used to produce this distribution by
applying multi-class classi   cation based on hidden feature-state vector
ht. formally we de   ne this as p(wt+1|w1, . . . ,wt ) = softmax(wht +b),
where w,b are parameters. the full computation of an id56 language
model is shown in figure 2.

it has been widely observed that the hidden states are able to cap-
ture important information about the structure of the input sentence
necessary to perform this prediction. however, it has been dif   cult to
trace how this is captured and what exactly is learned. for instance, it
has been shown that id56s can count parentheses or match quotes, but
is unclear whether id56s naturally discover aspects of language such
as phrases, grammar, or topics. in this work, we focus particularly on
exploring this question by examining the dynamics of the hidden states
through time.

our use cases will mainly focus on long short-term memory net-
works (lstm) [11]. lstms de   ne a variant of id56 that has a mod-
i   ed hidden state update which can more effectively learn long-term
interactions. as such these models are widely used in practice. in
addition, lstms and id56s can be stacked in layers to produce mul-
tiple hidden state vectors at each time step, which further improves
performance. while our results mainly use stacked lstms, our visu-
alization only requires access to some time evolving abstract vector
representation, and therefore can be used for any layer of a wide variety
of models.

note that lstms maintain both a cell state vector and a hidden
state vector at each time step. our system can be used to analyze
either or both of these vectors (or even the lstm gates), and in our
experiments we found that the cell states are easier to work with. for
simplicity, however, we refer to these vectors generically as hidden
states throughout the paper.

fig. 2. a recurrent neural network language model being used to
compute p(wt+1|w1, . . . ,wt ). at each time step, a word wt is converted
to a word vector xt, which is then used to update the hidden state
ht     id56(xt ,ht   1). this hidden state vector can be used for prediction.
in id38 (shown) it is used to de   ne the id203 of the
next word, p(wt+1|w1, . . . ,wt ) = softmax(wht + b).

for capturing representation in sequence-modeling applications, such
as text processing. recent strong empirical results indicate that internal
representations learn to capture complex relationships between the
words within a sentence or document. these improved representation
have led directly to end applications in machine translation [14, 28],
id103 [2], music generation [4], and text classi   cation [6],
among a variety of other applications.

while id56s have shown clear improvements for sequence modeling,
it has proven very dif   cult to interpret their feature representation. as
such, it remains unclear exactly how a particular model is representing
long-distance relationships within a sequence. typically, id56s contain
millions of parameters and utilize repeated transformations of large
hidden representations under time-varying conditions. these factors
make the model inter-dependencies challenging to interpret without
sophisticated mathematical tools. how do we enable users to explore
complex network interactions in an id56 and directly connect these
abstract representations to human understandable inputs?

in this work, we focus on the visual analysis of hidden features
in id56s. we have developed lstmvis, a tool to allow advanced
user groups to explore and form hypotheses about id56 hidden state
dynamics. we analyzed neural network users and identi   ed three ma-
jor user roles, each with a different set of requirements: architects
who develop novel deep learning structures, trainers who develop new
data sets to train existing models, and end users who apply deep mod-
els to new data. lstmvis is focused on architects and trainers, for
which we performed a goal and task analysis to develop effective visual
encodings and interactions. lstmvis combines a time-series based
select interface with an interactive match tool to search for similar
hidden state patterns in a large dataset. a live system can be accessed
via lstm.seas.harvard.edu and the source code is provided. we
present use cases applying our technique to identify and explore pat-
terns in id56s trained on large real-world datasets for text, speech
recognition, biological sequence analysis and other domains. we dis-
cuss our release-before-publish strategy used to develop and improve
the tool based on user feedback.

2 background: recurrent neural networks
id56s are a type of deep neural network architecture that has proven
effective for sequence modeling tasks such as text processing. a major
challenge of working with variable-length text sequences is producing
features that capture or summarize long-distance relations in the text.
these relationships are particularly important for tasks that require
processing and generating sequences such as machine translation. id56-
based models effectively learn hidden representations at each time-step
which are then used for decision making. we refer to the change in

3 related work

understanding id56s through visualization our core contri-
bution, visualizing the state dynamics of id56s in a structured way, is
inspired by previous work on convolutional neural networks in vision
applications [27, 34]. in linguistic tasks, visualizations have shown to
be useful tool for understanding certain aspects of id56s. karpathy et
al. [16] use static visualization techniques to help understand hidden
states in language models. their work demonstrates that selected cells
can model clear events such as open parentheses and the start of urls.

2

xt-2xt-1xtht-2ht-1htptwt-1wtwt-2to appear in ieee transactions on visualization and computer graphics

fig. 3. views on neural network models for different user roles. the architect analyzes and modi   es all components of the system. the trainer
abstracts the model to the main components and parameters and focuses on training on different data sets. the end user has the most abstract
view on the model and considers whether the output is coherent for a given input.

li et al. [18] present additional techniques, particularly the use of
gradient-based saliency to    nd important words. their work also looks
at several different models and datasets including text classi   cation
and auto-encoders. kadar et al. [12, 13] show that id56s speci   cally
learn lexical categories and grammatical functions that carry semantic
information, partially by modifying the inputs fed to the model. while
inspired by these techniques, our approach tries to extend beyond single
examples and provide a general interactive visualization approach of
the raw data for exploratory analysis.

extending id56 models for interpretability recent work has
also developed methods for extending id56s for certain problems to
make them easier to interpret (along with improving the models). one
popular technique has been to use a neural attention mechanism to allow
the model to focus in on a particular aspect of the input. bahdanau
et al. [3] use attention for soft alignment in machine translation. xu
et al. [32] use attention to identify important aspects of an image for
captioning, whereas hermann et al. [10] use attention to    nd important
aspects of a document for an extraction task. these approaches have
the side bene   t that they visualize the aspect of the model they are
using. this approach differs from our work in that it requires changing
the underlying model structure, whereas we attempt to interpret the
hidden states of a    xed model directly.

interactive visualization of neural networks there has been
some work on interactive visualization for interpreting machine learn-
ing models. tzeng et al. [30] present a visualization system for feed-
forward neural networks with the goal of interpretation, and kapoor et
al. [15] give a user-interface for tuning the learning itself. the prospec-
tor system [17] provides a general-purpose tool for practitioners to
better understand their machine learning model and its predictions.

recent work also describes systems that focus on analysis of hidden
states for convolutional neural networks. liu et al. [20] utilize a dag
metaphor to show neurons, their connections, and learned features.
rauber et al. [25] use projections to explore relationships between
neurons and learned observations. other work has focused on user
interfaces for constructing models, such as tensorboard [1] and the
related playground for convolutional neural models at playground.
tensorflow.org/. our work is most similar in spirit to the work by
tzeng et al. [30], liu et al. [20], and rauber et al. [25], in that we are
concerned with interpreting the hidden states of neural network models.
however, our speci   c goals focus on id56s and the needs of speci   c
users, and the resulting visual design is signi   cantly different.

4 user analysis and goals
deep neural networks are now widely employed both in the research
and industrial setting by a diverse set of users with different needs.
before developing our visual analysis goals we    rst laid out a set of
prototypical stakeholders who might bene   t from improved analysis.
in meetings with members of a natural language processing group

and a computational biology group, we identi   ed three user roles,
their incentives, and their view on neural network models. figure 3
summarizes the following roles and which aspect of a model they might
hope to master:

    architects are looking to develop new deep learning methodolo-
gies or to modify existing deep architectures for new domains.
an architect is interested in training many variant network struc-
tures and comparing how the models capture the features of their
domain. we assume that the architects are deeply knowledgeable
about machine learning, neural networks, and the internal struc-
ture of the system. their direct goal is comparing the performance
of variant models and understanding the learned properties of the
system.

    trainers are those users interested in applying known architec-
tures to tasks for which they are a domain experts. trainers utilize
id56s as a tool and understand the key concepts of network opti-
mization. however, their main focus is on the application domain
and utilizing effective methods to solve known problems. their
goal is to use a known network architecture and to observe how
it learns a novel model. examples of trainers include a bioinfor-
matician or an applied machine learning engineer.

    end users make up the most prevalent role of network users.
end users utilize general-purpose pretrained networks for various
tasks. these users may not need to understand the training process
at all, only how to apply the networks as an algorithm to new
data. their main desire is to explain the results and locate what is
happening when something goes wrong. examples of end-users
include data scientists or product engineers using ml.

these user roles are general to the neural network domain and we
believe they can help to describe and understand stakeholders in this
space. for our analysis, we decided to focus on the more advanced end
of this spectrum, particularly on the user role of architects. we aimed
to provide these users with greater visibility into the internals of the
system. user feedback from our    rst prototype further motivated us to
include the trainer role as users with a focus on the predictions of the
model. in future work, we want to develop systems to engage the end
users of id56 and other deep neural networks more.

with these roles in mind, we aimed to help trainers and architects
better understand the high-level question:    what information does an
id56 capture in its hidden feature-states?   . addressing this question is
the main goal of our project. based on a series of dicussions with deep
learning experts we identi   ed the following domain goals:

    g1 - formulate a hypothesis about properties that the hidden
states might learn to capture for a speci   c model. this hypothesis
requires an initial understanding of hidden state values over time
and a close read of the original input.

3

parametersparametersfzioxxx+xinputoutputmostlyblack boxinputoutput + reliabilitylayer 1layer 2id97   architect trainer end-user     g2 - re   ne the hypothesis based on insights about learned tex-
tual similarities based on patterns in the dynamics of the hidden
states. re   ning a hypothesis may also mean rejecting it.

    g3 - compare models and datasets to allow early generaliza-
tion about the insights the representations provide, and to observe
how task and domain may alter the patterns in the hidden states.

during the design phase, we developed the following list of tasks
for visual data analysis from the three domain goals (g1   g3). the
mapping of these tasks to goals is indicated by square brackets:

    t1 - visualize hidden states over time to allow exploration of

the hidden state dynamics in their raw form. [g1]

    t2 - filter hidden states by using discrete textual selection along
with continuous thresholding. these selections methods allow the
user to form hypotheses and to separate visual signal from noise.
[g1,g2]

    t3 - match selections to similar examples based on hidden state
activation pattern. a matched phrase should have intuitively simi-
lar characteristics as the selection to support or reject a hypothesis.
[g2]

    t4 - align textual annotations visually to matched phrases.
these annotations allow the user to compare the learned rep-
resentation with alternative structural hypotheses such as part-
of-speech tags or known grammars. the set of annotation data
should be easily extensible. [g2,g3]

    t5 - provide a general interface that can be used with any id56
model and text-like dataset.
it should make it easy to gener-
ate crowd knowledge and trigger discussions on similarities and
differences between a wide variety of models. [g3]

this list of tasks provided a guideline for the design of lstmvis.
in addition, tasks (t1-t4) de   ne the core interaction mechanisms for
discovery with lstmvis: visualize (section 5.1)     filter & select
(section 5.2)     match & align (section 5.3). we will    rst describe
the implementation of these interactions and later demonstrate their
application to multiple use cases in section 6.

5 design of lstmvis
lstmvis is composed of two major visual analysis components. the
select view (section 5.2) supports the formulation of a hypothesis (t2,
g1) by using a novel visual encoding for hidden state changes (t1,
section 5.1). the match view (section 5.3) allows re   nement of a
hypothesis (t3, t4, g2) while remaining agnostic to the underlying
data or model (t5).

our design decisions are the outcome of a long iterative process.
first, we developed several interactive, low-   delity prototypes of vary-
ing complexity with our expert users to highlight different aspects of
the data (figure 4). after developing a complete system, we released it
to a broader audience online to collect long-term feedback (section 7).
based on the feedback from this release we developed the current
version several months later.

5.1 visualization of hidden state changes
visualizing the progression of hidden state vectors h1, . . . ,ht along
a sequence of words (time-steps) is at the core of lstmvis.
in
the following, we refer to hidden state as one dimension of the d-
dimensional hidden state vector.

in the related literature, it is common to encode hidden state vectors
as a heatmap along the time-axis (figure 4(a)). this style has been
favored as a view of the complete hidden state vectors h1, . . . ,ht . how-
ever, this approach has several drawbacks in an interactive visualization.
foremost, the heatmaps do not scale well with increasing dimension-
ality d of hidden state vectors. they use a non-effective encoding for
the most important information, i.e. hidden state values by color hue.
additionally, they emphasize the order of hidden states in each vector,

fig. 4. two early-stage prototypes of the system. (a) hidden state vectors
are encoded as heatmaps over time. this style places emphasis on the
relationships between neighboring (vertically adjacent) states, which has
no particular meaning for this model. (b) a selection prototype utilizing
parallel coordinates. this prototype emphasized selections based on
small movements of state values directly on the plot, which made it
dif   cult to specify connections between hidden state values and source
text.

but this relative order of abstract hidden states is not actually used by
the model itself.

we decided to consider each hidden state as a data item and time-
steps as dimensions for each data item in a parallel coordinates plot.
doing so, we encode the hidden state value using the more effective
visual variable position. figure 4(b) shows the    rst iteration on using
a parallel coordinates plot. the number of data points along the plot
is additionally encoded by a heatmap in the background to emphasize
dense (e.g., around the zero value) and sparse regions.

however, it was very cumbersome to formulate a hypothesis for a
longer range by adjusting many y-axis brush selectors at a    ne granu-
larity. allowing the user to perform selection by directly manipulating
the hidden state values felt decoupled from the original source of
information   the text. the key idea to facilitate this selection process
was to allow the user to easily discretize the data based on a threshold
and select on and off ranges directly on top of the words (section 5.3).
figure 6 shows the    rst complete prototype that we put online to
collect long-term user feedback (section 7). several user comments led
us to believe that the redundant encoding of hidden states that are    on   
in the select view (figure 6d,e) was not well understood. in the    nal
design shown on the top in figure 1 we omitted this redundant encoding
for the sake of clarity and to highlight wider regions of text. the x-
axis is labeled with the word inputs w1, . . . ,wt for the corresponding
time-step. if words do not    t into the    xed width for time steps they
are distorted. figure 1 shows the movement of a hidden state vector
through an example sequence.

5.2 select view
the select view, shown in the top half of figure 1, is centered around
the parallel coordinates plot for hidden state dynamics. the full plot
can be dif   cult to comprehend directly. therefore, lstmvis allows
the user to formulate a hypothesis (g1) about the semantics of a subset
of hidden states by selecting a range of words that may express an

4

abto appear in ieee transactions on visualization and computer graphics

fig. 5. the hypothesis selection process. (a) the selection covers a little prince and has a threshold (cid:96) = 0.3. blue highlighted hidden states are
selected. (b) the threshold (cid:96) is raised to 0.6. (c) the pattern plot in the bottom is extended left, eliminating hidden states with values above (cid:96) after
reading of (one word to the left). (d) the pattern plot is additionally extended right, removing hidden states above the threshold after reading    .    (one
word to the right). i.e., only hidden states are selected with the following pattern: below threshold (cid:96) for one word before     above (cid:96) during a little
prince     below (cid:96) for one word after.

users asking us to include the tracks. some users that used the tool for
training also wanted to see the top k predictions (outcomes) for each
word. figure 1 shows examples for pos (e1) and topk (e2).

lstmvis also provides several convenience methods to navigate
to speci   c time steps. buttons on the timeline can be used to move
forward and backward (figure 1-i2). lstmvis also offers search
functionality to    nd speci   c phrases. the selection panel on the top
can be used to ef   ciently switch between the different layers (t5). the
word-width can be decreased and increased (figure 1-i1) to provide
support for different average word lengths (e.g., character-based models
vs. word-based models). the option to turn heatmaps on and off in
match view (figure 1g1 and g2) provides convenience when working
with many mate tracks.

these interaction methods allow the user to de   ne a hypothesis as
word range which results in the selection of a subset of hidden states
following a speci   ed pattern w.r.t. a de   ned threshold (t2, g1) that
only relies on the hidden state vectors themselves (t5). to re   ne or
reject the hypothesis the user can then make use of the match view.

5.3 match view
the match view (figure 1b) provides evidence for or against the se-
lected hypothesis. the view provides a set of relevant matched phrases
that have similar hidden state patterns as the phrase selected by the
user.

with the goal of maintaining an intuitive match interface, we de   ne
the matches to be ranges in the data set that would have lead to a similar
set of on hidden states under the selection criteria (threshold, on/off
pattern). formally, assume that the user has selected a threshold (cid:96) with
hidden states s1 and has not limited the selection to the right or left
further, as shown in figures 5a and 5b. we rank all possible candidate
ranges in the dataset starting at time a and ending at time b with a two
step process

1. collect the set of all hidden states that are    on    for the range,

s2 = {c     {1 . . .d} : ht,c     (cid:96) for all a     t     b}

2. rank the candidates by the number of overlapping states |s1    
s2| using the inverse of the number of additional    on    cells
   |s1     s2| and candidate length b    a as tiebreaks.

if the original selection is limited on either side (as, e.g., in figures 5c
or 5d), we modify step (2) to take this into account for the candidates.
for instance, if there is a limit on the left, we only include state indices
c in s2 in that also satisfy ha   1,c < (cid:96). for ef   ciency, we do not score
at all possible candidate ranges (datasets typically have t > 1 million).
we limit the candidate set by    ltering to ranges with a minimum number

fig. 6. snippet of the    rst complete prototype. while the list of selected
cells (a) and the brushing method (c) remained in the    nal version, we
modi   ed the pattern plot (b) and omitted the redundant encodings (d)
and (e).

interesting property. for instance, the user may select a range within a
shared nesting levels in tree-structured text (section 6.1), a representa-
tive noun phrase in a text corpus (section 6.2), or a chord progression
in a musical corpus(section 6.4).

to select, the user brushes over a range of words that form the pattern
of interest (figure 1c). in this process, she implicitly selects hidden
states that are    on    in the selected range. the dashed red line on the
parallel coordinates plot (figure 1t) indicates a user-de   ned threshold
value, (cid:96), that partitions the hidden states into    on    (timesteps     (cid:96)) and
   off    (timesteps < (cid:96)) within this range.

in addition to selecting a range, the user can modify the pattern
plot below (figure 1d) to de   ne that hidden states must also be    off   
immediately before or after the selected range. figure 5 shows different
combinations of pattern plot con   gurations and the corresponding
hidden state selections. using these selection criteria the user creates
a set of selected hidden states s1     {1 . . .d} that follow the speci   ed
on/off pattern w.r.t. the de   ned threshold.

to assist with the selection of ranges, the user can make use of a
heatmap underlying the word sequence which depicts how many of the
selected hidden states are    on    for each word (figure 1c). this indicates
repetitions of hidden state patterns in the close local neighborhood.

additionally, a user can add aligned tracks of textual annotations
(meta tracks) to the selection view. e.g., she can visualize part-of-
speech (pos) annotations or id39 (ner) results.
the feature of meta tracks is the result of feedback from multiple online

5

abcdselectviewmatchviewbcadefgfig. 7. plot of a phrase from the parenthesis synthetic language. (a) the full set of hidden states. note the strong movement of states at parenthesis
boundaries. (b) a selection is made at the start of the fourth level of nesting. even in the select view it is clear that several hidden states represent
a four-level nesting count. in both plots the meta-track indicates the nesting level as ground truth. (c) the result of matching the selected states
indicates that they seem to capture nesting level 4 phrases of variable length.

of hidden states from s1 over the threshold (cid:96). these candidate sets can
be computed ef   ciently using run-length encoding.

from the matching algorithm, we retrieve the top 50 results which
are shown, one per row each, in a word matrix (e.g., figure 1f) located
in the match view. each cell in the word matrix is linked to a cell in
corresponding heatmaps. these heatmaps encode additional informa-
tion about each word in the matching results. the always available
match count heatmap (figure 1-g1) encodes the number of overlapping
states |s1     s2| for each timestep.
the user can use additional annotations, similar to meta tracks in
the selection view, as heatmaps (t4). we imagine these annotations
act as ground truth data, e.g., part-of-speech tags for a text corpora
(figure 1-g2), or as further information to help calibrate the hypotheses,
e.g., nesting depth of tree-structured text. figure 1 shows how hovering
over    little    (mouse pointer) leads to highlights in the match count
heatmap (g1) indicating seven overlapping states between match and
selection for this position. the pos heatmap (g2) indicates that the
word at this position acts as adjective (adj).

the heatmap colors can be mapped directly to the background of the
matches (figure 1h) as a simple method to reveal pattern across results
(figure 1f). based on human identi   able patterns or alignments, the
matching and mapping methods can lead to further data analysis or a
re   nement of the current hypothesis.

5.4 design considerations and limitations
lstmvis operates around as a bottom-up approach starting from a
seed hypothesis and searching for similarities across the whole dataset.
during the project, we experimented with top-down approaches follow-
ing the shneiderman mantra (overview    rst     zoom and    lter later). we
found that global overviews, such as projections of hidden state values
or summary statistics, did little to reveal interpretable patterns on large
datasets. lstmvis differs from related work, in that instead of working
with the prediction output, it operates directly on the hidden states to
identify relationships. this design decision addresses our target group
of architects and trainers who are familiar with model internals.

another goal of our tool is to use a representation that is invariant to
the ordering of hidden states in the hidden state vector while remaining
scalable w.r.t. size of the vector. as addressed in section 5.1, those
two conditions are ful   lled by plotting hidden states individually onto
parallel coordinates. however, even with this compact representation,
applications with > 500 hidden states become challenging to analyze
as a whole. approaches to address the visual noise are to either    lter
the hidden states using our interactive methods or to use algorithmic
preprocessing, like id84 techniques or pruning
methods. after testing the latter automated    ltering approaches, we
decided against using them within the application. we found that if

the tool loses its inherent connection to the data, results were less
interpretable to the user.

5.5 technical design and implementation
lstmvis consists of two modules, the visualization system and the
id56 modeling component. the source code with documentation and
some example models are available at lstm.seas.harvard.edu.

the visualization is a client-server system that uses javascript and
d3 on client side and python, flask, connexion, h5py, and numpy on
server side. timeseries data (id56 hidden states and input) is loaded
dynamically through hdf5    les. optional annotation    les can be
speci   ed to map categorical data to labels (t4). new data sets can be
added easily by a declarative yaml con   guration    le.

the id56 modeling system is completely separated from the vi-
sualization to allow compatibility with any deep learning framework
(t5). for our experiments we use the torch framework. we trained our
models separately and exported results to the visualization.

6 use cases
in experimenting with the system we trained and explored many dif-
ferent id56 models, datasets and tasks, including word and character
language models, id4 systems, auto-encoders,
summarization systems, and classi   ers. additionally, we also experi-
mented with other types of real and synthetic input data.

in this section we highlight three use cases that demonstrate the

general applicability of lstmvis for the analysis of hidden states.

6.1 proof-of-concept: parenthesis language
as proof of concept we trained an lstm as language model on syn-
thetic data generated from a very simple counting language with a
parenthesis and letter alphabet    = {( ) 0 1 2 3 4 }. the lan-
guage is constrained to match parentheses, and nesting is limited to
at most 4 levels deep. each opening parenthesis increases and each
closing parenthesis decreases the nesting level, respectively. numbers
are generated randomly, but are constrained to indicate the nesting level
at their position. for example, a string in the language might look like:

blue lines indicates ranges of nesting level    1, orange lines indicate
nesting level    2, and green lines indicate nesting level    3.

to analyze this language, we view the states in lstmvis. an
example of the cell states of a multi-layer 2x300 lstm modelis is
shown in figure 7(a). here even the initial parallel coordinates plot

6

cabto appear in ieee transactions on visualization and computer graphics

shows a strong regularity, as hidden state changes occur predominately
at parentheses.

our hypothesis is that the hidden states mainly re   ex the nesting
level. to test this, we select a range spanning nesting level four by
selecting the phrase ( 4. we immediately see that several hidden
states seem to cover this pattern and that in the local neighborhood
several other occurrences of our hypothesis are covered as well, e.g., the
empty parenthesis and the full sequence ( 4 4 4 . this observation
nicely con   rms earlier work that demonstrates simple context-free
models in id56s and lstms [9, 31].

the visualization hints that the model has implicitly learned a repre-
sentation for id38 that can differentiate between the two
types of phrases. of course the tool itself cannot con   rm or deny this
type of hypothesis, but the aim is to provide clues for further analysis.
we can check, outside of the tool, if the model is clearly differentiating
between the classes in the phrase dataset. to do this we compute the
set s1 for every noun and verb phrase in the shared task. we then run
pca on the vector representation for each set. the results are shown in
figure 6.2, which shows that indeed these on-off patterns are enough
to partition the noun phrases and verb phrases.

6.2 phrase separation in id38

fig. 9. pca projection of the hidden state patterns (s1) of all multi-word
phrasal chunks in the id32, as numerical follow-up to the
phrase chunking hypothesis. red points indicate noun phrases, blue
points indicate verb phrases, other colors indicate remaining phrase
types. while trained for id38, the model separates out
these two phrase classes in its hidden states.

fig. 8. phrase selections and match annotations in the wall street
journal. (a) the user selects the phrase a very marked improvement
(turning off when improvement is seen). the matches found are entirely
other noun phrases, and start with different words. note that here ground-
truth noun phrases are indicated with a sequence of colors: cyan (det),
blue (adv), violet (adj), red (noun). (b) we select a range starting with
has invited. the results are various open verb phrases as sequence
of colors orange (verb) and blue (adv). note that for both examples
the model can return matches of varying lengths.

next we consider the case of a real-world natural language model
from the perspective of an architect interested in the structure of the
internal states and how they relate to underlying properties. for this
experiment we trained a 2-layer lstm language model with 650 hidden
states on the id32 [21] following the medium-sized model
of [33]. while the model is trained for id38 (predict
the next word), we were interested in seeing if it additionally learned
properties about the underlying language structure. to test this, we
additionally include linguistic annotations in the visual analysis from
the id32. we experimented with including part-of-speech
tags, named entities, and parse structure.

here we focus on the case of phrase chunking. we annotated the
dataset with the gold-standard phrase chunks provided by the conll
2003 shared task [29] for a subset of the treebank (sections 15-18).
these include annotations for noun phrases and verb phrases, along
with prepositions and several other less common phrase types.

while running experimental analysis, we found a strong pattern that
selecting noun phrases as hypotheses leads to almost entirely noun
phrase matches. additionally, we found that selecting verb phrase
pre   xes would lead to primarily verb phrase matches. in figure 6.2 we
show two examples of these selections and matches.

6.3 biological sequence analysis
id56 models are now commonly used for time-series analysis outside
of the space of text processing. one area of interest is in biological
sequence analysis for genomics where deep neural networks are di-
rectly applied to sequences of dna for tasks such as classi   cation and
sequence labeling. we consider models trained for regulatory marker
prediction, where neural networks are used to predict binding sites
aligned to sequences of the genome, a task that has been recently ex-
plored with both id98 [35] and id56 models [24]. for this case study,
we collaborated with a domain expert trainer who approached us after
becoming aware of the release of our tool. he had employed a mixed
id56/id98 model that was trained over a genomic dataset made up
of a 2.3 billion base pair long nucleotide sequence for this problem of
regulatory marker prediction.

notably this problem differs in several crucial ways from our previ-
ous use case: the granularity of the input is much smaller (base pairs
as opposed to words), the training objective is different (0/1 binding
site labels as opposed to the next word), and the problem is known to
exhibit much longer term dependencies due to its latent 3d structure.
conversations around these issues led us to introduce several iterative
features to our tool. these include the (a) ability to zoom in and out
of the timeseries representation to adjust for granularity, (b) use of
auto-scaling axes ranges to allow for switching between data of dif-
ferent activation ranges, such as id98 outputs, and most notably (c)
ability to add/remove arbitrarily many annotation label along the word
sequence timeline, to allow domain experts to view both the predictions
and ground truth as an annotation track associated with the features at
each time step. figure 6.3 shows an example of the last feature which
shows the predict binding locations for several different proteins along
a region of dna.

for this application the tool has so far been used primarily as a de-
bugging assistant, providing a way for an expert in an ongoing research
project to analyze the output of a trained model and make adjustments

7

abmatching resultmatching resultbased on mistakes of the model. for instance, in early use of the tool,
the researcher noticed that one layer of the network was using very
few of the available states, and another had signi   cant artifacts from a
poorly aligned convolutional layer. these observations have helped pro-
vide feedback for subsequent experimental design. furthermore, recent
work indicates an increasing interest in lstmvis in the biomedical
domain and for genomics (see section 7).

fig. 10. biological sequence analysis. a selected region of the genome
with seven different aligned annotation tracks. each track indicates the
0/1 prediction of protein binding sites at each time step. tracks can
be activated/deactivated as part of the debugging process to compare
predictions, ground truth, input properties, and other user-speci   ed an-
notations.

fig. 11. three examples of single state patterns in the guitar chord
dataset. (a) we see several permutation of the very common i - v - vi -
iv progression (informally, the    don   t stop believing    progression). (b)
we see several patterns ending in a variant of the i- vi- iv- v (the 50   s
progression). (c) we see two variants of i - v - vi -iii - iv - i (beginning
of the pachelbel   s canon progression). chord progression patterns are
based on http://openmusictheory.com/.

6.4 musical chord progressions
past work on lstm structure has emphasized cases where single
hidden states are semantically interpretable. for text and biological
data sets, we found that with a few exceptions (quotes, brackets, and
commas) this was rarely the case. however, for datasets with more
regular long-term structure, single states could be quite meaningful.

as a simple example, we collected a large set of songs with annotated
chords for rock and pop songs to use as a training data set, 219k chords
in total. we then trained an lstm language model to predict the next
chord wt+1 in the sequence, conditioned on previous chord symbols
(chords are left in their raw format).

when we viewed the results in lstmvis we found that the regular
repeating structure of the chord progressions is strongly re   ected in
the hidden states. certain states will turn on at the beginning of a
standard progression, and remain on though variant-length patterns
until a resolution is reached. in figure 6.4, we examine three very
common general chord progressions in rock and pop music. we select
a prototypical instance of the progression and show a single state that
captures the pattern, i.e., remains on when the progression begins and
turns off upon resolution.

7 long-term case study
shneiderman and plaisant [26] propose strategies for multi-dimensional
in-depth long-term case (milc) studies to evaluate information visual-
ization tools. they observe that    scaling up by an order of magnitude
in terms of number of users and duration of the observations is clearly
bene   cial.    we decided to adopt their core ideas and report on qualita-
tive feedback and quantitative success indicators after the open-source
release of lstmvis in june 2016.

we created a webpage and a video that introduces the core ideas of
lstmvis at lstm.seas.harvard.edu. the webpage provides an
opportunity for users to leave comments. to advertise the tool online
we followed a social media strategy that included collecting followers
on twitter, using broadcast media such as reddit and hackernews,
and inviting editors of popular machine learning blogs to write guest
articles.

the webpage contains a demo system with example datasets that
allows us to acquire a large set of logging data. we noticed that users

8

often try to reproduce the scenarios that are explained in the online
video. to allow users to share insights from their exploratory analy-
sis, we ensured that our url parameter string contains all necessary
information to replay and share a scenario.
we collected logging information about our webpage using google
analytics. within the    rst 7 days, the web page received    5,600
unique users, with 49% of traf   c coming through social media and 39%
arriving directly. the social media traf   c was dominated by channels
that we used to advertise the tool (twitter 40%, reddit 26%). to our
surprise we also observed substantial traf   c from channels that we did
not contact directly (e.g., sina weibo 11%, google+ 9%). after 300
days we recorded    19,500 page views with shrinking user traf   c from
social media (31%). at that point most users used search (22%) or
accessed the webpage directly (39%). only a small percentage (10%)
of users tried the online demo. most of these users used the datasets
shown in the explanation video and did not explore further.

our open source code release was stable yet simple enough to    ...en-
sure that the tool has a reasonable level of reliability and support for
basic features    [26]. for easy adoption, we provide user documentation
that explains what data can be used and how to use the tool. we also
provide convenience tools to prepare the data for import (section 5.5).
we asked students to act as testers for our source code. based on their
feedback we made several improvements to the installation process.
for example, our prototype required nodejs to resolve client-side de-
pendencies. by providing the required libraries within our repository
we removed the cumbersome step of installing nodejs for our target
audience. we observe that around 400 programmers liked the project
(stars on github) and over 95 practitioners copied (forked) the project
to make custom modi   cations. we think that this demonstrate a reason-
able interest in the system after only 300 days considering its highly
specialized target audience.

furthermore, we observe adoption of the tool for several documented
use cases. evermann et.al. [8] describe the application of lstmvis to
understand a trained model for a business process intelligence dataset.
liu et.al. [19] use lstmvis in experiments to investigate language
variants and vagueness in website privacy policies. we see an increasing
interest to apply our tool for biomedical and genomic data. this is
indicated by the use case we described in section 6.3 or, e.g., in ching

abcto appear in ieee transactions on visualization and computer graphics

et.al. [5]

besides the quantitative observations we also collected qualitative
feedback from comments on the webpage, github tickets (feature
requests), and in-person presentations of the prototype. this qualita-
tive feedback led us to make several changes to our system that were
discussed in section 5.

in retrospective, conducting a long-term user study bene   ted the
project at multiple stages. preparing the release of the prototype re-
quired us to focus strongly on simplicity, usability, and robustness of
our tool. this lead to many small improvements to an internal proto-
type. the design iterations we inferred from user feedback strengthen
the tool further. we think, that planning a successful long-term study
requires four core ingredients: (1) reach out to your target audience
by describing your approach (webpage, video) and inform them using
social media, email, etc. (2) allow users to play with your tool by
setting up a demo server, (3) allow engagement and experimentation
with your tool by providing suf   ciently documented, easily adoptable
source code, and (4) make it as simple as possible for users to give you
feedback via discussion forums, reported issues, or in person. during
the study, we found it to be crucial to continuously engage with users
and quickly take action based on their feedback.

8 conclusion
lstmvis provides an interactive visualization to facilitate data analy-
sis of id56 hidden states. the tool is based on direct id136 where a
user selects a range of text to represent a hypothesis and the tool then
matches this selection to other examples in the data set. the tool easily
allows for external annotations to verify or reject hypothesizes. it only
requires a time-series of hidden states, which makes it easy to adopt for
a wide range of visual analyses of different data sets and models, and
even different tasks (id38, translation etc.).

to demonstrate the use of the model we presented several case
studies of applying the tool to different data sets. releasing the tool and
source code online allows us to collect long-term user feedback that
has already led us to make several improvements. in future work, we
will explore how the wide variety of application cases can be adopted    
beyond our imagined use cases and user groups. as example for such a
use case, we got contacted by a highschool student using lstmvis to
learn about id56 methods. while we did not optimize for a learning
scenario, we are now thinking about datasets and a blog publication
that focus on learning. another interesting future work is to support
the user role of end users with simpli   ed views on internals of id56 to
help explaining speci   c model behavior.

acknowledgments
this work was supported in part by the air force research laboratory,
darpa grant fa8750-12-c-0300, oracle research grant, and nih
grant u01ca198935.

references
[1] m. abadi, a. agarwal, p. barham, e. brevdo, z. chen, c. citro, g. s.
corrado, a. davis, j. dean, m. devin, et al. tensor   ow: large-scale
machine learning on heterogeneous distributed systems. arxiv preprint
arxiv:1603.04467, 2016.

[2] d. amodei, r. anubhai, e. battenberg, c. case, j. casper, b. c. catanzaro,
j. chen, m. chrzanowski, a. coates, g. diamos, e. elsen, j. engel, l. fan,
c. fougner, t. han, a. y. hannun, b. jun, p. legresley, l. lin, s. narang,
a. y. ng, s. ozair, r. prenger, j. raiman, s. satheesh, d. seetapun,
s. sengupta, y. wang, z. wang, c. wang, b. xiao, d. yogatama, j. zhan,
and z. zhu. deep speech 2: end-to-end id103 in english and
mandarin. corr, abs/1512.02595, 2015.

[3] d. bahdanau, k. cho, and y. bengio. id4 by

jointly learning to align and translate. corr, abs/1409.0473, 2014.

[4] n. boulanger-lewandowski, y. bengio, and p. vincent. modeling tem-
poral dependencies in high-dimensional sequences: application to poly-
phonic music generation and transcription. in proceedings of the 29th
international conference on machine learning, icml 2012, edinburgh,
scotland, uk, june 26 - july 1, 2012. icml.cc / omnipress, 2012.

[5] t. ching, d. s. himmelstein, b. k. beaulieu-jones, a. a. kalinin, b. t.
do, g. p. way, e. ferrero, p.-m. agapow, w. xie, g. l. rosen, b. j.

9

lengerich, j. israeli, j. lanchantin, s. woloszynek, a. e. carpenter,
a. shrikumar, j. xu, e. m. cofer, d. j. harris, d. decaprio, y. qi,
a. kundaje, y. peng, l. k. wiley, m. h. s. segler, a. gitter, and c. s.
greene. opportunities and obstacles for deep learning in biology and
medicine. biorxiv, 2017. doi: 10.1101/142760

[6] a. m. dai and q. v. le. semi-supervised sequence learning. in advances

in neural information processing systems, pp. 3079   3087, 2015.

[7] j. l. elman. finding structure in time. cognitive science, 14(2):179   211,

1990.

[8] j. evermann, j.-r. rehse, and p. fettke. predicting process behaviour
using deep learning. decision support systems, pp.    , 2017. doi: 10.1016/j
.dss.2017.04.003

[9] f. a. gers and e. schmidhuber. lstm recurrent networks learn simple
context-free and context-sensitive languages. ieee transactions on neural
networks, 12(6):1333   1340, 2001.

[10] k. m. hermann, t. kocisk  y, e. grefenstette, l. espeholt, w. kay, m. su-
leyman, and p. blunsom. teaching machines to read and comprehend.
in c. cortes, n. d. lawrence, d. d. lee, m. sugiyama, and r. garnett,
eds., advances in neural information processing systems 28: annual
conference on neural information processing systems 2015, december
7-12, 2015, montreal, quebec, canada, pp. 1693   1701, 2015.

[11] s. hochreiter and j. schmidhuber. long short-term memory. neural

computation, 9(8):1735   1780, 1997.

[12] a. k  ad  ar, g. chrupa  a, and a. alishahi. lingusitic analysis of multi-modal

[13]

recurrent neural networks. 2015.
  a. k  ad  ar, g. chrupa  a, and a. alishahi. representation of linguis-
tic form and function in recurrent neural networks. arxiv preprint
arxiv:1602.08952, 2016.

[14] n. kalchbrenner and p. blunsom. recurrent continuous translation models.

in emnlp, vol. 3, p. 413, 2013.

[15] a. kapoor, b. lee, d. tan, and e. horvitz. interactive optimization for
steering machine classi   cation. in proceedings of the sigchi conference
on human factors in computing systems, pp. 1343   1352. acm, 2010.
[16] a. karpathy, j. johnson, and f.-f. li. visualizing and understanding

recurrent networks. arxiv preprint arxiv:1506.02078, 2015.

[17] j. krause, a. perer, and k. ng.

interacting with predictions: visual
in proceedings of
inspection of black-box machine learning models.
the 2016 chi conference on human factors in computing systems, pp.
5686   5697. acm, 2016.

[18] j. li, x. chen, e. hovy, and d. jurafsky. visualizing and understanding
neural models in nlp. in proceedings of the 2016 conference of the north
american chapter of the association for computational linguistics: hu-
man language technologies, pp. 681   691. association for computational
linguistics, san diego, california, june 2016.

[19] f. liu, n. l. fella, and k. liao. modeling language vagueness in privacy
policies using deep neural networks. in 2016 aaai fall symposium series,
2016.

[20] m. liu, j. shi, z. li, c. li, j. zhu, and s. liu. towards better analysis of
deep convolutional neural networks. ieee transactions on visualization
and computer graphics, 23(1):91   100, 2017.

[21] m. p. marcus, m. a. marcinkiewicz, and b. santorini. building a large
annotated corpus of english: the id32. computational linguistics,
19(2):313   330, 1993.

[22] t. mikolov, m. kara     at, l. burget, j. cernock`y, and s. khudanpur. re-
current neural network based language model. in interspeech, vol. 2, p. 3,
2010.

[23] t. mikolov, i. sutskever, k. chen, g. s. corrado, and j. dean. dis-
tributed representations of words and phrases and their compositionality.
in advances in neural information processing systems, pp. 3111   3119,
2013.

[24] d. quang and x. xie. danq: a hybrid convolutional and recurrent deep
neural network for quantifying the function of dna sequences. nucleic
acids research, p. gkw226, 2016.

[25] p. e. rauber, s. g. fadel, a. x. falco, and a. c. telea. visualizing
the hidden activity of arti   cial neural networks. ieee transactions on
visualization and computer graphics, 23(1):101   110, jan 2017. doi: 10.
1109/tvcg.2016.2598838

[26] b. shneiderman and c. plaisant. strategies for evaluating information
visualization tools: multi-dimensional in-depth long-term case studies. in
proceedings of the 2006 avi workshop on beyond time and errors: novel
evaluation methods for information visualization, beliv 2006, venice,
italy, may 23, 2006, pp. 1   7, 2006. doi: 10.1145/1168149.1168158

[27] k. simonyan, a. vedaldi, and a. zisserman. deep inside convolutional

networks: visualising image classi   cation models and saliency maps.
arxiv preprint arxiv:1312.6034, 2013.

[28] i. sutskever, o. vinyals, and q. v. le. sequence to sequence learning with
neural networks. in advances in neural information processing systems,
pp. 3104   3112, 2014.

[29] e. f. tjong kim sang and f. de meulder.

introduction to the conll-
2003 shared task: language-independent id39. in
proceedings of the seventh conference on natural language learning at
hlt-naacl 2003-volume 4, pp. 142   147. association for computational
linguistics, 2003.

[30] f.-y. tzeng and k.-l. ma. opening the black box-data driven visualization
of neural networks. in vis 05. ieee visualization, 2005., pp. 383   390.
ieee, 2005.

[31] p. r. j. wiles. recurrent neural networks can learn to implement symbol-
sensitive counting. in advances in neural information processing systems
10: proceedings of the 1997 conference, vol. 10, p. 87. mit press, 1998.
[32] k. xu, j. ba, r. kiros, k. cho, a. c. courville, r. salakhutdinov, r. s.
zemel, and y. bengio. show, attend and tell: neural image caption
generation with visual attention.
in f. r. bach and d. m. blei, eds.,
proceedings of the 32nd international conference on machine learning,
icml 2015, lille, france, 6-11 july 2015, vol. 37 of jmlr proceedings,
pp. 2048   2057. jmlr.org, 2015.

[33] w. zaremba, i. sutskever, and o. vinyals. recurrent neural network

id173. arxiv:1409.2329, 2014.

[34] m. d. zeiler and r. fergus. visualizing and understanding convolutional
networks. in european conference on id161, pp. 818   833.
springer, 2014.

[35] j. zhou and o. g. troyanskaya. predicting effects of noncoding variants
with deep learning-based sequence model. nature methods, 12(10):931   
934, 2015.

10

