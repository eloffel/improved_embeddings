neural crf parsing

greg durrett and dan klein

computer science division

university of california, berkeley

5
1
0
2

 
l
u
j
 

3
1

 
 
]
l
c
.
s
c
[
 
 

1
v
1
4
6
3
0

.

7
0
5
1
:
v
i
x
r
a

{gdurrett,klein}@cs.berkeley.edu

abstract

this paper describes a parsing model that
combines the exact id145
of crf parsing with the rich nonlinear fea-
turization of neural net approaches. our
model is structurally a crf that factors
over anchored rule productions, but in-
stead of linear potential functions based
on sparse features, we use nonlinear po-
tentials computed via a feedforward neu-
ral network. because potentials are still
local to anchored rules, structured infer-
ence (cky) is unchanged from the sparse
case. computing gradients during learn-
ing involves backpropagating an error sig-
nal formed from standard crf suf   cient
statistics (expected rule counts).
us-
ing only dense features, our neural crf
already exceeds a strong baseline crf
model (hall et al., 2014). in combination
with sparse features, our system1 achieves
91.1 f1 on section 23 of the penn tree-
bank, and more generally outperforms the
best prior single parser results on a range
of languages.

introduction

1
neural network-based approaches to structured
nlp tasks have both strengths and weaknesses
when compared to more conventional models,
such conditional random    elds (crfs). a key
strength of neural approaches is their ability to
learn nonlinear interactions between underlying
features. in the case of unstructured output spaces,
this capability has led to gains in problems rang-
ing from syntax (chen and manning, 2014; be-
linkov et al., 2014) to lexical semantics (kalch-
brenner et al., 2014; kim, 2014). neural methods
are also powerful tools in the case of structured

1system available at http://nlp.cs.berkeley.edu

output spaces. here, past work has often relied on
recurrent architectures (henderson, 2003; socher
et al., 2013;   irsoy and cardie, 2014), which can
propagate information through structure via real-
valued hidden state, but as a result do not admit ef-
   cient id145 (socher et al., 2013;
le and zuidema, 2014). however, there is a nat-
ural marriage of nonlinear induced features and
ef   cient structured id136, as explored by col-
lobert et al. (2011) for the case of sequence mod-
eling: feedforward neural networks can be used to
score local decisions which are then    reconciled   
in a discrete structured modeling framework, al-
lowing id136 via id145.

in this work, we present a crf constituency
parser based on these principles, where individ-
ual anchored rule productions are scored based
on nonlinear features computed with a feedfor-
ward neural network. a separate,
identically-
parameterized replicate of the network exists for
each possible span and split point. as input, it
takes vector representations of words at the split
point and span boundaries; it then outputs scores
for anchored rules applied to that span and split
point. these scores can be thought of as non-
linear potentials analogous to linear potentials in
conventional crfs. crucially, while the network
replicates are connected in a uni   ed model, their
computations factor along the same substructures
as in standard crfs.

prior work on parsing using neural network
models has often sidestepped the problem of struc-
tured id136 by making sequential decisions
(henderson, 2003; chen and manning, 2014;
tsuboi, 2014) or by doing reranking (socher et
al., 2013; le and zuidema, 2014); by contrast, our
framework permits exact id136 via cky, since
the model   s structured interactions are purely dis-
crete and do not involve continuous hidden state.
therefore, we can exploit a neural net   s capac-
ity to learn nonlinear features without modifying

figure 1: neural crf model. on the right, each
anchored rule (r, s) in the tree is independently
scored by a function   , so we can perform in-
ference with cky to compute marginals or the
viterbi tree. on the left, we show the process
for scoring an anchored rule with neural features:
words in fw (see figure 2) are embedded, then fed
through a neural network with one hidden layer to
compute dense intermediate features, whose con-
junctions with sparse rule indicator features fo are
scored according to parameters w .

our core id136 mechanism, allowing us to use
tricks like coarse pruning that make id136 ef-
   cient in the purely sparse model. our model can
be trained by id119 exactly as in a con-
ventional crf, with the gradient of the network
parameters naturally computed by backpropagat-
ing a difference of expected anchored rule counts
through the network for each span and split point.
using dense learned features alone, the neu-
ral crf model obtains high performance, out-
performing the crf parser of hall et al. (2014).
when sparse indicators are used in addition, the
resulting model gets 91.1 f1 on section 23 of
the id32, outperforming the parser of
socher et al. (2013) as well as the berkeley parser
(petrov and klein, 2007) and matching the dis-
criminative parser of carreras et al. (2008). the
model also obtains the best single parser results
on nine other languages, again outperforming the
system of hall et al. (2014).

2 model

figure 1 shows our neural crf model. the
model decomposes over anchored rules, and it
scores each of these with a potential function; in
a standard crf, these potentials are typically lin-
ear functions of sparse indicator features, whereas

figure 2: example of an anchored rule production
for the rule np     np pp. from the anchoring s =
(i, j, k), we extract either sparse surface features
fs or a sequence of word indicators fw which are
embedded to form a vector representation v(fw)
of the anchoring   s lexical properties.

in our approach they are nonlinear functions of
id27s.2 section 2.1 describes our no-
tation for anchored rules, and section 2.2 talks
about how they are scored. we then discuss spe-
ci   c choices of our featurization (section 2.3) and
the backbone grammar used for structured infer-
ence (section 2.4).

2.1 anchored rules
the fundamental units that our parsing models
consider are anchored rules. as shown in fig-
ure 2, we de   ne an anchored rule as a tuple (r, s),
where r is an indicator of the rule   s identity and
s = (i, j, k) indicates the span (i, k) and split
point j of the rule.3 a tree t is simply a collec-
tion of anchored rules subject to the constraint that
those rules form a tree. all of our parsing models
are crfs that decompose over anchored rule pro-
ductions and place a id203 distribution over
trees conditioned on a sentence w as follows:

       (cid:88)

(r,s)   t

      

p (t|w)     exp

  (w, r, s)

2throughout this work, we will primarily consider two
potential functions: linear functions of sparse indicators and
nonlinear neural networks over dense, continuous features.
although other modeling choices are possible, these two
points in the design space re   ect common choices in nlp,
and past work has suggested that nonlinear functions of indi-
cators or linear functions of dense features may perform less
well (wang and manning, 2013).

3for simplicity of exposition, we ignore unary rules; how-
ever, they are easily supported in this framework by simply
specifying a null value for the split point.

snpvpdtnnpvbznp   wthefedissuedstructured id136	

(discrete)feature extraction (continuous)foh fwv(fw)re   ected  the     ip  side  of  the  stoltzman  personality  .re   ected   the  side  of   personality  .ijk[[previousword = re   ected]], [[spanlength = 7]],    fsnpppnpr=np      np pp!fwv(fw)where    is a scoring function that considers the
input sentence and the anchored rule in question.
figure 1 shows this scoring process schematically.
as we will see, the module on the left can be be
a neural net, a linear function of surface features,
or a combination of the two, as long as it provides
anchored rule scores, and the structured id136
component is the same regardless (cky).

a pid18 estimated with maximum likelihood
has   (w, r, s) = log p (r|parent(r)), which is in-
dependent of the anchoring s and the words w ex-
cept for preterminal productions; a basic discrimi-
native parser might let this be a learned parameter
but still disregard the surface information. how-
ever, surface features can capture useful syntactic
cues (finkel et al., 2008; hall et al., 2014). con-
sider the example in figure 2: the proposed parent
np is preceded by the word re   ected and followed
by a period, which is a surface context character-
istic of nps or pps in object position. beginning
with the and ending with personality are typical
properties of nps as well, and the choice of the
particular rule np     np pp is supported by the
fact that the proposed child pp begins with of. this
information can be captured with sparse features
(fs in figure 2) or, as we describe below, with a
neural network taking lexical context as input.

2.2 scoring anchored rules
following hall et al. (2014), our baseline sparse
scoring function takes the following bilinear form:

  sparse(w, r, s; w ) = fs(w, s)

(cid:62)

w fo(r)

where fo(r)     {0, 1}no is a sparse vector of
features expressing properties of r (such as the
rule   s identity or its parent label) and fs(w, s)    
{0, 1}ns is a sparse vector of surface features as-
sociated with the words in the sentence and the
anchoring, as shown in figure 2. w is a ns    no
matrix of weights.4 the scoring of a particular an-
chored rule is depicted in figure 3a; note that sur-
face features and rule indicators are conjoined in a
systematic way.

the role of fs can be equally well played by a
vector of dense features learned via a neural net-
4a more conventional expression of the scoring function
for a crf is   (w, r, s) =   (cid:62)f (w, r, s), with a vector    for
the parameters and a single feature extractor f that jointly
inspects the surface and the rule. however, when the feature
representation conjoins each rule r with surface properties of
the sentence in a systematic way (an assumption that holds in
our case as well as for standard crf models for id52
and ner), this is equivalent to our formalism.

figure 3: our sparse (left) and neural (right) scor-
ing functions for crf parsing. fs and fw are
raw surface feature vectors for the sparse and neu-
ral models (respectively) extracted over anchored
spans with split points.
(a) in the sparse case,
we multiply fs by a weight matrix w and then
a sparse output vector fo to score the rule produc-
tion. (b) in the neural case, we    rst embed fw and
then transform it with a one-layer neural network
in order to produce an intermediate feature repre-
sentation h before combining with w and fo.

work. we will now describe how to compute these
features, which represent a transformation of sur-
face lexical indicators fw. de   ne fw(w, s)     nnw
to be a function that produces a    xed-length se-
quence of word indicators based on the input sen-
tence and the anchoring. this vector of word
identities is then passed to an embedding function
v : n     rne and the dense representations of
the words are subsequently concatenated to form
a vector we denote by v(fw).5 finally, we mul-
tiply this by a matrix h     rnh  (nwne) of real-
valued parameters and pass it through an elemen-
twise nonlinearity g(  ). we use recti   ed linear
units g(x) = max(x, 0) and discuss this choice
more in section 6.

replacing fs with the end result of this compu-
tation h(w, s; h) = g(hv(fw(w, s))), our scor-
ing function becomes

  neural(w, r, s; h, w ) = h(w, s; h)

(cid:62)

w fo(r)

as shown in figure 3b. for a    xed h, this model
can be viewed as a basic crf with dense input fea-
tures. by learning h, we learn intermediate fea-
ture representations that provide the model with
5embedding words allows us to use standard pre-trained
vectors more easily and tying embeddings across word posi-
tions substantially reduces the number of model parameters.
however, embedding features rather than words has also been
shown to be effective (chen et al., 2014).

fowfowfswij=weight([[fs,i^fo,j]])a)b)fwv(fw)h =f>swfo =g(hv(fw))>wfomore discriminating power. also note that it is
possible to use deeper networks or more sophis-
ticated architectures here; we will return to this in
section 6.

our two models can be easily combined:

  (w, r, s; w1, h, w2) =   sparse(w, r, s; w1)

+   neural(w, r, s; h, w2)

weights for each component of the scoring func-
tion can be learned fully jointly and id136 pro-
ceeds as before.

2.3 features
we take fs to be the set of features described in
hall et al. (2014). at the preterminal layer, the
model considers pre   xes and suf   xes up to length
5 of the current word and neighboring words, as
well as the words    identities. for nonterminal pro-
ductions, we    re indicators on the words6 before
and after the start, end, and split point of the an-
chored rule (as shown in figure 2) as well as on
two other span properties, span length and span
shape (an indicator of where capitalized words,
numbers, and punctuation occur in the span).

for our neural model, we take fw for all pro-
ductions (preterminal and nonterminal) to be the
words surrounding the beginning and end of a span
and the split point, as shown in figure 2; in partic-
ular, we look two words in either direction around
each point of interest, meaning the neural net takes
12 words as input.7 for our id27s v,
we use pre-trained word vectors from bansal et al.
(2014). we compare with other sources of word
vectors in section 5. contrary to standard practice,
we do not update these vectors during training; we
found that doing so did not provide an accuracy
bene   t and slowed down training considerably.

2.4 grammar re   nements
a recurring issue in discriminative constituency
parsing is the granularity of annotation in the base
grammar (finkel et al., 2008; petrov and klein,
2008; hall et al., 2014). using    ner-grained sym-
bols in our rules r gives the model greater capacity,
but also introduces more parameters into w and

6the model actually uses the longest suf   x of each word
occurring at least 100 times in the training set, up to the entire
word. removing this abstraction of rare words harms perfor-
mance.

7the sparse model did not bene   t from using this larger
neighborhood, so improvements from the neural net are not
simply due to considering more lexical context.

increases the ability to over   t. following hall et
al. (2014), we use grammars with very little anno-
tation: we use no horizontal markovization for any
of experiments, and all of our english experiments
with the neural crf use no vertical markovization
(v = 0). this also has the bene   t of making the
system much faster, due to the smaller state space
for id145. we do    nd that using
parent annotation (v = 1) is useful on other lan-
guages (see section 7.2), but this is the only gram-
mar re   nement we consider.

3 learning
to learn weights for our neural model, we maxi-
mize the conditional log likelihood of our d train-
ing trees t    :

l(h, w ) =

log p (t

   
i |wi; h, w )

because we are using recti   ed linear units as our
nonlinearity, our objective is not everywhere dif-
ferentiable. the interaction of the parameters and
the nonlinearity also makes the objective non-
convex. however, in spite of this, we can still fol-
low subgradients to optimize this objective, as is
standard practice.

recall that h(w, s; h) are the hidden layer ac-
tivations. the gradient of w takes the standard
form of id148:

d(cid:88)

i=1

       (cid:88)

(r,s)   t    

=

   l
   w

      (cid:88)

t

h(w, s; h)fo(r)

(cid:88)

(r,s)   t

p (t|w; h, w )

h(w, s; h)fo(r)

      

(cid:62)

         

(cid:62)

note that the outer products give matrices of fea-
ture counts isomorphic to w . the second expres-
sion can be simpli   ed to be in terms of expected
feature counts. to update h, we use standard
id26 by    rst computing:

   l
   h

       (cid:88)
      (cid:88)

=

(r,s)   t    

t

w fo(r)

         
(cid:88)

p (t|w; h, w )

(r,s)   t

      

w fo(r)

since h is the output of the neural network, we can
then apply the chain rule to compute gradients for
h and any other parameters in the neural network.

learning uses adadelta (zeiler, 2012), which
has been employed in past work (kim, 2014). we
found that adagrad (duchi et al., 2011) performed
equally well with tuned id173 and step
size parameters, but adadelta worked better out
of the box. we set the momentum term    = 0.95
(as suggested by zeiler (2012)) and did not reg-
ularize the weights at all. we used a minibatch
size of 200 trees, although the system was not par-
ticularly sensitive to this. for each treebank, we
trained for either 10 passes through the treebank
or 1000 minibatches, whichever is shorter.

we initialized the output weight matrix w to
zero. to break symmetry, the lower level neural
network parameters h were initialized with each
entry being independently sampled from a gaus-
sian with mean 0 and variance 0.01; gaussian per-
formed better than uniform initialization, but the
variance was not important.

id136

4
our baseline and neural model both score an-
chored rule productions. we can use cky in the
standard fashion to compute either expected an-
chored rule counts ep (t|w)[(r, s)] or the viterbi
tree arg maxt p (t|w).
we speed up id136 by using a coarse prun-
ing pass. we follow hall et al. (2014) and
prune according to an x-bar grammar with head-
outward binarization, ruling out any constituent
whose max marginal id203 is less than e   9.
with this pruning, the number of spans and split
points to be considered is greatly reduced; how-
ever, we still need to compute the neural network
activations for each remaining span and split point,
of which there may be thousands for a given sen-
tence.8 we can improve ef   ciency further by not-
ing that the same word will appear in the same po-
sition in a large number of span/split point combi-
nations, and cache the contribution to the hidden
layer caused by that word (chen and manning,
2014). computing the hidden layer then simply
requires adding nw vectors together and applying
the nonlinearity, instead of a more costly matrix
multiply.

because the number of rule indicators no is
fairly large (approximately 4000 in the penn tree-
bank), the multiplication by w in the model is also
8one reason we did not choose to include the rule identity
fo as an input to the network is that it requires computing an
even larger number of network activations, since we cannot
reuse them across rules over the same span and split point.

expensive. however, because only a small number
of rules can apply to a given span and split point,
fo is sparse and we can selectively compute the
terms necessary for the    nal bilinear product.

our combined sparse and neural model trains on
the id32 in 24 hours on a single machine
with a parallelized cpu implementation. for ref-
erence, the purely sparse model with a parent-
annotated grammar (necessary for the best results)
takes around 15 hours on the same machine.

5 system ablations

table 1 shows results on section 22 (the develop-
ment set) of the english id32 (marcus
et al., 1993), computed using evalb. full test re-
sults and comparisons to other systems are shown
in table 4. we compare variants of our system
along two axes: whether they use standard linear
sparse features, nonlinear dense features from the
neural net, or both, and whether any word repre-
sentations (vectors or clusters) are used.

sparse vs. neural the neural crf (line (d) in
table 1) on its own outperforms the sparse crf
(a, b) even when the sparse crf has a more heav-
ily annotated grammar. this is a surprising re-
sult:
the features in the sparse crf have been
carefully engineered to capture a range of linguis-
tic phenomena (hall et al., 2014), and there is
no guarantee that word vectors will capture the
same. for example, at the id52 layer,
the sparse model looks at pre   xes and suf   xes of
words, which give the model access to morphol-
ogy for predicting tags of unknown words, which
typically have regular in   ection patterns. by con-
trast, the neural model must rely on the geometry
of the vector space exposing useful regularities.
at the same time, the strong performance of the
combination of the two systems (g) indicates that
not only are both featurization approaches high-
performing on their own, but that they have com-
plementary strengths.

unlabeled data much attention has been paid
to the choice of word vectors for various nlp
tasks, notably whether they capture more syntac-
tic or semantic phenomena (bansal et al., 2014;
levy and goldberg, 2014). we primarily use vec-
tors from bansal et al. (2014), who train the skip-
gram model of mikolov et al. (2013) using con-
texts from dependency links; a similar approach
was also suggested by levy and goldberg (2014).

sparse neural v word reps f1 len     40 f1 all
hall et al. (2014), v = 1
(cid:88)
(cid:88)
(cid:88)

a
b
c
d
e
f
g
h

(cid:88)
(cid:88)
(cid:88)
(cid:88)
(cid:88)

(cid:88)
(cid:88)

0
1
1
brown
0
bansal
0 collobert
0
0
0

ptb
bansal
ptb

90.5
89.89
90.82
90.80
90.97
90.25
89.34
92.04
91.39

89.22
90.13
90.17
90.44
89.63
88.99
91.34
90.91

table 1: results of our sparse crf, neural crf,
and combined parsing models on section 22 of
the id32. systems are broken down
by whether local potentials come from sparse
features and/or the neural network (the primary
contribution of this work), their level of vertical
markovization, and what kind of word represen-
tations they use. the neural crf (d) outperforms
the sparse crf (a, b) even when a more heavily
annotated grammar is used, and the combined ap-
proach (g) is substantially better than either indi-
vidual model. the contribution of the neural ar-
chitecture cannot be replaced by brown clusters
(c), and even word representations learned just on
the id32 are surprisingly effective (f, h).

however, as these embeddings are trained on a
relatively small corpus (bllip minus the penn
treebank), it is natural to wonder whether less-
syntactic embeddings trained on a larger corpus
might be more useful. this is not the case: line
(e) in table 1 shows the performance of the neu-
ral crf using the wikipedia-trained word embed-
dings of collobert et al. (2011), which do not per-
form better than the vectors of bansal et al. (2014).
to isolate the contribution of continuous word
representations themselves, we also experimented
with vectors trained on just the text from the train-
ing set of the id32 using the skip-gram
model with a window size of 1. while these vec-
tors are somewhat lower performing on their own
(f), they still provide a surprising and noticeable
gain when stacked on top of sparse features (h),
again suggesting that dense and sparse represen-
tations have complementary strengths. this result
also reinforces the notion that the utility of word
vectors does not come primarily from importing
information about out-of-vocabulary words (an-
dreas and klein, 2014).

since the neural features incorporate informa-
tion from unlabeled data, we should provide the

neural crf

nonlinearity

depth

relu
tanh
cube
0 hl
1 hl
2 hl

embed output

f1 len     40

90.97
90.97
90.74
89.94
90.54
90.97
90.58
88.81

   
   
   
   0.23
   1.03
   0.43
   
   0.39
   2.16

table 2: exploration of other implementation
choices in the feedforward neural network on sen-
tences of length     40 from section 22 of the penn
treebank. recti   ed linear units perform better
than tanh or cubic units, a network with one hid-
den layer performs best, and embedding the output
feature vector gives worse performance.

sparse model with similar information for a true
apples-to-apples comparison. brown clusters have
been shown to be effective vehicles in the past
(koo et al., 2008; turian et al., 2010; bansal et al.,
2014). we can incorporate brown clusters into the
baseline crf model in an analogous way to how
embedding features are used in the dense model:
surface features are    red on brown cluster iden-
tities (we use pre   xes of length 4 and 10) of key
words. we use the brown clusters from koo et al.
(2008), which are trained on the same data as the
vectors of bansal et al. (2014). however, table 1
shows that these features provide no bene   t to the
baseline model, which suggests either that it is dif-
   cult to learn reliable weights for these as sparse
features or that different regularities are being cap-
tured by the id27s.

6 design choices

the neural net design space is large, so we wish
to analyze the particular design choices we made
for this system by examining the performance of
several variants of the neural net architecture used
in our system. table 2 shows development re-
sults from potential alternate architectural choices,
which we now discuss.

choice of nonlinearity the choice of nonlin-
earity g has been frequently discussed in the neural
network literature. our choice g(x) = max(x, 0),
a recti   ed linear unit, is increasingly popular in

id161 (krizhevsky et al., 2012). g(x) =
tanh(x) is a traditional nonlinearity widely used
throughout the history of neural nets (bengio et
al., 2003). g(x) = x3 (cube) was found to be most
successful by chen and manning (2014).

table 2 compares the performance of these
three nonlinearities. we see that recti   ed linear
units perform the best, followed by tanh units,
followed by cubic units.9 one drawback of tanh
as an activation function is that it is easily    satu-
rated    if the input to the unit is too far away from
zero, causing the id26 of derivatives
through that unit to essentially cease; this is known
to cause problems for training, requiring special
purpose machinery for use in deep networks (ioffe
and szegedy, 2015).

depth given that we are using recti   ed linear
units, it bears asking whether or not our imple-
mentation is improving substantially over linear
features of the continuous input. we can use the
embedding vector of an anchored span v(fw) di-
rectly as input to a basic linear crf, as shown in
figure 4a. table 1 shows that the purely linear ar-
chitecture (0 hl) performs surprisingly well, but
is still less effective than the network with one hid-
den layer. this agrees with the results of wang
and manning (2013), who noted that dense fea-
tures typically bene   t from nonlinear modeling.
we also compare against a two-layer neural net-
work, but    nd that this also performs worse than
the one-layer architecture.

densifying output features overall, it appears
bene   cial to use dense representations of surface
features; a natural question that one might ask is
whether the same technique can be applied to the
sparse output feature vector fo. we can apply the
approach of srikumar and manning (2014) and
multiply the sparse output vector by a dense matrix
k, giving the following scoring function (shown
in figure 4b):
  (w, r, s; h, w, k) = g(hv(fw(w, s)))(cid:62)w kfo(r)

where w is now nh    noe and k is noe    no.
w k can be seen a low-rank approximation of the
original w at the output layer, similar to low-rank
factorizations of parameter matrices used in past

9the performance of cube decreased substantially late in
learning; it peaked at around 90.52. dropout may be useful
for alleviating this type of over   tting, but in our experiments
we did not    nd dropout to be bene   cial overall.

figure 4: two additional forms of the scoring
function. a) linear version of the dense model,
equivalent to a crf with continuous-valued input
features. b) version of the dense model where out-
puts are also embedded according to a learned ma-
trix k.

work (lei et al., 2014). this approach saves us
from having to learn a separate row of w for ev-
ery rule in the grammar; if rules are given similar
embeddings, then they will behave similarly ac-
cording to the model.

we experimented with noe = 20 and show the
results in table 2. unfortunately, this approach
does not seem to work well for parsing. learn-
ing the output representation was empirically very
unstable, and it also required careful initialization.
we tried gaussian initialization (as in the rest of
our model) and initializing the model by id91
rules either randomly or according to their parent
symbol. the latter is what is shown in the table,
and gave substantially better performance. we hy-
pothesize that blurring distinctions between output
classes may harm the model   s ability to differenti-
ate between closely-related symbols, which is re-
quired for good parsing performance. using pre-
trained rule embeddings at this layer might also
improve performance of this method.

7 test results

we evaluate our system under two conditions:
   rst, on the english id32, and second,
on the nine languages used in the spmrl 2013
and 2014 shared tasks.

7.1 id32
table 4 reports results on section 23 of the penn
treebank (ptb). we focus our comparison on sin-
gle parser systems as opposed to rerankers, ensem-
bles, or self-trained methods (though these are also
mentioned for context). first, we compare against

fowwha)b)fokfo =g(hv(fw))>wkfo =v(fw)>wfofwv(fw)fwv(fw)arabic basque french german hebrew hungarian korean polish swedish avg

hall et al. (2014)
this work*

78.89
80.68

83.74
84.37

79.40
80.65

83.28
85.25

88.06
89.37

dev, all lengths

test, all lengths

berkeley
berkeley-tags
crabb  e and seddah (2014)
hall et al. (2014)
this work*

79.19
78.66
77.66
78.75
80.24

70.50
74.74
85.35
83.39
85.41

80.38
79.76
79.68
79.70
81.25

78.30
78.28
77.15
78.43
80.95

86.96
85.42
86.19
87.18
88.61

reranked ensemble

87.44
89.46

81.62
85.22
87.51
88.25
90.66

81.85
82.35

91.10
92.10

75.95
77.93

83.30
84.68

71.42
78.56
79.35
80.18
82.23

79.23
86.75
91.60
90.66
92.97

79.18
80.64
82.72
82.00
83.45

78.53
80.89
83.02
83.17
85.08

2014 best

81.32

88.24

82.53

81.66

89.80

91.72

83.81

90.50

85.50

86.12

table 3: results for the nine treebanks in the spmrl 2013/2014 shared tasks; all values are f-scores
for sentences of all lengths using the version of evalb distributed with the shared task. our parser
substantially outperforms the strongest single parser results on this dataset (hall et al., 2014; crabb  e and
seddah, 2014). berkeley-tags is an improved version of the berkeley parser designed for the shared task
(seddah et al., 2013). 2014 best is a reranked ensemble of modi   ed berkeley parsers and constitutes the
best published numbers on this dataset (bj  orkelund et al., 2013; bj  orkelund et al., 2014).

f1 all

single model, ptb only
hall et al. (2014)
berkeley
carreras et al. (2008)
shindo et al. (2012) single

89.2
90.1
91.1
91.1
single model, ptb + vectors/clusters
91.3
91.1

zhu et al. (2013)
this work*
extended conditions
charniak and johnson (2005)
socher et al. (2013)
vinyals et al. (2014) single
vinyals et al. (2014) ensemble
shindo et al. (2012) ensemble

91.5
90.4
90.5
91.6
92.4

table 4: test results on section 23 of the penn
treebank. we compare to several categories of
parsers from the literatures. we outperform strong
baselines such as the berkeley parser (petrov and
klein, 2007) and the cvg stanford parser (socher
et al., 2013) and we match the performance of so-
phisticated generative (shindo et al., 2012) and
discriminative (carreras et al., 2008) parsers.

four parsers trained only on the ptb with no aux-
iliary data: the crf parser of hall et al. (2014),
the berkeley parser (petrov and klein, 2007), the
discriminative parser of carreras et al. (2008), and

the single tsg parser of shindo et al. (2012). to
our knowledge, the latter two systems are the high-
est performing in this ptb-only, single parser data
condition; we match their performance at 91.1 f1,
though we also use word vectors computed from
unlabeled data. we further compare to the shift-
reduce parser of zhu et al. (2013), which uses un-
labeled data in the form of brown clusters. our
method achieves performance close to that of their
parser.

we also compare to the compositional vector
grammar (cvg) parser of socher et al. (2013)
as well as the lstm-based parser of vinyals et
al. (2014). the conditions these parsers are op-
erating under are slightly different: the former is
a reranker on top of the stanford parser (klein
and manning, 2003) and the latter trains on much
larger amounts of data parsed by a product of
berkeley parsers (petrov, 2010). regardless, we
outperform the cvg parser as well as the single
parser results from vinyals et al. (2014).

languages,

7.2 spmrl
we also examine the performance of our
parser on other
speci   cally the
nine morphologically-rich languages used in the
spmrl 2013/2014 shared tasks (seddah et al.,
2013; seddah et al., 2014). we train word vec-
tors on the monolingual data distributed with the
spmrl 2014 shared task (typically 100m-200m
tokens per language) using the skip-gram ap-
proach of id97 with a window size of 1

(mikolov et al., 2013).10 here we use v = 1
in the backbone grammar, which we found to be
bene   cial overall. table 3 shows that our system
improves upon the performance of the parser from
hall et al. (2014) as well as the top single parser
from the shared task (crabb  e and seddah, 2014),
with robust improvements on all languages.

8 conclusion
in this work, we presented a crf parser that
scores anchored rule productions using dense in-
put features computed from a feedforward neu-
ral net. because the neural component is mod-
ularized, we can easily integrate it into a pre-
existing learning and id136 framework based
around id145 of a discrete parse
chart. our combined neural and sparse model
gives strong performance both on english and on
other languages.

our

system is

publicly

available

at

http://nlp.cs.berkeley.edu.

acknowledgments
this work was partially supported by bbn un-
der darpa contract hr0011-12-c-0014, by a
facebook fellowship for the    rst author, and by
a google faculty research award to the second
author. thanks to david hall for assistance with
the epic parsing framework and for a preliminary
implementation of the neural architecture, to kush
rastogi for training word vectors on the spmrl
data, to dan jurafsky for helpful discussions, and
to the anonymous reviewers for their insightful
comments.

references
jacob andreas and dan klein. 2014. how much do
in pro-
id27s encode about syntax?
ceedings of the association for computational lin-
guistics.

mohit bansal, kevin gimpel, and karen livescu.
2014. tailoring continuous word representations
for id33. in proceedings of the as-
sociation for computational linguistics.

yonatan belinkov, tao lei, regina barzilay, and amir
globerson. 2014. exploring compositional archi-
tectures and word vector representations for prepo-
sitional phrase attachment. transactions of the as-
sociation for computational linguistics, 2:561   572.

10training vectors with the skipdep method of bansal et

al. (2014) did not substantially improve performance here.

yoshua bengio, r  ejean ducharme, pascal vincent, and
christian janvin. 2003. a neural probabilistic lan-
journal of machine learning re-
guage model.
search, 3:1137   1155, march.

anders bj  orkelund, ozlem cetinoglu, rich  ard farkas,
thomas mueller, and wolfgang seeker.
2013.
(re)ranking meets morphosyntax: state-of-the-art
results from the spmrl 2013 shared task. in pro-
ceedings of the fourth workshop on statistical pars-
ing of morphologically-rich languages.

anders bj  orkelund,

  ozlem c   etino  glu, agnieszka
fale  nska, rich  ard farkas, thomas mueller, wolf-
gang seeker, and zsolt sz  ant  o. 2014. introducing
the ims-wroc  aw-szeged-cis entry at the spmrl
2014 shared task: reranking and morpho-syntax
in proceedings of the first
meet unlabeled data.
joint workshop on statistical parsing of morpho-
logically rich languages and syntactic analysis of
non-canonical languages.

xavier carreras, michael collins, and terry koo.
2008. tag, id145, and the per-
ceptron for ef   cient, feature-rich parsing. in pro-
ceedings of the conference on computational natu-
ral language learning.

eugene charniak and mark johnson. 2005. coarse-
to-fine n-best parsing and maxent discriminative
in proceedings of the association for
reranking.
computational linguistics.

danqi chen and christopher d manning. 2014. a
fast and accurate dependency parser using neural
networks. in proceedings of empirical methods in
natural language processing.

wenliang chen, yue zhang, and min zhang. 2014.
in
the international conference on

feature embedding for id33.
proceedings of
computational linguistics.

ronan collobert, jason weston, l  eon bottou, michael
karlen, koray kavukcuoglu, and pavel kuksa.
2011. natural language processing (almost) from
journal of machine learning research,
scratch.
12:2493   2537.

benoit crabb  e and djam  e seddah. 2014. multilingual
discriminative shift-reduce phrase structure pars-
ing for the spmrl 2014 shared task. in proceed-
ings of the first joint workshop on statistical pars-
ing of morphologically rich languages and syntac-
tic analysis of non-canonical languages.

john duchi, elad hazan, and yoram singer. 2011.
adaptive subgradient methods for online learning
and stochastic optimization. journal of machine
learning research, 12:2121   2159, july.

jenny rose finkel, alex kleeman, and christopher d.
manning. 2008. ef   cient, feature-based, condi-
tional random field parsing. in proceedings of the
association for computational linguistics.

david hall, greg durrett, and dan klein. 2014. less
grammar, more features. in proceedings of the as-
sociation for computational linguistics.

james henderson. 2003. inducing history represen-
tations for broad coverage statistical parsing.
in
proceedings of the north american chapter of the
association for computational linguistics.

sergey ioffe and christian szegedy. 2015. batch nor-
malization: accelerating deep network training by
reducing internal covariate shift. arxiv preprint,
arxiv:1502.03167.

ozan   irsoy and claire cardie. 2014. opinion min-
ing with deep recurrent neural networks. in pro-
ceedings of the conference on empirical methods in
natural language processing.

nal kalchbrenner, edward grefenstette, and phil blun-
som. 2014. a convolutional neural network for
modelling sentences. in proceedings of the associ-
ation for computational linguistics.

yoon kim. 2014. convolutional neural networks for
sentence classi   cation. in proceedings of the con-
ference on empirical methods in natural language
processing.

dan klein and christopher d. manning. 2003. ac-
curate unlexicalized parsing. in proceedings of the
association for computational linguistics.

terry koo, xavier carreras, and michael collins.
2008. simple semi-supervised dependency pars-
ing. in proceedings of the association for compu-
tational linguistics.

alex krizhevsky, ilya sutskever, and geoffrey e. hin-
ton. 2012. id163 classi   cation with deep con-
volutional neural networks. in advances in neural
information processing systems.

phong le and willem zuidema. 2014. the inside-
outside id56 model for depen-
dency parsing. in proceedings of the conference on
empirical methods in natural language process-
ing.

tao lei, yu xin, yuan zhang, regina barzilay, and
tommi jaakkola.
2014. low-rank tensors for
scoring dependency structures. in proceedings of
the association for computational linguistics.

omer levy and yoav goldberg. 2014. dependency-
based id27s. in proceedings of the as-
sociation for computational linguistics.

mitchell p. marcus, beatrice santorini, and mary ann
marcinkiewicz. 1993. building a large annotated
corpus of english: the id32. computa-
tional linguistics, 19(2).

tomas mikolov, kai chen, greg corrado, and jeffrey
dean. 2013. ef   cient estimation of word repre-
in proceedings of the
sentations in vector space.
international conference on learning representa-
tions.

slav petrov and dan klein. 2007.

improved infer-
in proceedings of
ence for unlexicalized parsing.
the north american chapter of the association for
computational linguistics.

slav petrov and dan klein. 2008. sparse multi-scale
grammars for discriminative latent variable pars-
ing. in proceedings of the conference on empirical
methods in natural language processing.

slav petrov. 2010. products of random latent vari-
able grammars. in proceedings of the north amer-
ican chapter of the association for computational
linguistics.

djam  e seddah, reut tsarfaty, sandra k  ubler, marie
candito, jinho d. choi, rich  ard farkas, jen-
nifer foster, iakes goenaga, koldo gojenola gal-
letebeitia, yoav goldberg, spence green, nizar
habash, marco kuhlmann, wolfgang maier, joakim
nivre, adam przepi  orkowski, ryan roth, wolf-
gang seeker, yannick versley, veronika vincze,
marcin woli  nski, and alina wr  oblewska.
2013.
overview of the spmrl 2013 shared task: a
cross-framework evaluation of parsing morpho-
in proceedings of
logically rich languages.
the fourth workshop on statistical parsing of
morphologically-rich languages.

djam  e seddah, sandra k  ubler, and reut tsarfaty.
2014. introducing the spmrl 2014 shared task on
in pro-
parsing morphologically-rich languages.
ceedings of the first joint workshop on statisti-
cal parsing of morphologically rich languages and
syntactic analysis of non-canonical languages.

hiroyuki shindo, yusuke miyao, akinori fujino, and
masaaki nagata. 2012. bayesian symbol-re   ned
tree substitution grammars for syntactic parsing.
in proceedings of the association for computational
linguistics.

richard socher, john bauer, christopher d. manning,
and andrew y. ng. 2013. parsing with composi-
tional vector grammars. in proceedings of the as-
sociation for computational linguistics.

vivek srikumar and christopher d manning. 2014.
learning distributed representations for structured
output prediction. in advances in neural informa-
tion processing systems.

yuta tsuboi.

2014. neural networks leverage
corpus-wide information for part-of-speech tag-
ging. in proceedings of the conference on empir-
ical methods in natural language processing.

joseph turian, lev ratinov, and yoshua bengio.
2010. word representations: a simple and general
method for semi-supervised learning. in proceed-
ings of the association for computational linguis-
tics.

oriol vinyals, lukasz kaiser, terry koo, slav
petrov, ilya sutskever, and geoffrey e. hinton.
2014. grammar as a foreign language. corr,
abs/1412.7449.

mengqiu wang and christopher d. manning. 2013.
effect of non-linear deep architecture in sequence
labeling. in proceedings of the international joint
conference on natural language processing.

matthew d. zeiler. 2012. adadelta: an adaptive

learning rate method. corr, abs/1212.5701.

muhua zhu, yue zhang, wenliang chen, min zhang,
and jingbo zhu. 2013. fast and accurate shift-
reduce constituent parsing. in proceedings of the
association for computational linguistics.

