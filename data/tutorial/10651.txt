4
1
0
2

 
c
e
d
0
1

 

 
 
]
e
n
.
s
c
[
 
 

2
v
1
0
4
5

.

0
1
4
1
:
v
i
x
r
a

id63s

alex graves
greg wayne
ivo danihelka

gravesa@google.com
gregwayne@google.com
danihelka@google.com

google deepmind, london, uk

abstract

we extend the capabilities of neural networks by coupling them to external memory re-
sources, which they can interact with by attentional processes. the combined system is
analogous to a turing machine or von neumann architecture but is differentiable end-to-
end, allowing it to be ef   ciently trained with id119. preliminary results demon-
strate that id63s can infer simple algorithms such as copying, sorting,
and associative recall from input and output examples.

1

introduction

computer programs make use of three fundamental mechanisms: elementary operations
(e.g., arithmetic operations), logical    ow control (branching), and external memory, which
can be written to and read from in the course of computation (von neumann, 1945). de-
spite its wide-ranging success in modelling complicated data, modern machine learning
has largely neglected the use of logical    ow control and external memory.

recurrent neural networks (id56s) stand out from other machine learning methods
for their ability to learn and carry out complicated transformations of data over extended
periods of time. moreover, it is known that id56s are turing-complete (siegelmann and
sontag, 1995), and therefore have the capacity to simulate arbitrary procedures, if properly
wired. yet what is possible in principle is not always what is simple in practice. we
therefore enrich the capabilities of standard recurrent networks to simplify the solution of
algorithmic tasks. this enrichment is primarily via a large, addressable memory, so, by
analogy to turing   s enrichment of    nite-state machines by an in   nite memory tape, we

1

dub our device a    id63    (ntm). unlike a turing machine, an ntm
is a differentiable computer that can be trained by id119, yielding a practical
mechanism for learning programs.

in human cognition, the process that shares the most similarity to algorithmic operation
is known as    working memory.    while the mechanisms of working memory remain some-
what obscure at the level of neurophysiology, the verbal de   nition is understood to mean
a capacity for short-term storage of information and its rule-based manipulation (badde-
ley et al., 2009). in computational terms, these rules are simple programs, and the stored
information constitutes the arguments of these programs. therefore, an ntm resembles
a working memory system, as it is designed to solve tasks that require the application of
approximate rules to    rapidly-created variables.    rapidly-created variables (hadley, 2009)
are data that are quickly bound to memory slots, in the same way that the number 3 and the
number 4 are put inside registers in a conventional computer and added to make 7 (minsky,
1967). an ntm bears another close resemblance to models of working memory since the
ntm architecture uses an attentional process to read from and write to memory selectively.
in contrast to most models of working memory, our architecture can learn to use its working
memory instead of deploying a    xed set of procedures over symbolic data.

the organisation of this report begins with a brief review of germane research on work-
ing memory in psychology, linguistics, and neuroscience, along with related research in
arti   cial intelligence and neural networks. we then describe our basic contribution, a mem-
ory architecture and attentional controller that we believe is well-suited to the performance
of tasks that require the induction and execution of simple programs. to test this architec-
ture, we have constructed a battery of problems, and we present their precise descriptions
along with our results. we conclude by summarising the strengths of the architecture.

2 foundational research
2.1 psychology and neuroscience
the concept of working memory has been most heavily developed in psychology to explain
the performance of tasks involving the short-term manipulation of information. the broad
picture is that a    central executive    focuses attention and performs operations on data in a
memory buffer (baddeley et al., 2009). psychologists have extensively studied the capacity
limitations of working memory, which is often quanti   ed by the number of    chunks    of
information that can be readily recalled (miller, 1956).1 these capacity limitations lead
toward an understanding of structural constraints in the human working memory system,
but in our own work we are happy to exceed them.

in neuroscience, the working memory process has been ascribed to the functioning of a
system composed of the prefrontal cortex and basal ganglia (goldman-rakic, 1995). typ-

1there remains vigorous debate about how best to characterise capacity limitations (barrouillet et al.,

2004).

2

ical experiments involve recording from a single neuron or group of neurons in prefrontal
cortex while a monkey is performing a task that involves observing a transient cue, waiting
through a    delay period,    then responding in a manner dependent on the cue. certain tasks
elicit persistent    ring from individual neurons during the delay period or more complicated
neural dynamics. a recent study quanti   ed delay period activity in prefrontal cortex for a
complex, context-dependent task based on measures of    dimensionality    of the population
code and showed that it predicted memory performance (rigotti et al., 2013).

modeling studies of working memory range from those that consider how biophysical
circuits could implement persistent neuronal    ring (wang, 1999) to those that try to solve
explicit tasks (hazy et al., 2006) (dayan, 2008) (eliasmith, 2013). of these, hazy et al.   s
model is the most relevant to our work, as it is itself analogous to the long short-term
memory architecture, which we have modi   ed ourselves. as in our architecture, hazy
et al.   s has mechanisms to gate information into memory slots, which they use to solve a
memory task constructed of nested rules. in contrast to our work, the authors include no
sophisticated notion of memory addressing, which limits the system to storage and recall
of relatively simple, atomic data. addressing, fundamental to our work, is usually left
out from computational models in neuroscience, though it deserves to be mentioned that
gallistel and king (gallistel and king, 2009) and marcus (marcus, 2003) have argued that
addressing must be implicated in the operation of the brain.

2.2 cognitive science and linguistics
historically, cognitive science and linguistics emerged as    elds at roughly the same time
as arti   cial intelligence, all deeply in   uenced by the advent of the computer (chomsky,
1956) (miller, 2003). their intentions were to explain human mental behaviour based on
information or symbol-processing metaphors. in the early 1980s, both    elds considered
recursive or procedural (rule-based) symbol-processing to be the highest mark of cogni-
tion. the parallel distributed processing (pdp) or connectionist revolution cast aside the
symbol-processing metaphor in favour of a so-called    sub-symbolic    description of thought
processes (rumelhart et al., 1986).

fodor and pylyshyn (fodor and pylyshyn, 1988) famously made two barbed claims
about the limitations of neural networks for cognitive modeling. they    rst objected that
connectionist theories were incapable of variable-binding, or the assignment of a particular
datum to a particular slot in a data structure. in language, variable-binding is ubiquitous;
for example, when one produces or interprets a sentence of the form,    mary spoke to john,   
one has assigned    mary    the role of subject,    john    the role of object, and    spoke to    the
role of the transitive verb. fodor and pylyshyn also argued that neural networks with    xed-
length input domains could not reproduce human capabilities in tasks that involve process-
ing variable-length structures. in response to this criticism, neural network researchers
including hinton (hinton, 1986), smolensky (smolensky, 1990), touretzky (touretzky,
1990), pollack (pollack, 1990), plate (plate, 2003), and kanerva (kanerva, 2009) inves-
tigated speci   c mechanisms that could support both variable-binding and variable-length

3

structure within a connectionist framework. our architecture draws on and potentiates this
work.

recursive processing of variable-length structures continues to be regarded as a hall-
mark of human cognition. in the last decade, a    re   ght in the linguistics community staked
several leaders of the    eld against one another. at issue was whether recursive processing
is the    uniquely human    evolutionary innovation that enables language and is specialized to
language, a view supported by fitch, hauser, and chomsky (fitch et al., 2005), or whether
multiple new adaptations are responsible for human language evolution and recursive pro-
cessing predates language (jackendoff and pinker, 2005). regardless of recursive process-
ing   s evolutionary origins, all agreed that it is essential to human cognitive    exibility.

2.3 recurrent neural networks
recurrent neural networks constitute a broad class of machines with dynamic state; that
is, they have state whose evolution depends both on the input to the system and on the
current state. in comparison to id48, which also contain dynamic state,
id56s have a distributed state and therefore have signi   cantly larger and richer memory
and computational capacity. dynamic state is crucial because it affords the possibility of
context-dependent computation; a signal entering at a given moment can alter the behaviour
of the network at a much later moment.

a crucial innovation to recurrent networks was the long short-term memory (lstm)
(hochreiter and schmidhuber, 1997). this very general architecture was developed for a
speci   c purpose, to address the    vanishing and exploding gradient    problem (hochreiter
et al., 2001a), which we might relabel the problem of    vanishing and exploding sensitivity.   
lstm ameliorates the problem by embedding perfect integrators (seung, 1998) for mem-
ory storage in the network. the simplest example of a perfect integrator is the equation
x(t + 1) = x(t) + i(t), where i(t) is an input to the system. the implicit identity matrix
ix(t) means that signals do not dynamically vanish or explode. if we attach a mechanism
to this integrator that allows an enclosing network to choose when the integrator listens to
inputs, namely, a programmable gate depending on context, we have an equation of the
form x(t + 1) = x(t) + g(context)i(t). we can now selectively store information for an
inde   nite length of time.

recurrent networks readily process variable-length structures without modi   cation. in
sequential problems, inputs to the network arrive at different times, allowing variable-
length or composite structures to be processed over multiple steps. because they natively
handle variable-length structures, they have recently been used in a variety of cognitive
problems, including id103 (graves et al., 2013; graves and jaitly, 2014), text
generation (sutskever et al., 2011), handwriting generation (graves, 2013) and machine
translation (sutskever et al., 2014). considering this property, we do not feel that it is ur-
gent or even necessarily valuable to build explicit parse trees to merge composite structures
greedily (pollack, 1990) (socher et al., 2012) (frasconi et al., 1998).

other important precursors to our work include differentiable models of attention (graves,

4

figure 1: id63 architecture. during each update cycle, the controller
network receives inputs from an external environment and emits outputs in response.
it also
reads to and writes from a memory matrix via a set of parallel read and write heads. the dashed
line indicates the division between the ntm circuit and the outside world.

2013) (bahdanau et al., 2014) and program search (hochreiter et al., 2001b) (das et al.,
1992), constructed with recurrent neural networks.

3 id63s

a id63 (ntm) architecture contains two basic components: a neural
network controller and a memory bank. figure 1 presents a high-level diagram of the ntm
architecture. like most neural networks, the controller interacts with the external world via
input and output vectors. unlike a standard network, it also interacts with a memory matrix
using selective read and write operations. by analogy to the turing machine we refer to the
network outputs that parametrise these operations as    heads.   

crucially, every component of the architecture is differentiable, making it straightfor-
ward to train with id119. we achieved this by de   ning    blurry    read and write
operations that interact to a greater or lesser degree with all the elements in memory (rather
than addressing a single element, as in a normal turing machine or digital computer). the
degree of blurriness is determined by an attentional    focus    mechanism that constrains each
read and write operation to interact with a small portion of the memory, while ignoring the
rest. because interaction with the memory is highly sparse, the ntm is biased towards
storing data without interference. the memory location brought into attentional focus is
determined by specialised outputs emitted by the heads. these outputs de   ne a normalised
weighting over the rows in the memory matrix (referred to as memory    locations   ). each
weighting, one per read or write head, de   nes the degree to which the head reads or writes

5

rt       (cid:88)

at each location. a head can thereby attend sharply to the memory at a single location or
weakly to the memory at many locations.

3.1 reading
let mt be the contents of the n    m memory matrix at time t, where n is the number
of memory locations, and m is the vector size at each location. let wt be a vector of
weightings over the n locations emitted by a read head at time t. since all weightings are
normalised, the n elements wt(i) of wt obey the following constraints:

wt(i) = 1,

0     wt(i)     1,    i.

(1)

(cid:88)

i

the length m read vector rt returned by the head is de   ned as a convex combination of
the row-vectors mt(i) in memory:

wt(i)mt(i),

(2)

which is clearly differentiable with respect to both the memory and the weighting.

i

3.2 writing
taking inspiration from the input and forget gates in lstm, we decompose each write into
two parts: an erase followed by an add.

given a weighting wt emitted by a write head at time t, along with an erase vector
et whose m elements all lie in the range (0, 1), the memory vectors mt   1(i) from the
previous time-step are modi   ed as follows:

  mt(i)        mt   1(i) [1     wt(i)et] ,

(3)

where 1 is a row-vector of all 1-s, and the multiplication against the memory location acts
point-wise. therefore, the elements of a memory location are reset to zero only if both the
weighting at the location and the erase element are one; if either the weighting or the erase
is zero, the memory is left unchanged. when multiple write heads are present, the erasures
can be performed in any order, as multiplication is commutative.

each write head also produces a length m add vector at, which is added to the memory

after the erase step has been performed:

mt(i)          mt(i) + wt(i) at.

(4)

once again, the order in which the adds are performed by multiple heads is irrelevant. the
combined erase and add operations of all the write heads produces the    nal content of the
memory at time t. since both erase and add are differentiable, the composite write oper-
ation is differentiable too. note that both the erase and add vectors have m independent
components, allowing    ne-grained control over which elements in each memory location
are modi   ed.

6

figure 2: flow diagram of the addressing mechanism. the key vector, kt, and key
strength,   t, are used to perform content-based addressing of the memory matrix, mt. the
resulting content-based weighting is interpolated with the weighting from the previous time step
based on the value of the interpolation gate, gt. the shift weighting, st, determines whether
and by how much the weighting is rotated. finally, depending on   t, the weighting is sharpened
and used for memory access.

3.3 addressing mechanisms
although we have now shown the equations of reading and writing, we have not described
how the weightings are produced. these weightings arise by combining two addressing
mechanisms with complementary facilities. the    rst mechanism,    content-based address-
ing,    focuses attention on locations based on the similarity between their current values
and values emitted by the controller. this is related to the content-addressing of hop   eld
networks (hop   eld, 1982). the advantage of content-based addressing is that retrieval is
simple, merely requiring the controller to produce an approximation to a part of the stored
data, which is then compared to memory to yield the exact stored value.

however, not all problems are well-suited to content-based addressing. in certain tasks
the content of a variable is arbitrary, but the variable still needs a recognisable name or ad-
dress. arithmetic problems fall into this category: the variable x and the variable y can take
on any two values, but the procedure f (x, y) = x    y should still be de   ned. a controller
for this task could take the values of the variables x and y, store them in different addresses,
then retrieve them and perform a multiplication algorithm. in this case, the variables are
addressed by location, not by content. we call this form of addressing    location-based ad-
dressing.    content-based addressing is strictly more general than location-based addressing
as the content of a memory location could include location information inside it. in our ex-
periments however, providing location-based addressing as a primitive operation proved
essential for some forms of generalisation, so we employ both mechanisms concurrently.

figure 2 presents a    ow diagram of the entire addressing system that shows the order

of operations for constructing a weighting vector when reading or writing.

7

3.3.1 focusing by content

k(cid:2)  ,  (cid:3). the content-based system produces a normalised weighting wc

for content-addressing, each head (whether employed for reading or writing)    rst produces
a length m key vector kt that is compared to each vector mt(i) by a similarity measure
t based on the sim-
ilarity and a positive key strength,   t, which can amplify or attenuate the precision of the
focus:

t (i)       
wc

j exp

exp

(cid:80)
k(cid:2)u, v(cid:3) =

(cid:18)
  tk(cid:2)kt, mt(i)(cid:3)(cid:19)
  tk(cid:2)kt, mt(j)(cid:3)(cid:19) .
(cid:18)

u    v

||u||    ||v|| .

(5)

(6)

in our current implementation, the similarity measure is cosine similarity:

3.3.2 focusing by location

the location-based addressing mechanism is designed to facilitate both simple iteration
across the locations of the memory and random-access jumps. it does so by implementing
a rotational shift of a weighting. for example, if the current weighting focuses entirely on
a single location, a rotation of 1 would shift the focus to the next location. a negative shift
would move the weighting in the opposite direction.

prior to rotation, each head emits a scalar interpolation gate gt in the range (0, 1). the
value of g is used to blend between the weighting wt   1 produced by the head at the previous
time-step and the weighting wc
t produced by the content system at the current time-step,
yielding the gated weighting wg
t :
t        gtwc
wg

t + (1     gt)wt   1.

(7)

if the gate is zero, then the content weighting is entirely ignored, and the weighting from the
previous time step is used. conversely, if the gate is one, the weighting from the previous
iteration is ignored, and the system applies content-based addressing.

after interpolation, each head emits a shift weighting st that de   nes a normalised distri-
bution over the allowed integer shifts. for example, if shifts between -1 and 1 are allowed,
st has three elements corresponding to the degree to which shifts of -1, 0 and 1 are per-
formed. the simplest way to de   ne the shift weightings is to use a softmax layer of the
appropriate size attached to the controller. we also experimented with another technique,
where the controller emits a single scalar that is interpreted as the lower bound of a width
one uniform distribution over shifts. for example, if the shift scalar is 6.7, then st(6) = 0.3,
st(7) = 0.7, and the rest of st is zero.

8

if we index the n memory locations from 0 to n     1, the rotation applied to wg

t by st

can be expressed as the following circular convolution:

  wt(i)        n   1(cid:88)

j=0

t (j) st(i     j)
wg

(8)

where all index arithmetic is computed modulo n. the convolution operation in equa-
tion (8) can cause leakage or dispersion of weightings over time if the shift weighting is
not sharp. for example, if shifts of -1, 0 and 1 are given weights of 0.1, 0.8 and 0.1, the
rotation will transform a weighting focused at a single point into one slightly blurred over
three points. to combat this, each head emits one further scalar   t     1 whose effect is to
sharpen the    nal weighting as follows:

(cid:80)

wt(i)          wt(i)  t
j   wt(j)  t

(9)

the combined addressing system of weighting interpolation and content and location-
based addressing can operate in three complementary modes. one, a weighting can be
chosen by the content system without any modi   cation by the location system. two, a
weighting produced by the content addressing system can be chosen and then shifted. this
allows the focus to jump to a location next to, but not on, an address accessed by content;
in computational terms this allows a head to    nd a contiguous block of data, then access a
particular element within that block. three, a weighting from the previous time step can
be rotated without any input from the content-based addressing system. this allows the
weighting to iterate through a sequence of addresses by advancing the same distance at
each time-step.

3.4 controller network
the ntm architecture architecture described above has several free parameters, including
the size of the memory, the number of read and write heads, and the range of allowed lo-
cation shifts. but perhaps the most signi   cant architectural choice is the type of neural
network used as the controller. in particular, one has to decide whether to use a recurrent
or feedforward network. a recurrent controller such as lstm has its own internal memory
that can complement the larger memory in the matrix. if one compares the controller to
the central processing unit in a digital computer (albeit with adaptive rather than prede   ned
instructions) and the memory matrix to ram, then the hidden activations of the recurrent
controller are akin to the registers in the processor. they allow the controller to mix infor-
mation across multiple time steps of operation. on the other hand a feedforward controller
can mimic a recurrent network by reading and writing at the same location in memory at
every step. furthermore, feedforward controllers often confer greater transparency to the
network   s operation because the pattern of reading from and writing to the memory matrix
is usually easier to interpret than the internal state of an id56. however, one limitation of

9

a feedforward controller is that the number of concurrent read and write heads imposes a
bottleneck on the type of computation the ntm can perform. with a single read head, it
can perform only a unary transform on a single memory vector at each time-step, with two
read heads it can perform binary vector transforms, and so on. recurrent controllers can
internally store read vectors from previous time-steps, so do not suffer from this limitation.

4 experiments

this section presents preliminary experiments on a set of simple algorithmic tasks such
as copying and sorting data sequences. the goal was not only to establish that ntm is
able to solve the problems, but also that it is able to do so by learning compact internal
programs. the hallmark of such solutions is that they generalise well beyond the range of
the training data. for example, we were curious to see if a network that had been trained
to copy sequences of length up to 20 could copy a sequence of length 100 with no further
training.

for all the experiments we compared three architectures: ntm with a feedforward
controller, ntm with an lstm controller, and a standard lstm network. because all
the tasks were episodic, we reset the dynamic state of the networks at the start of each
input sequence. for the id137, this meant setting the previous hidden state equal
to a learned bias vector. for ntm the previous state of the controller, the value of the
previous read vectors, and the contents of the memory were all reset to bias values. all
the tasks were supervised learning problems with binary targets; all networks had logistic
sigmoid output layers and were trained with the cross-id178 objective function. sequence
prediction errors are reported in bits-per-sequence. for more details about the experimental
parameters see section 4.6.

4.1 copy
the copy task tests whether ntm can store and recall a long sequence of arbitrary in-
formation. the network is presented with an input sequence of random binary vectors
followed by a delimiter    ag. storage and access of information over long time periods has
always been problematic for id56s and other dynamic architectures. we were particularly
interested to see if an ntm is able to bridge longer time delays than lstm.

the networks were trained to copy sequences of eight bit random vectors, where the
sequence lengths were randomised between 1 and 20. the target sequence was simply a
copy of the input sequence (without the delimiter    ag). note that no inputs were presented
to the network while it receives the targets, to ensure that it recalls the entire sequence with
no intermediate assistance.

as can be seen from figure 3, ntm (with either a feedforward or lstm controller)
learned much faster than lstm alone, and converged to a lower cost. the disparity be-
tween the ntm and lstm learning curves is dramatic enough to suggest a qualitative,

10

figure 3: copy learning curves.

rather than quantitative, difference in the way the two models solve the problem.

we also studied the ability of the networks to generalise to longer sequences than seen
during training (that they can generalise to novel vectors is clear from the training error).
figures 4 and 5 demonstrate that the behaviour of lstm and ntm in this regime is rad-
ically different. ntm continues to copy as the length increases2, while lstm rapidly
degrades beyond length 20.

the preceding analysis suggests that ntm, unlike lstm, has learned some form of
copy algorithm. to determine what this algorithm is, we examined the interaction between
the controller and the memory (figure 6). we believe that the sequence of operations per-
formed by the network can be summarised by the following pseudocode:

initialise: move head to start location
while input delimiter not seen do

receive input vector
write input to head location
increment head location by 1

end while
return head to start location
while true do

read output vector from head location
emit output
increment head location by 1

end while

this is essentially how a human programmer would perform the same task in a low-

2the limiting factor was the size of the memory (128 locations), after which the cyclical shifts wrapped

around and previous writes were overwritten.

11

 0 2 4 6 8 10 0 200 400 600 800 1000cost per sequence (bits)sequence number (thousands)lstmntm with lstm controllerntm with feedforward controllerfigure 4: ntm generalisation on the copy task. the four pairs of plots in the top row
depict network outputs and corresponding copy targets for test sequences of length 10, 20, 30,
and 50, respectively. the plots in the bottom row are for a length 120 sequence. the network
was only trained on sequences of up to length 20. the    rst four sequences are reproduced with
high con   dence and very few mistakes. the longest one has a few more local errors and one
global error: at the point indicated by the red arrow at the bottom, a single vector is duplicated,
pushing all subsequent vectors one step back. despite being subjectively close to a correct copy,
this leads to a high loss.

in terms of data structures, we could say that ntm has
level programming language.
learned how to create and iterate through arrays. note that the algorithm combines both
content-based addressing (to jump to start of the sequence) and location-based address-
ing (to move along the sequence). also note that the iteration would not generalise to
long sequences without the ability to use relative shifts from the previous read and write
weightings (equation 7), and that without the focus-sharpening mechanism (equation 9)
the weightings would probably lose precision over time.

4.2 repeat copy
the repeat copy task extends copy by requiring the network to output the copied sequence a
speci   ed number of times and then emit an end-of-sequence marker. the main motivation
was to see if the ntm could learn a simple nested function. ideally, we would like it to be
able to execute a    for loop    containing any subroutine it has already learned.

the network receives random-length sequences of random binary vectors, followed by
a scalar value indicating the desired number of copies, which appears on a separate input
channel. to emit the end marker at the correct time the network must be both able to
interpret the extra input and keep count of the number of copies it has performed so far.
as with the copy task, no inputs are provided to the network after the initial sequence and
repeat number. the networks were trained to reproduce sequences of size eight random
binary vectors, where both the sequence length and the number of repetitions were chosen
randomly from one to ten. the input representing the repeat number was normalised to
have mean zero and variance one.

12

figure 5: lstm generalisation on the copy task. the plots show inputs and outputs
for the same sequence lengths as figure 4. like ntm, lstm learns to reproduce sequences
of up to length 20 almost perfectly. however it clearly fails to generalise to longer sequences.
also note that the length of the accurate pre   x decreases as the sequence length increases,
suggesting that the network has trouble retaining information for long periods.

figure 6: ntm memory use during the copy task. the plots in the left column depict
the inputs to the network (top), the vectors added to memory (middle) and the corresponding
write weightings (bottom) during a single test sequence for the copy task. the plots on the right
show the outputs from the network (top), the vectors read from memory (middle) and the read
weightings (bottom). only a subset of memory locations are shown. notice the sharp focus of
all the weightings on a single location in memory (black is weight zero, white is weight one).
also note the translation of the focal point over time, re   ects the network   s use of iterative
shifts for location-based addressing, as described in section 3.3.2. lastly, observe that the read
locations exactly match the write locations, and the read vectors match the add vectors. this
suggests that the network writes each input vector in turn to a speci   c memory location during
the input phase, then reads from the same location sequence during the output phase.

13

figure 7: repeat copy learning curves.

figure 7 shows that ntm learns the task much faster than lstm, but both were able to
solve it perfectly.3 the difference between the two architectures only becomes clear when
they are asked to generalise beyond the training data. in this case we were interested in
generalisation along two dimensions: sequence length and number of repetitions. figure 8
illustrates the effect of doubling    rst one, then the other, for both lstm and ntm. whereas
lstm fails both tests, ntm succeeds with longer sequences and is able to perform more
than ten repetitions; however it is unable to keep count of of how many repeats it has
completed, and does not predict the end marker correctly. this is probably a consequence
of representing the number of repetitions numerically, which does not easily generalise
beyond a    xed range.

figure 9 suggests that ntm learns a simple extension of the copy algorithm in the

previous section, where the sequential read is repeated as many times as necessary.

4.3 associative recall
the previous tasks show that the ntm can apply algorithms to relatively simple, linear data
structures. the next order of complexity in organising data arises from    indirection      that
is, when one data item points to another. we test the ntm   s capability for learning an
instance of this more interesting class by constructing a list of items so that querying with
one of the items demands that the network return the subsequent item. more speci   cally,
we de   ne an item as a sequence of binary vectors that is bounded on the left and right
by delimiter symbols. after several items have been propagated to the network, we query
by showing a random item, and we ask the network to produce the next item.
in our
experiments, each item consisted of three six-bit binary vectors (giving a total of 18 bits

3it surprised us that lstm performed better here than on the copy problem. the likely reasons are that the
sequences were shorter (up to length 10 instead of up to 20), and the lstm network was larger and therefore
had more memory capacity.

14

 0 20 40 60 80 100 120 140 160 180 200 0 100 200 300 400 500cost per sequence (bits)sequence number (thousands)lstmntm with lstm controllerntm with feedforward controllerfigure 8: ntm and lstm generalisation for the repeat copy task. ntm generalises
almost perfectly to longer sequences than seen during training. when the number of repeats is
increased it is able to continue duplicating the input sequence fairly accurately; but it is unable
to predict when the sequence will end, emitting the end marker after the end of every repetition
beyond the eleventh. lstm struggles with both increased length and number, rapidly diverging
from the input sequence in both cases.

per item). during training, we used a minimum of 2 items and a maximum of 6 items in a
single episode.

figure 10 shows that ntm learns this task signi   cantly faster than lstm, terminating
at near zero cost within approximately 30, 000 episodes, whereas lstm does not reach
zero cost after a million episodes. additionally, ntm with a feedforward controller learns
faster than ntm with an lstm controller. these two results suggest that ntm   s external
memory is a more effective way of maintaining the data structure than lstm   s internal
state. ntm also generalises much better to longer sequences than lstm, as can be seen
in figure 11. ntm with a feedforward controller is nearly perfect for sequences of up to
12 items (twice the maximum length used in training), and still has an average cost below
1 bit per sequence for sequences of 15 items.

in figure 12, we show the operation of the ntm memory, controlled by an lstm
with one head, on a single test episode. in    inputs,    we see that the input denotes item
delimiters as single bits in row 7. after the sequence of items has been propagated, a

15

figure 9: ntm memory use during the repeat copy task. as with the copy task the
network    rst writes the input vectors to memory using iterative shifts.
it then reads through
the sequence to replicate the input as many times as necessary (six in this case). the white dot
at the bottom of the read weightings seems to correspond to an intermediate location used to
redirect the head to the start of the sequence (the ntm equivalent of a goto statement).

figure 10: associative recall learning curves for ntm and lstm.

16

 0 2 4 6 8 10 12 14 16 18 20 0 200 400 600 800 1000cost per sequence (bits)sequence number (thousands)lstmntm with lstm controllerntm with feedforward controllerfigure 11: generalisation performance on associative recall for longer item sequences.
the ntm with either a feedforward or lstm controller generalises to much longer sequences
of items than the lstm alone. in particular, the ntm with a feedforward controller is nearly
perfect for item sequences of twice the length of sequences in its training set.

delimiter in row 8 prepares the network to receive a query item. in this case, the query
item corresponds to the second item in the sequence (contained in the green box).
in
   outputs,    we see that the network crisply outputs item 3 in the sequence (from the red
box). in    read weightings,    on the last three time steps, we see that the controller reads
from contiguous locations that each store the time slices of item 3. this is curious because it
appears that the network has jumped directly to the correct location storing item 3. however
we can explain this behaviour by looking at    write weightings.    here we see that the
memory is written to even when the input presents a delimiter symbol between items.
one can con   rm in    adds    that data are indeed written to memory when the delimiters
are presented (e.g., the data within the black box); furthermore, each time a delimiter is
presented, the vector added to memory is different. further analysis of the memory reveals
that the network accesses the location it reads after the query by using a content-based
lookup that produces a weighting that is shifted by one. additionally, the key used for
content-lookup corresponds to the vector that was added in the black box. this implies the
following memory-access algorithm: when each item delimiter is presented, the controller
writes a compressed representation of the previous three time slices of the item. after the
query arrives, the controller recomputes the same compressed representation of the query
item, uses a content-based lookup to    nd the location where it wrote the    rst representation,
and then shifts by one to produce the subsequent item in the sequence (thereby combining
content-based lookup with location-based offsetting).

4.4 dynamic id165s
the goal of the dynamic id165s task was to test whether ntm could rapidly adapt to
new predictive distributions. in particular we were interested to see if it were able to use its

17

051015202530354068101214161820cost per sequence (bits)number of items per sequencelstmntm with lstm controllerntm with feedforward controllerfigure 12: ntm memory use during the associative recall task.
in    inputs,    a se-
quence of items, each composed of three consecutive binary random vectors is propagated to the
controller. the distinction between items is designated by delimiter symbols (row 7 in    inputs   ).
after several items have been presented, a delimiter that designates a query is presented (row 8
in    inputs   ). a single query item is presented (green box), and the network target corresponds
to the subsequent item in the sequence (red box). in    outputs,    we see that the network cor-
rectly produces the target item. the red boxes in the read and write weightings highlight the
three locations where the target item was written and then read. the solution the network    nds
is to form a compressed representation (black box in    adds   ) of each item that it can store in
a single location. for further analysis, see the main text.

memory as a re-writable table that it could use to keep count of transition statistics, thereby
emulating a conventional id165 model.

we considered the set of all possible 6-gram distributions over binary sequences. each
6-gram distribution can be expressed as a table of 25 = 32 numbers, specifying the prob-
ability that the next bit will be one, given all possible length    ve binary histories. for
each training example, we    rst generated random 6-gram probabilities by independently
drawing all 32 probabilities from the beta( 1

2, 1

2) distribution.

we then generated a particular training sequence by drawing 200 successive bits using
the current lookup table.4 the network observes the sequence one bit at a time and is then
asked to predict the next bit. the optimal estimator for the problem can be determined by

4the    rst 5 bits, for which insuf   cient context exists to sample from the table, are drawn i.i.d. from a

bernoulli distribution with p = 0.5.

18

figure 13: dynamic id165 learning curves.

bayesian analysis (murphy, 2012):

p (b = 1|n1, n0, c) =

n1 + 1
2

n1 + n0 + 1

(10)

where c is the    ve bit previous context, b is the value of the next bit and n0 and n1 are
respectively the number of zeros and ones observed after c so far in the sequence. we can
therefore compare ntm to the optimal predictor as well as lstm. to assess performance
we used a validation set of 1000 length 200 sequences sampled from the same distribu-
tion as the training data. as shown in figure 13, ntm achieves a small, but signi   cant
performance advantage over lstm, but never quite reaches the optimum cost.

the evolution of the two architecture   s predictions as they observe new inputs is shown
in figure 14, along with the optimal predictions. close analysis of ntm   s memory usage
(figure 15) suggests that the controller uses the memory to count how many ones and zeros
it has observed in different contexts, allowing it to implement an algorithm similar to the
optimal estimator.

4.5 priority sort
this task tests whether the ntm can sort data   an important elementary algorithm. a
sequence of random binary vectors is input to the network along with a scalar priority
rating for each vector. the priority is drawn uniformly from the range [-1, 1]. the target
sequence contains the binary vectors sorted according to their priorities, as depicted in
figure 16.

each input sequence contained 20 binary vectors with corresponding priorities, and
each target sequence was the 16 highest-priority vectors in the input.5 inspection of ntm   s

5we limited the sort to size 16 because we were interested to see if ntm would solve the task using a

binary heap sort of depth 4.

19

 130 135 140 145 150 155 160 0 200 400 600 800 1000cost per sequence (bits)sequence number (thousands)lstmntm with lstm controllerntm with feedforward controlleroptimal estimatorfigure 14: dynamic id165 id136. the top row shows a test sequence from the id165
task, and the rows below show the corresponding predictive distributions emitted by the optimal
estimator, ntm, and lstm. in most places the ntm predictions are almost indistinguishable
from the optimal ones. however at the points indicated by the two arrows it makes clear
mistakes, one of which is explained in figure 15. lstm follows the optimal predictions closely
in some places but appears to diverge further as the sequence progresses; we speculate that this
is due to lstm    forgetting    the observations at the start of the sequence.

figure 15: ntm memory use during the dynamic id165 task. the red and green
arrows indicate point where the same context is repeatedly observed during the test sequence
(   00010    for the green arrows,    01111    for the red arrows). at each such point the same
location is accessed by the read head, and then, on the next time-step, accessed by the write
head. we postulate that the network uses the writes to keep count of the fraction of ones and
zeros following each context in the sequence so far. this is supported by the add vectors, which
are clearly anti-correlated at places where the input is one or zero, suggesting a distributed
   counter.    note that the write weightings grow fainter as the same context is repeatedly seen;
this may be because the memory records a ratio of ones to zeros, rather than absolute counts.
the red box in the prediction sequence corresponds to the mistake at the    rst red arrow in
figure 14; the controller appears to have accessed the wrong memory location, as the previous
context was    01101    and not    01111.   

20

figure 16: example input and target sequence for the priority sort task. the input
sequence contains random binary vectors and random scalar priorities. the target sequence is a
subset of the input vectors sorted by the priorities.

figure 17: ntm memory use during the priority sort task. left: write locations
returned by    tting a linear function of the priorities to the observed write locations. middle:
observed write locations. right: read locations.

memory use led us to hypothesise that it uses the priorities to determine the relative location
of each write. to test this hypothesis we    tted a linear function of the priority to the
observed write locations. figure 17 shows that the locations returned by the linear function
closely match the observed write locations. it also shows that the network reads from the
memory locations in increasing order, thereby traversing the sorted sequence.

the learning curves in figure 18 demonstrate that ntm with both feedforward and
lstm controllers substantially outperform lstm on this task. note that eight parallel
read and write heads were needed for best performance with a feedforward controller on
this task; this may re   ect the dif   culty of sorting vectors using only unary vector operations
(see section 3.4).

4.6 experimental details
for all experiments, the rmsprop algorithm was used for training in the form described
in (graves, 2013) with momentum of 0.9. tables 1 to 3 give details about the network
con   gurations and learning rates used in the experiments. all id137 had three
stacked hidden layers. note that the number of lstm parameters grows quadratically with

21

write weightingsread weightingshypothesised locationstimetimetimelocatiobnfigure 18: priority sort learning curves.

task

#heads controller size memory size learning rate

#parameters

copy
repeat copy
associative
id165s
priority sort

1
1
4
1
8

100
100
256
100
512

128    20
128    20
128    20
128    20
128    20

10   4
10   4
10   4
3    10   5
3    10   5

17, 162
16, 712
146, 845
14, 656
508, 305

table 1: ntm with feedforward controller experimental settings

the number of hidden units (due to the recurrent connections in the hidden layers). this
contrasts with ntm, where the number of parameters does not increase with the number of
memory locations. during the training backward pass, all gradient components are clipped
elementwise to the range (-10, 10).

5 conclusion

we have introduced the id63, a neural network architecture that takes
inspiration from both models of biological working memory and the design of digital com-
puters. like conventional neural networks, the architecture is differentiable end-to-end and
can be trained with id119. our experiments demonstrate that it is capable of
learning simple algorithms from example data and of using these algorithms to generalise
well outside its training regime.

22

 0 20 40 60 80 100 120 140 0 200 400 600 800 1000cost per sequence (bits)sequence number (thousands)lstmntm with lstm controllerntm with feedforward controllertask

#heads controller size memory size learning rate

#parameters

copy
repeat copy
associative
id165s
priority sort

1
1
1
1
5

100
100
100
100
2    100

128    20
128    20
128    20
128    20
128    20

10   4
10   4
10   4
3    10   5
3    10   5

67, 561
66, 111
70, 330
61, 749
269, 038

table 2: ntm with lstm controller experimental settings

task

network size learning rate

#parameters

copy
repeat copy
associative
id165s
priority sort

3    256
3    512
3    256
3    128
3    128

3    10   5
3    10   5
10   4
10   4
3    10   5

1, 352, 969
5, 312, 007
1, 344, 518
331, 905
384, 424

table 3: lstm network experimental settings

6 acknowledgments

many have offered thoughtful insights, but we would especially like to thank daan wier-
stra, peter dayan, ilya sutskever, charles blundell, joel veness, koray kavukcuoglu,
dharshan kumaran, georg ostrovski, chris summer   eld, jeff dean, geoffrey hinton, and
demis hassabis.

23

references

baddeley, a., eysenck, m., and anderson, m. (2009). memory. psychology press.

bahdanau, d., cho, k., and bengio, y. (2014). id4 by jointly

learning to align and translate. abs/1409.0473.

barrouillet, p., bernardin, s., and camos, v. (2004). time constraints and resource shar-
ing in adults    working memory spans. journal of experimental psychology: general,
133(1):83.

chomsky, n. (1956). three models for the description of language. id205,

ieee transactions on, 2(3):113   124.

das, s., giles, c. l., and sun, g.-z. (1992). learning context-free grammars: capabil-
ities and limitations of a recurrent neural network with an external stack memory. in
proceedings of the fourteenth annual conference of cognitive science society. indiana
university.

dayan, p. (2008). simple substrates for complex cognition. frontiers in neuroscience,

2(2):255.

eliasmith, c. (2013). how to build a brain: a neural architecture for biological cognition.

oxford university press.

fitch, w., hauser, m. d., and chomsky, n. (2005). the evolution of the language faculty:

clari   cations and implications. cognition, 97(2):179   210.

fodor, j. a. and pylyshyn, z. w. (1988). connectionism and cognitive architecture: a

critical analysis. cognition, 28(1):3   71.

frasconi, p., gori, m., and sperduti, a. (1998). a general framework for adaptive process-

ing of data structures. neural networks, ieee transactions on, 9(5):768   786.

gallistel, c. r. and king, a. p. (2009). memory and the computational brain: why cogni-

tive science will transform neuroscience, volume 3. john wiley & sons.

goldman-rakic, p. s. (1995). cellular basis of working memory. neuron, 14(3):477   485.

graves, a. (2013). generating sequences with recurrent neural networks. arxiv preprint

arxiv:1308.0850.

graves, a. and jaitly, n. (2014). towards end-to-end id103 with recurrent
neural networks. in proceedings of the 31st international conference on machine learn-
ing (icml-14), pages 1764   1772.

24

graves, a., mohamed, a., and hinton, g. (2013). id103 with deep recurrent
in acoustics, speech and signal processing (icassp), 2013 ieee

neural networks.
international conference on, pages 6645   6649. ieee.

hadley, r. f. (2009). the problem of rapid variable creation. neural computation,

21(2):510   532.

hazy, t. e., frank, m. j., and o   reilly, r. c. (2006). banishing the homunculus: making

working memory work. neuroscience, 139(1):105   118.

hinton, g. e. (1986). learning distributed representations of concepts. in proceedings
of the eighth annual conference of the cognitive science society, volume 1, page 12.
amherst, ma.

hochreiter, s., bengio, y., frasconi, p., and schmidhuber, j. (2001a). gradient    ow in

recurrent nets: the dif   culty of learning long-term dependencies.

hochreiter, s. and schmidhuber, j. (1997). long short-term memory. neural computation,

9(8):1735   1780.

hochreiter, s., younger, a. s., and conwell, p. r. (2001b). learning to learn using gradient

descent. in arti   cial neural networks?icann 2001, pages 87   94. springer.

hop   eld, j. j. (1982). neural networks and physical systems with emergent collective
computational abilities. proceedings of the national academy of sciences, 79(8):2554   
2558.

jackendoff, r. and pinker, s. (2005). the nature of the language faculty and its implications
for evolution of language (reply to    tch, hauser, and chomsky). cognition, 97(2):211   
225.

kanerva, p. (2009). hyperdimensional computing: an introduction to computing in dis-
tributed representation with high-dimensional random vectors. cognitive computation,
1(2):139   159.

marcus, g. f. (2003). the algebraic mind: integrating connectionism and cognitive sci-

ence. mit press.

miller, g. a. (1956). the magical number seven, plus or minus two: some limits on our

capacity for processing information. psychological review, 63(2):81.

miller, g. a. (2003). the cognitive revolution: a historical perspective. trends in cognitive

sciences, 7(3):141   144.

minsky, m. l. (1967). computation:    nite and in   nite machines. prentice-hall, inc.

murphy, k. p. (2012). machine learning: a probabilistic perspective. mit press.

25

plate, t. a. (2003). holographic reduced representation: distributed representation for

cognitive structures. csli.

pollack, j. b. (1990). recursive distributed representations. arti   cial intelligence,

46(1):77   105.

rigotti, m., barak, o., warden, m. r., wang, x.-j., daw, n. d., miller, e. k., and fusi,
s. (2013). the importance of mixed selectivity in complex cognitive tasks. nature,
497(7451):585   590.

rumelhart, d. e., mcclelland, j. l., group, p. r., et al. (1986). parallel distributed pro-

cessing, volume 1. mit press.

seung, h. s. (1998). continuous attractors and oculomotor control. neural networks,

11(7):1253   1258.

siegelmann, h. t. and sontag, e. d. (1995). on the computational power of neural nets.

journal of computer and system sciences, 50(1):132   150.

smolensky, p. (1990). tensor product variable binding and the representation of symbolic

structures in connectionist systems. arti   cial intelligence, 46(1):159   216.

socher, r., huval, b., manning, c. d., and ng, a. y. (2012). semantic compositionality
through recursive matrix-vector spaces. in proceedings of the 2012 joint conference on
empirical methods in natural language processing and computational natural lan-
guage learning, pages 1201   1211. association for computational linguistics.

sutskever, i., martens, j., and hinton, g. e. (2011). generating text with recurrent neural
networks. in proceedings of the 28th international conference on machine learning
(icml-11), pages 1017   1024.

sutskever, i., vinyals, o., and le, q. v. (2014). sequence to sequence learning with neural

networks. arxiv preprint arxiv:1409.3215.

touretzky, d. s. (1990). boltzcons: dynamic symbol structures in a connectionist network.

arti   cial intelligence, 46(1):5   46.

von neumann, j. (1945). first draft of a report on the edvac.

wang, x.-j. (1999). synaptic basis of cortical persistent activity: the importance of nmda

receptors to working memory. the journal of neuroscience, 19(21):9587   9603.

26

