data recombination for neural id29

robin jia

computer science department

stanford university

percy liang

computer science department

stanford university

robinjia@stanford.edu

pliang@cs.stanford.edu

6
1
0
2

 

n
u
j
 

1
1

 
 
]
l
c
.
s
c
[
 
 

1
v
2
2
6
3
0

.

6
0
6
1
:
v
i
x
r
a

abstract

modeling crisp logical regularities is cru-
cial in id29, making it dif   cult
for neural models with no task-speci   c
prior knowledge to achieve good results.
in this paper, we introduce data recom-
bination, a novel framework for inject-
ing such prior knowledge into a model.
from the training data, we induce a high-
precision synchronous context-free gram-
mar, which captures important conditional
independence properties commonly found
in id29. we then train a
sequence-to-sequence recurrent network
(id56) model with a novel attention-based
copying mechanism on datapoints sam-
pled from this grammar, thereby teaching
the model about these structural proper-
ties. data recombination improves the ac-
curacy of our id56 model on three se-
mantic parsing datasets, leading to new
state-of-the-art performance on the stan-
dard geoquery dataset for models with
comparable supervision.

introduction

1
id29   the precise translation of nat-
ural language utterances into logical forms   has
many applications,
including question answer-
ing (zelle and mooney, 1996; zettlemoyer and
collins, 2005; zettlemoyer and collins, 2007;
liang et al., 2011; berant et al., 2013), instruc-
tion following (artzi and zettlemoyer, 2013b),
and regular expression generation (kushman and
barzilay, 2013). modern semantic parsers (artzi
and zettlemoyer, 2013a; berant et al., 2013)
are complex pieces of software, requiring hand-
crafted features, lexicons, and grammars.

meanwhile, recurrent neural networks (id56s)

figure 1: an overview of our system. given a
dataset, we induce a high-precision synchronous
context-free grammar. we then sample from this
grammar to generate new    recombinant    exam-
ples, which we use to train a sequence-to-sequence
id56.

have made swift inroads into many structured pre-
diction tasks in nlp, including machine trans-
lation (sutskever et al., 2014; bahdanau et al.,
2014) and syntactic parsing (vinyals et al., 2015b;
dyer et al., 2015). because id56s make very few
domain-speci   c assumptions, they have the poten-
tial to succeed at a wide variety of tasks with min-
imal feature engineering. however, this    exibil-
ity also puts id56s at a disadvantage compared
to standard semantic parsers, which can generalize
naturally by leveraging their built-in awareness of
logical compositionality.

in this paper, we introduce data recombina-
tion, a generic framework for declaratively inject-

what are the major cities in utah ?what states border maine ?original examplestrain modelsequence-to-sequence id56sample new examplessynchronous id18induce grammarwhat are the major cities in [states border [maine]] ? what are the major cities in [states border [utah]]  ?what states border [states border [maine]] ?what states border [states border [utah]] ?recombinant examplesgeo
x:    what is the population of iowa ?   
y: _answer ( nv , (

_population ( nv , v1 ) , _const (

v0 , _stateid ( iowa ) ) ) )

atis
x:    can you list all    ights from chicago to milwaukee   
y: ( _lambda $0 e ( _and

( _flight $0 )
( _from $0 chicago :
( _to $0 milwaukee :

_ci )
_ci ) ) )

overnight
x:    when is the weekly standup   
y: ( call listvalue ( call

getproperty meeting.weekly_standup
( string start_time ) ) )

figure 2: one example from each of our domains.
we tokenize logical forms as shown, thereby cast-
ing id29 as a sequence-to-sequence
task.

ing prior knowledge into a domain-general struc-
tured prediction model.
in data recombination,
prior knowledge about a task is used to build a
high-precision generative model that expands the
empirical distribution by allowing fragments of
different examples to be combined in particular
ways. samples from this generative model are
then used to train a domain-general model. in the
case of id29, we construct a genera-
tive model by inducing a synchronous context-free
grammar (sid18), creating new examples such
as those shown in figure 1; our domain-general
model is a sequence-to-sequence id56 with a
novel attention-based copying mechanism. data
recombination boosts the accuracy of our id56
model on three id29 datasets. on the
geo dataset, data recombination improves test ac-
curacy by 4.3 percentage points over our baseline
id56, leading to new state-of-the-art results for
models that do not use a seed lexicon for predi-
cates.

2 problem statement

we cast id29 as a sequence-to-
sequence task. the input utterance x is a sequence
of words x1, . . . , xm     v(in), the input vocabulary;
similarly, the output logical form y is a sequence
of tokens y1, . . . , yn     v(out), the output vocab-
ulary. a linear sequence of tokens might appear
to lose the hierarchical structure of a logical form,
but there is precedent for this choice: vinyals et al.

(2015b) showed that an id56 can reliably predict
tree-structured outputs in a linear fashion.

we evaluate our system on three existing se-
mantic parsing datasets. figure 2 shows sample
input-output pairs from each of these datasets.

    geoquery (geo) contains natural language
questions about us geography paired with
corresponding prolog database queries. we
use the standard split of 600 training exam-
ples and 280 test examples introduced by
zettlemoyer and collins (2005). we prepro-
cess the logical forms to de brujin index no-
tation to standardize variable naming.

    atis (atis) contains natural

language
queries for a    ights database paired with
corresponding database queries written in
id198. we train on 4473 examples
and evaluate on the 448 test examples used
by zettlemoyer and collins (2007).

    overnight (overnight) contains logical
forms paired with natural
language para-
phrases across eight varied subdomains.
wang et al. (2015) constructed the dataset by
generating all possible logical forms up to
some depth threshold, then getting multiple
natural language paraphrases for each logi-
cal form from workers on amazon mechan-
ical turk. we evaluate on the same train/test
splits as wang et al. (2015).

in this paper, we only explore learning from log-
ical forms.
in the last few years, there has an
emergence of semantic parsers learned from de-
notations (clarke et al., 2010; liang et al., 2011;
berant et al., 2013; artzi and zettlemoyer, 2013b).
while our system cannot directly learn from deno-
tations, it could be used to rerank candidate deriva-
tions generated by one of these other systems.
3 sequence-to-sequence id56 model
our sequence-to-sequence id56 model is based
on existing attention-based neural machine trans-
lation models (bahdanau et al., 2014; luong et al.,
2015a), but also includes a novel attention-based
copying mechanism. similar copying mechanisms
have been explored in parallel by gu et al. (2016)
and gulcehre et al. (2016).

3.1 basic model
encoder. the encoder converts the input se-
quence x1, . . . , xm into a sequence of context-

sensitive embeddings b1, . . . , bm using a bidirec-
tional id56 (bahdanau et al., 2014). first, a word
embedding function   (in) maps each word xi to a
   xed-dimensional vector. these vectors are fed as
input to two id56s: a forward id56 and a back-
ward id56. the forward id56 starts with an initial
hidden state hf
0, and generates a sequence of hid-
den states hf
m by repeatedly applying the
recurrence

1, . . . , hf

hf
i = lstm(  (in)(xi), hf

i   1).

(1)

i and hb

the recurrence takes the form of an lstm
(hochreiter and schmidhuber, 1997). the back-
ward id56 similarly generates hidden states
hb
m, . . . , hb
1 by processing the input sequence in
reverse order. finally, for each input position i,
we de   ne the context-sensitive embedding bi to be
the concatenation of hf
decoder. the decoder
is an attention-based
model (bahdanau et al., 2014; luong et al., 2015a)
that generates the output sequence y1, . . . , yn one
token at a time. at each time step j, it writes
yj based on the current hidden state sj, then up-
dates the hidden state to sj+1 based on sj and yj.
formally, the decoder is de   ned by the following
equations:

i

s1 = tanh(w (s)[hf
eji = s(cid:62)

j w (a)bi.

m, hb

1 ]).

(cid:80)m
m(cid:88)

  ji =

cj =

exp(eji)
i(cid:48)=1 exp(eji(cid:48))

.

  jibi.

(2)
(3)

(4)

(5)

i=1

p (yj = w | x, y1:j   1)     exp(uw[sj, cj]).
sj+1 = lstm([  (out)(yj), cj], sj).

(6)
(7)
when not speci   ed, i ranges over {1, . . . , m} and
j ranges over {1, . . . , n}. intuitively, the   ji   s de-
   ne a id203 distribution over the input words,
describing what words in the input the decoder is
focusing on at time j. they are computed from
the unnormalized attention scores eji. the matri-
ces w (s), w (a), and u, as well as the embedding
function   (out), are parameters of the model.

3.2 attention-based copying
in the basic model of the previous section, the next
output word yj is chosen via a simple softmax over
all words in the output vocabulary. however, this

model has dif   culty generalizing to the long tail of
entity names commonly found in id29
datasets. conveniently, entity names in the input
often correspond directly to tokens in the output
(e.g.,    iowa    becomes iowa in figure 2).1

to capture this intuition, we introduce a new
attention-based copying mechanism. at each time
step j, the decoder generates one of two types of
actions. as before, it can write any word in the
output vocabulary. in addition, it can copy any in-
put word xi directly to the output, where the prob-
ability with which we copy xi is determined by
the attention score on xi. formally, we de   ne a
latent action aj that is either write[w] for some
w     v(out) or copy[i] for some i     {1, . . . , m}.
we then have
p (aj = write[w] | x, y1:j   1)     exp(uw[sj, cj]),
(8)
(9)

p (aj = copy[i] | x, y1:j   1)     exp(eji).

the decoder chooses aj with a softmax over all
these possible actions; yj is then a deterministic
function of aj and x. during training, we maxi-
mize the log-likelihood of y, marginalizing out a.
attention-based copying can be seen as a com-
bination of a standard softmax output layer of an
attention-based model (bahdanau et al., 2014) and
a pointer network (vinyals et al., 2015a); in a
pointer network, the only way to generate output
is to copy a symbol from the input.

4 data recombination
4.1 motivation
the main contribution of this paper is a novel data
recombination framework that injects important
prior knowledge into our oblivious sequence-to-
sequence id56. in this framework, we induce a
high-precision generative model from the training
data, then sample from it to generate new training
examples. the process of inducing this generative
model can leverage any available prior knowledge,
which is transmitted through the generated exam-
ples to the id56 model. a key advantage of our
two-stage approach is that it allows us to declare
desired properties of the task which might be hard
to capture in the model architecture.

1 on geo and atis, we make a point not to rely on or-
thography for non-entities such as    state    to _state, since
this leverages information not available to previous models
(zettlemoyer and collins, 2005) and is much less language-
independent.

examples
(   what states border texas ?   ,
answer(nv, (state(v0), next_to(v0, nv), const(v0, stateid(texas)))))
(   what is the highest mountain in ohio ?   ,
answer(nv, highest(v0, (mountain(v0), loc(v0, nv), const(v0, stateid(ohio))))))
rules created by absentities
root     (cid:104)    what states border stateid ?   ,
stateid     (cid:104)    texas   , texas (cid:105)
root     (cid:104)    what is the highest mountain in stateid ?   ,

answer(nv, (state(v0), next_to(v0, nv), const(v0, stateid(stateid ))))(cid:105)

answer(nv, highest(v0, (mountain(v0), loc(v0, nv),
const(v0, stateid(stateid )))))(cid:105)

stateid     (cid:104)   ohio   , ohio(cid:105)
rules created by abswholephrases
root     (cid:104)    what states border state ?   , answer(nv, (state(v0), next_to(v0, nv), state ))(cid:105)
state     (cid:104)    states border texas   , state(v0), next_to(v0, nv), const(v0, stateid(texas))(cid:105)
root     (cid:104)    what is the highest mountain in state ?   ,

answer(nv, highest(v0, (mountain(v0), loc(v0, nv), state )))(cid:105)

rules created by concat-2
root     (cid:104)sent1 </s> sent2, sent1 </s> sent2(cid:105)
sent     (cid:104)    what states border texas ?   ,
sent     (cid:104)    what is the highest mountain in ohio ?   ,
answer(nv, highest(v0, (mountain(v0), loc(v0, nv), const(v0, stateid(ohio))))) (cid:105)

answer(nv, (state(v0), next_to(v0, nv), const(v0, stateid(texas)))) (cid:105)

figure 3: various grammar induction strategies illustrated on geo. each strategy converts the rules of
an input grammar into rules of an output grammar. this    gure shows the base case where the input
grammar has rules root     (cid:104)x, y(cid:105) for each (x, y) pair in the training dataset.

our approach generalizes data augmentation,
which is commonly employed to inject prior
knowledge into a model.
data augmenta-
tion techniques focus on modeling invariances   
transformations like translating an image or
adding noise that alter the inputs x, but do not
change the output y.
these techniques have
proven effective in areas like id161
(krizhevsky et al., 2012) and id103
(jaitly and hinton, 2013).

in id29, however, we would like to
capture more than just invariance properties. con-
sider an example with the utterance    what states
border texas ?   . given this example, it should be
easy to generalize to questions where    texas    is
replaced by the name of any other state: simply
replace the mention of texas in the logical form
with the name of the new state. underlying this
phenomenon is a strong conditional independence
principle: the meaning of the rest of the sentence
is independent of the name of the state in ques-
tion. standard data augmentation is not suf   cient
to model such phenomena: instead of holding y
   xed, we would like to apply simultaneous trans-
formations to x and y such that the new x still
maps to the new y. data recombination addresses

this need.

4.2 general setting
in the general setting of data recombination, we
start with a training set d of (x, y) pairs, which
de   nes the empirical distribution   p(x, y). we then
   t a generative model   p(x, y) to   p which gener-
alizes beyond the support of   p, for example by
splicing together fragments of different examples.
we refer to examples in the support of   p as re-
combinant examples. finally, to train our actual
model p  (y | x), we maximize the expected value
of log p  (y | x), where (x, y) is drawn from   p.

4.3 sid18s for id29
for id29, we induce a synchronous
context-free grammar (sid18) to serve as the
backbone of our generative model   p. an sid18
consists of a set of production rules x     (cid:104)  ,   (cid:105),
where x is a category (non-terminal), and    and   
are sequences of terminal and non-terminal sym-
bols. any non-terminal symbols in    must be
aligned to the same non-terminal symbol in   , and
vice versa. therefore, an sid18 de   nes a set of
joint derivations of aligned pairs of strings. in our
case, we use an sid18 to represent joint deriva-

tions of utterances x and logical forms y (which
for us is just a sequence of tokens). after we
induce an sid18 g from d, the corresponding
generative model   p(x, y) is the distribution over
pairs (x, y) de   ned by sampling from g, where
we choose production rules to apply uniformly at
random.

it is instructive to compare our sid18-based
data recombination with wasp (wong and
mooney, 2006; wong and mooney, 2007), which
uses an sid18 as the actual id29
model. the grammar induced by wasp must have
good coverage in order to generalize to new in-
puts at test time. wasp also requires the imple-
mentation of an ef   cient algorithm for computing
the id155 p(y | x). in contrast,
our sid18 is only used to convey prior knowl-
edge about conditional independence structure, so
it only needs to have high precision; our id56
model is responsible for boosting recall over the
entire input space. we also only need to forward
sample from the sid18, which is considerably eas-
ier to implement than conditional id136.

below, we examine various strategies for induc-
ing a grammar g from a dataset d. we    rst en-
code d as an initial grammar with rules root
    (cid:104)x, y(cid:105) for each (x, y)     d. next, we will
de   ne each grammar induction strategy as a map-
ping from an input grammar gin to a new gram-
mar gout. this formulation allows us to compose
grammar induction strategies (section 4.3.4).

4.3.1 abstracting entities
our    rst grammar induction strategy, absenti-
ties, simply abstracts entities with their types.
we assume that each entity e (e.g., texas) has
a corresponding type e.t (e.g., state), which we
infer based on the presence of certain predicates
in the logical form (e.g. stateid). for each
grammar rule x     (cid:104)  ,   (cid:105) in gin, where    con-
tains a token (e.g.,    texas   ) that string matches
an entity (e.g., texas) in   , we add two rules
to gout: (i) a rule where both occurrences are re-
placed with the type of the entity (e.g., state),
and (ii) a new rule that maps the type to the en-
tity (e.g., stateid     (cid:104)   texas   , texas(cid:105); we re-
serve the category name state for the next sec-
tion). thus, gout generates recombinant examples
that fuse most of one example with an entity found
in a second example. a concrete example from the
geo domain is given in figure 3.

4.3.2 abstracting whole phrases

our second grammar induction strategy, absw-
holephrases, abstracts both entities and whole
phrases with their types. for each grammar rule
x     (cid:104)  ,   (cid:105) in gin, we add up to two rules to
gout. first, if    contains tokens that string match
to an entity in   , we replace both occurrences with
the type of the entity, similarly to rule (i) from ab-
sentities. second, if we can infer that the entire
expression    evaluates to a set of a particular type
(e.g. state) we create a rule that maps the type
to (cid:104)  ,   (cid:105).
in practice, we also use some simple
rules to strip question identi   ers from   , so that
the resulting examples are more natural. again,
refer to figure 3 for a concrete example.

this strategy works because of a more general
conditional independence property:
the meaning
of any semantically coherent phrase is condition-
ally independent of the rest of the sentence, the
cornerstone of id152. note that
this assumption is not always correct in general:
for example, phenomena like anaphora that in-
volve long-range context dependence violate this
assumption. however, this property holds in most
existing id29 datasets.

4.3.3 concatenation

the    nal grammar induction strategy is a surpris-
ingly simple approach we tried that turns out to
work. for any k     2, we de   ne the concat-k
strategy, which creates two types of rules. first,
we create a single rule that has root going to
a sequence of k sent   s. then, for each root-
level rule root     (cid:104)  ,   (cid:105) in gin, we add the rule
sent     (cid:104)  ,   (cid:105) to gout. see figure 3 for an ex-
ample.

unlike absentities

and abswhole-
phrases, concatenation is very general, and can
be applied to any sequence transduction problem.
of course, it also does not introduce additional
information about compositionality or indepen-
dence properties present
in id29.
however, it does generate harder examples for the
attention-based id56, since the model must learn
to attend to the correct parts of the now-longer
input sequence. related work has shown that
training a model on more dif   cult examples can
improve generalization, the most canonical case
being dropout (hinton et al., 2012; wager et al.,
2013).

function train(dataset d, number of epochs t ,

number of examples to sample n)

induce grammar g from d
initialize id56 parameters    randomly
for each iteration t = 1, . . . , t do

compute current learning rate   t
initialize current dataset dt to d
for i = 1, . . . , n do

sample new example (x(cid:48), y(cid:48)) from g
add (x(cid:48), y(cid:48)) to dt

end for
shuf   e dt
for each example (x, y) in dt do
          +   t    log p  (y | x)

end for

end for

end function

figure 4: the training procedure with data recom-
bination. we    rst induce an sid18, then sample
new recombinant examples from it at each epoch.

4.3.4 composition
we note that grammar induction strategies can
be composed, yielding more complex grammars.
given any two grammar induction strategies f1
and f2, the composition f1     f2 is the grammar
induction strategy that takes in gin and returns
f1(f2(gin)). for the strategies we have de   ned,
we can perform this operation symbolically on the
grammar rules, without having to sample from the
intermediate grammar f2(gin).
5 experiments
we evaluate our system on three domains: geo,
atis, and overnight. for atis, we report
logical form exact match accuracy. for geo and
overnight, we determine correctness based on
denotation match, as in liang et al. (2011) and
wang et al. (2015), respectively.

5.1 choice of grammar induction strategy
we note that not all grammar induction strate-
gies make sense for all domains.
in particular,
we only apply abswholephrases to geo and
overnight. we do not apply abswhole-
phrases to atis, as the dataset has little nesting
structure.

implementation details

5.2
we tokenize logical forms in a domain-speci   c
manner, based on the syntax of the formal lan-
guage being used. on geo and atis, we dis-
allow copying of predicate names to ensure a fair

comparison to previous work, as string matching
between input words and predicate names is not
commonly used. we prevent copying by prepend-
ing underscores to predicate tokens; see figure 2
for examples.

on atis alone, when doing attention-based
copying and data recombination, we leverage
an external lexicon that maps natural language
phrases (e.g.,    kennedy airport   ) to entities (e.g.,
jfk:ap). when we copy a word that is part of
a phrase in the lexicon, we write the entity asso-
ciated with that lexicon entry. when performing
data recombination, we identify entity alignments
based on matching phrases and entities from the
lexicon.

logical

the correct

we run all experiments with 200 hidden units
and 100-dimensional word vectors. we initial-
ize all parameters uniformly at random within
the interval [   0.1, 0.1]. we maximize the log-
likelihood of
form using
stochastic id119. we train the model
for a total of 30 epochs with an initial learning rate
of 0.1, and halve the learning rate every 5 epochs,
starting after epoch 15. we replace word vectors
for words that occur only once in the training set
with a universal <unk> word vector. our model
is implemented in theano (bergstra et al., 2010).
when performing data recombination, we sam-
ple a new round of recombinant examples from
our grammar at each epoch. we add these ex-
amples to the original training dataset, randomly
shuf   e all examples, and train the model for the
epoch. figure 4 gives pseudocode for this training
procedure. one important hyperparameter is how
many examples to sample at each epoch: we found
that a good rule of thumb is to sample as many re-
combinant examples as there are examples in the
training dataset, so that half of the examples the
model sees at each epoch are recombinant.

at test time, we use id125 with beam size
5. we automatically balance missing right paren-
theses by adding them at the end. on geo and
overnight, we then pick the highest-scoring
logical form that does not yield an executor error
when the corresponding denotation is computed.
on atis, we just pick the top prediction on the
beam.

impact of the copying mechanism

5.3
first, we measure the contribution of the attention-
based copying mechanism to the model   s overall

no copying
with copying

geo atis overnight
74.6
85.0

69.9
76.3

76.7
75.8

table 1:
test accuracy on geo, atis, and
overnight, both with and without copying. on
overnight, we average across all eight domains.

previous work
zettlemoyer and collins (2007)
kwiatkowski et al. (2010)
liang et al. (2011)2
kwiatkowski et al. (2011)
poon (2013)
zhao and huang (2015)
our model
no recombination
absentities
abswholephrases
concat-2
concat-3
awp + ae
ae + c2
awp + ae + c2
ae + c3

geo

atis

88.9
91.1
88.6

88.9

85.0
85.4
87.5
84.6

88.9

89.3

84.6

82.8
83.5
84.2

76.3
79.9

79.0
77.5

78.8

83.3

table 2: test accuracy using different data recom-
bination strategies on geo and atis. ae is ab-
sentities, awp is abswholephrases, c2 is
concat-2, and c3 is concat-3.

performance. on each task, we train and evalu-
ate two models: one with the copying mechanism,
and one without. training is done without data re-
combination. the results are shown in table 1.

on geo and atis, the copying mechanism
helps signi   cantly:
it improves test accuracy by
10.4 percentage points on geo and 6.4 points
on atis. however, on overnight, adding the
copying mechanism actually makes our model
perform slightly worse. this result is somewhat
expected, as the overnight dataset contains a
very small number of distinct entities. it is also
notable that both systems surpass the previous best
system on overnight by a wide margin.

we choose to use the copying mechanism in all
subsequent experiments, as it has a large advan-
tage in realistic settings where there are many dis-
tinct entities in the world. the concurrent work of
gu et al. (2016) and gulcehre et al. (2016), both of
whom propose similar copying mechanisms, pro-
vides additional evidence for the utility of copying
on a wide range of nlp tasks.

5.4 main results

2the method of liang et al. (2011) is not comparable to

for our main results, we train our model with a va-
riety of data recombination strategies on all three
datasets. these results are summarized in tables 2
and 3. we compare our system to the baseline of
not using any data recombination, as well as to
state-of-the-art systems on all three datasets.

we    nd that data recombination consistently
improves accuracy across the three domains we
evaluated on, and that the strongest results come
from composing multiple strategies. combin-
ing abswholephrases, absentities, and
concat-2 yields a 4.3 percentage point improve-
ment over the baseline without data recombina-
tion on geo, and an average of 1.7 percentage
points on overnight.
in fact, on geo, we
achieve test accuracy of 89.3%, which surpasses
the previous state-of-the-art, excluding liang et al.
(2011), which used a seed lexicon for predicates.
on atis, we experiment with concatenating more
than 2 examples, to make up for the fact that we
cannot apply abswholephrases, which gen-
erates longer examples. we obtain a test accu-
racy of 83.3 with absentities composed with
concat-3, which beats the baseline by 7 percent-
age points and is competitive with the state-of-the-
art.

data recombination without copying. for
completeness, we also investigated the effects
of data recombination on the model without
attention-based copying. we found that recom-
bination helped signi   cantly on geo and atis,
but hurt the model slightly on overnight. on
geo, the best data recombination strategy yielded
test accuracy of 82.9%, for a gain of 8.3 percent-
age points over the baseline with no copying and
no recombination; on atis, data recombination
gives test accuracies as high as 74.6%, a 4.7 point
gain over the same baseline. however, no data re-
combination strategy improved average test accu-
racy on overnight; the best one resulted in a
0.3 percentage point decrease in test accuracy. we
hypothesize that data recombination helps less on
overnight in general because the space of pos-
sible logical forms is very limited, making it more
like a large multiclass classi   cation task. there-
fore, it is less important for the model to learn
good compositional representations that general-
ize to new logical forms at test time.

ours, as they as they used a seed lexicon mapping words to
predicates. we explicitly avoid using such prior knowledge
in our system.

previous work
wang et al. (2015)
our model
no recombination
absentities
abswholephrases
concat-2
awp + ae
awp + ae + c2

basketball blocks calendar housing publications recipes restaurants

social avg.

46.3

85.2
86.7
86.7
84.7
85.2
87.5

41.9

58.1
60.2
55.9
60.7
54.1
60.2

74.4

78.0
78.0
79.2
75.6
78.6
81.0

54.0

71.4
65.6
69.8
69.8
67.2
72.5

59.0

76.4
73.9
76.4
74.5
73.9
78.3

70.8

79.6
77.3
77.8
80.1
79.6
81.0

75.9

76.2
79.5
80.7
79.5
81.9
79.5

48.2

58.8

81.4
81.3
80.9
80.8
82.1
79.6

75.8
75.3
75.9
75.7
75.3
77.5

table 3: test accuracy using different data recombination strategies on the overnight tasks.

depth-2 (same length)
x:    rel:12 of rel:17 of ent:14   
y: ( _rel:12 ( _rel:17 _ent:14 ) )
depth-4 (longer)
x:    rel:23 of rel:36 of rel:38 of rel:10 of ent:05   
y: ( _rel:23 ( _rel:36 ( _rel:38
( _rel:10 _ent:05 ) ) ) )

figure 5: a sample of our arti   cial data.

figure 6: the results of our arti   cial data exper-
iments. we see that the model learns more from
longer examples than from same-length examples.

5.5 effect of longer examples

strategies

interestingly,
like abswhole-
phrases and concat-2 help the model even
though the resulting recombinant examples are
generally not in the support of the test distribution.
in particular, these recombinant examples are on
average longer than those in the actual dataset,
which makes them harder for the attention-based
model.
for every domain, our best
accuracy numbers involved some form of concate-
nation, and often involved abswholephrases

indeed,

as well. in comparison, applying absentities
alone, which generates examples of the same
length as those in the original dataset, was
generally less effective.

we conducted additional experiments on arti   -
cial data to investigate the importance of adding
longer, harder examples. we experimented with
adding new examples via data recombination, as
well as adding new independent examples (e.g. to
simulate the acquisition of more training data). we
constructed a simple world containing a set of enti-
ties and a set of binary relations. for any n, we can
generate a set of depth-n examples, which involve
the composition of n relations applied to a single
entity. example data points are shown in figure 5.
we train our model on various datasets, then test
it on a set of 500 randomly chosen depth-2 exam-
ples. the model always has access to a small seed
training set of 100 depth-2 examples. we then add
one of four types of examples to the training set:
    same length, independent: new randomly

chosen depth-2 examples.3

    longer,

independent: randomly chosen

depth-4 examples.

    same length, recombinant: depth-2 exam-
ples sampled from the grammar induced by
applying absentities to the seed dataset.
    longer, recombinant: depth-4 examples
sampled from the grammar induced by apply-
ing abswholephrases followed by ab-
sentities to the seed dataset.

to maintain consistency between the independent
and recombinant experiments, we    x the recombi-
nant examples across all epochs, instead of resam-
pling at every epoch. in figure 6, we plot accu-
racy on the test set versus the number of additional
examples added of each of these four types. as

3technically, these are not completely independent, as we
sample these new examples without replacement. the same
applies to the longer    independent    examples.

0100200300400500020406080100number of additional examplestest accuracy (%)same length, independentlonger, independentsame length, recombinantlonger, recombinantexpected, independent examples are more help-
ful than the recombinant ones, but both help the
model improve considerably. in addition, we see
that even though the test dataset only has short ex-
amples, adding longer examples helps the model
more than adding shorter ones, in both the inde-
pendent and recombinant cases. these results un-
derscore the importance training on longer, harder
examples.

6 discussion

in this paper, we have presented a novel frame-
work we term data recombination, in which we
generate new training examples from a high-
precision generative model induced from the orig-
inal
training dataset. we have demonstrated
its effectiveness in improving the accuracy of a
sequence-to-sequence id56 model on three se-
mantic parsing datasets, using a synchronous
context-free grammar as our generative model.

there has been growing interest in applying
neural networks to id29 and related
tasks. dong and lapata (2016) concurrently de-
veloped an attention-based id56 model for se-
mantic parsing, although they did not use data re-
combination. grefenstette et al. (2014) proposed
a non-recurrent neural model for semantic pars-
ing, though they did not run experiments. mei et
al. (2016) use an id56 model to perform a related
task of instruction following.

our proposed attention-based copying mech-
anism bears a strong resemblance to two mod-
els that were developed independently by other
groups. gu et al. (2016) apply a very similar copy-
ing mechanism to text summarization and single-
turn dialogue generation. gulcehre et al. (2016)
propose a model that decides at each step whether
to write from a    shortlist    vocabulary or copy from
the input, and report improvements on machine
translation and text summarization. another piece
of related work is luong et al. (2015b), who train
a id4 system to copy rare
words, relying on an external system to generate
alignments.

prior work has explored using id141 for
data augmentation on nlp tasks. zhang et al.
(2015) augment their data by swapping out words
for synonyms from id138. wang and yang
(2015) use a similar strategy, but identify similar
words and phrases based on cosine distance be-
tween vector space embeddings. unlike our data

recombination strategies,
these techniques only
change inputs x, while keeping the labels y    xed.
additionally, these id141-based transfor-
mations can be described in terms of grammar
induction, so they can be incorporated into our
framework.

in data recombination, data generated by a high-
precision generative model is used to train a sec-
ond, domain-general model. generative oversam-
pling (liu et al., 2007) learns a generative model
in a multiclass classi   cation setting, then uses it
to generate additional examples from rare classes
in order to combat label imbalance. uptraining
(petrov et al., 2010) uses data labeled by an ac-
curate but slow model to train a computationally
cheaper second model. vinyals et al. (2015b) gen-
erate a large dataset of constituency parse trees
by taking sentences that multiple existing systems
parse in the same way, and train a neural model on
this dataset.

some of our induced grammars generate ex-
amples that are not in the test distribution, but
nonetheless aid in generalization. related work
has also explored the idea of training on altered
or out-of-domain data, often interpreting it as a
form of id173. dropout training has been
shown to be a form of adaptive id173
(hinton et al., 2012; wager et al., 2013). guu et al.
(2015) showed that encouraging a knowledge base
completion model to handle longer path queries
acts as a form of structural id173.

language is a blend of crisp regularities and
soft relationships. our work takes id56s, which
excel at modeling soft phenomena, and uses a
highly structured tool   synchronous context free
grammars   to infuse them with an understanding
of crisp structure. we believe this paradigm for si-
multaneously modeling the soft and hard aspects
of language should have broader applicability be-
yond id29.

acknowledgments this work was supported by
the nsf graduate research fellowship under
grant no. dge-114747, and the darpa com-
municating with computers (cwc) program under
aro prime contract no. w911nf-15-1-0462.

for

code,

reproducibility. all
and
experiments
avail-
able on the codalab platform at https:
//worksheets.codalab.org/worksheets/
0x50757a37779b485f89012e4ba03b6f4f/.

data,
are

paper

this

references
[artzi and zettlemoyer2013a] y. artzi and l. zettle-
moyer. 2013a. uw spf: the university of wash-
ington id29 framework. arxiv preprint
arxiv:1311.3011.

[artzi and zettlemoyer2013b] y. artzi and l. zettle-
moyer. 2013b. weakly supervised learning of se-
mantic parsers for mapping instructions to actions.
transactions of the association for computational
linguistics (tacl), 1:49   62.

[bahdanau et al.2014] d. bahdanau, k. cho,

and
y. bengio. 2014. id4 by
jointly learning to align and translate. arxiv preprint
arxiv:1409.0473.

[berant et al.2013] j. berant, a. chou, r. frostig, and
p. liang.
2013. id29 on freebase
from question-answer pairs. in empirical methods
in natural language processing (emnlp).

[bergstra et al.2010] j.

o.

bergstra,

breuleux,
f. bastien, p. lamblin, r. pascanu, g. des-
jardins, j. turian, d. warde-farley, and y. bengio.
2010. theano: a cpu and gpu math expression
in python for scienti   c computing
compiler.
conference.

[clarke et al.2010] j.

clarke,

goldwasser,
m. chang, and d. roth. 2010. driving semantic
in computa-
parsing from the world   s response.
tional natural language learning (conll), pages
18   27.

d.

[dong and lapata2016] l. dong and m. lapata. 2016.
language to logical form with neural attention. in
association for computational linguistics (acl).

[dyer et al.2015] c. dyer, m. ballesteros, w. ling,
a. matthews, and n. a. smith. 2015. transition-
based id33 with stack long short-
in association for computational
term memory.
linguistics (acl).

[hinton et al.2012] g. e. hinton, n. srivastava,
a. krizhevsky, i. sutskever, and r. r. salakhut-
dinov.
improving neural networks by
preventing co-adaptation of feature detectors. arxiv
preprint arxiv:1207.0580.

2012.

[hochreiter and schmidhuber1997] s. hochreiter and
j. schmidhuber. 1997. long short-term memory.
neural computation, 9(8):1735   1780.

[jaitly and hinton2013] n. jaitly and g. e. hinton.
2013. vocal tract length perturbation (vtlp) im-
proves id103. in international confer-
ence on machine learning (icml).

[krizhevsky et al.2012] a. krizhevsky,

i. sutskever,
id163 classi   cation
and g. e. hinton. 2012.
in ad-
with deep convolutional neural networks.
vances in neural information processing systems
(nips), pages 1097   1105.

kushman

[kushman and barzilay2013] n.

and
r. barzilay.
2013. using semantic uni   cation
to generate id157 from natural lan-
in human language technology and
guage.
north american association for computational
linguistics (hlt/naacl), pages 826   836.

[kwiatkowski et al.2010] t. kwiatkowski, l. zettle-
moyer, s. goldwater, and m. steedman.
2010.
inducing probabilistic id35 grammars from logi-
in em-
cal form with higher-order uni   cation.
pirical methods in natural language processing
(emnlp), pages 1223   1233.

[kwiatkowski et al.2011] t. kwiatkowski, l. zettle-
moyer, s. goldwater, and m. steedman. 2011. lex-
ical generalization in id35 grammar induction for
id29. in empirical methods in natural
language processing (emnlp), pages 1512   1523.

[liang et al.2011] p. liang, m. i. jordan, and d. klein.
2011. learning dependency-based compositional
in association for computational lin-
semantics.
guistics (acl), pages 590   599.

[grefenstette et al.2014] e. grefenstette, p. blunsom,
n. de freitas, and k. m. hermann. 2014. a deep
architecture for id29. in acl workshop
on id29, pages 22   27.

[liu et al.2007] a. liu, j. ghosh, and c. martin. 2007.
generative oversampling for mining imbalanced
datasets. in international conference on data min-
ing (dmin).

[gu et al.2016] j. gu, z. lu, h. li, and v. o. li. 2016.
incorporating copying mechanism in sequence-to-
in association for computa-
sequence learning.
tional linguistics (acl).

[gulcehre et al.2016] c. gulcehre, s. ahn, r. nallap-
ati, b. zhou, and y. bengio. 2016. pointing the
unknown words. in association for computational
linguistics (acl).

[guu et al.2015] k. guu, j. miller, and p. liang. 2015.
traversing id13s in vector space.
in
empirical methods in natural language processing
(emnlp).

[luong et al.2015a] m. luong, h. pham, and c. d.
effective approaches to
manning.
attention-based id4. in em-
pirical methods in natural language processing
(emnlp), pages 1412   1421.

2015a.

[luong et al.2015b] m. luong, i. sutskever, q. v. le,
o. vinyals, and w. zaremba. 2015b. addressing
the rare word problem in id4.
in association for computational linguistics (acl),
pages 11   19.

[mei et al.2016] h. mei, m. bansal, and m. r. walter.
2016. listen, attend, and walk: neural mapping of

[zettlemoyer and collins2007] l. s. zettlemoyer and
2007. online learning of relaxed
m. collins.
id35 grammars for parsing to logical form.
in
empirical methods in natural language process-
ing and computational natural language learning
(emnlp/conll), pages 678   687.

[zhang et al.2015] x. zhang, j. zhao, and y. lecun.
2015. character-level convolutional networks for
text classi   cation. in advances in neural informa-
tion processing systems (nips).

[zhao and huang2015] k. zhao and l. huang. 2015.
type-driven incremental id29 with
polymorphism. in north american association for
computational linguistics (naacl).

navigational instructions to action sequences. in as-
sociation for the advancement of arti   cial intelli-
gence (aaai).

[petrov et al.2010] s. petrov, p. chang, m. ringgaard,
and h. alshawi. 2010. uptraining for accurate de-
terministic question parsing. in empirical methods
in natural language processing (emnlp).

[poon2013] h. poon. 2013. grounded unsupervised
id29. in association for computational
linguistics (acl).

[sutskever et al.2014] i. sutskever, o. vinyals, and
q. v. le. 2014. sequence to sequence learning with
neural networks. in advances in neural information
processing systems (nips), pages 3104   3112.

[vinyals et al.2015a] o. vinyals, m. fortunato, and
in advances
n. jaitly. 2015a. id193.
in neural information processing systems (nips),
pages 2674   2682.

[vinyals et al.2015b] o. vinyals, l. kaiser, t. koo,
2015b.
s. petrov, i. sutskever, and g. hinton.
in advances
grammar as a foreign language.
in neural information processing systems (nips),
pages 2755   2763.

[wager et al.2013] s. wager, s. i. wang, and p. liang.
2013. dropout training as adaptive id173.
in advances in neural information processing sys-
tems (nips).

[wang and yang2015] w. y. wang and d. yang. 2015.
that   s so annoying!!!: a lexical and frame-semantic
embedding based data augmentation approach to au-
tomatic categorization of annoying behaviors using
#petpeeve tweets. in empirical methods in natural
language processing (emnlp).

[wang et al.2015] y. wang, j. berant, and p. liang.
2015. building a semantic parser overnight. in as-
sociation for computational linguistics (acl).

2006.

[wong and mooney2006] y. w. wong and r.

j.
learning for semantic pars-
mooney.
in north
ing with id151.
american association for computational linguis-
tics (naacl), pages 439   446.

[wong and mooney2007] y. w. wong and r.

j.
mooney. 2007. learning synchronous grammars
for id29 with id198. in asso-
ciation for computational linguistics (acl), pages
960   967.

[zelle and mooney1996] m. zelle and r. j. mooney.
1996. learning to parse database queries using in-
ductive logic programming. in association for the
advancement of arti   cial intelligence (aaai), pages
1050   1055.

[zettlemoyer and collins2005] l. s. zettlemoyer and
m. collins. 2005. learning to map sentences to log-
ical form: structured classi   cation with probabilis-
tic categorial grammars. in uncertainty in arti   cial
intelligence (uai), pages 658   666.

