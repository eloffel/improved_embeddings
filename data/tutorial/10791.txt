a joint many-task model:

growing a neural network for multiple nlp tasks

kazuma hashimoto   , caiming xiong   , yoshimasa tsuruoka, and richard socher

{hassy, tsuruoka}@logos.t.u-tokyo.ac.jp

the university of tokyo

{cxiong, rsocher}@salesforce.com

salesforce research

7
1
0
2

 
l
u
j
 

4
2

 
 
]
l
c
.
s
c
[
 
 

5
v
7
8
5
1
0

.

1
1
6
1
:
v
i
x
r
a

abstract

transfer and id72 have
traditionally focused on either a single
source-target pair or very few, similar
tasks. ideally, the linguistic levels of mor-
phology, syntax and semantics would ben-
e   t each other by being trained in a sin-
gle model. we introduce a joint many-task
model together with a strategy for succes-
sively growing its depth to solve increas-
ingly complex tasks. higher layers in-
clude shortcut connections to lower-level
task predictions to re   ect linguistic hierar-
chies. we use a simple id173 term
to allow for optimizing all model weights
to improve one task   s loss without exhibit-
ing catastrophic interference of the other
tasks. our single end-to-end model ob-
tains state-of-the-art or competitive results
on    ve different tasks from tagging, pars-
ing, relatedness, and entailment tasks.

1

introduction

the potential for leveraging multiple levels of
representation has been demonstrated in various
ways in the    eld of natural language processing
(nlp). for example, part-of-speech (pos) tags
are used for syntactic parsers. the parsers are used
to improve higher-level tasks, such as natural lan-
guage id136 (chen et al., 2016) and machine
translation (eriguchi et al., 2016). these systems
are often pipelines and not trained end-to-end.

deep nlp models have yet shown bene   ts from
predicting many increasingly complex tasks each
at a successively deeper layer. existing models
often ignore linguistic hierarchies by predicting
    work was done while the    rst author was an intern at
   corresponding author.

salesforce research.

figure 1: overview of the joint many-task model
predicting different linguistic outputs at succes-
sively deeper layers.

different tasks either entirely separately or at the
same depth (collobert et al., 2011).

we introduce a joint many-task (jmt) model,
outlined in figure 1, which predicts increasingly
complex nlp tasks at successively deeper lay-
ers. unlike traditional pipeline systems, our sin-
gle jmt model can be trained end-to-end for pos
tagging, chunking, id33, semantic
relatedness, and id123, by consider-
ing linguistic hierarchies. we propose an adaptive
training and id173 strategy to grow this
model in its depth. with the help of this strat-
egy we avoid catastrophic interference between
the tasks. our model is motivated by s  gaard and
goldberg (2016) who showed that predicting two
different tasks is more accurate when performed in
different layers than in the same layer (collobert
et al., 2011). experimental results show that our
single model achieves competitive results for all
of the    ve different tasks, demonstrating that us-

chunkposdeprelatedness encoderrelatednessentailment encoderentailmentword representationsentence1chunkposdeprelatedness encoderentailment encoderword representationsentence2semanticlevelsyntacticlevel word leveling linguistic hierarchies is more important than
handling different tasks in the same layer.

2 the joint many-task model

this section describes the id136 procedure of
our model, beginning at the lowest level and work-
ing our way to higher layers and more complex
tasks; our model handles the    ve different tasks in
the order of id52, chunking, dependency
parsing, semantic relatedness, and textual entail-
ment, by considering linguistic hierarchies. the
pos tags are used for chunking, and the chunking
tags are used for id33 (attardi and
dellorletta, 2008). tai et al. (2015) have shown
that dependencies improve the relatedness task.
the relatedness and entailment tasks are closely
related to each other. if the semantic relatedness
between two sentences is very low, they are un-
likely to entail each other. based on this obser-
vation, we make use of the information from the
relatedness task for improving the entailment task.

2.1 word representations
for each word wt in the input sentence s of length
l, we use two types of embeddings.
id27s: we use skip-gram (mikolov
et al., 2013) to train id27s.
character embeddings: character id165 em-
beddings are trained by the same skip-gram ob-
jective. we construct the character id165 vocab-
ulary in the training data and assign an embed-
ding for each entry. the    nal character embed-
ding is the average of the unique character id165
embeddings of wt. for example, the character n-
grams (n = 1, 2, 3) of the word    cat    are {c, a,
t, #b#c, ca, at, t#e#, #b#ca, cat, at#e#}, where
   #b#    and    #e#    represent the beginning and the
end of each word, respectively. using the char-
acter embeddings ef   ciently provides morpholog-
ical features. each word is subsequently repre-
sented as xt, the concatenation of its correspond-
ing word and character embeddings shared across
the tasks.1

2.2 word-level task: id52
the    rst layer of the model is a bi-directional
lstm (graves and schmidhuber, 2005; hochre-
iter and schmidhuber, 1997) whose hidden states

1bojanowski et al. (2017) previously proposed to train the

character id165 embeddings by the skip-gram objective.

are used to predict pos tags. we use the follow-
ing long short-term memory (lstm) units for
the forward direction:

it =    (wigt + bi) , ft =    (wf gt + bf ) ,
ot =    (wogt + bo) , ut = tanh (wugt + bu) ,
ct = it (cid:12) ut + ft (cid:12) ct   1, ht = ot (cid:12) tanh (ct) ,

(1)

      
where we de   ne the input gt as gt = [
h t   1; xt],
i.e. the concatenation of the previous hidden state
and the word representation of wt. the backward
pass is expanded in the same way, but a different
set of weights are used.

for predicting the pos tag of wt, we use the
concatenation of the forward and backward states
in a one-layer bi-lstm layer corresponding to the
      
h t]. then each ht (1     t    
t-th word: ht = [
l) is fed into a standard softmax classi   er with a
single relu layer which outputs the id203
vector y(1) for each of the pos tags.

      
h t;

2.3 word-level task: chunking
chunking is also a word-level classi   cation task
which assigns a chunking tag (b-np, i-vp, etc.)
for each word. the tag speci   es the region of ma-
jor phrases (e.g., noun phrases) in the sentence.

chunking is performed in the second bi-lstm
layer on top of the pos layer. when stacking
the bi-lstm layers, we use eq. (1) with input
(2)
is the
t = [h
g
hidden state of the    rst (pos) layer. we de   ne
the weighted label embedding y

(1)
], where h
t

(pos)
; xt; y
t

as follows:

(2)
t   1; h

(1)
t

(pos)
t

c(cid:88)

(pos)
y
t

=

(1)

t = j|h

p(y

(1)
t )(cid:96)(j),

(2)

j=1

(1)
where c is the number of the pos tags, p(y
t =
j|h
(1)
t ) is the id203 value that the j-th pos
tag is assigned to wt, and (cid:96)(j) is the correspond-
ing label embedding. the id203 values are
predicted by the pos layer, and thus no gold pos
tags are needed. this output embedding is simi-
lar to the k-best pos tag feature which has been
shown to be effective in syntactic tasks (andor
et al., 2016; alberti et al., 2015). for predict-
ing the chunking tags, we employ the same strat-
egy as id52 by using the concatenated bi-
directional hidden states h
] in
the chunking layer. we also use a single relu
hidden layer before the softmax classi   er.

(2)
t = [

      
h

      
h

(2)
t

(2)
t

;

2.4 syntactic task: id33
id33 identi   es syntactic relations
(such as an adjective modifying a noun) between
word pairs in a sentence. we use the third bi-
lstm layer to classify relations between all pairs
of words. the input vector for the lstm in-
cludes hidden states, word representations, and
the label embeddings for the two previous tasks:
(3)
)], where we
t = [h
g
computed the chunking vector in a similar fashion
as the pos vector in eq. (2).

(2)
(3)
t   1; h
t

; xt; (y

(chk)
t

(pos)
t

+ y

we predict the parent node (head) for each
word. then a dependency label is predicted for
each child-parent pair. this approach is related
to dozat and manning (2017) and zhang et al.
(2017), where the main difference is that our
model works on a multi-task framework. to pre-
dict the parent node of wt, we de   ne a matching
function between wt and the candidates of the par-
(3)
(3)
j ), where wd
ent node as m (t, j) = h
t
is a parameter matrix. for the root, we de   ne
(3)
l+1 = r as a parameterized vector. to com-
h
pute the id203 that wj (or the root node) is
the parent of wt, the scores are normalized:

   (wdh

p(j|h

(3)
t ) =

exp (m (t, j))

k=1,k(cid:54)=t exp (m (t, k))

.

(3)

(3)
; h
j

the dependency labels are predicted using
(3)
] as input to a softmax classi   er with
[h
t
a single relu layer. we greedily select the par-
ent node and the dependency label for each word.
when the parsing result is not a well-formed tree,
we apply the    rst-order eisner   s algorithm (eisner,
1996) to obtain a well-formed tree from it.

2.5 semantic task: semantic relatedness
the next two tasks model the semantic relation-
ships between two input sentences. the    rst task
measures the semantic relatedness between two
sentences. the output is a real-valued relatedness
score for the input sentence pair. the second task
is id123, which requires one to deter-
mine whether a premise sentence entails a hypoth-
esis sentence. there are typically three classes:
entailment, contradiction, and neutral. we use the
fourth and    fth bi-lstm layer for the relatedness
and entailment task, respectively.

now it is required to obtain the sentence-level
representation rather than the word-level represen-
used in the    rst three tasks. we com-
tation h
(4)
pute the sentence-level representation h
as the
s

(4)
t

(cid:80)l+1

(cid:16)

(cid:17)

(cid:105)

element-wise maximum values across all of the
word-level representations in the fourth layer:

(4)
s = max

h

(4)
h
1 , h

(4)
2 , . . . , h

(4)
l

.

(4)

(cid:104)(cid:12)(cid:12)(cid:12)h

(cid:12)(cid:12)(cid:12) ; h

this max-pooling technique has proven effective
in text classi   cation tasks (lai et al., 2015).
to model the semantic relatedness between s
and s(cid:48), we follow tai et al. (2015). the feature
vector for representing the semantic relatedness is
computed as follows:

(cid:12)(cid:12)(cid:12)h

d1(s, s

(cid:48)) =

(4)

(4)

(4)
s(cid:48)

s     h

s (cid:12) h
(4)
s(cid:48)

(cid:12)(cid:12)(cid:12) is the absolute values of the

(5)

,

(4)

s     h
(4)
s(cid:48)

where
element-wise subtraction, and h
is the
element-wise multiplication. then d1(s, s(cid:48)) is fed
into a softmax classi   er with a single maxout
hidden layer (goodfellow et al., 2013) to output
a relatedness score (from 1 to 5 in our case).

s (cid:12) h

(4)
s(cid:48)

(4)

2.6 semantic task: id123
for entailment classi   cation, we also use the max-
pooling technique as in the semantic relatedness
task.
to classify the premise-hypothesis pair
(s, s(cid:48)) into one of the three classes, we com-
pute the feature vector d2(s, s(cid:48)) as in eq. (5) ex-
cept that we do not use the absolute values of
the element-wise subtraction, because we need
to identify which is the premise (or hypothesis).
then d2(s, s(cid:48)) is fed into a softmax classi   er.

to use the output from the relatedness layer di-
rectly, we use the label embeddings for the related-
ness task. more concretely, we compute the class
label embeddings for the semantic relatedness task
similar to eq. (2). the    nal feature vectors that are
concatenated and fed into the entailment classi   er
are the weighted relatedness label embedding and
the feature vector d2(s, s(cid:48)). we use three maxout
hidden layers before the classi   er.

3 training the jmt model

the model is trained jointly over all datasets. dur-
ing each epoch, the optimization iterates over each
full training dataset in the same order as the corre-
sponding tasks described in the modeling section.

3.1 pre-training word representations
we pre-train id27s using the skip-
gram model with negative sampling (mikolov

et al., 2013). we also pre-train the character n-
gram embeddings using skip-gram.2 the only dif-
ference is that each input id27 is re-
placed with its corresponding average character n-
gram embedding described in section 2.1. these
embeddings are    ne-tuned during the model train-
ing. we denote the embedding parameters as   e.

3.2 training the pos layer
let   pos = (wpos, bpos,   e) denote the set of
model parameters associated with the pos layer,
where wpos is the set of the weight matrices in
the    rst bi-lstm and the classi   er, and bpos is
the set of the bias vectors. the objective function
to optimize   pos is de   ned as follows:

j1(  pos) =    (cid:88)

(cid:88)

(1)

log p(y

t =   |h
(1)
t )
+   (cid:107)wpos(cid:107)2 +   (cid:107)  e       
e(cid:107)2,
(cid:48)

s

t

(6)

(1)

t =   wt|h

(1)
where p(y
t ) is the id203 value
that the correct label    is assigned to wt in the sen-
tence s,   (cid:107)wpos(cid:107)2 is the l2-norm id173
term, and    is a hyperparameter.
we call the second id173 term   (cid:107)  e    
e(cid:107)2 a successive id173 term. the suc-
  (cid:48)
cessive id173 is based on the idea that we
do not want the model to forget the information
learned for the other tasks.
in the case of pos
tagging, the id173 is applied to   e, and   (cid:48)
e
is the embedding parameter after training the    nal
task in the top-most layer at the previous training
epoch.    is a hyperparameter.

3.3 training the chunking layer
the objective function is de   ned as follows:

j2(  chk) =    (cid:88)

(cid:88)

(2)

log p(y

t =   |h
(2)
t )
+   (cid:107)wchk(cid:107)2 +   (cid:107)  pos       
pos(cid:107)2,
(cid:48)

s

t

(7)

which is similar to that of id52, and   chk is
(wchk, bchk, epos,   e), where wchk and bchk are
the weight and bias parameters including those in
  pos, and epos is the set of the pos label em-
beddings.   (cid:48)
pos is the one after training the pos
layer at the current training epoch.

2the training code and the pre-trained embeddings
are available at https://github.com/hassygo/
charngram2vec.

3.4 training the dependency layer
the objective function is de   ned as follows:

j3(  dep) =    (cid:88)

(cid:88)

t )p(  |h
+   ((cid:107)wdep(cid:107)2 + (cid:107)wd(cid:107)2) +   (cid:107)  chk       

log p(  |h

(3)

s

t

(3)
, h(3)
   )
t
chk(cid:107)2,
(cid:48)
(8)

, h

(3)
t

where p(  |h
(3)
t ) is the id203 value as-
signed to the correct parent node    for wt,
and p(  |h
(3)
   ) is the id203 value as-
signed to the correct dependency label    for
the child-parent pair (wt,   ).   dep is de   ned as
(wdep, bdep, wd, r, epos, echk,   e), where wdep
and bdep are the weight and bias parameters in-
cluding those in   chk, and echk is the set of the
chunking label embeddings.

3.5 training the relatedness layer
following tai et al. (2015), the objective function
is de   ned as follows:

(cid:13)(cid:13)(cid:13)p(h(4)

(cid:88)

(cid:16)

(cid:48))
  p(s, s

kl

s , h
(s,s(cid:48))
+   (cid:107)wrel(cid:107)2 +   (cid:107)  dep       

j4(  rel) =

(9)

(cid:16)

(4)
s(cid:48) )

(4)
s , h

(4)
s , h

  p(s, s(cid:48))

(cid:13)(cid:13)(cid:13)p(h

where   p(s, s(cid:48)) is the gold distribution over the de-
(4)
s(cid:48) ) is the pre-
   ned relatedness scores, p(h
dicted distribution given the the sentence repre-
is the
sentations, and kl
kl-divergence between the two distributions.   rel
is de   ned as (wrel, brel, epos, echk,   e).
3.6 training the entailment layer
the objective function is de   ned as follows:
(s,s(cid:48)) =   |h(5)
s , h
rel(cid:107)2,
(cid:48)

j5(  ent) =     (cid:88)

+   (cid:107)went(cid:107)2 +   (cid:107)  rel       

log p(y

(5)
s(cid:48) )

(s,s(cid:48))

(5)

(cid:17)
(4)
s(cid:48) )
dep(cid:107)2,
(cid:48)
(cid:17)

(10)

(5)

(s,s(cid:48)) =   |h

(5)
s , h

(5)
s(cid:48) ) is the probabil-
where p(y
ity value that the correct label    is assigned to
the premise-hypothesis pair (s, s(cid:48)).   ent is de   ned
as (went, bent, epos, echk, erel,   e), where erel is
the set of the relatedness label embeddings.

4 related work
many deep learning approaches have proven to be
effective in a variety of nlp tasks and are becom-
ing more and more complex. they are typically

designed to handle single tasks, or some of them
are designed as general-purpose models (kumar
et al., 2016; sutskever et al., 2014) but applied to
different tasks independently.

for handling multiple nlp tasks, multi-task
learning models with deep neural networks have
been proposed (collobert et al., 2011; luong et al.,
2016), and more recently s  gaard and goldberg
(2016) have suggested that using different layers
for different tasks is more effective than using the
same layer in jointly learning closely-related tasks,
such as id52 and chunking. however, the
number of tasks was limited or they have very sim-
ilar task settings like word-level tagging, and it
was not clear how lower-level tasks could be also
improved by combining higher-level tasks.

more related to our work, godwin et al. (2016)
also followed s  gaard and goldberg (2016) to
jointly learn id52, chunking, and lan-
guage modeling, and zhang and weiss (2016)
have shown that it is effective to jointly learn pos
tagging and id33 by sharing inter-
nal representations. in the    eld of relation extrac-
tion, miwa and bansal (2016) proposed a joint
learning model for entity detection and relation ex-
traction. all of them suggest the importance of
id72, and we investigate the poten-
tial of handling different types of nlp tasks rather
than closely-related ones in a single hierarchical
deep model.

in the    eld of id161, some trans-
fer and id72 approaches have also
been proposed (li and hoiem, 2016; misra et al.,
2016). for example, misra et al. (2016) proposed
a id72 model to handle different
tasks. however, they assume that each data sam-
ple has annotations for the different tasks, and do
not explicitly consider task hierarchies.

recently, rusu et al. (2016) have proposed a
progressive neural network model to handle mul-
tiple id23 tasks, such as atari
games. like our jmt model, their model is also
successively trained according to different tasks
using different layers called columns in their pa-
per.
in their model, once the    rst task is com-
pleted, the model parameters for the    rst task are
   xed, and then the second task is handled with new
model parameters. therefore, accuracy of the pre-
viously trained tasks is never improved. in nlp
tasks, id72 has the potential to im-
prove not only higher-level tasks, but also lower-

level tasks. rather than    xing the pre-trained
model parameters, our successive id173
allows our model to continuously train the lower-
level tasks without signi   cant accuracy drops.

5 experimental settings
5.1 datasets
id52: to train the id52 layer, we
used the wall street journal (wsj) portion of penn
treebank, and followed the standard split for the
training (section 0-18), development (section 19-
21), and test (section 22-24) sets. the evaluation
metric is the word-level accuracy.
chunking: for chunking, we also used the wsj
corpus, and followed the standard split for the
training (section 15-18) and test (section 20) sets
as in the conll 2000 shared task. we used sec-
tion 19 as the development set and employed the
iobes tagging scheme. the evaluation metric is
the f1 score de   ned in the shared task.
id33: we also used the wsj cor-
pus for id33, and followed the stan-
dard split for the training (section 2-21), devel-
opment (section 22), and test (section 23) sets.
we obtained stanford style dependencies using the
version 3.3.0 of the stanford converter. the evalu-
ation metrics are the unlabeled attachment score
(uas) and the labeled attachment score (las),
and punctuations are excluded for the evaluation.
semantic relatedness: for the semantic related-
ness task, we used the sick dataset (marelli et al.,
2014), and followed the standard split for the train-
ing, development, and test sets. the evaluation
metric is the mean squared error (mse) between
the gold and predicted scores.
id123: for id123, we
also used the sick dataset and exactly the same
data split as the semantic relatedness dataset. the
evaluation metric is the accuracy.

5.2 training details
we set the dimensionality of the embeddings and
the hidden states in the bi-lstms to 100. at each
training epoch, we trained our model in the or-
der of id52, chunking, dependency pars-
ing, semantic relatedness, and id123.
we used mini-batch stochastic gradient decent and
empirically found it effective to use a gradient
clipping method with growing clipping values for
the different tasks; concretely, we employed the
simple function: min(3.0, depth), where depth is

the number of bi-lstm layers involved in each
task, and 3.0 is the maximum value. we applied
our successive id173 to our model, along
with l2-norm id173 and dropout (srivas-
tava et al., 2014). more details are summarized in
the supplemental material.

6 results and discussion

table 1 shows our results on the test sets of the
   ve tasks.3 the column    single    shows the re-
sults of handling each task separately using single-
layer bi-lstms, and the column    jmtall    shows
the results of our jmt model. the single task set-
tings only use the annotations of their own tasks.
for example, when handling id33
as a single task, the pos and chunking tags are not
used. we can see that all results of the    ve tasks
are improved in our jmt model, which shows that
our jmt model can handle the    ve different tasks
in a single model. our jmt model allows us to
access arbitrary information learned from the dif-
ferent tasks. if we want to use the model just as a
pos tagger, we can use only    rst bi-lstm layer.
table 1 also shows the results of    ve subsets
of the different tasks. for example, in the case
of    jmtabc   , only the    rst three layers of the
bi-lstms are used to handle the three tasks. in
the case of    jmtde   , only the top two layers are
used as a two-layer bi-lstm by omitting all in-
formation from the    rst three layers. the results
of the closely-related tasks (   ab   ,    abc   , and
   de   ) show that our jmt model improves both
of the high-level and low-level tasks. the results
of    jmtcd    and    jmtce    show that the parsing
task can be improved by the semantic tasks.

it should be noted that in our analysis on the
greedy parsing results of the    jmtabc    setting,
we have found that more than 95% are well-
formed dependency trees on the development set.
in the 1,700 sentences of the development data, 11
results have multiple root notes, 11 results have
no root nodes, and 61 results have cycles. these
83 parsing results are converted into well-formed
trees by eisner   s algorithm, and the accuracy does
not signi   cantly change (uas: 94.52%   94.53%,
las: 92.61%   92.62%).

3in chunking evaluation, we only show the results of    sin-
gle    and    jmtab    because the sentences for chunking eval-
uation overlap the training data for id33.

6.1 comparison with published results
id52 table 2 shows the results of pos
tagging, and our jmt model achieves the score
close to the state-of-the-art results. the best result
to date has been achieved by ling et al. (2015),
which uses character-based lstms.
incorporat-
ing the character-based encoders into our jmt
model would be an interesting direction, but we
have shown that the simple pre-trained character
id165 embeddings lead to the promising result.

chunking table 3 shows the results of chunk-
ing, and our jmt model achieves the state-of-the-
art result. s  gaard and goldberg (2016) proposed
to jointly learn id52 and chunking in dif-
ferent layers, but they only showed improvement
for chunking. by contrast, our results show that
the low-level tasks are also improved.

id33 table 4 shows the results
of id33 by using only the wsj cor-
pus in terms of the dependency annotations.4 it is
notable that our simple greedy dependency parser
outperforms the model in andor et al. (2016)
which is based on id125 with global infor-
mation. the result suggests that the bi-lstms ef-
   ciently capture global information necessary for
id33. moreover, our single task
result already achieves high accuracy without the
pos and chunking information. the best result to
date has been achieved by the model propsoed in
dozat and manning (2017), which uses higher di-
mensional representations than ours and proposes
a more sophisticated attention mechanism called
biaf   ne attention. it should be promising to incor-
porate their attention mechanism into our parsing
component.

semantic relatedness table 5 shows the results
of the semantic relatedness task, and our jmt
model achieves the state-of-the-art result. the re-
sult of    jmtde    is already better than the previous
state-of-the-art results. both of zhou et al. (2016)
and tai et al. (2015) explicitly used syntactic trees,
and zhou et al. (2016) relied on attention mecha-
nisms. however, our method uses the simple max-
pooling strategy, which suggests that it is worth

4choe and charniak (2016) employed a tri-training
method to expand the training data with 400,000 trees in ad-
dition to the wsj data, and they reported 95.9 uas and 94.1
las by converting their constituency trees into dependency
trees. kuncoro et al. (2017) also reported high accuracy (95.8
uas and 94.6 las) by using a converter.

pos
chunking

a    
b    
c     dependency uas
dependency las
d     relatedness
e    
entailment

single
97.45
95.02
93.35
91.42
0.247
81.8

jmtall
97.55
n/a
94.67
92.90
0.233
86.2

jmtab
97.52
95.77
n/a
n/a
n/a
n/a

jmtabc

97.54
n/a
94.71
92.92
n/a
n/a

jmtde

n/a
n/a
n/a
n/a
0.238
86.8

jmtcd

n/a
n/a
93.53
91.62
0.251
n/a

jmtce

n/a
n/a
93.57
91.69
n/a
82.4

table 1: test set results for the    ve tasks. in the relatedness task, the lower scores are better.

method
jmtall
ling et al. (2015)
kumar et al. (2016)
ma and hovy (2016)
s  gaard (2011)
collobert et al. (2011)
tsuruoka et al. (2011)
toutanova et al. (2003)

acc.    
97.55
97.78
97.56
97.55
97.50
97.29
97.28
97.27

table 2: id52 results.

method
jmtab
single
s  gaard and goldberg (2016)
suzuki and isozaki (2008)
collobert et al. (2011)
kudo and matsumoto (2001)
tsuruoka et al. (2011)

f1    
95.77
95.02
95.56
95.15
94.32
93.91
93.81

table 3: chunking results.

method
jmtall
jmtde
zhou et al. (2016)
tai et al. (2015)

mse    
0.233
0.238
0.243
0.253

method
jmtall
single
dozat and manning (2017)
andor et al. (2016)
alberti et al. (2015)
zhang et al. (2017)
weiss et al. (2015)
dyer et al. (2015)
bohnet (2010)

uas    
94.67
93.35
95.74
94.61
94.23
94.10
93.99
93.10
92.88

las    
92.90
91.42
94.08
92.79
92.36
91.90
92.05
90.90
90.71

table 4: dependency results.

method
jmtall
jmtde
yin et al. (2016)
lai and hockenmaier (2014)

acc.    
86.2
86.8
86.2
84.6

table 5: semantic relatedness results.

table 6: id123 results.

pos
chunking
dependency uas
dependency las
relatedness
entailment

jmtall
97.88
97.59
94.51
92.60
0.236
84.6

w/o sc
97.79
97.08
94.52
92.62
0.698
75.0

w/o le
97.85
97.40
94.09
92.14
0.261
81.6

w/o sc&le

97.87
97.33
94.04
92.03
0.765
71.2

table 7: effectiveness of the shortcut connections
(sc) and the label embeddings (le).

investigating such simple methods before develop-
ing complex methods for simple tasks. currently,
our jmt model does not explicitly use the learned
dependency structures, and thus the explicit use of
the output from the dependency layer should be an
interesting direction of future work.

id123 table 6 shows the results of
id123, and our jmt model achieves
the state-of-the-art result. the previous state-of-
the-art result in yin et al. (2016) relied on at-
tention mechanisms and dataset-speci   c data pre-
processing and features. again, our simple max-
pooling strategy achieves the state-of-the-art result
boosted by the joint training. these results show
the importance of jointly handling related tasks.

6.2 analysis on the model architectures
we investigate the effectiveness of our model in
detail. all of the results shown in this section are
the development set results.

pos
chunking
dependency uas
dependency las

jmtabc

97.90
97.80
94.52
92.61

w/o sc&le

97.87
97.41
94.13
92.16

all-3
97.62
96.52
93.59
91.47

table 8: effectiveness of using different layers for
different tasks.

shortcut connections our jmt model feeds the
word representations into all of the bi-lstm lay-
ers, which is called the shortcut connection. ta-
ble 7 shows the results of    jmtall    with and with-
out the shortcut connections. the results with-
out the shortcut connections are shown in the col-
umn of    w/o sc   . these results clearly show that
the importance of the shortcut connections, and in
particular, the semantic tasks in the higher layers
strongly rely on the shortcut connections. that is,
simply stacking the lstm layers is not suf   cient
to handle a variety of nlp tasks in a single model.
in the supplementary material, it is qualitatively
shown how the shortcut connections work in our
model.

output label embeddings table 7 also shows
the results without using the output labels of the
pos, chunking, and relatedness layers, in the col-
umn of    w/o le   . these results show that the ex-
plicit use of the output information from the clas-
si   ers of the lower layers is important in our jmt

pos
chunking
dependency uas
dependency las
relatedness
entailment

jmtall
97.88
97.59
94.51
92.60
0.236
84.6

w/o sr
97.85
97.13
94.46
92.57
0.239
84.2

w/o vc
97.82
97.45
94.38
92.48
0.241
84.8

pos
chunking
dependency uas
dependency las
relatedness
entailment

single

95.65
93.38
91.37
0.239
83.8

single+

97.52

96.08
93.88
91.83
0.665
66.4

table 9: effectiveness of the successive regular-
ization (sr) and the vertical connections (vc).

pos
chunking
dependency uas
dependency las
relatedness
entailment

jmtall
97.88
97.59
94.51
92.60
0.236
84.6

random
97.83
97.71
94.66
92.80
0.298
83.2

table 10: effects of the order of training.

model. the results in the column of    w/o sc&le   
are the ones without both of the shortcut connec-
tions and the label embeddings.

different layers for different tasks table 8
shows the results of our    jmtabc    setting and
that of not using the shortcut connections and the
label embeddings (   w/o sc&le   ) as in table 7.
in addition, in the column of    all-3   , we show the
results of using the highest (i.e., the third) layer for
all of the three tasks without any shortcut connec-
tions and label embeddings, and thus the two set-
tings    w/o sc&le    and    all-3    require exactly
the same number of the model parameters. the
   all-3    setting is similar to the multi-task model
of collobert et al. (2011) in that task-speci   c out-
put layers are used but most of the model param-
eters are shared. the results show that using the
same layers for the three different tasks hampers
the effectiveness of our jmt model, and the de-
sign of the model is much more important than the
number of the model parameters.

successive id173 in table 9, the col-
umn of    w/o sr    shows the results of omitting the
successive id173 terms described in sec-
tion 3. we can see that the accuracy of chunking is
improved by the successive id173, while
other results are not affected so much. the chunk-
ing dataset used here is relatively small compared
with other low-level tasks, id52 and de-
pendency parsing. thus, these results suggest
that the successive id173 is effective when
dataset sizes are imbalanced.

vertical connections we investigated our jmt
results without using the vertical connections in

table 11: effects of depth for the single tasks.

single
pos
chunking
dependency uas
dependency las

w&c
97.52
95.65
93.38
91.37

only w
96.26
94.92
92.90
90.44

table 12: effects of the character embeddings.

the    ve-layer bi-lstms. more concretely, when
constructing the input vectors gt, we do not use
the bi-lstm hidden states of the previous lay-
ers. table 9 also shows the jmtall results with
and without the vertical connections. as shown in
the column of    w/o vc   , we observed the compet-
itive results. therefore, in the target tasks used in
our model, sharing the word representations and
the output label embeddings is more effective than
just stacking the bi-lstm layers.

order of training our jmt model iterates the
training process in the order described in sec-
tion 3. our hypothesis is that it is important to start
from the lower-level tasks and gradually move to
the higher-level tasks. table 10 shows the results
of training our model by randomly shuf   ing the
order of the tasks for each epoch in the column of
   random   . we see that the scores of the semantic
tasks drop by the random strategy. in our prelimi-
nary experiments, we have found that constructing
the mini-batch samples from different tasks also
hampers the effectiveness of our model, which
also supports our hypothesis.

depth the single task settings shown in table 1
are obtained by using single layer bi-lstms, but
in our jmt model, the higher-level tasks use suc-
cessively deeper layers. to investigate the gap be-
tween the different number of the layers for each
task, we also show the results of using multi-layer
bi-lstms for the single task settings, in the col-
umn of    single+    in table 11. more concretely,
we use the same number of the layers with our
jmt model; for example, three layers are used
for id33, and    ve layers are used
for id123. as shown in these results,
deeper layers do not always lead to better results,
and the joint learning is more important than mak-

ing the models complex only for single tasks.
character id165 embeddings finally, ta-
ble 12 shows the results for the three single tasks
with and without the pre-trained character id165
embeddings. the column of    w&c    corresponds
to using both of the word and character id165
embeddings, and that of    only w    corresponds
to using only the id27s. these re-
sults clearly show that jointly using the pre-trained
word and character id165 embeddings is helpful
in improving the results. the pre-training of the
character id165 embeddings is also effective; for
example, without the pre-training, the pos accu-
racy drops from 97.52% to 97.38% and the chunk-
ing accuracy drops from 95.65% to 95.14%.

6.3 discussion
training strategies
in our jmt model, it is not
obvious when to stop the training while trying to
maximize the scores of all the    ve tasks. we fo-
cused on maximizing the accuracy of dependency
parsing on the development data in our experi-
ments. however, the sizes of the training data
are different across the different tasks; for exam-
ple, the semantic tasks include only 4,500 sen-
tence pairs, and the id33 dataset
includes 39,832 sentences with word-level anno-
tations. thus,
in general, id33
requires more training epochs than the semantic
tasks, but currently, our model trains all of the
tasks for the same training epochs. the same strat-
egy for decreasing the learning rate is also shared
across all the different tasks, although our growing
gradient clipping method described in section 5.2
helps improve the results.
indeed, we observed
that better scores of the semantic tasks can be
achieved before the accuracy of dependency pars-
ing reaches the best score. developing a method
for achieving the best scores for all of the tasks at
the same time is important future work.
more tasks our jmt model has the potential
of handling more tasks than the    ve tasks used
in our experiments; examples include entity de-
tection and id36 as in miwa and
bansal (2016) as well as id38 (god-
win et al., 2016). it is also a promising direction
to train each task for multiple domains by focus-
ing on id20 (s  gaard and goldberg,
2016). in particular, incorporating language mod-
eling tasks provides an opportunity to use large
text data. such large text data was used in our

experiments to pre-train the word and character n-
gram embeddings. however, it would be prefer-
able to ef   ciently use it for improving the entire
model.
task-oriented learning of low-level tasks each
task in our jmt model is supervised by its cor-
responding dataset. however, it would be possi-
ble to learn low-level tasks by optimizing high-
level tasks, because the model parameters of the
low-level tasks can be directly modi   ed by learn-
ing the high-level tasks. one example has al-
ready been presented in hashimoto and tsuruoka
(2017), where our jmt model is extended to learn-
ing task-oriented latent graph structures of sen-
tences by training our id33 com-
ponent according to a id4
objective.

7 conclusion
we presented a joint many-task model to handle
multiple nlp tasks with growing depth in a sin-
gle end-to-end model. our model is successively
trained by considering linguistic hierarchies, di-
rectly feeding word representations into all lay-
ers, explicitly using low-level predictions, and ap-
plying successive id173.
in experiments
on    ve nlp tasks, our single model achieves the
state-of-the-art or competitive results on chunk-
ing, id33, semantic relatedness,
and id123.
acknowledgments
we thank the anonymous reviewers and the sales-
force research team members for their fruitful
comments and discussions.

references
chris alberti, david weiss, greg coppola, and slav
improved transition-based parsing
petrov. 2015.
in proceed-
and tagging with neural networks.
ings of the 2015 conference on empirical methods
in natural language processing, pages 1354   1359.

daniel andor, chris alberti, david weiss, aliaksei
severyn, alessandro presta, kuzman ganchev, slav
petrov, and michael collins. 2016. globally nor-
malized transition-based neural networks. in pro-
ceedings of the 54th annual meeting of the associa-
tion for computational linguistics (volume 1: long
papers), pages 2442   2452.

giuseppe attardi and felice dellorletta. 2008. chunk-
in proceedings of

ing and id33.
lrec 2008 workshop on partial parsing.

bernd bohnet. 2010. top accuracy and fast depen-
in proceed-
dency parsing is not a contradiction.
ings of the 23rd international conference on com-
putational linguistics, pages 89   97.

piotr bojanowski, edouard grave, armand joulin, and
tomas mikolov. 2017. enriching word vectors with
subword information. transactions of the associa-
tion for computational linguistics, 5:135   146.

qian chen, xiaodan zhu, zhenhua ling, si wei, and
hui jiang. 2016. enhancing and combining se-
quential and tree lstm for natural language in-
ference. arxiv, cs.cl 1609.06038.

do kook choe and eugene charniak. 2016. parsing
as id38. in proceedings of the 2016
conference on empirical methods in natural lan-
guage processing, pages 2331   2336.

ronan collobert,

jason weston, leon bottou,
michael karlen nad koray kavukcuoglu, and pavel
kuksa. 2011. natural language processing (al-
most) from scratch. journal of machine learning
research, 12:2493   2537.

timothy dozat and christopher d. manning. 2017.
deep biaf   ne attention for neural dependency
in proceedings of the 5th international
parsing.
conference on learning representations.

chris dyer, miguel ballesteros, wang ling, austin
matthews, and noah a. smith. 2015. transition-
based id33 with stack long short-
term memory. in proceedings of the 53rd annual
meeting of the association for computational lin-
guistics and the 7th international joint conference
on natural language processing (volume 1: long
papers), pages 334   343.

jason eisner. 1996. ef   cient normal-form parsing for
id35. in proceedings
of the 34th annual meeting of the association for
computational linguistics, pages 79   86.

akiko eriguchi, kazuma hashimoto, and yoshimasa
tsuruoka. 2016. tree-to-sequence attentional neu-
ral machine translation. in proceedings of the 54th
annual meeting of the association for computa-
tional linguistics (volume 1: long papers), pages
823   833.

jonathan godwin, pontus stenetorp, and sebastian
riedel. 2016. deep semi-supervised learning with
linguistically motivated sequence labeling task
hierarchies. arxiv, cs.cl 1612.09113.

ian j. goodfellow, david warde-farley, mehdi mirza,
aaron courville, and yoshua bengio. 2013. max-
in proceedings of the 30th inter-
out networks.
national conference on machine learning, pages
1319   1327.

alex graves and jurgen schmidhuber. 2005. frame-
wise phoneme classi   cation with bidirectional
lstm and other neural network architectures.
neural networks, 18(5):602   610.

kazuma hashimoto and yoshimasa tsuruoka. 2017.
id4 with source-side la-
tent graph parsing. in proceedings of the 2017 con-
ference on empirical methods in natural language
processing. to appear.

sepp hochreiter and jurgen schmidhuber. 1997.
long short-term memory. neural computation,
9(8):1735   1780.

eliyahu kiperwasser and yoav goldberg. 2016. easy-
first id33 with hierarchical tree
lstms. transactions of the association for com-
putational linguistics, 4:445   461.

taku kudo and yuji matsumoto. 2001. chunking with
in proceedings of the
support vector machines.
second meeting of the north american chapter of
the association for computational linguistics.

ankit kumar, ozan irsoy, peter ondruska, mohit
iyyer, james bradbury, ishaan gulrajani, victor
zhong, romain paulus, and richard socher. 2016.
ask me anything: dynamic memory networks
in proceedings
for natural language processing.
of the 33rd international conference on machine
learning, pages 1378   1387.

adhiguna kuncoro, miguel ballesteros, lingpeng
kong, chris dyer, graham neubig, and noah a.
smith. 2017. what do recurrent neural network
in proceedings
grammars learn about syntax?
of the 15th conference of the european chapter
of the association for computational linguistics,
pages 1249   1258.

alice lai and julia hockenmaier. 2014.

illinois-lh:
a denotational and distributional approach to se-
in proceedings of the 8th international
mantics.
workshop on semantic evaluation, pages 329   334.

siwei lai, liheng xu, kang liu, and jun zhao. 2015.
recurrent convolutional neural networks for text
classi   cation. in proceedings of the twenty-ninth
aaai conference on arti   cial intelligence, pages
2267   2273.

zhizhong li and derek hoiem. 2016. learning with-

out forgetting. corr, abs/1606.09282.

wang ling, chris dyer, alan w black, isabel tran-
coso, ramon fermandez, silvio amir, luis marujo,
and tiago luis. 2015. finding function in form:
compositional character models for open vocab-
in proceedings of the
ulary word representation.
2015 conference on empirical methods in natural
language processing, pages 1520   1530.

minh-thang luong, ilya sutskever, quoc v. le, oriol
vinyals, and lukasz kaiser. 2016. multi-task se-
quence to sequence learning. in proceedings of the
4th international conference on learning represen-
tations.

xuezhe ma and eduard hovy. 2016. end-to-end se-
quence labeling via bi-directional lstm-id98s-
crf. in proceedings of the 54th annual meeting of
the association for computational linguistics (vol-
ume 1: long papers), pages 1064   1074.

marco marelli, luisa bentivogli, marco baroni, raf-
faella bernardi, stefano menini, and roberto zam-
parelli. 2014. semeval-2014 task 1: evaluation of
compositional distributional semantic models on
full sentences through semantic relatedness and
in proceedings of the 8th in-
id123.
ternational workshop on semantic evaluation (se-
meval 2014), pages 1   8.

tomas mikolov, ilya sutskever, kai chen, greg s cor-
rado, and jeff dean. 2013. distributed representa-
tions of words and phrases and their composition-
ality. in advances in neural information processing
systems 26, pages 3111   3119.

ishan misra, abhinav shrivastava, abhinav gupta, and
martial hebert. 2016. cross-stitch networks for
id72. corr, abs/1604.03539.

makoto miwa and mohit bansal. 2016. end-to-end
id36 using lstms on sequences and
in proceedings of the 54th an-
tree structures.
nual meeting of the association for computational
linguistics (volume 1: long papers), pages 1105   
1116.

yasumasa miyamoto and kyunghyun cho. 2016.
gated word-character recurrent language model.
in proceedings of the 2016 conference on empiri-
cal methods in natural language processing, pages
1992   1997.

masataka ono, makoto miwa, and yutaka sasaki.
2015. id27-based antonym detection
using thesauri and distributional information.
in
proceedings of the 2015 conference of the north
american chapter of the association for computa-
tional linguistics: human language technologies,
pages 984   989.

vu pham, theodore bluche, christopher kermorvant,
and jerome louradour. 2014. dropout improves re-
current neural networks for handwriting recogni-
tion. corr, abs/1312.4569.

andrei a. rusu, neil c. rabinowitz, guillaume des-
jardins, hubert soyer, james kirkpatrick, koray
kavukcuoglu, razvan pascanu, and raia hadsell.
corr,
2016.
abs/1606.04671.

progressive neural networks.

anders s  gaard. 2011. semi-supervised condensed
nearest neighbor for part-of-speech tagging. in pro-
ceedings of the 49th annual meeting of the associ-
ation for computational linguistics: human lan-
guage technologies, pages 48   52.

anders s  gaard and yoav goldberg. 2016. deep
id72 with low level tasks supervised
at lower layers. in proceedings of the 54th annual

meeting of the association for computational lin-
guistics (volume 2: short papers), pages 231   235.

nitish srivastava, geoffrey hinton, alex krizhevsky,
ilya sutskever, and ruslan salakhutdinov. 2014.
dropout: a simple way to prevent neural networks
from over   tting. journal of machine learning re-
search, 15:1929   1958.

ilya sutskever, oriol vinyals, and quoc v le. 2014.
sequence to sequence learning with neural net-
works. in advances in neural information process-
ing systems 27, pages 3104   3112.

jun suzuki and hideki isozaki. 2008. semi-supervised
sequential labeling and segmentation using giga-
word scale unlabeled data. in proceedings of the
46th annual meeting of the association for com-
putational linguistics: human language technolo-
gies, pages 665   673.

kai sheng tai, richard socher, and christopher d.
manning. 2015.
improved semantic representa-
tions from tree-structured long short-term mem-
in proceedings of the 53rd annual
ory networks.
meeting of the association for computational lin-
guistics and the 7th international joint conference
on natural language processing (volume 1: long
papers), pages 1556   1566.

kristina toutanova, dan klein, christopher d man-
ning, and yoram singer. 2003. feature-rich part-
of-speech tagging with a cyclic dependency net-
in proceedings of the 2003 human lan-
work.
guage technology conference of the north ameri-
can chapter of the association for computational
linguistics, pages 173   180.

yoshimasa tsuruoka, yusuke miyao, and jun   ichi
kazama. 2011. learning with lookahead: can
history-based models rival globally optimized
in proceedings of the fifteenth confer-
models?
ence on computational natural language learning,
pages 238   246.

david weiss, chris alberti, michael collins, and slav
petrov. 2015. structured training for neural net-
in proceedings of
work transition-based parsing.
the 53rd annual meeting of the association for
computational linguistics and the 7th international
joint conference on natural language processing
(volume 1: long papers), pages 323   333.

john wieting, mohit bansal, kevin gimpel, and karen
livescu. 2016. charagram: embedding words
and sentences via character id165s. in proceed-
ings of the 2016 conference on empirical methods
in natural language processing, pages 1504   1515.

wenpeng yin, hinrich schtze, bing xiang, and bowen
zhou. 2016. abid98: attention-based convolu-
tional neural network for modeling sentence pairs.
transactions of the association for computational
linguistics, 4:259   272.

xingxing zhang, jianpeng cheng, and mirella lapata.
2017. id33 as head selection.
in
proceedings of the 15th conference of the european
chapter of the association for computational lin-
guistics, pages 665   676.

yuan zhang and david weiss. 2016.

stack-
propagation: improved representation learning for
in proceedings of the 54th annual meet-
syntax.
ing of the association for computational linguistics
(volume 1: long papers), pages 1557   1566.

yao zhou, cong liu, and yan pan. 2016. modelling
sentence pairs with tree-structured attentive en-
coder. in proceedings of the 26th international con-
ference on computational linguistics, pages 2912   
2922.

used

embeddings we

supplemental material
a training details
pre-training
the
to pre-train the word em-
id97 toolkit
beddings. we created our training corpus by
selecting lowercased english wikipedia text
and obtained 100-dimensional skip-gram word
embeddings trained with the context window size
1,
the negative sampling method (15 negative
samples), and the sub-sampling method (10   5 of
the sub-sampling coef   cient). we also pre-trained
the character id165 embeddings using the
same parameter settings with the case-sensitive
wikipedia text. we trained the character id165
embeddings for n = 1, 2, 3, 4 in the pre-training
step.
embedding initialization we used the pre-
trained id27s to initialize the word
embeddings, and the word vocabulary was built
based on the training data of the    ve tasks.
all words in the training data were included
in the word vocabulary, and we employed the
word-dropout method (kiperwasser and gold-
berg, 2016) to train the id27 for
the unknown words. we also built the charac-
ter id165 vocabulary for n = 2, 3, 4, follow-
ing wieting et al. (2016), and the character n-
gram embeddings were initialized with the pre-
trained embeddings. all of the label embed-
dings were initialized with uniform random values

(cid:112)6/(dim + c)], where

in [   (cid:112)6/(dim + c),

dim = 100 is the dimensionality of the label em-
beddings and c is the number of labels.
weight initialization the dimensionality of the
hidden layers in the bi-lstms was set to 100. we

initialized all of the softmax parameters and bias
vectors, except for the forget biases in the lstms,
with zeros, and the weight matrix wd and the root
node vector r for id33 were also
initialized with zeros. all of the forget biases
were initialized with ones. the other weight ma-
trices were initialized with uniform random values

(cid:112)6/(row + col)], where

in [   (cid:112)6/(row + col),

row and col are the number of rows and columns
of the matrices, respectively.

optimization at each epoch, we trained our
model in the order of id52, chunking, de-
pendency parsing, semantic relatedness, and tex-
tual entailment. we used mini-batch stochastic
gradient decent to train our model. the mini-
batch size was set to 25 for id52, chunk-
ing, and the sick tasks, and 15 for dependency
parsing. we used a gradient clipping strategy
with growing clipping values for the different
tasks; concretely, we employed the simple func-
tion: min(3.0, depth), where depth is the number
of bi-lstm layers involved in each task, and 3.0
is the maximum value. the learning rate at the
k-th epoch was set to
1.0+  (k   1), where    is the
initial learning rate, and    is the hyperparameter
to decrease the learning rate. we set    to 1.0 and   
to 0.3. at each epoch, the same learning rate was
shared across all of the tasks.

  

id173 we set the id173 coef   -
cient to 10   6 for the lstm weight matrices, 10   5
for the weight matrices in the classi   ers, and 10   3
for the successive id173 term excluding
the classi   er parameters of the lower-level tasks,
respectively. the successive id173 coef   -
cient for the classi   er parameters was set to 10   2.
we also used dropout (srivastava et al., 2014). the
dropout rate was set to 0.2 for the vertical con-
nections in the multi-layer bi-lstms (pham et al.,
2014), the word representations and the label em-
beddings of the entailment layer, and the classi   er
of the id52, chunking, dependency pars-
ing, and entailment. a different dropout rate of
0.4 was used for the word representations and the
label embeddings of the pos, chunking, and de-
pendency layers, and the classi   er of the related-
ness layer.

b details of character id165

embeddings

here we    rst describe the pre-training process of
the character id165 embeddings in detail and
then show further analysis on the results in ta-
ble 12.

b.1 pre-training with skip-gram objective
we pre-train the character id165 embeddings us-
ing the objective function of the skip-gram model
with negative sampling (mikolov et al., 2013).
we build the vocabulary of the character id165s
based on the training corpus, the case-sensitive
english wikipedia text. this is because such
case-sensitive information is important in han-
dling some types of words like named entities.
assuming that a word w has its corresponding
k character id165s {cn1, cn2, . . . , cnk}, where
any overlaps and unknown ones are removed.
then the word w is represented with an embed-
ding vc(w) computed as follows:

vc(w) =

1
k

v(cni),

(11)

where v(cni) is the parameterized embedding of
the character id165 cni, and the computation of
vc(w) is exactly the same as the one used in our
jmt model explained in section 2.1.

the remaining part of the pre-training process
is the same as the original skip-gram model. for
each word-context pair (w, w) in the training cor-
pus, n negative context words are sampled, and
the objective function is de   ned as follows:

k(cid:88)

i=1

(cid:18)

(cid:88)

(w,w)

    n(cid:88)

i=1

    log   (vc(w)      v(w))

(cid:19)

task setting for id52, based on the results
reported in table 12. table 13 shows that the joint
use of the word and character id165 embeddings
improves the score by about 19% in terms of the
accuracy for unknown words.

we also show the results of the single task set-
ting for id33 in table 14. again,
we can see that using the character-level informa-
tion is effective, and in particular, the improve-
ment of the las score is large. these results sug-
gest that it is better to use not only the word em-
beddings, but also the character id165 embed-
dings by default. recently, the joint use of word
and character information has proven to be effec-
tive in id38 (miyamoto and cho,
2016), but just using the simple character id165
embeddings is fast and also effective.

c analysis on id33

our dependency parser is based on the idea of
predicting a head (or parent) for each word, and
thus the parsing results do not always lead to cor-
rect trees. to inspect this aspect, we checked the
parsing results on the development set (1,700 sen-
tences), using the    jmtabc    setting.

in the dependency annotations used in this
work, each sentence has only one root node, and
we have found 11 sentences with multiple root
nodes and 11 sentences with no root nodes in our
parsing results. we show two examples below:

(a) underneath the headline     diversi   cation ,
    it counsels ,     based on the events of the
past week , all investors need to know their
portfolios are balanced to help protect them
against the market    s volatility .    

log   (   vc(w)      v(wi))

,

(12)

(b) mr.

eskandarian , who resigned his
della femina post in september , becomes
chairman and chief executive of arnold .

where   (  ) is the logistic sigmoid function,   v(w)
is the weight vector for the context word w, and
wi is a negative sample. it should be noted that
the weight vectors for the context words are pa-
rameterized for the words without any character
information.

b.2 effectiveness on unknown words
one expectation from the use of the character
id165 embeddings is to better handle unknown
words. we veri   ed this assumption in the single

the two boldfaced words
in the example (a),
   counsels    and    need    are predicted as child nodes
of the root node, and the underlined word    coun-
sels    is the correct one based on the gold annota-
tions. this example sentence (a) consists of mul-
tiple internal sentences, and our parser misunder-
stood that both of the two verbs are the heads of
the sentence.

in the example (b), none of the words is con-
nected to the root node, and the correct child node
of the root is the underlined word    chairman   .

single (pos) overall acc. acc. for unknown words
w&c
only w

90.68 (3,502/3,862)
71.44 (2,759/3,862)

97.52
96.26

table 13: id52 scores on the development set with and without the character id165 embeddings,
focusing on accuracy for unknown words. the overall accuracy scores are taken from table 12. there
are 3,862 unknown words in the sentences of the development set.

single (dependency) uas
93.38
w&c
only w
92.90

overall scores
las
91.37
90.44

scores for unknown words

uas

las

92.21 (900/976)
91.39 (892/976)

87.81 (857/976)
81.05 (791/976)

table 14: id33 scores on the development set with and without the character id165
embeddings, focusing on uas and las for unknown words. the overall scores are taken from table 12.
there are 976 unknown words in the sentences of the development set.

without the internal phrase    who resigned...
in
september   , the example sentence (b) is very sim-
ple, but we have found that such a simpli   ed sen-
tence is still not parsed correctly. in many cases,
verbs are linked to the root nodes, but some-
times other types of words like nouns can be the
candidates.
in our model, the single parameter-
ized vector r is used to represent the root node
for each sentence. therefore, the results of the
examples (a) and (b) suggest that it would be
needed to capture various types of root nodes,
and using sentence-dependent root representations
would lead to better results in future work.

d analysis on semantic tasks

we inspected the development set results on the
semantic tasks using the    jmtall    setting.
in
our model, the highest-level task is the textual
entailment task. we show an example premise-
hypothesis pair which is misclassi   ed in our re-
sults:

premise:    a surfer is riding a big wave across
dark green water   , and

hypothesis:    the surfer is riding a small
wave   .

the predicted label is entailment, but the gold
label is contradiction. this example is very
easy by focusing on the difference between the
two words    big    and    small   . however, our model
fails to correctly classify this example because
there are few opportunities to learn the differ-
ence. our model relies on the pre-trained word

embeddings based on word co-occurrence statis-
tics (mikolov et al., 2013), and it is widely known
that such co-occurrence-based embeddings can
rarely discriminate between antonyms and syn-
onyms (ono et al., 2015). moreover, the other four
tasks in our jmt model do not explicitly provide
the opportunities to learn such semantic aspects.
even in the training data of the id123
task, we can    nd only one example to learn the
difference between the two words, which is not
enough to obtain generalization capacities. there-
fore, it is worth investigating the explicit use of ex-
ternal dictionaries or the use of pre-trained word
embeddings learned with such dictionaries (ono
et al., 2015), to see whether our jmt model is fur-
ther improved not only for the semantic tasks, but
also for the low-level tasks.

e how do shared embeddings change

in our jmt model, the word and character id165
embedding matrices are shared across all of the
   ve different tasks. to better qualitatively ex-
plain the importance of the shortcut connections
shown in table 7, we inspected how the shared
embeddings change when fed into the different bi-
lstm layers. more concretely, we checked clos-
est neighbors in terms of the cosine similarity for
the word representations before and after fed into
the forward lstm layers. in particular, we used
the corresponding part of wu in eq. (1) to perform
linear transformation of the input embeddings, be-
cause ut directly affects the hidden states of the
lstms. thus, this is a context-independent anal-
ysis.

table 15 shows the examples of the word
   standing   .
the row of    embedding    shows
the cases of using the shared embeddings, and
the others show the results of using the linear-
transformed embeddings. in the column of    only
word   , the results of using only the word embed-
dings are shown. the closest neighbors in the case
of    embedding    capture the semantic similarity,
but after fed into the pos layer, the semantic sim-
ilarity is almost washed out. this is not surpris-
ing because it is suf   cient to cluster the words of
the same pos tags: here, nn, vbg, etc.
in the
chunking layer, the similarity in terms of verbs is
captured, and this is because it is suf   cient to iden-
tify the coarse chunking tags: here, vp. in the de-
pendency layer, the closest neighbors are adverbs,
gerunds of verbs, and nouns, and all of them can
be child nodes of verbs in dependency trees. how-
ever, this information is not suf   cient in further
classifying the dependency labels. then we can
see that in the column of    word and char   , jointly
using the character id165 embeddings adds the
morphological information, and as shown in ta-
ble 12, the las score is substantially improved.

in the case of semantic tasks, the projected em-
beddings capture not only syntactic, but also se-
mantic similarities. these results show that dif-
ferent tasks need different aspects of the word
similarities, and our jmt model ef   ciently trans-
forms the shared embeddings for the different
tasks by the simple linear transformation. there-
fore, without the shortcut connections, the infor-
mation about the word representations are fed into
the semantic tasks after transformed in the lower
layers where the semantic similarities are not al-
ways important. indeed, the results of the seman-
tic tasks are very poor without the shortcut con-
nections.

embedding

pos

chunking

dependency

relatedness

entailment

word and char
leaning
kneeling
saluting
clinging
railing
warning
waxing
dunking
proving
tipping
applauding
disdaining
pickin
readjusting
reclaiming
guaranteeing
resting
grounding
hanging
hugging
stood
stands
unchallenged
notwithstanding
judging
nudging
skirting
straddling
contesting
footing

only word
stood
stands
sit
pillar
cross-legged
ladder
rc6280
bethle
warning
f-a-18
   ght
favor
pick
rejoin
answer
patiently
hugging
anxiously
resting
disappointment
stood
unchallenged
stands
beside
exists
beside
stands
pillar
swung
ovation

table 15: closest neighbors of the word    stand-
ing    in the embedding space and the projected
space in each forward lstm.

