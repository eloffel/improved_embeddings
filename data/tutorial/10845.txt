pathnet: evolution channels id119 in super

neural networks

chrisantha fernando, dylan banarse, charles blundell, yori zwols, david ha   , andrei

a. rusu, alexander pritzel, daan wierstra

google deepmind, london, uk.    google brain

chrisantha@google.com

7
1
0
2

 

n
a
j
 

0
3

 
 
]
e
n
.
s
c
[
 
 

1
v
4
3
7
8
0

.

1
0
7
1
:
v
i
x
r
a

abstract
for arti   cial general intelligence (agi) it would be e   cient
if multiple users trained the same giant neural network, per-
mitting parameter reuse, without catastrophic forgetting.
pathnet is a    rst step in this direction. it is a neural net-
work algorithm that uses agents embedded in the neural net-
work whose task is to discover which parts of the network to
re-use for new tasks. agents are pathways (views) through
the network which determine the subset of parameters that
are used and updated by the forwards and backwards passes
of the backpropogation algorithm. during learning, a tour-
nament selection genetic algorithm is used to select path-
ways through the neural network for replication and muta-
tion. pathway    tness is the performance of that pathway
measured according to a cost function. we demonstrate
successful id21;    xing the parameters along a
path learned on task a and re-evolving a new population
of paths for task b, allows task b to be learned faster than
it could be learned from scratch or after    ne-tuning. paths
evolved on task b re-use parts of the optimal path evolved
on task a. positive transfer was demonstrated for binary
mnist, cifar, and svhn supervised learning classi   ca-
tion tasks, and a set of atari and labyrinth reinforcement
learning tasks, suggesting pathnets have general applicabil-
ity for neural network training. finally, pathnet also signif-
icantly improves the robustness to hyperparameter choices
of a parallel asynchronous id23 algorithm
(a3c).

keywords
giant networks, path evolution algorithm, evolution and
learning, continual learning, id21, multitask
learning, basal ganglia

1.

introduction

a plausible requirement for arti   cial general intelligence
is that many users will be required to train the same giant

acm isbn x-xxxxx-xx-x/xx/xx.
doi: xxx

neural network on a multitude of tasks. this is the most ef-
   cient way for the network to gain experience, because such
a network can reuse existing knowledge instead of learning
from scratch for each task. to achieve this, we propose that
each user of the giant net be given a population of agents
whose job it is to learn the user-de   ned task as e   ciently
as possible. agents will learn how best to re-use existing
parameters in the environment of the neural network by ex-
ecuting actions within the neural network. they must work
in parallel with other agents who are learning other tasks
for other users, sharing parameters if transfer is possible,
learning to update disjoint parameters if interference is sig-
ni   cant. each agent may itself be controlled by an arbitrar-
ily complex id23 algorithm, but here we
chose the very simplest possible    agent   , a unit of evolution
[4].

the framework for agi described above includes aspects
of id21 [22], continual learning [16] and mul-
titask learning [2]. our work shares a motivation with a
recent paper    outrageously large neural networks    in which
the authors write that    the capacity of a neural network to
absorb information is limited by its number of parameters   
[19]. if a standard neural network is naively trained training
cost scales quadratically with model width, whereas path-
net theoretically has constant computation speed with re-
spect to the network width because only a    xed-size subset
of the larger network is used for the forwards and backwards
pass at any time (although there is no guarantee that more
training may not be required in some cases). our work is
related also to    convolutional neural fabrics    in which con-
nection strengths between modules in the fabric are learned,
but where (unlike pathnet) the whole fabric is used all the
time [18].

this paper introduces pathnet, a novel learning algorithm
with explicit support for transfer, continual, and multitask
learning. figure 1 illustrates the algorithm in action. the
   rst task a is pong and the second task b is alien; both are
trained consecutively for 80m timesteps each. the purple
lines in box 1 of the    gure shows all 64 randomly initialized
paths through the neural network model at the beginning of
pong training. a tournament selection genetic algorithm is
then used to evolve paths, where during a    tness evaluation
the path is trained for a few game episodes by gradient de-
scent using a id23 algorithm. thus, evolu-
tion and learning are taking place simultaneously, with evo-
lution only guiding where id119 should be applied

to change the weight and bias parameters. box 2 shows the
population converging (with many paths overlapping with
each other) as performance improves. as perfect perfor-
mance is achieved the population converges to a single path
as shown in box 3. box 4 shows that the converged single
pathway persists until the end of the training session. at
this point the task switches to task b (alien) and the op-
timal path for pong gets       xed   , i.e. the modules on that
path have their weights and biases frozen. box 5 shows the
   xed path as heavy dark red lines alongside a new randomly
initialized population of paths in light blue. the new popu-
lation of paths evolve and converge on alien by box 8. after
160m steps, the optimal path for alien was    xed, shown as
dark blue lines in box 9.

pathnets evolve a population of pathways through a neu-
ral network that sca   olds and channels any desired gradient-
descent-based learning algorithm towards a limited subset
of the neural network   s parameters and then    xes these pa-
rameters after learning so that functionality can never be
lost; it resembles progressive neural networks, in that catas-
trophic forgetting is prevented by design [17]. in progressive
neural networks the topology determining transfer is hard-
wired rather than learned, whereby the    rst neural network
is trained on the source task and then a second neural net-
work is trained on the target task which receives inputs from
the    rst neural network, which has its weights    xed. path-
nets allow the relationships between the original    columns   
and later    columns    to be evolved, where a column is one
deep neural network.

two examples of pathnets were investigated, a serial im-
plementation on two supervised learning tasks where the
pathnet is trained by stochastic id119, and a par-
allel implementation on id23 tasks (atari
and labyrinth games) where the pathnet is trained by the
async advantage actor-critic (a3c) . a3c is an e   cient
distributed id23 algorithm which runs on
multiple cpus with e.g. 64 asynchronously updated work-
ers that simultaneously share and update the parameters of
a single network[12]. positive transfer from a source task to
a target task is demonstrated in all four domains, compared
to single    xed path controls trained from scratch and after
   ne-tuning on the    rst task.

the concept of the pathnet was    rst conceived of within
the framework of darwinian neurodynamics as an attempt
to envisage how evolutionary algorithms could be imple-
mented in the brain [5]. however, in that original work both
the topology and the weights of the path were evolved and
there was no id119 learning [4]. performance was
comparable with a standard genetic algorithm on combina-
torial optimization problems. here we show performance
superior to a3c and stochastic id119 for transfer
learning.

2. methods
2.1 pathnet architecture

a pathnet is a modular deep neural network having l
layers with each layer consisting of m modules. each mod-
ule is itself a neural network, here either convolutional or

linear, followed by a transfer function; recti   ed linear units
are used here. for each layer the outputs of the modules
in that layer are summed before being passed into the ac-
tive modules of the next layer. a module is active if it is
present in the path genotype currently being evaluated (see
below). a maximum of n distinct modules per layer are
permitted in a pathway (typically n = 3 or 4). the    nal
layer is unique and unshared for each task being learned.
in the supervised case this is a single linear layer for each
task, and in the a3c case each task (e.g. atari game) has
a value function readout and a policy readout (see [12] for a
complete description of the a3c algorithm used).

2.2 pathway evolution: serial and parallel

p genotypes (pathways) are initialized randomly, each
genotype is at most a n by l matrix of integers, which
describe the active modules in each layer in that pathway.
in the serial supervised implementation, a binary tourna-
ment selection algorithm is implemented in series as follows.
a random genotype is chosen, and its pathway is trained
for t epochs, its    tness being the negative classi   cation er-
ror during that period of training. then another random
genotype is chosen and its pathway trained for t epochs.
a copy of the winning pathway   s genotype overwrites the
losing pathways genotype. the copy of the winning path-
way   s genotype is then mutated by choosing independently
each element with a id203 of 1/[n    l] and adding an
integer in the range [   2, 2] to it. a local neighbourhood was
used to promote spatial localization of network functionality.

in the a3c (id23) case, all 64 genotypes
are evaluated in parallel, one by each of the 64 workers.
therefore pathways restrict the simultaneous updates of pa-
rameters by the workers to only their speci   c subsets, as op-
posed to the standard a3c algorithm in which all workers
update all parameters. the    tness of a genotype is the re-
turn accumulated over the t episodes that a worker played
using that genotypes pathway. while a worker is evaluat-
ing, it writes a large negative    tness to the shared    tness
array, so that no genotypes wins a tournament until it has
been evaluated. once the worker has    nished t episodes, it
chooses b other random genotypes and checks if any of those
genotypes have returned a    tness of at least its own    tness.
if at least one has, then the highest    t genotype overwrites
the current worker   s genotype, and is mutated as above. if
no other worker had a genotype with    tness greater than
this workers own genotype, then the worker reevaluates its
own genotype.
2.3 id21 paradigm

once task a has been trained for a    xed period of time
or until some error threshold has been reached, the best
   t pathway is    xed, which means its parameters are no
longer allowed to change. all other parameters not in an
optimal path are reinitialized. we found that without re-
initialization transfer performance did not exceed that of
   ne-tuning. in the a3c case (but not the supervised learn-
ing cases) the original best    t pathway is always active dur-
ing the forwards pass of the network, in addition to the
newly evolving pathway, but its parameters are not modi-
   ed by the backwards pass. a new set of random pathways
is then initialized and evolved/trained on task b. in both the

supervised and reinforcement settings, pathnet is compared
with two alternative setups: an independent learning control
where the target task is learned de novo, and a    ne-tuning
control where the second task is learned with the same path
that learned the    rst task (but with a new value function
and policy readout).

2.4 binary mnist classi   cation tasks

a binary mnist classi   cation involves distinguishing two
classes of mnist digits from one another, for example 5
verses 6 [11]. to make the task more di   cult, salt and pep-
per noise of 50% is added to the mnist digits. a trans-
fer experiment involves training and evolving paths on the
   rst task until perfect classi   cation on the training set is
achieved.

at this point, a new population of path genotypes is ini-
tialized and evolved on the second task until perfect per-
formance on the training set is achieved. between tasks the
following modi   cations are made to the underlying network.
the parameters contained in the optimal path evolved on
the    rst task are    xed, and all other parameters are reset to
their random initial values. the reported outcome measures
are the training times required to reach this classi   cation ac-
curacy. the overall pathnet consists of l = 3 layers. each
layer contains m = 10 linear units with 20 neurons each
followed by recti   ed linear units. between layers the activa-
tions of the units are summed. reading out from the    nal
layer is a separate linear layer for each task.

a maximum of 3 of these units per layer can be included
in a single pathway. the genotype describing this pathway
is a 3  3 matrix of integers in the range [1, 10]. a population
of 64 of these genotypes was generated uniformly randomly
at the start of each task. the overall algorithm is as follows.
two paths are chosen randomly for evaluation. the evalu-
ation of one path involves training with stochastic gradient
descent with learning rate 0.0001 on 50 mini-batches of size
16. the    tness of that pathway is the proportion of correct
examples classi   ed on the training set during this training
period. once the    tness of both pathways has been calcu-
lated, the pathway with the lower    tness is overwritten by
a copy of the pathway with the higher    tness and mutated.
mutation takes place with equal id203 1/(3    3) per
element of the genotype, adding a new random integer from
range[   2, 2] to the current value of that element. this is a
binary tournament selection algorithm (b = 2) [7].

2.5 cifar and svhn classi   cation tasks
the larger version of the above network is used to train
on cifar and cropped svhn [13] of standard size 28    28
withl = 3 and m = 20 modules per layer of 20 neurons
each, and with pathways that may contain up to 5 mod-
ules per layer. in this case the networks were not trained
to some    xed accuracy, but for a    xed period of 500 gener-
ations. each generation consisted of the evaluation of two
pathways, each for 50 mini-batches of size 16 images. the
performance measure here was the accuracy achieved after
this    xed training time. evidence for positive transfer in
this case is given by the second task showing a higher    nal

accuracy compared to when it was learned from scratch.

2.6 atari games

we tested whether there was a speedup in learning a sec-
ond (target) game after having played either pong, river-
raid or seaquest as a source game. the target games were
as follows: alien, asterix, boxing, centipede, gopher, hero,
jamesbond, krull, roadrunner, stargunner, wizardofwor.
these are the same games presented by the authors of pro-
gressive neural networks. in this case the a3c algorithm
was used with 64 workers running in parallel. the    rst game
is learned for 80m (or 40m) timesteps of training in total
across all workers. during this time, workers are evolv-
ing pathways through the network. after the    rst game
is learned the population of paths is reinitialized and the
workers play the second game for 40m timesteps in total.
between tasks the following modi   cations are made to the
underlying network. the parameters contained in the opti-
mal path evolved on the    rst task are    xed, and all other
parameters are reset to their random initial values. evo-
lution takes place according to a distributed asynchronous
tournament selection algorithm which works as follows. the
population of pathways and their    tnesses is stored in a cen-
tral parameter server. each worker accesses its own partic-
ular index into this population of genotypes corresponding
to that worker   s id. while it is    rst evaluating that pathway
it writes -1000 to the    tness array at a position correspond-
ing to it   s id. after t = 10 episodes that worker writes the
total sum of rewards obtained into the    tness array. it then
observes the    tnesses of b = 20 other random workers and
if any worker has a higher    tness than itself, it chooses the
highest    tness worker in that set, and copies the pathway
genotype to its own location with mutation, and resets its
own    tness to -1000. however, if no other worker of the b
chosen has a path better than its own, then its own pathway
is re-evaluated without resetting the    tness obtained from
the previous evaluation. mutation is as before, with the mi-
nor modi   cation that if a location is chosen for mutation,
then there is a 20% chance (during the second task) that a
module from the optimal pathway evolved in the    rst task
will be incorporated into the genotype.
in the variant of
pathnet used for this task, the optimal path evolved in the
   rst task is always active during the forwards pass, in this
sense, this version resembles progressive nets more closely
than the supervised versions presented above. the architec-
ture of the network used consists of a core of l = 4 layers,
each with a width of m = 10 modules: namely, 3 convolu-
tional layers where each module consists of 8 kernels, and
a    nal layer of fully connected modules of 50 hidden nodes
each. between layers the feature maps and activations are
summed. reading out from the    nal layer are two linear
layers for each game, one encoding a value function and
the other encoding an action policy. figure 2 shows the
network architecture: the    rst three layers    modules are
shown as green boxes;    nal layer of modules shown as pur-
ple boxes; the between-layer summing modules are shown as
blue boxes; and active modules speci   ed by the pathway as
red boxes. readout units not involved in the pathnet itself
are shown as circles on the right.

2.7 labyrinth games

we investigated the performance of a very similar pathnet
architecture on 3 labyrinth games. labyrinth is a 3d    rst
person game environment [10]. we used the same settings
used for atari games. we chose three games:
   laser tag
chasm    (lt chasm),    seek avoid arena 01    (seekavoid arena)
and    stairway to melon 01    (stairway to melon).
lt chasm
takes place in a square room with four opponents that must
be tagged for points. a chasm in the center of the room must
be avoided and shield pick-ups exist that the player must
seekavoid arena is a 3d room containing
jump to reach.
apples and lemons. the player must pick up the apples
stairway to melon o   ers the
whilst avoiding the lemons.
player two options; the player can either collect a set of
small rewards (apples) or they can opt to take a punishment
(lemon) in order to reach a melon which results in a higher
net reward.

the pathnet architecture used for labyrinth was identical
to the one used for atari with the exception of a module-
duplication mechanism.
in the previous models there has
not been any actual copying of parameters, only copying of
views over a    xed set of parameters. in the labyrinth model
we enabled pathnet to copy the weights of modules to other
modules within the same layer, emulating net2net [3] or a
distillation [9] like operation. to aid this, we measure the
extent to which a module contributes to the    tness of all
the paths it is in by taking a sliding mean over the    tness of
any path which contains that module. using this measure
it is possible to bias a weight-copying operator such that
currently more globally useful modules are more likely to be
copied across into other modules and hence into other paths.
the hyperparameter module duplication rate determines the
rate at which modules would be allowed to duplicate them-
selves. for the labyrinth games both the    rst and second
tasks were trained for 40m timesteps.

3. results
3.1 binary mnist classi   cation

figure 3 shows that with pathnet, learning a source mnist
classi   cation task helps speed up learning in the target mnist
classi   cation task (mean time to solution = 167 genera-
tions); greater than the speedup achievable by    ne-tuning
a    xed path that had initially been trained on the source
task (mean time to solution = 229), and also compared to
de novo learning of the target task from scratch (mean time
to solution = 195). pathnet (bottom graph) learns in fewer
generations with less data than both the    ne-tuning (mid-
dle) and independent learning controls (top). the control
networks consisted of exactly the same learning algorithm,
but with no evolution of paths, and only one    xed maximum
size pathway through the network. the total speedup ratio
compared to the independent controls was 1.18.

videos showing performance of pathnet can be obtained
online at https://goo.gl/ovhmjo. they reveal that the
modules in early layers of the big network converge in the
population of pathways the quickest, followed by later lay-
ers, there being much more exploration and training of all
the modules in the    nal layer. many modules in the    nal
layer contribute to high    tness, whereas only a few modules
in the    rst layer do so. thus, a population provides an el-
egant solution to the exploration /exploitation trade-o    in

a layer speci   c manner. analysis did not reveal that the
speedup ratio was correlated with path overlap as measured
by the number of modules in the original optimal path that
were present in the population of paths at the end of the
second task. this suggests that speedup can be obtained
by pathnet both determining when there should be overlap
and when there should not be overlap. the fact that on
average    ne-tuning is slower than independent task learning
in mnist binary classi   cation tasks implies that generally
overlap would not be expected to provide speedup. thus,
pathnet can be seen to have done its job by controlling the
amount of overlap properly, see figure 4

3.2 cifar and svhn

in this experiment we compare only the accuracy path-
net obtains after a short    xed number of 500 generations. a
fully connected network of this size is generally insu   cient
to perform well on these datasets. after 500 generations,
when learning from scratch with pathnet, csvhn and ci-
far are learned to 25.5% and 35.3% accuracy on average,
see figure 5. but after the    rst task has been learned to this
accuracy, learning the second task is faster, so when csvhn
and cifar are learned as the second task with pathnet,
then accuracies of 35.7% and 39.8% are achieved respec-
tively. thus, both csvhn and cifar are learned faster
with pathnet when learned second rather than    rst.
3.3 atari games

transfer performance on pathnet is compared with    xed
maximum-size-path de novo training and    ne-tuning con-
trols for which a hyperparameter sweep was conducted in-
volving learning rates [0.001,0.0005,0.0001] and id178 costs
[0.01, 0.001, 0.0001]. the following hyperparameters were
investigated for pathnet: evaluation time t [1,10,50], mu-
tation rate [0.1, 0.01, 0.001] and tournament size b [2, 10,
20].

in figure 6 the performance of pathnet (blue) is com-
pared with independent and    ne-tuning controls (green) on
4 target games, having learned riverraid    rst. in all cases
the top 5 runs of a hyperparameter search are shown. we
generally found that strong selection with tournament sizes
of b = 10, t = 10 game episodes per evaluation, and low
mutation rates of 0.01-0.001 were optimal, allowing rapid
convergence of paths to a single path, followed by explo-
ration of small variants to a path, thus focusing learning on
a few parameters, with occasional exploration of novel by-
passes. pathnet is superior to controls in these 4 cases.

figure 7 shows that pathnet is on average superior to
independent learning and    ne-tuning over the atari games
we investigated. compared to a control of 1.0,    ne tun-
ing achieves a 1.16 speedup on average whereas pathnet
achieves a 1.33 times speedup. results for transfer on more
atari games can be seen in figure 12.

3.4 labyrinth games

pathnet transfer between the three labyrinth games lt chasm,

seekavoid arena and stairway to melon is compared with    xed
maximum-size-path de novo training and    ne-tuning con-
trols for which a hyperparameter sweep was conducted in-
volving mutation rates [ 0.1, 0.01, 0.001], module duplication

rate [ 0.0, 0.05, 0.1, 0.5] (per episode completed by worker 0)
and tournament size b [2, 10]. the learning rate was    xed
at 0.001, id178 cost at 0.0001 and evaluation time t at 13.

figure 9 shows the mean of the training performance for
the top 5 experiments for both pathnet and the    xed-path
controls. each row represents a di   erent source game and
each column a di   erent target game. where the source game
and target game are the same the graph shows the results
of learning the game de novo from scratch. figure 11 shows
that in some cases the module duplication operation pro-
duces improved performance compared to standard path-
net.

in several cases (transfer to lt chasm and transfer from
lt chasm to seekavoid arena) pathnet learns the second task
faster than    ne-tuning. interestingly, pathnet also performs
better than    ne-tuning when learning stairway to melon and
seekavoid arena from scratch.

results of the best runs from a hyperparameter search are
summarized in figure 10. here performance is evaluated by
measuring the area under the learning curve (average score
per episode during training), rather than    nal score. the
numbers in the table show the relative performance of an
architecture learning a target task (each column) compared
with an independent baseline with a    xed maximum size
path trained from scratch only on the target task. the con-
trols are labelled as    fixed path de novo from scratch    (top
row) and is 1 for each column (target task). a ratio in a col-
umn >1 represents the speedup when learning that column   s
target task, and <1 is a slowdown. the three rows below
the de novo control show the    ne-tuning results between
the three games. the    rst row in the pathnet results show
performance learning the individual games from scratch and
the three rows below that show the pathnet transfer results
between the three games.

on transferring to lt chasm both    ne-tuning and path-
net perform worse than the control de novo learning. on
the the other two games both exhibit positive transfer per-
formance. the average performance ratio for    ne-tuning for
transfer across all the game combinations is 1.00 (2 d.p.), es-
sentially no faster than learning from scratch. the average
performance ratio for pathnet is 1.26 (2 d.p.); largely due
to the good performance transferring from seekavoid arena
to stairway to melon.

we also compared pathnet to independent and    ne-tuning
controls over the same sweep of 243 hyperparameters as used
in the atari experiments described above. on the labyrinth
level seekavoid arena in which the agent must collect apples
but avoid lemons we found that the pathnet had signif-
icantly higher mean performance than control runs, both
when learning seekavoid arena from scratch compared to the
de novo controls, and for relearning from the same task,
compared to    ne-tuning from a network that had previously
learned seekavoid arena, see figure 8.

4. conclusion

pathnet extends our original work on the path evolu-
tion algorithm [4] to deep learning whereby the weights

and biases of the network are learned by id119,
but evolution determines which subset of parameters is to
be trained. we have shown that pathnet is capable of sus-
taining id21 on at least four tasks in both the
supervised and id23 settings.

pathnet may be thought of as implementing a form of
   evolutionary dropout    in which instead of randomly drop-
ping out units and their connections, dropout samples or
   thinned networks    are evolved [21]. pathnet has the added
advantage that dropout frequency is emergent, because the
population converges faster at the early layers of the net-
work than in the later layers. pathnet also resembles    evo-
lutionary swapout    [20], in fact we have experimented with
having standard linear modules, skip modules and residual
modules in the same layer and found that path evolution
was capable of discovering e   ective structures within this
diverse network. pathnet is related also to recent work on
convolutional neural fabrics, but there the whole network is
always used and so the principle cannot scale to giant net-
works [18]. other approaches to combining evolution and
learning have involved parameter copying, whereas there is
no such copying in the current implementation of pathnet
[1][3].

whilst we have only demonstrated pathnet in a fairly
small network, the principle can scale to much larger neu-
ral networks with more e   cient implementations of pathway
gating. this will allow extension to multiple tasks. we also
wish to try pathnet on other rl tasks which may be more
suitable for id21 than atari, for example con-
tinuous robotic control problems. further investigation is
required to understand the extent to which pathnet may be
superior to using    xed paths. firstly, a possibility is that
mutable paths provide a more useful form of diverse explo-
ration in rl tasks [15]. secondly, it is possible that a larger
number of workers can be used in a3c because if each worker
can determine which parameters to update, there may be se-
lection for pathways that do not interfere with each other.

we are still investigating the potential bene   ts of module

duplication. see supplementary video https://goo.gl/ovhmjo.
using this measure it is possible to bias the mutation oper-
ator such that currently more globally useful modules are
more likely to be slotted into other paths. further work is
also to be carried out in id72 which has not
yet been addressed in this paper.

finally, it is always possible and sometimes desirable to
replace evolutionary variation operators with variation op-
erators learned by id23. a tournament se-
lection algorithm with mutation is only the simplest way to
achieve adaptive paths. it is clear that more sophisticated
methods such as id189 may be used to
learn the distribution of pathways as a function of the long
term returns obtained by paths, and as a function of a task
description input. this may be done through a softer form of
gating than used by pathnet here. furthermore, a popula-
tion (ensemble) of soft gate matrices may be maintained and
an rl algorithm may be permitted to    mutate    these values.

the operations of pathnet resemble those of the basal
ganglia, which we propose determines which subsets of the

cortex are to be active and trainable as a function of goal/sub-
goal signals from the prefrontal cortex, a hypothesis related
to others in the literature [8] [14] [6].

5. acknowledgments

thanks to hubert soyer, arka pal, gabriel dulac-arnold,

gabriel barth-maron, matteo hessel, alban rustrani, stephen
ga   ney, joel leibo, eors szathmary

6. references
[1] j. e. auerbach, c. fernando, and d. floreano. online

extreme evolutionary learning machines. in arti   cial
life 14: proceedings of the fourteenth international
conference on the synthesis and simulation of living
systems, number epfl-conf-200273, pages
465   472. the mit press, 2014.

[2] r. caruana. multitask learning. in learning to learn,

pages 95   133. springer, 1998.

[14] r. c. o   reilly and m. j. frank. making working

memory work: a computational model of learning in
the prefrontal cortex and basal ganglia. neural
computation, 18(2):283   328, 2006.

[15] i. osband, c. blundell, a. pritzel, and b. van roy.

deep exploration via bootstrapped id25. arxiv
preprint arxiv:1602.04621, 2016.

[16] m. b. ring. continual learning in reinforcement
environments. phd thesis, university of texas at
austin, 1994.

[17] a. a. rusu, n. c. rabinowitz, g. desjardins,

h. soyer, j. kirkpatrick, k. kavukcuoglu, r. pascanu,
and r. hadsell. progressive neural networks. arxiv
preprint arxiv:1606.04671, 2016.

[18] s. saxena and j. verbeek. convolutional neural
fabrics. arxiv preprint arxiv:1606.02492, 2016.

[19] n. shazeer, a. mirhoseini, k. maziarz, a. davis,

q. le, g. hinton, and j. dean. outrageously large
neural networks: a sparsely-gated mixture-of-experts
layer. 2017. [icar submission].

[3] t. chen, i. goodfellow, and j. shlens. net2net:

[20] s. singh, d. hoiem, and d. forsyth. swapout:

accelerating learning via knowledge transfer. arxiv
preprint arxiv:1511.05641, 2015.

learning an ensemble of deep architectures. arxiv
preprint arxiv:1605.06465, 2016.

[4] c. fernando, v. vasas, e. szathm  ary, and

[21] n. srivastava, g. e. hinton, a. krizhevsky,

i. sutskever, and r. salakhutdinov. dropout: a simple
way to prevent neural networks from over   tting.
journal of machine learning research,
15(1):1929   1958, 2014.

[22] m. e. taylor and p. stone. an introduction to

intertask transfer for id23. ai
magazine, 32(1):15, 2011.

p. husbands. evolvable neuronal paths: a novel basis
for information and search in the brain. plos one,
6(8):e23534, 2011.

[5] c. t. fernando, e. szathmary, and p. husbands.
selectionist and evolutionary approaches to brain
function: a critical appraisal. frontiers in
computational neuroscience, 6:24, 2012.

[6] m. j. frank, b. loughry, and r. c. o  a   a  zreilly.

interactions between frontal cortex and basal ganglia
in working memory: a computational model.
cognitive, a   ective, & behavioral neuroscience,
1(2):137   160, 2001.

[7] i. harvey. the microbial genetic algorithm. in

advances in arti   cial life. darwin meets von
neumann, pages 126   133. springer, 2011.

[8] t. e. hazy, m. j. frank, and r. c. o   reilly. towards

an executive without a homunculus: computational
models of the prefrontal cortex/basal ganglia system.
philosophical transactions of the royal society b:
biological sciences, 362(1485):1601   1613, 2007.

[9] g. hinton, o. vinyals, and j. dean. distilling the

knowledge in a neural network. arxiv preprint
arxiv:1503.02531, 2015.

[10] m. jaderberg, v. mnih, w. m. czarnecki, t. schaul,

j. z. leibo, d. silver, and k. kavukcuoglu.
id23 with unsupervised auxiliary
tasks. arxiv preprint arxiv:1611.05397, 2016.

[11] y. lecun, l. bottou, y. bengio, and p. ha   ner.

gradient-based learning applied to document
recognition. proceedings of the ieee,
86(11):2278   2324, 1998.

[12] v. mnih, a. p. badia, m. mirza, a. graves, t. p.

lillicrap, t. harley, d. silver, and k. kavukcuoglu.
asynchronous methods for deep reinforcement
learning. arxiv preprint arxiv:1602.01783, 2016.

[13] y. netzer, t. wang, a. coates, a. bissacco, b. wu,
and a. y. ng. reading digits in natural images with
unsupervised id171.

figure 1: a population of randomly initialized pathways (purple lines in box 1) are evolved whilst learning task a, pong. at
the end of training, the best pathway is    xed (dark red lines in box 5) and a new population of paths are generated (light
blue lines in box 5) for task b. this population is then trained on alien and the optimal pathway that is evolved on alien is
subsequently    xed at the end of training, shown as dark blue lines in box 9.

1234567898e7 steps16e7 stepspongalienscorefigure 2: the pathnet used for learning atari and labyrinth games consists of a 4 layer network with 10 (or sometimes 15)
modules in each layer. the    rst three layers    modules are convolutional 2d kernels with 8 kernels per module (green boxes
in    gure), kernel sizes (8, 4, 3), and strides (4, 2, 1) from 1st to 3rd layers respectively, and with the    nal layer consisting of
fully connected linear layers of 50 neurons each (purple boxes). after each module there is a recti   ed linear unit. between
layers the feature maps are summed before being passed to the modules of the subsequent layer (blue boxes). typically a
maximum of 4 modules per layer are permitted to be included in a pathway (shown as red boxes), otherwise evolution would
simply grow the pathway to include the whole network as this would improve    tness by growing the number of parameters
that can be tuned by learning.

figure 3: pathnet is capable of supporting id21 in binary mnist classi   cation. the top    gure shows c1 +
c2 which is the sum of learning times over the source and target tasks required to learn both tasks to 0.998 accuracy, with
a separate maximum sized    xed path for each task, and thus constitutes the independent learning control; mean = 195
generations. the middle    gure shows c1 + c2|c1, which is the time required to learn both tasks where the second task is
not learned from scratch, but by    ne tuning the same maximum sized    xed path as was used to learn the    rst task; mean
= 229 generations. the bottom graph shows the sum of times required to learn the source and target tasks using pathnet;
mean = 167 generations.

figure 4: overlap (y-axis) is not correlated with speedup ratio (c1 + c2)/(p1 + p2|p1) suggesting that pathnet discovers
how much overlap to use based on whether the tasks could bene   t from overlap or not.

c1 + c2c1 +c2|c1p1 + p2|p1frequencygenerations to achieve 0.998 accuracy independent controlfine-tuning controlpathnet speedup ratio overlap measurefigure 5: top graph shows a histogram of accuracies when learning csvhn    rst and cifar second. the bottom graph shows
a histogram of accuracies when learning cifar    rst and csvhn second. learning either task second with pathnet results
in improved performance, suggesting that pathnet is able to use weights in the optimal path found in task a, when learning
task b.

= csvhn= cifarcsvhn     cifarcifar     csvhn correct classifications out of test set of size 1000frequency figure 6: pathnet shows positive transfer from river raid to centipede, boxing, hero and james bond. the graphs show the
reward over the    rst 40 million steps of training. blue shows the results from the best    ve hyperparameter settings of pathnet
out of 243. compare these to the best    ve hyperparameter setting runs for independent learning (red) and    ne-tuning (green)
controls out of 45.

figure 7: we report results by showing the best run from a hyperparameter search. performance is evaluated by measuring
the area under the learning curve (average score per episode during training), rather than    nal score. the transfer score is then
de   ned as the relative performance of an architecture compared with a independent baseline (control) with a    xed maximum
size path, trained only on the target task (top row). this ratio is >1 if there is speedup, and <1 if there is slowdown. we
present transfer score curves for selected source-target games, and summarize all such pairs in this transfer matrix. the next
3 rows show    ne-tuning controls, and the    nal three rows show pathnet. green means positive transfer, and blue means
negative transfer.

figure 8: pathnet outperforms the de novo control and the    ne-tuning control on learning seekavoid arena for the    rst time,
on average over all hyperparameters explored, out of 243 experiments. it also outperforms    ne tuning when seekavoid arena
[10] is learned a second time, with a new value and policy readout, with the same set of 243 hyperparameter settings.

deepgrowalienasterixboxingcentipedegopherherojamesbondkrullroad_runnerrobotankstar_gunner wizard_of_worpathnetfine-tuningde novo pathnetcontrolpathnetcontrolfigure 9: means of the best 5 (out of a size 24 parameter sweep) training runs for pathnet compared with the    ne-tuning
(o    diagonal) and independent path (diagonal) controls for the three labyrinth levels considered. the diagonal results show
the performance of pathnet when learning from scratch compared to the independent    xed path control. o   -diagonal results
show the performance of pathnet during transfer.

figure 10: results of the best runs from a hyperparameter search. the numbers in the table show the relative performance of
an architecture learning a target task compared with an independent baseline with a    xed maximum size path trained from
scratch only on the target task. a number >1 (green) represents improved performance and <1 (blue) is worse performance.
the top row (   fixed path de novo from scratch   ) are the controls, i.e. the performance of the    xed-path network learning the
target task (each column) from scratch. the rows below show    xed-path performance on    ne-tuning and pathnet, learning
de novo from scratch, and pathnet performance transferring from task a to task b.

figure 11: the contribution of module duplication on performance. graphs show the mean performance across all hyperpa-
rameters for pathnet with di   erent module duplication rates [0, 0.05. 0.1, 0.5] per episode completed by worker 0. for some
tasks (e.g. learning seekavoid arena module duplication has been bene   cial.

figure 12: transfer results on various atari games. the graphs show the reward over the    rst 40 million steps of training.
blue shows the results from the best    ve hyperparameter settings of pathnet out of 243. compare these to the best    ve
hyperparameter setting runs for independent learning (red) and    ne-tuning (green) controls out of 45.

