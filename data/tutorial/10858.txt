assessing the ability of lstms to learn syntax-sensitive dependencies

tal linzen1,2

emmanuel dupoux1

lscp1 & ijn2, cnrs,

ehess and ens, psl research university

{tal.linzen,

emmanuel.dupoux}@ens.fr

6
1
0
2

 

v
o
n
4

 

 
 
]
l
c
.
s
c
[
 
 

1
v
8
6
3
1
0

.

1
1
6
1
:
v
i
x
r
a

abstract

the success of
long short-term memory
(lstm) neural networks in language process-
ing is typically attributed to their ability to
capture long-distance statistical regularities.
linguistic regularities are often sensitive to
syntactic structure; can such dependencies be
captured by lstms, which do not have ex-
plicit structural representations? we begin ad-
dressing this question using number agreement
in english subject-verb dependencies. we
probe the architecture   s grammatical compe-
tence both using training objectives with an
explicit grammatical target (number prediction,
grammaticality judgments) and using language
models. in the strongly supervised settings,
the lstm achieved very high overall accu-
racy (less than 1% errors), but errors increased
when sequential and structural information con-
   icted. the frequency of such errors rose
sharply in the language-modeling setting. we
conclude that lstms can capture a non-trivial
amount of grammatical structure given targeted
supervision, but stronger architectures may be
required to further reduce errors; furthermore,
the id38 signal is insuf   cient
for capturing syntax-sensitive dependencies,
and should be supplemented with more direct
supervision if such dependencies need to be
captured.

1

introduction

recurrent neural networks (id56s) are highly effec-
tive models of sequential data (elman, 1990). the
rapid adoption of id56s in nlp systems in recent
years, in particular of id56s with gating mecha-
nisms such as long short-term memory (lstm) units

yoav goldberg

computer science department

bar ilan university

yoav.goldberg@gmail.com

(hochreiter and schmidhuber, 1997) or gated recur-
rent units (gru) (cho et al., 2014), has led to sig-
ni   cant gains in id38 (mikolov et al.,
2010; sundermeyer et al., 2012), parsing (vinyals
et al., 2015; kiperwasser and goldberg, 2016; dyer
et al., 2016), machine translation (bahdanau et al.,
2015) and other tasks.

the effectiveness of id56s1 is attributed to their
ability to capture statistical contingencies that may
span an arbitrary number of words. the word france,
for example, is more likely to occur somewhere in
a sentence that begins with paris than in a sentence
that begins with penguins. the fact that an arbitrary
number of words can intervene between the mutually
predictive words implies that they cannot be captured
by models with a    xed window such as id165 mod-
els, but can in principle be captured by id56s, which
do not have an architecturally    xed limit on depen-
dency length.

id56s are sequence models: they do not explicitly
incorporate syntactic structure. indeed, many word
co-occurrence statistics can be captured by treating
the sentence as an unstructured list of words (paris-
france); it is therefore unsurprising that id56s can
learn them well. other dependencies, however, are
sensitive to the syntactic structure of the sentence
(chomsky, 1965; everaert et al., 2015). to what
extent can id56s learn to model such phenomena
based only on sequential cues?

previous research has shown that id56s (in particu-
lar lstms) can learn arti   cial context-free languages
(gers and schmidhuber, 2001) as well as nesting and

1in this work we use the term id56 to refer to the entire
class of sequential recurrent neural networks. instances of the
class include id137 (lstm) and the
simple recurrent network (srn) due to elman (1990).

indentation in a programming language (karpathy et
al., 2016). the goal of the present work is to probe
their ability to learn natural language hierarchical
(syntactic) structures from a corpus without syntactic
annotations. as a    rst step, we focus on a particular
dependency that is commonly regarded as evidence
for hierarchical structure in human language: english
subject-verb agreement, the phenomenon in which
the form of a verb depends on whether the subject
is singular or plural (the kids play but the kid plays;
see additional details in section 2). if an id56-based
model succeeded in learning this dependency, that
would indicate that it can learn to approximate or
even faithfully implement syntactic structure.

our main interest is in whether lstms have the
capacity to learn structural dependencies from a nat-
ural corpus. we therefore begin by addressing this
question under the most favorable conditions: train-
ing with explicit supervision. in the setting with the
strongest supervision, which we refer to as the num-
ber prediction task, we train it directly on the task of
guessing the number of a verb based on the words that
preceded it (sections 3 and 4). we further experiment
with a grammaticality judgment training objective, in
which we provide the model with full sentences an-
notated as to whether or not they violate subject-verb
number agreement, without an indication of the locus
of the violation (section 5). finally, we trained the
model without any grammatical supervision, using
a id38 objective (predicting the next
word).

our quantitative results (section 4) and qualitative
analysis (section 7) indicate that most naturally oc-
curring agreement cases in the wikipedia corpus are
easy: they can be resolved without syntactic informa-
tion, based only on the sequence of nouns preceding
the verb. this leads to high overall accuracy in all
models. most of our experiments focus on the super-
vised number prediction model. the accuracy of this
model was lower on harder cases, which require the
model to encode or approximate structural informa-
tion; nevertheless, it succeeded in recovering the ma-
jority of agreement cases even when four nouns of the
opposite number intervened between the subject and
the verb (17% errors). baseline models failed spec-
tacularly on these hard cases, performing far below
chance levels. fine-grained analysis revealed that
mistakes are much more common when no overt cues

to syntactic structure (in particular function words)
are available, as is the case in noun-noun compounds
and reduced relative clauses. this indicates that the
number prediction model indeed managed to capture
a decent amount of syntactic knowledge, but was
overly reliant on function words.

error rates increased only mildly when we
switched to more indirect supervision consisting only
of sentence-level grammaticality annotations without
an indication of the crucial verb. by contrast, the
language model trained without explicit grammati-
cal supervision performed worse than chance on the
harder agreement prediction cases. even a state-of-
the-art large-scale language model (jozefowicz et
al., 2016) was highly sensitive to recent but struc-
turally irrelevant nouns, making more than    ve times
as many mistakes as the number prediction model on
these harder cases. these results suggest that explicit
supervision is necessary for learning the agreement
dependency using this architecture, limiting its plau-
sibility as a model of child id146 (el-
man, 1990). from a more applied perspective, this
result suggests that for tasks in which it is desirable to
capture syntactic dependencies (e.g., machine trans-
lation or language generation), id38
objectives should be supplemented by supervision
signals that directly capture the desired behavior.

2 background: subject-verb agreement

as evidence for syntactic structure

the form of an english third-person present tense
verb depends on whether the head of the syntactic
subject is plural or singular:2

(1)

the key is on the table.

a.
b. *the key are on the table.
c. *the keys is on the table.
d.

the keys are on the table.

while in these examples the subject   s head is adjacent
to the verb, in general the two can be separated by
some sentential material:3

2 identifying the head of the subject is typically straightfor-
ward. in what follows we will use the shorthand    the subject    to
refer to the head of the subject.

3in the examples, the subject and the corresponding verb
are marked in boldface, agreement attractors are underlined and
intervening nouns of the same number as the subject are marked
in italics. asterisks mark unacceptable sentences.

(2)

the keys to the cabinet are on the table.

given a syntactic parse of the sentence and a verb, it
is straightforward to identify the head of the subject
that corresponds to that verb, and use that information
to determine the number of the verb (figure 1).

root

nsubj

pobj
det

det

prep

prep

pobj
det

the keys to the cabinet are on the table

figure 1: the form of the verb is determined by
the head of the subject, which is directly connected
to it via an nsubj edge. other nouns that intervene
between the head of the subject and the verb (here
cabinet is such a noun) are irrelevant for determining
the form of the verb and need to be ignored.

by contrast, models that are insensitive to structure
may run into substantial dif   culties capturing this de-
pendency. one potential issue is that there is no limit
to the complexity of the subject np, and any number
of sentence-level modi   ers and parentheticals   and
therefore an arbitrary number of words   can appear
between the subject and the verb:

(3)

the building on the far right that   s quite old
and run down is the kilgore bank building.

this property of the dependency entails that it can-
not be captured by an id165 model with a    xed n.
id56s are in principle able to capture dependencies
of an unbounded length; however, it is an empirical
question whether or not they will learn to do so in
practice when trained on a natural corpus.

a more fundamental challenge that the depen-
dency poses for structure-insensitive models is the
possibility of agreement attraction errors (bock and
miller, 1991). the correct form in (3) could be se-
lected using simple heuristics such as    agree with
the most recent noun   , which are readily available to
sequence models. in general, however, such heuris-
tics are unreliable, since other nouns can intervene
between the subject and the verb in the linear se-
quence of the sentence. those intervening nouns can
have the same number as the subject, as in (4), or the
opposite number as in (5)-(7):

(4)

(5)

(6)
(7)

alluvial soils carried in the    oodwaters add
nutrients to the    oodplains.
the only championship banners that are cur-
rently displayed within the building are for
national or ncaa championships.
the length of the forewings is 12-13.
yet the ratio of men who survive to the
women and children who survive is not clear
in this story.

intervening nouns with the opposite number from the
subject are called agreement attractors. the potential
presence of agreement attractor entails that the model
must identify the head of the syntactic subject that
corresponds to a given verb in order to choose the
correct in   ected form of that verb.

given the dif   culty in identifying the subject from
the linear sequence of the sentence, dependencies
such as subject-verb agreement serve as an argument
for structured syntactic representations in humans
(everaert et al., 2015); they may challenge models
such as id56s that do not have pre-wired syntac-
tic representations. we note that subject-verb num-
ber agreement is only one of a number of structure-
sensitive dependencies; other examples include nega-
tive polarity items (e.g., any) and re   exive pronouns
(herself ). nonetheless, a model   s success in learning
subject-verb agreement would be highly suggestive
of its ability to master hierarchical structure.

3 the number prediction task

to what extent can a sequence model learn to be sensi-
tive to the hierarchical structure of natural language?
to study this question, we propose the number pre-
diction task. in this task, the model sees the sentence
up to but not including a present-tense verb, e.g.:

(8)

the keys to the cabinet

it then needs to guess the number of the following
verb (a binary choice, either plural or singular).
we examine variations on this task in section 5.

in order to perform well on this task, the model
needs to encode the concepts of syntactic number
and syntactic subjecthood: it needs to learn that some
words are singular and others are plural, and to be
able to identify the correct subject. as we have illus-

trated in section 2, correctly identifying the subject
that corresponds to a particular verb often requires
sensitivity to hierarchical syntax.

data: an appealing property of the number predic-
tion task is that we can generate practically unlimited
training and testing examples for this task by query-
ing a corpus for sentences with present-tense verbs,
and noting the number of the verb. importantly, we
do not need to correctly identify the subject in order
to create a training or test example. we generated a
corpus of    1.35 million number prediction problems
based on wikipedia, of which    121,500 (9%) were
used for training,    13,500 (1%) for validation, and
the remaining    1.21 million (90%) were reserved
for testing.4 the large number of test sentences was
necessary to ensure that we had a good variety of test
sentences representing less common constructions
(see section 4).5

model and baselines: we encode words as one-
hot vectors: the model does not have access to the
characters that make up the word. those vectors are
then embedded into a 50-dimensional vector space.
an lstm with 50 hidden units reads those embed-
ding vectors in sequence; the state of the lstm at
the end of the sequence is then fed into a logistic
regression classi   er. the network is trained6 in an
end-to-end fashion, including the id27s.7
to isolate the effect of syntactic structure, we also
consider a baseline which is exposed only to the
nouns in the sentence, in the order in which they
appeared originally, and is then asked to predict the
number of the following verb. the goal of this base-

4we limited our search to sentences that were shorter than
50 words. whenever a sentence had more than one subject-verb
dependency, we selected one of the dependencies at random.

5code and data are available at http://tallinzen.

net/projects/lstm_agreement.

6the network was optimized using adam (kingma and ba,
2015) and early stopping based on validation set error. we
trained the number prediction model 20 times with different
random initializations, and report accuracy averaged across all
runs. the models described in sections 5 and 6 are based on 10
runs, with the exception of the language model, which is slower
to train and was trained once.

7the size of the vocabulary was capped at 10000 (after low-
ercasing). infrequent words were replaced with their part of
speech (id32 tagset, which explicitly encodes number
distinctions); this was the case for 9.6% of all tokens and 7.1%
of the subjects.

line is to withhold the syntactic information carried
by function words, verbs and other parts of speech.
we explore two variations on this baseline: one that
only receives common nouns (dogs, pipe), and an-
other that also receives pronouns (he) and proper
nouns (france). we refer to these as the noun-only
baselines.

4 number prediction results
overall accuracy: accuracy was very high over-
all: the system made an incorrect number prediction
only in 0.83% of the dependencies. the noun-only
baselines performed signi   cantly worse: 4.2% errors
for the common-nouns case and 4.5% errors for the
all-nouns case. this suggests that function words,
verbs and other syntactically informative elements
play an important role in the model   s ability to cor-
rectly predict the verb   s number. however, while the
noun-only baselines made more than four times as
many mistakes as the number prediction system, their
still-low absolute error rate indicates that around 95%
of agreement dependencies can be captured based
solely on the sequence of nouns preceding the verb.
this is perhaps unsurprising: sentences are often
short and the verb is often directly adjacent to the sub-
ject, making the identi   cation of the subject simple.
to gain deeper insight into the syntactic capabilities
of the model, then, the rest of this section investigates
its performance on more challenging dependencies.8

distance: we    rst examine whether the network
shows evidence of generalizing to dependencies
where the subject and the verb are far apart. we focus
in this analysis on simpler cases where no nouns in-
tervened between the subject and the verb. as figure
2a shows, performance did not degrade considerably
when the distance between the subject and the verb
grew up to 15 words (there were very few longer
dependencies). this indicates that the network gen-
eralized the dependency from the common distances
of 0 and 1 to rare distances of 10 and more.

agreement attractors: we next examine how the
model   s error rate was affected by nouns that inter-
vened between the subject and the verb in the linear

8these properties of the dependencies were identi   ed by
parsing the test sentences using the parser described in goldberg
and nivre (2012).

(a)

(d)

(b)

(c)

(e)

(f)

figure 2: (a-d) error rates of the lstm number prediction model as a function of: (a) distance between
the subject and the verb, in dependencies that have no intervening nouns; (b) presence and number of last
intervening noun; (c) count of attractors in dependencies with homogeneous intervention; (d) presence of
a relative clause with and without an overt relativizer in dependencies with homogeneous intervention and
exactly one attractor. all error bars represent 95% binomial con   dence intervals.

(e-f) additional plots: (e) count of attractors per dependency in the corpus (note that the y-axis is on a log

scale); (f) embeddings of singular and plural nouns, projected onto their    rst two principal components.

order of the sentence. we    rst focus on whether or
not there were any intervening nouns, and if there
were, whether the number of the subject differed
from the number of the last intervening noun   the
type of noun that would trip up the simple heuristic
of agreeing with the most recent noun.

as figure 2b shows, a last intervening noun of the
same number as the subject increased error rates only
moderately, from 0.4% to 0.7% in singular subjects
and from 1% to 1.4% in plural subjects. on the other
hand, when the last intervening noun was an agree-
ment attractor, error rates increased by almost an
order of magnitude (to 6.5% and 5.4% respectively).
note, however, that even an error rate of 6.5% is
quite impressive considering uninformed strategies
such as random guessing (50% error rate), always
assigning the more common class label (32% error
rate, since 32% of the subjects in our corpus are plu-
ral) and the number-of-most-recent-noun heuristic
(100% error rate). the noun-only lstm baselines
performed much worse in agreement attraction cases,
with error rates of 46.4% (common nouns) and 40%
(all nouns).

we next tested whether the effect of attractors is
cumulative, by focusing on dependencies with multi-
ple attractors. to avoid cases in which the effect of
an attractor is offset by an intervening noun with the
same number as the subject, we restricted our search
to dependencies in which all of the intervening nouns
had the same number, which we term dependencies
with homogeneous intervention. for example, (9) has
homogeneous intervention whereas (10) does not:

(9)

the roses in the vase by the door are red.

(10)

the roses in the vase by the chairs are red.

figure 2c shows that error rates increased gradually
as more attractors intervened between the subject and
the verb. performance degraded quite slowly, how-
ever: even with four attractors the error rate was only
17.6%. as expected, the noun-only baselines per-
formed signi   cantly worse in this setting, reaching
an error rate of up to 84% (worse than chance) in the
case of four attractors. this con   rms that syntactic
cues are critical for solving the harder cases.

2468101214distance (no intervening nouns)0%10%20%30%40%50%error rateplural subjectsingular subject0%5%10%15%20%error ratelast intervening nounnonepluralsingular01234count of attractors0%20%40%60%80%100%error ratebaseline(common nouns)numberpredictionmajority classrandom guessno relative clausewith relativizerwithout relativizer0%20%40%60%80%100%error ratemajorityrandom01234567count of attractors100101102103104105106107count of dependenciesallhomongeneous21012pc10.60.00.6pc2pluralsingularrelative clauses: we now look in greater detail
into the network   s performance when the words that
intervened between the subject and verb contained
a relative clause. relative clauses with attractors
are likely to be fairly challenging, for several rea-
sons. they typically contain a verb that agrees with
the attractor, reinforcing the misleading cue to noun
number. the attractor is often itself a subject of an
irrelevant verb, making a potential    agree with the
most recent subject    strategy unreliable. finally, the
existence of a relative clause is sometimes not overtly
indicated by a function word (relativizer), as in (11)
(for comparison, see the minimally different (12)):

(11)

(12)

the landmarks this article lists here are
also run-of-the-mill and not notable.

the landmarks that this article lists here
are also run-of-the-mill and not notable.

for data sparsity reasons we restricted our attention
to dependencies with a single attractor and no other
intervening nouns. as figure 2d shows, attraction
errors were more frequent in dependencies with an
overt relative clause (9.9% errors) than in dependen-
cies without a relative clause (3.2%), and consider-
ably more frequent when the relative clause was not
introduced by an overt relativizer (25%). as in the
case of multiple attractors, however, while the model
struggled with the more dif   cult dependencies, its
performance was much better than random guessing,
and slightly better than a majority-class strategy.

word representations: we explored the 50-
dimensional word representations acquired by the
model by performing a principal component anal-
ysis. we assigned a part-of-speech (pos) to each
word based on the word   s most common pos in the
corpus. we only considered relatively ambiguous
words, in which a single pos accounted for more
than 90% of the word   s occurrences in the corpus.
figure 2f shows that the    rst principal component
corresponded almost perfectly to the expected num-
ber of the noun, suggesting that the model learned
the number of speci   c words very well; recall that
the model did not have access during training to noun
number annotations or to morphological suf   xes such
as -s that could be used to identify plurals.

visualizing the network   s activations: we start
investigating the inner workings of the number pre-
diction network by analyzing its activation in re-
sponse to particular syntactic constructions. to sim-
plify the analysis, we deviate from our practice in the
rest of this paper and use constructed sentences.

we    rst constructed sets of sentence pre   xes based

on the following patterns:

(13)
(14)

pp: the toy(s) of the boy(s)...
rc: the toy(s) that the boy(s)...

these patterns differ by exactly one function word,
which determines the type of the modi   er of the main
clause subject: a prepositional phrase (pp) in the    rst
sentence and a relative clause (rc) in the second. in
pp sentences the correct number of the upcoming
verb is determined by the main clause subject toy(s);
in rc sentences it is determined by the embedded
subject boy(s).

we generated all four versions of each pattern, and
repeated the process ten times with different lexical
items (the house(s) of/that the girl(s), the computer(s)
of/that the student(s), etc.), for a total of 80 sentences.
the network made correct number predictions for all
40 pp sentences, but made three errors in rc sen-
tences. we averaged the word-by-word activations
across all sets of ten sentences that had the same com-
bination of modi   er (pp or rc),    rst noun number
and second noun number. plots of the activation of
all 50 units are provided in the appendix (figure
5). figure 3a highlights a unit (unit 1) that shows
a particularly clear pattern: it tracks the number of
the main clause subject throughout the pp modi   er,
resets when it reaches the relativizer that which intro-
duces the rc modi   er, and then switches to tracking
the number of the embedded subject.

to explore how the network deals with dependen-
cies spanning a larger number of words, we tracked
its activation during the processing of the following
two sentences:9

(15)

the houses of/that the man from the of   ce
across the street...

the network made the correct prediction for the pp

9we simpli   ed this experiment in light of the relative robust-
ness of the    rst experiment to lexical items and to whether each
of the nouns was singular or plural.

(a)

(b)

(c)

figure 3: word-by-word visualization of lstm activation: (a) a unit that correctly predicts the number of an
upcoming verb. this number is determined by the    rst noun (x) when the modi   er is a prepositional phrase
(pp) and by the second noun (y) when it is an object relative clause (rc); (b) the evolution of the predictions
in the case of a longer modi   er: the predictions correctly diverge at the embedded noun, but then incorrectly
converge again; (c) the activation of four representative units over the course of the same sentences.

but not the rc sentence (as before, the correct pre-
dictions are plural for pp and singular for rc).
figure 3b shows that the network begins by mak-
ing the correct prediction for rc immediately after
that, but then falters: as the sentence goes on, the
resetting effect of that diminishes. the activation
time courses shown in figure 3c illustrate that unit 1,
which identi   ed the subject correctly when the pre   x
was short, gradually forgets that it is in an embedded
clause as the pre   x grows longer. by contrast, unit
0 shows a stable capacity to remember the current
embedding status. additional representative units
shown in figure 3c are unit 46, which consistently
stores the number of the main clause subject, and
unit 27, which tracks the number of the most recent
noun, resetting at noun phrase boundaries.

while the interpretability of these patterns is en-
couraging, our analysis only scratches the surface
of the rich possibilities of a linguistically-informed
analysis of a neural network trained to perform a
syntax-sensitive task; we leave a more extensive in-
vestigation for future work.

5 alternative training objectives

the number prediction task followed a fully super-
vised objective, in which the network identi   es the
number of an upcoming verb based only on the words
preceding the verb. this section proposes three objec-
tives that modify some of the goals and assumptions
of the number prediction objective (see table 1 for
an overview).

verb in   ection: this objective is similar to num-
ber prediction, with one difference: the network re-
ceives not only the words leading up to the verb,
but also the singular form of the upcoming verb (e.g.,
writes). in practice, then, the network needs to decide
between the singular and plural forms of a particular
verb (writes or write). having access to the semantics
of the verb can help the network identify the noun
that serves as its subject without using the syntactic
subjecthood criteria. for example, in the following
sentence:

(16)

people from the capital often eat pizza.

thehousesthat/ofthemanfromtheofficeacrossthestreet0.00.51.0p(plural)pprcclass predictionsample input

training objective
number prediction the keys to the cabinet
verb in   ection
grammaticality
language model

training signal
plural
plural

prediction task
singular/plural?
singular/plural?

correct answer
plural
plural

the keys to the cabinet [is/are]
the keys to the cabinet are here. grammatical grammatical/ungrammatical? grammatical
the keys to the cabinet

p (are) > p (is)?

true

are

table 1: examples of the four training objectives and corresponding prediction tasks.

only people is a plausible subject for eat; the network
can use this information to infer that the correct form
of the verb is eat is rather than eats.

this objective is similar to the task that humans
face during language production: after the speaker
has decided to use a particular verb (e.g., write), he
or she needs to decide whether its form will be write
or writes (levelt et al., 1999; staub, 2009).

grammaticality judgments: the previous objec-
tives explicitly indicate the location in the sentence in
which a verb can appear, giving the network a cue to
syntactic clause boundaries. they also explicitly di-
rect the network   s attention to the number of the verb.
as a form of weaker supervision, we experimented
with a grammaticality judgment objective. in this sce-
nario, the network is given a complete sentence, and
is asked to judge whether or not it is grammatical.

to train the network, we made half of the examples
in our training corpus ungrammatical by    ipping the
number of the verb.10 the network read the entire
sentence and received a supervision signal at the end.
this task is modeled after a common human data col-
lection technique in linguistics (sch  utze, 1996), al-
though our training regime is of course very different
to the training that humans are exposed to: humans
rarely receive ungrammatical sentences labeled as
such (bowerman, 1988).

id38 (lm): finally, we experi-
mented with a word prediction objective, in which
the model did not receive any grammatically relevant
supervision (elman, 1990; elman, 1991). in this sce-
nario, the goal of the network is to predict the next
word at each point in every sentence. it receives un-
labeled sentences and is not speci   cally instructed to

10in some sentences this will not in fact result in an ungram-
matical sentence, e.g. with collective nouns such as group, which
are compatible with both singular and plural verbs in some di-
alects of english (huddleston and pullum, 2002); those cases
appear to be rare.

attend to the number of the verb. in the network that
implements this training scenario, id56 activation
after each word is fed into a fully connected dense
layer followed by a softmax layer over the entire
vocabulary.

we evaluate the knowledge that the network has
acquired about subject-verb noun agreement using
a task similar to the verb in   ection task. to per-
form the task, we compare the probabilities that the
model assigns to the two forms of the verb that in
fact occurred in the corpus (e.g., write and writes),
and select the form with the higher id203.11 as
this task is not part of the network   s training objec-
tive, and the model needs to allocate considerable
resources to predicting each word in the sentence, we
expect the lm to perform worse than the explicitly
supervised objectives.

results: when considering all agreement depen-
dencies, all models achieved error rates below 7%
(figure 4a); as mentioned above, even the noun-only
number prediction baselines achieved error rates be-
low 5% on this task. at the same time, there were
large differences in accuracy across training objec-
tives. the verb in   ection network performed slightly
but signi   cantly better than the number prediction
one (0.8% compared to 0.83% errors), suggesting
that the semantic information carried by the verb is
moderately helpful. the grammaticality judgment
objective performed somewhat worse, at 2.5% errors,
but still outperformed the noun-only baselines by a
large margin, showing the capacity of the lstm ar-
chitecture to learn syntactic dependencies even given
fairly indirect evidence.

the worst performer was the language model. it

11one could also imagine performing the equivalent of the
number prediction task by aggregating lm id203 mass over
all plural verbs and all singular verbs. this approach may be
more severely affected by part-of-speech ambiguous words than
the one we adopted; we leave the exploration of this approach to
future work.

(a)

(b)

(c)

(d)

(e)

.

figure 4: alternative tasks and additional experiments: (a) overall error rate across tasks (note that the y-axis
ends in 10%); (b) effect of count of attractors in homogeneous dependencies across training objectives; (c)
comparison of the google lm (jozefowicz et al., 2016) to our lm and one of our supervised verb in   ection
systems, on a sample of sentences; (d) number prediction: effect of count of attractors using srns with
standard training or lstm with targeted training; (e) number prediction: difference in error rate between
singular and plural subjects across id56 cell types. error bars represent binomial 95% con   dence intervals.

made eight times as many errors as the original num-
ber prediction network (6.78% compared to 0.83%),
and did substantially worse than the noun-only base-
lines (though recall that the noun-only baselines were
still explicitly trained to predict verb number).

the differences across the networks are more strik-
ing when we focus on dependencies with agreement
attractors (figure 4b). here, the language model
does worse than chance in the most dif   cult cases,
and only slightly better than the noun-only baselines.
the worse-than-chance performance suggests that
attractors actively confuse the networks rather than
cause them to make a random decision. the other
models degrade more gracefully with the number
of agreement attractors; overall, the grammaticality
judgment objective is somewhat more dif   cult than
the number prediction and verb in   ection ones. in
summary, we conclude that while the lstm is capa-
ble of learning syntax-sensitive agreement dependen-
cies under various objectives, the language-modeling
objective alone is not suf   cient for learning such de-
pendencies, and a more direct form of training signal

is required.
comparison to a large-scale language model:
one objection to our id38 result is
that our lm faced a much harder objective than
our other models   predicting a distribution over
10,000 vocabulary items is certainly harder than bi-
nary classi   cation   but was equipped with the same
capacity (50-dimensional hidden state and word vec-
tors). would the performance gap between the lm
and the explicitly supervised models close if we in-
creased the capacity of the lm?

we address this question using a very large pub-
licly available lm (jozefowicz et al., 2016), which
we refer to as the google lm.12 the google lm rep-
resent the current state-of-the-art in language mod-
eling: it is trained on a billion-word corpus (chelba
et al., 2013), with a vocabulary of 800,000 words.
it is based on a two-layer lstm with 8192 units in
each layer, or more than 300 times as many units
as our lm; at 1.04 billion parameters it has almost

12

https://github.com/tensorflow/models/

tree/master/lm_1b

number predictiongrammaticality judgmentsverb inflectionlanguage modelbaseline (common nouns)baseline (all nouns)0%2%4%6%8%10%overall error rate01234count of attractors0%20%40%60%80%100%error rategrammaticalityverb inflectionid38number predictionbaseline (all nouns)baseline (common nouns)majority classrandom guess01234count of attractors0%20%40%60%80%100%error rateour lmverb inflectiongoogle lmmajorityrandom01234count of attractors0%20%40%60%80%100%error ratelstmsrnlstm (targeted)majorityrandomnumber prediction01234count of attractors0%20%40%60%80%100%error ratemajorityrandomsingular subj.plural subj.lstm01234count of attractorsmajorityrandomsingular subj.plural subj.srn2000 times as many parameters. it is a    ne-tuned
language model that achieves impressive perplexity
scores on common benchmarks, requires a massive
infrastructure for training, and pushes the boundaries
of what   s feasible with current hardware.

we tested the google lm with the methodology
we used to test ours.13 due to computational resource
limitations, we did not evaluate it on the entire test
set, but sampled a random selection of 500 sentences
for each count of attractors (testing a single sentence
under the google lm takes around 5 seconds on
average). the results are presented in figure 4c,
where they are compared to the performance of the
supervised verb in   ection system. despite having an
order of magnitude more parameters and signi   cantly
larger training data, the google lm performed poorly
compared to the supervised models; even a single
attractor led to a sharp increase in error rate to 28.5%,
almost as high as our small-scale lm (32.6% on the
same sentences). while additional attractors caused
milder degradation than in our lm, the performance
of the google lm on sentences with four attractors
was still worse than always guessing the majority
class (singular).

in summary, our experiments with the google lm
do not change our conclusions: the contrast between
the poor performance of the lms and the strong per-
formance of the explicitly supervised objectives sug-
gests that direct supervision has a dramatic effect
on the model   s ability to learn syntax-sensitive de-
pendencies. given that the google lm was already
trained on several hundred times more data than the
number prediction system, it appears unlikely that
its relatively poor performance was due to lack of
training data.
6 additional experiments
comparison to simple
recurrent networks:
how much of the success of the network is due to
the lstm cells? we repeated the number prediction
experiment with a simple recurrent network (srn)
(elman, 1990), with the same number of hidden
units. the srn   s performance was inferior to the
lstm   s, but the average performance for a given

13one technical exception was that we did not replace low-
frequency words with their part-of-speech, since the google
lm is a large-vocabulary language model, and does not have
parts-of-speech as part of its vocabulary.

number of agreement attractors does not suggest a
qualitative difference between the cell types:
the
srn makes about twice as many errors as the lstm
across the board (figure 4d).

training only on dif   cult dependencies: only a
small proportion of the dependencies in the corpus
had agreement attractors (figure 2e). would the
network generalize better if dependencies with in-
tervening nouns were emphasized during training?
we repeated our number prediction experiment, this
time training the model only on dependencies with
at least one intervening noun (of any number). we
doubled the proportion of training sentences to 20%,
since the total size of the corpus was smaller (226k
dependencies).

this training regime resulted in a 27% decrease in
error rate on dependencies with exactly one attractor
(from 4.1% to 3.0%). this decrease is statistically
signi   cant, and encouraging given that total number
of dependencies in training was much lower, which
complicates the learning of id27s. error
rates mildly decreased in dependencies with more
attractors as well, suggesting some generalization
(figure 4d). surprisingly, a similar experiment us-
ing the grammaticality judgment task led to a slight
increase in error rate. while tentative at this point,
these results suggest that oversampling dif   cult train-
ing cases may be bene   cial; a curriculum progressing
from easier to harder dependencies (elman, 1993)
may provide additional gains.

7 error analysis
singular vs. plural subjects: most of the nouns
in english are singular: in our corpus, the fraction
of singular subjects is 68%. agreement attraction
errors in humans are much more common when the
attractor is plural than when it is singular (bock and
miller, 1991; eberhard et al., 2005). do our models   
error rates depend on the number of the subject?

as figure 2b shows, our lstm number prediction
model makes somewhat more agreement attraction
errors with plural than with singular attractors; the
difference is statistically signi   cant, but the asymme-
try is much less pronounced than in humans. inter-
estingly, the srn version of the model does show a
large asymmetry, especially as the count of attractors
increases; with four plural attractors the error rate

reaches 60% (figure 4e).

qualitative analysis: we manually examined a
sample of 200 cases in which the majority of the
20 runs of the number prediction network made the
wrong prediction. there were only 8890 such depen-
dencies (about 0.6%). many of those were straight-
forward agreement attraction errors; others were dif-
   cult to interpret. we mention here three classes of
errors that can motivate future experiments.

the networks often misidenti   ed the heads of
noun-noun compounds. in (17), for example, the
models predict a singular verb even though the num-
ber of the subject conservation refugees should be
determined by its head refugees. this suggests that
the networks didn   t master the structure of english
noun-noun compounds.14

(17)

(18)

conservation refugees live in a world col-
ored in shades of gray; limbo.
information technology (it) assets com-
monly hold large volumes of con   dential
data.

some verbs that are ambiguous with plural nouns
seem to have been misanalyzed as plural nouns and
consequently act as attractors. the models predicted
a plural verb in the following two sentences even
though neither of them has any plural nouns, possibly
because of the ambiguous verbs drives and lands:

(19)

(20)

the ship that the player drives has a very
high speed.
it was also to be used to learn if the area
where the lander lands is typical of the sur-
rounding terrain.

other errors appear to be due to dif   culty not in
identifying the subject but in determining whether it
is plural or singular. in example (22), in particular,
there is very little information in the left context of
the subject 5 paragraphs suggesting that the writer
considers it to be singular:

(21)

rabaul-based japanese aircraft make three
dive-bombing attacks.

14the dependencies are presented as they appeared in the
corpus; the predicted number was the opposite of the correct one
(e.g., singular in (17), where the original is plural).

(22)

the lead is also rather long; 5 paragraphs
is pretty lengthy for a 62 kilobyte article.

the last errors point to a limitation of the number
prediction task, which jointly evaluates the model   s
ability to identify the subject and its ability to assign
the correct number to noun phrases.

8 related work
the majority of nlp work on neural networks eval-
uates them on their performance in a task such as
id38 or machine translation (sunder-
meyer et al., 2012; bahdanau et al., 2015). these
evaluation setups average over many different syn-
tactic constructions, making it dif   cult to isolate the
network   s syntactic capabilities.

other studies have tested the capabilities of id56s
to learn simple arti   cial languages. gers and schmid-
huber (2001) showed that lstms can learn the
context-free language anbn, generalizing to ns as
high as 1000 even when trained only on n    
{1, . . . , 10}. simple recurrent networks struggled
with this language (rodriguez et al., 1999; rodriguez,
2001). these results have been recently replicated
and extended by joulin and mikolov (2015).

elman (1991) tested an srn on a miniature lan-
guage that simulated english relative clauses, and
found that the network was only able to learn the
language under highly speci   c circumstances (el-
man, 1993), though later work has called some of his
conclusions into question (rohde and plaut, 1999;
cartling, 2008). frank et al. (2013) studied the ac-
quisition of anaphora coreference by srns, again
in a miniature language. recently, bowman et al.
(2015) tested the ability of lstms to learn an arti   -
cial language based on id118. as in our
study, the performance of the network degraded as
the complexity of the test sentences increased.

karpathy et al. (2016) present analyses and visual-
ization methods for character-level id56s. k  ad  ar et
al. (2016) and li et al. (2016) suggest visualization
techniques for word-level id56s trained to perform
tasks that aren   t explicitly syntactic (image caption-
ing and id31).

early work that used neural networks to model
grammaticality judgments includes allen and sei-
denberg (1999) and lawrence et al. (1996). more re-
cently, the connection between grammaticality judg-

ments and the probabilities assigned by a language
model was explored by clark et al. (2013) and lau
et al. (2015). finally, arguments for evaluating nlp
models on a strategically sampled set of dependency
types rather than a random sample of sentences have
been made in the parsing literature (rimell et al.,
2009; nivre et al., 2010; bender et al., 2011).

9 discussion and future work

neural network architectures are typically evaluated
on random samples of naturally occurring sentences,
e.g., using perplexity on held-out data in language
modeling. since the majority of natural language sen-
tence are grammatically simple, models can achieve
high overall accuracy using    awed heuristics that
fail on harder cases. this makes it dif   cult to distin-
guish simple but robust sequence models from more
expressive architectures (socher, 2014; grefenstette
et al., 2015; joulin and mikolov, 2015). our work
suggests an alternative strategy   evaluation on natu-
rally occurring sentences that are sampled based on
their grammatical complexity   which can provide
more nuanced tests of language models (rimell et al.,
2009; bender et al., 2011).

this approach can be extended to the training
stage: neural networks can be encouraged to develop
more sophisticated generalizations by oversampling
grammatically challenging training sentences. we
took a    rst step in this direction when we trained
the network only on dependencies with intervening
nouns (section 6). this training regime indeed im-
proved the performance of the network; however, the
improvement was quantitative rather than qualitative:
there was limited generalization to dependencies that
were even more dif   cult than those encountered in
training. further experiments are needed to establish
the ef   cacy of this method.

a network that has acquired syntactic represen-
tations sophisticated enough to handle subject-verb
agreement is likely to show improved performance
on other structure-sensitive dependencies, including
pronoun coreference, quanti   er scope and negative
polarity items. as such, neural models used in nlp
applications may bene   t from grammatically sophis-
ticated sentence representations developed in a multi-
task learning setup (caruana, 1998), where the model
is trained concurrently on the task of interest and on

one of the tasks we proposed in this paper. of course,
grammatical phenomena differ from each other in
many ways. the distribution of negative polarity
items is highly sensitive to semantic factors (gian-
nakidou, 2011). restrictions on unbounded depen-
dencies (ross, 1967) may require richer syntactic
representations than those required for subject-verb
dependencies. the extent to which the results of our
study will generalize to other constructions and other
languages, then, is a matter for empirical research.

humans occasionally make agreement attraction
mistakes during language production (bock and
miller, 1991) and comprehension (nicol et al., 1997).
these errors persist in human acceptability judg-
ments (tanner et al., 2014), which parallel our gram-
maticality judgment task. cases of grammatical
agreement with the nearest rather than structurally rel-
evant constituent have been documented in languages
such as slovenian (maru  si  c et al., 2007), and have
even been argued to be occasionally grammatical
in english (zwicky, 2005). in future work, explor-
ing the relationship between these cases and neural
network predictions can shed light on the cognitive
plausibility of those networks.

10 conclusion

lstms are sequence models; they do not have built-
in hierarchical representations. we have investigated
how well they can learn subject-verb agreement, a
phenomenon that crucially depends on hierarchical
syntactic structure. when provided explicit supervi-
sion, lstms were able to learn to perform the verb-
number agreement task in most cases, although their
error rate increased on particularly dif   cult sentences.
we conclude that lstms can learn to approximate
structure-sensitive dependencies fairly well given ex-
plicit supervision, but more expressive architectures
may be necessary to eliminate errors altogether. fi-
nally, our results provide evidence that the language
modeling objective is not by itself suf   cient for learn-
ing structure-sensitive dependencies, and suggest that
a joint training objective can be used to supplement
language models on tasks for which syntax-sensitive
dependencies are important.

acknowledgments

we thank marco baroni, grzegorz chrupa  a, alexan-
der clark, sol lago, paul smolensky, benjamin
spector and roberto zamparelli for comments and
discussion. this research was supported by the
european research council (grant erc-2011-adg
295810 bootphon), the agence nationale pour la
recherche (grants anr-10-idex-0001-02 psl and
anr-10-labx-0087 iec) and the israeli science
foundation (grant number 1555/15).

references
joseph allen and mark s. seidenberg. 1999. the emer-
gence of grammaticality in connectionist networks. in
brian macwhinney, editor, emergentist approaches
to language: proceedings of the 28th carnegie sym-
posium on cognition, pages 115   151. mahwah, nj:
erlbaum.

dzmitry bahdanau, kyunghyun cho, and yoshua bengio.
2015. id4 by jointly learning
to align and translate. in international conference for
learning representations.

emily m. bender, dan flickinger, stephan oepen, and
yi zhang. 2011. parser evaluation over local and
non-local deep dependencies in a large corpus. in pro-
ceedings of emnlp, pages 397   408.

kathryn bock and carol a. miller. 1991. broken agree-

ment. cognitive psychology, 23(1):45   93.

melissa bowerman. 1988. the    no negative evidence   
problem: how do children avoid constructing an overly
general grammar? in john a. hawkins, editor, explain-
ing language universals, pages 73   101. oxford: basil
blackwell.

samuel r. bowman, christopher d. manning, and
christopher potts. 2015. tree-structured composi-
tion in neural networks without tree-structured archi-
tectures. in proceedings of the nips workshop on cog-
nitive computation: integrating neural and symbolic
approaches.

bo cartling. 2008. on the implicit acquisition of a
context-free grammar by a simple recurrent neural net-
work. neurocomputing, 71(7):1527   1537.

rich caruana. 1998. multitask learning. in sebastian
thrun and lorien pratt, editors, learning to learn,
pages 95   133. boston: kluwer.

ciprian chelba, tomas mikolov, mike schuster, qi ge,
thorsten brants, phillipp koehn, and tony robin-
son. 2013. one billion word benchmark for measur-
ing progress in statistical id38. arxiv
preprint arxiv:1312.3005.

kyunghyun cho, bart van merrienboer, caglar gulcehre,
dzmitry bahdanau, fethi bougares, holger schwenk,
and yoshua bengio. 2014. learning phrase repre-
sentations using id56 encoder   decoder for statistical
machine translation. in proceedings of emnlp, pages
1724   1734.

noam chomsky. 1965. aspects of the theory of syntax.

cambridge, ma: mit press.

alexander clark, gianluca giorgolo, and shalom lap-
pin. 2013. statistical representation of grammaticality
judgements: the limits of id165 models. in proceed-
ings of the fourth annual workshop on cognitive mod-
eling and computational linguistics (cmcl), pages
28   36.

chris dyer, adhiguna kuncoro, miguel ballesteros, and
a. noah smith. 2016. recurrent neural network gram-
mars. in proceedings of naacl/hlt, pages 199   209.
kathleen m. eberhard, j. cooper cutting, and kathryn
bock. 2005. making syntax of sense: number agree-
ment in sentence production. psychological review,
112(3):531   559.

jeffrey l. elman. 1990. finding structure in time. cogni-

tive science, 14(2):179   211.

jeffrey l. elman. 1991. distributed representations, sim-
ple recurrent networks, and grammatical structure. ma-
chine learning, 7(2-3):195   225.

jeffrey l. elman. 1993. learning and development in neu-
ral networks: the importance of starting small. cogni-
tion, 48(1):71   99.

martin b. h. everaert, marinus a. c. huybregts, noam
chomsky, robert c. berwick, and johan j. bolhuis.
2015. structures, not strings: linguistics as part of
the cognitive sciences. trends in cognitive sciences,
19(12):729   743.

robert frank, donald mathis, and william badecker.
2013. the acquisition of anaphora by simple recur-
rent networks. id146, 20(3):181   227.
felix gers and j  urgen schmidhuber. 2001. lstm re-
current networks learn simple context-free and context-
sensitive languages. ieee transactions on neural net-
works, 12(6):1333   1340.

anastasia giannakidou. 2011. negative and positive
polarity items: variation, licensing, and compositional-
ity. in claudia maienborn, klaus von heusinger, and
paul portner, editors, semantics: an international hand-
book of natural language meaning. berlin: mouton de
gruyter.

yoav goldberg and joakim nivre. 2012. a dynamic ora-
cle for arc-eager id33. in proceedings
of coling 2012, pages 959   976.

edward grefenstette, karl moritz hermann, mustafa su-
leyman, and phil blunsom. 2015. learning to trans-
duce with unbounded memory. in advances in neural
information processing systems, pages 1828   1836.

joakim nivre, laura rimell, ryan mcdonald, and carlos
gomez-rodriguez. 2010. evaluation of dependency
parsers on unbounded dependencies. in proceedings of
the 23rd international conference on computational
linguistics, pages 833   841. association for computa-
tional linguistics.

laura rimell, stephen clark, and mark steedman. 2009.
unbounded dependency recovery for parser evaluation.
in proceedings of emnlp, pages 813   821.

paul rodriguez, janet wiles, and jeffrey l. elman. 1999.
a recurrent neural network that learns to count. con-
nection science, 11(1):5   40.

paul rodriguez. 2001. simple recurrent networks learn
context-free and context-sensitive languages by count-
ing. neural computation, 13(9):2093   2118.

douglas l. t. rohde and david c. plaut. 1999. language
acquisition in the absence of explicit negative evidence:
how important is starting small? cognition, 72(1):67   
109.

john robert ross. 1967. constraints on variables in

syntax. ph.d. thesis, mit.

carson t. sch  utze. 1996. the empirical base of linguis-
tics: grammaticality judgments and linguistic method-
ology. chicago, il: university of chicago press.

richard socher. 2014. recursive deep learning for
natural language processing and id161.
ph.d. thesis, stanford university.

adrian staub. 2009. on the interpretation of the number
attraction effect: response time evidence. journal of
memory and language, 60(2):308   327.

martin sundermeyer, ralf schl  uter, and hermann ney.
2012. lstm neural networks for id38.
in interspeech.

darren tanner, janet nicol, and laurel brehm. 2014. the
time-course of feature interference in agreement com-
prehension: multiple mechanisms and asymmetrical
attraction. journal of memory and language, 76:195   
215.

oriol vinyals,   ukasz kaiser, terry koo, slav petrov, ilya
sutskever, and geoffrey hinton. 2015. grammar as a
foreign language. in advances in neural information
processing systems, pages 2755   2763.

arnold zwicky. 2005. agreement with nearest always
http://itre.cis.upenn.edu/  myl/

bad?
languagelog/archives/001846.html.

sepp hochreiter and j  urgen schmidhuber. 1997. long
short-term memory. neural computation, 9(8):1735   
1780.

rodney huddleston and geoffrey k. pullum. 2002. the
cambridge grammar of the english language. cam-
bridge university press, cambridge.

armand joulin and tomas mikolov. 2015.

inferring
algorithmic patterns with stack-augmented recurrent
nets. in advances in neural information processing
systems, pages 190   198.

rafal jozefowicz, oriol vinyals, mike schuster, noam
exploring
arxiv preprint

shazeer, and yonghui wu.
the limits of id38.
arxiv:1602.02410.

2016.

  akos k  ad  ar, grzegorz chrupa  a, and afra alishahi.
2016. representation of linguistic form and func-
arxiv preprint
tion in recurrent neural networks.
arxiv:1602.08952.

andrej karpathy, justin johnson, and fei-fei li. 2016.

visualizing and understanding recurrent networks.

diederik kingma and jimmy ba. 2015. adam: a method
for stochastic optimization. in international confer-
ence for learning representations.

eliyahu kiperwasser and yoav goldberg. 2016. simple
and accurate id33 using bidirectional
lstm feature representations. transactions of the asso-
ciation of computational linguistics, 4:313   327.

jey han lau, alexander clark, and shalom lappin. 2015.
unsupervised prediction of acceptability judgements.
in proceedings of acl/ijcnlp, pages 1618   1628.

steve lawrence, lee c. giles, and santliway fong. 1996.
can recurrent neural networks learn natural language
grammars? in ieee international conference on neu-
ral networks, volume 4, pages 1853   1858.

willem j. m. levelt, ardi roelofs, and antje s. meyer.
1999. a theory of lexical access in speech production.
behavioral and brain sciences, 22(1):1   75.

jiwei li, xinlei chen, eduard h. hovy, and dan jurafsky.
2016. visualizing and understanding neural models
in nlp. in proceedings of naacl-hlt 2016, pages
681   691.

franc maru  si  c, andrew nevins, and amanda saksida.
2007. last-conjunct agreement in slovenian. in an-
nual workshop on formal approaches to slavic lin-
guistics, pages 210   227.

tomas mikolov, martin kara     at, lukas burget, jan cer-
nock`y, and sanjeev khudanpur. 2010. recurrent neu-
ral network based language model. in interspeech,
pages 1045   1048.

janet l. nicol, kenneth i. forster, and csaba veres. 1997.
subject   verb agreement processes in comprehension.
journal of memory and language, 36(4):569   587.

figure 5: activation plots for all units (see figure 3a and text in p. 7).

thex(s)ofthey(s)1.00.80.60.40.20.00.2x,yx,ysxs,yxs,ysunit 0: ppthex(s)thatthey(s)1.00.80.60.40.20.00.2x,yx,ysxs,yxs,ysunit 0: rcthex(s)ofthey(s)0.50.00.51.0x,yx,ysxs,yxs,ysunit 1: ppthex(s)thatthey(s)0.50.00.51.0x,yx,ysxs,yxs,ysunit 1: rcthex(s)ofthey(s)0.80.60.40.20.00.20.4x,yx,ysxs,yxs,ysunit 2: ppthex(s)thatthey(s)0.80.60.40.20.00.20.4x,yx,ysxs,yxs,ysunit 2: rcthex(s)ofthey(s)0.80.60.40.20.00.2x,yx,ysxs,yxs,ysunit 3: ppthex(s)thatthey(s)0.80.60.40.20.00.2x,yx,ysxs,yxs,ysunit 3: rcthex(s)ofthey(s)0.80.60.40.20.00.20.4x,yx,ysxs,yxs,ysunit 4: ppthex(s)thatthey(s)0.80.60.40.20.00.20.4x,yx,ysxs,yxs,ysunit 4: rcthex(s)ofthey(s)0.50.00.5x,yx,ysxs,yxs,ysunit 5: ppthex(s)thatthey(s)0.50.00.5x,yx,ysxs,yxs,ysunit 5: rcthex(s)ofthey(s)1.00.50.00.5x,yx,ysxs,yxs,ysunit 6: ppthex(s)thatthey(s)1.00.50.00.5x,yx,ysxs,yxs,ysunit 6: rcthex(s)ofthey(s)0.00.20.40.60.8x,yx,ysxs,yxs,ysunit 7: ppthex(s)thatthey(s)0.00.20.40.60.8x,yx,ysxs,yxs,ysunit 7: rcthex(s)ofthey(s)0.80.60.40.20.00.2x,yx,ysxs,yxs,ysunit 8: ppthex(s)thatthey(s)0.80.60.40.20.00.2x,yx,ysxs,yxs,ysunit 8: rcthex(s)ofthey(s)0.00.20.40.60.8x,yx,ysxs,yxs,ysunit 9: ppthex(s)thatthey(s)0.00.20.40.60.8x,yx,ysxs,yxs,ysunit 9: rcthex(s)ofthey(s)1.00.80.60.40.20.0x,yx,ysxs,yxs,ysunit 10: ppthex(s)thatthey(s)1.00.80.60.40.20.0x,yx,ysxs,yxs,ysunit 10: rcthex(s)ofthey(s)1.00.50.00.51.0x,yx,ysxs,yxs,ysunit 11: ppthex(s)thatthey(s)1.00.50.00.51.0x,yx,ysxs,yxs,ysunit 11: rcthex(s)ofthey(s)1.00.50.00.5x,yx,ysxs,yxs,ysunit 12: ppthex(s)thatthey(s)1.00.50.00.5x,yx,ysxs,yxs,ysunit 12: rcthex(s)ofthey(s)0.40.20.00.20.4x,yx,ysxs,yxs,ysunit 13: ppthex(s)thatthey(s)0.40.20.00.20.4x,yx,ysxs,yxs,ysunit 13: rcthex(s)ofthey(s)0.60.40.20.00.20.4x,yx,ysxs,yxs,ysunit 14: ppthex(s)thatthey(s)0.60.40.20.00.20.4x,yx,ysxs,yxs,ysunit 14: rcthex(s)ofthey(s)0.50.00.5x,yx,ysxs,yxs,ysunit 15: ppthex(s)thatthey(s)0.50.00.5x,yx,ysxs,yxs,ysunit 15: rcthex(s)ofthey(s)0.50.00.5x,yx,ysxs,yxs,ysunit 16: ppthex(s)thatthey(s)0.50.00.5x,yx,ysxs,yxs,ysunit 16: rcthex(s)ofthey(s)0.40.20.00.20.40.60.8x,yx,ysxs,yxs,ysunit 17: ppthex(s)thatthey(s)0.40.20.00.20.40.60.8x,yx,ysxs,yxs,ysunit 17: rcthex(s)ofthey(s)0.80.60.40.20.00.2x,yx,ysxs,yxs,ysunit 18: ppthex(s)thatthey(s)0.80.60.40.20.00.2x,yx,ysxs,yxs,ysunit 18: rcthex(s)ofthey(s)0.20.40.60.8x,yx,ysxs,yxs,ysunit 19: ppthex(s)thatthey(s)0.20.40.60.8x,yx,ysxs,yxs,ysunit 19: rcthex(s)ofthey(s)0.40.20.00.2x,yx,ysxs,yxs,ysunit 20: ppthex(s)thatthey(s)0.40.20.00.2x,yx,ysxs,yxs,ysunit 20: rcthex(s)ofthey(s)0.20.10.00.10.2x,yx,ysxs,yxs,ysunit 21: ppthex(s)thatthey(s)0.20.10.00.10.2x,yx,ysxs,yxs,ysunit 21: rcthex(s)ofthey(s)0.40.20.00.20.40.60.8x,yx,ysxs,yxs,ysunit 22: ppthex(s)thatthey(s)0.40.20.00.20.40.60.8x,yx,ysxs,yxs,ysunit 22: rcthex(s)ofthey(s)0.150.100.050.000.050.10x,yx,ysxs,yxs,ysunit 23: ppthex(s)thatthey(s)0.150.100.050.000.050.10x,yx,ysxs,yxs,ysunit 23: rcthex(s)ofthey(s)1.00.50.00.5x,yx,ysxs,yxs,ysunit 24: ppthex(s)thatthey(s)1.00.50.00.5x,yx,ysxs,yxs,ysunit 24: rcthex(s)ofthey(s)0.50.00.51.0x,yx,ysxs,yxs,ysunit 25: ppthex(s)thatthey(s)0.50.00.51.0x,yx,ysxs,yxs,ysunit 25: rcthex(s)ofthey(s)0.40.20.00.20.4x,yx,ysxs,yxs,ysunit 26: ppthex(s)thatthey(s)0.40.20.00.20.4x,yx,ysxs,yxs,ysunit 26: rcthex(s)ofthey(s)0.00.10.20.30.40.50.60.7x,yx,ysxs,yxs,ysunit 27: ppthex(s)thatthey(s)0.00.10.20.30.40.50.60.7x,yx,ysxs,yxs,ysunit 27: rcthex(s)ofthey(s)0.50.00.5x,yx,ysxs,yxs,ysunit 28: ppthex(s)thatthey(s)0.50.00.5x,yx,ysxs,yxs,ysunit 28: rcthex(s)ofthey(s)1.00.80.60.40.20.0x,yx,ysxs,yxs,ysunit 29: ppthex(s)thatthey(s)1.00.80.60.40.20.0x,yx,ysxs,yxs,ysunit 29: rcthex(s)ofthey(s)0.50.00.51.0x,yx,ysxs,yxs,ysunit 30: ppthex(s)thatthey(s)0.50.00.51.0x,yx,ysxs,yxs,ysunit 30: rcthex(s)ofthey(s)0.70.60.50.40.30.20.10.0x,yx,ysxs,yxs,ysunit 31: ppthex(s)thatthey(s)0.70.60.50.40.30.20.10.0x,yx,ysxs,yxs,ysunit 31: rcthex(s)ofthey(s)0.00.10.20.30.40.50.6x,yx,ysxs,yxs,ysunit 32: ppthex(s)thatthey(s)0.00.10.20.30.40.50.6x,yx,ysxs,yxs,ysunit 32: rcthex(s)ofthey(s)1.00.50.00.5x,yx,ysxs,yxs,ysunit 33: ppthex(s)thatthey(s)1.00.50.00.5x,yx,ysxs,yxs,ysunit 33: rcthex(s)ofthey(s)0.20.00.20.40.60.8x,yx,ysxs,yxs,ysunit 34: ppthex(s)thatthey(s)0.20.00.20.40.60.8x,yx,ysxs,yxs,ysunit 34: rcthex(s)ofthey(s)0.40.20.00.2x,yx,ysxs,yxs,ysunit 35: ppthex(s)thatthey(s)0.40.20.00.2x,yx,ysxs,yxs,ysunit 35: rcthex(s)ofthey(s)0.30.20.10.00.10.20.3x,yx,ysxs,yxs,ysunit 36: ppthex(s)thatthey(s)0.30.20.10.00.10.20.3x,yx,ysxs,yxs,ysunit 36: rcthex(s)ofthey(s)0.20.00.20.4x,yx,ysxs,yxs,ysunit 37: ppthex(s)thatthey(s)0.20.00.20.4x,yx,ysxs,yxs,ysunit 37: rcthex(s)ofthey(s)0.50.00.51.0x,yx,ysxs,yxs,ysunit 38: ppthex(s)thatthey(s)0.50.00.51.0x,yx,ysxs,yxs,ysunit 38: rcthex(s)ofthey(s)0.50.00.51.0x,yx,ysxs,yxs,ysunit 39: ppthex(s)thatthey(s)0.50.00.51.0x,yx,ysxs,yxs,ysunit 39: rcthex(s)ofthey(s)0.60.40.20.00.20.4x,yx,ysxs,yxs,ysunit 40: ppthex(s)thatthey(s)0.60.40.20.00.20.4x,yx,ysxs,yxs,ysunit 40: rcthex(s)ofthey(s)0.10.00.10.20.30.40.5x,yx,ysxs,yxs,ysunit 41: ppthex(s)thatthey(s)0.10.00.10.20.30.40.5x,yx,ysxs,yxs,ysunit 41: rcthex(s)ofthey(s)0.00.10.20.30.40.5x,yx,ysxs,yxs,ysunit 42: ppthex(s)thatthey(s)0.00.10.20.30.40.5x,yx,ysxs,yxs,ysunit 42: rcthex(s)ofthey(s)0.50.00.5x,yx,ysxs,yxs,ysunit 43: ppthex(s)thatthey(s)0.50.00.5x,yx,ysxs,yxs,ysunit 43: rcthex(s)ofthey(s)0.40.20.00.20.40.60.81.0x,yx,ysxs,yxs,ysunit 44: ppthex(s)thatthey(s)0.40.20.00.20.40.60.81.0x,yx,ysxs,yxs,ysunit 44: rcthex(s)ofthey(s)0.00.20.40.60.8x,yx,ysxs,yxs,ysunit 45: ppthex(s)thatthey(s)0.00.20.40.60.8x,yx,ysxs,yxs,ysunit 45: rcthex(s)ofthey(s)1.00.50.00.5x,yx,ysxs,yxs,ysunit 46: ppthex(s)thatthey(s)1.00.50.00.5x,yx,ysxs,yxs,ysunit 46: rcthex(s)ofthey(s)0.50.00.51.0x,yx,ysxs,yxs,ysunit 47: ppthex(s)thatthey(s)0.50.00.51.0x,yx,ysxs,yxs,ysunit 47: rcthex(s)ofthey(s)0.80.60.40.20.00.20.4x,yx,ysxs,yxs,ysunit 48: ppthex(s)thatthey(s)0.80.60.40.20.00.20.4x,yx,ysxs,yxs,ysunit 48: rcthex(s)ofthey(s)0.70.60.50.40.30.20.10.0x,yx,ysxs,yxs,ysunit 49: ppthex(s)thatthey(s)0.70.60.50.40.30.20.10.0x,yx,ysxs,yxs,ysunit 49: rc