evolving deep neural networks

risto miikkulainen1,2, jason liang1,2, elliot meyerson1,2, aditya rawal1,2, dan fink1, olivier
francon1, bala raju1, hormoz shahrzad1, arshak navruzyan1, nigel du(cid:130)y1, babak hodjat1

1sentient technologies, inc.

2(cid:140)e university of texas at austin

7
1
0
2

 
r
a

m
4

 

 
 
]
e
n
.
s
c
[
 
 

2
v
8
4
5
0
0

.

3
0
7
1
:
v
i
x
r
a

abstract
(cid:140)e success of deep learning depends on (cid:128)nding an architecture
to (cid:128)t the task. as deep learning has scaled up to more challenging
tasks, the architectures have become di(cid:129)cult to design by hand.
(cid:140)is paper proposes an automated method, codeepneat, for opti-
mizing deep learning architectures through evolution. by extending
existing neuroevolution methods to topology, components, and hy-
perparameters, this method achieves results comparable to best
human designs in standard benchmarks in object recognition and
id38. it also supports building a real-world applica-
tion of automated image captioning on a magazine website. given
the anticipated increases in available computing power, evolution of
deep networks is promising approach to constructing deep learning
applications in the future.

keywords
neural networks, deep learning, lstms, bilevel optimization, co-
evolution, design

1 introduction
large databases (i.e. big data) and large amounts of computing
power have become readily available since the 2000s. as a result,
it has become possible to scale up machine learning systems. in-
terestingly, not only have these systems been successful in such
scaleup, but they have become more powerful. some ideas that did
not quite work before, now do, with million times more compute
and data. for instance, deep learning neural networks (dnns), i.e.
convolutional neural networks [30] and recurrent neural networks
(in particular long short-term memory, or lstm [22]), which have
existed since the 1990s, have improved state-of-the-art signi(cid:128)cantly
in id161, speech, language processing, and many other
areas [9, 17, 45].

as dnns have been scaled up and improved, they have become
much more complex. a new challenge has therefore emerged:
how to con(cid:128)gure such systems? human engineers can optimize a
handful of con(cid:128)guration parameters through experimentation, but
dnns have complex topologies and hundreds of hyperparameters.
moreover, such design choices ma(cid:138)er; o(cid:137)en success depends on
(cid:128)nding the right architecture for the problem. much of the recent
work in deep learning has indeed focused on proposing di(cid:130)erent
hand-designed architectures on new problems [5, 20, 39, 45].

(cid:140)e complexity challenge is not unique to neural networks. so(cid:137)-
ware and many other engineered systems have become too complex
for humans to optimize fully. as a result, a new way of thinking
about such design has started to emerge. in this approach, hu-
mans are responsible for the high-level design, and the details are

le(cid:137) for computational optimization systems to (cid:128)gure out. for in-
stance, humans write the overall design of a so(cid:137)ware system, and
the parameters and low-level code is optimized automatically [23];
humans write imperfect versions of programs, and evolutionary
algorithms are then used to repair them [15]; humans de(cid:128)ne the
space of possible web designs, and evolution is used to (cid:128)nd e(cid:130)ective
ones [35].

(cid:140)is same approach can be applied to the design of dnn archi-
tectures. (cid:140)is problem includes three challenges: how to design the
components of the architecture, how to put them together into a
full network topology, and how to set the hyperparameters for the
components and the global design. (cid:140)ese three aspects need to be
optimized separately for each new task.

(cid:140)is paper develops an approach for automatic design of dnns.
it is based on the existing neuroevolution technique of neat [43],
which has been successful in evolving topologies and weights of rel-
atively small recurrent networks in the past. in this paper, neat is
extended to the coevolutionary optimization of components, topolo-
gies, and hyperparameters. (cid:140)e (cid:128)tness of the evolved networks is
determined based on how well they can be trained, through gradi-
ent descent, to perform in the task. (cid:140)e approach is demonstrated
in the standard benchmark tasks of object recognition and language
modeling, and in a real-world application of captioning images on
a magazine website.

(cid:140)e results show that the approach discovers designs that are
comparable to the state of the art, and does it automatically with-
out much development e(cid:130)ort. (cid:140)e approach is computationally
extremely demanding   with more computational power, it is likely
to be more e(cid:130)ective and possibly surpass human design. such
power is now becoming available in various forms of cloud comput-
ing and grid computing, thereby making evolutionary optimization
of neural networks a promising approach for the future.

2 background and related work
neuroevolution techniques have been applied successfully to se-
quential decision tasks for three decades [11, 31, 36, 50]. in such
tasks there is no gradient available, so instead of id119,
evolution is used to optimize the weights of the neural network.
neuroevolution is a good approach in particular to pomdp (par-
tially observable markov decision process) problems because of
recurrency: it is possible to evolve recurrent connections to allow
disambiguating hidden states.

(cid:140)e weights can be optimized using various evolutionary tech-
niques. id107 are a natural choice because crossover
is a good match with neural networks: they recombine parts of
existing neural networks to (cid:128)nd be(cid:138)er ones. cma-es [24], a tech-
nique for continuous optimization, works well on optimizing the

weights as well because it can capture interactions between them.
other approaches such as sane, esp, and cosyne evolve partial
neural networks and combine them into fully functional networks
[12, 14, 37]. further, techniques such as cellular encoding [18]
and neat [43] have been developed to evolve the topology of the
neural network, which is particularly e(cid:130)ective in determining the
required recurrence. neuroevolution techniques have been shown
to work well in many tasks in control, robotics, constructing intel-
ligent agents for games, and arti(cid:128)cial life [31]. however, because
of the large number of weights to be optimized, they are generally
limited to relatively small networks.

evolution has been combined with gradient-descent based learn-
ing in several ways, making it possible to utilize much larger net-
works. (cid:140)ese methods are still usually applied to sequential decision
tasks, but gradients from a related task (such as prediction of the
next sensory inputs) are used to help search. much of the work is
based on utilizing the baldwin e(cid:130)ect, where learning only a(cid:130)ects
the selection [21]. computationally, it is possible to utilize lamar-
ckian evolution as well, i.e. encode the learned weight changes
back into the genome [18]. however, care must be taken to main-
tain diversity so that evolution can continue to innovate when all
individuals are learning similar behavior.

evolution of dnns departs from this prior work in that it is
applied to supervised domains where gradients are available, and
evolution is used only to optimize the design of the neural network.
deep neuroevolution is thus more closely related to bilevel (or
multilevel) optimization techniques [40]. (cid:140)e idea is to use an
evolutionary optimization process at a high level to optimize the
parameters of a low-level evolutionary optimization process.

consider for instance the problem of controlling a helicopter
through aileron, elevator, rudder, and rotor inputs. (cid:140)is is a chal-
lenging benchmark from the 2000s for which various reinforcement
learning approaches have been developed [1, 2, 38]. one of the most
successful ones is single-level neuroevolution, where the helicopter
is controlled by a neural network that is evolved through genetic al-
gorithms [29]. (cid:140)e eight parameters of the neuroevolution method
(such mutation and crossover rate, id203, and amount and
population and elite size) are optimized by hand. it would be di(cid:129)-
cult to include more parameters because the parameters interact
nonlinearly. a large part of the parameter space thus remains un-
explored in the single-level neuroevolution approach. however, a
bilevel approach, where a high-level evolutionary process is em-
ployed to optimize these parameters, can search this space more
e(cid:130)ectively [32]. with bilevel evolution, the number of parameters
optimized could be extended to 15, which resulted in signi(cid:128)cantly
be(cid:138)er performance. in this manner, evolution was harnessed in
this example task to optimize a system design that was too complex
to be optimized by hand.

very recently, a studies have started to emerge with the goal
of optimizing dnns. due to limited computational resources,
they have focused on speci(cid:128)c parts of the design. for instance,
loshchilov et al. [33] used cma-es to optimize the hyperparame-
ters of existing dnns obtaining state-of-the-art results on e.g. object
recognition. further, fernando et al. [10] evolved a cppn (com-
positional pa(cid:138)ern-producing network [42]) to output the weights
of an auto-encoder neural network. (cid:140)e autoencoder was then
trained further through id119, forming gradients for

figure 1: a visualization of how codeepneat assembles
networks for (cid:128)tness evaluation. modules and blueprints
are assembled together into a network through replacement
of blueprint nodes with corresponding modules. (cid:135)is ap-
proach allows evolving repetitive and deep structures seen
in many successful recent dnns.

the cppn training, and its trained weights were then incorporated
back into the cppn genome through lamarckian adaptation. a
related approach was proposed by zoph and le [54]: the topology
and hyperparameters of a deep network and lstm network were
modi(cid:128)ed through policy iteration.

building on this foundation, a systematic approach to evolving
dnns is developed in this paper. first, the standard neat neu-
roevolution method is applied to the topology and hyperparameters
of convolutional neural networks, and then extended to evolution
of components as well, achieving results comparable to state of
the art in the cifar-10 image classi(cid:128)cation benchmark. second, a
similar method is used to evolve the structure of id137
in id38, showing that even small innovations in the
components can have a signi(cid:128)cant e(cid:130)ect on performance. (cid:140)ird,
the approach is used to build a real-world application on captioning
images in the website for an online magazine.

3 evolution of deep learning

architectures

neat neuroevolution method [43] is (cid:128)rst extended to evolving
network topology and hyperparameters of deep neural networks
in deepneat, and then further to coevolution of modules and
blueprints for combining them in codeepneat. (cid:140)e approach is
tested in the standard cifar-10 benchmark of object recognition,
and found to be comparable to the state of the art.

3.1 extending neat to deep networks
deepneat is a most immediate extension of the standard neural
network topology-evolution method neat to dnn. it follows the
same fundamental process as neat: first, a population of chromo-
somes (each represented by a graph) with minimal complexity is
created. over generations, structure (i.e. nodes and edges) is added
to the graph incrementally through mutation. during crossover,
historical markings are used to determine how genes of two chro-
mosomes can be lined up. (cid:140)e population is divided into species (i.e.
subpopulations) based on a similarity metric. each species grows

2

proportionally to its (cid:128)tness and evolution occurs separately in each
species.

deepneat di(cid:130)ers from neat in that each node in the chromo-
some no longer represents a neuron, but a layer in a dnn. each
node contains a table of real and binary valued hyperparameters
that are mutated through uniform gaussian distribution and ran-
dom bit-(cid:131)ipping, respectively. (cid:140)ese hyperparameters determine
the type of layer (such as convolutional, fully connected, or recur-
rent) and the properties of that layer (such as number of neurons,
kernel size, and activation function). (cid:140)e edges in the chromosome
are no longer marked with weights; instead they simply indicate
how the nodes (layers) are connected together. to construct a dnn
from a deepneat chromosome, one simply needs to traverse the
chromosome graph, replacing each node with the corresponding
layer. (cid:140)e chromosome also contains a set of global hyperparame-
ters applicable to the entire network (such as learning rate, training
algorithm, and id174).

when arbitrary connectivity is allowed between layers, addi-
tional complexity is required. if the current layer has multiple
parent layers, a merge layer must be applied to the parents in order
to ensure that the parent layer   s output is the same size as the
current layer   s input. typically, this adjustment is done through
a concatenation or element-wise sum operation. if the parent lay-
ers have mismatched output sizes, all of the parent layers must be
downsampled to parent layer with the smallest output size. (cid:140)e spe-
ci(cid:128)c method for downsampling is domain dependent. for example,
in image classi(cid:128)cation, a max-pooling layer is inserted a(cid:137)er speci(cid:128)c
parent layers; in image captioning, a fully connected bo(cid:138)leneck
layer will serve this function.

during (cid:128)tness evaluation, each chromosome is converted into a
dnn. (cid:140)ese dnns are then trained for a (cid:128)xed number of epochs.
a(cid:137)er training, a metric that indicates the network   s performance is
returned back to deepneat and assigned as (cid:128)tness to the corre-
sponding chromosome in the population.

while deepneat can be used to evolve dnns, the resulting
structures are o(cid:137)en complex and unprincipled. (cid:140)ey contrast with
typical dnn architectures that utilize repetition of basic compo-
nents. deepneat is therefore extend to evolution of modules and
blueprints next.

3.2 cooperative coevolution of modules and

blueprints

many of the most successful dnns, such as googlenet and resnet
are composed of modules that are repeated multiple times [20,
45]. (cid:140)ese modules o(cid:137)en themselves have complicated structure
with branching and merging of various layers. inspired by this
observation, a variant of deepneat, called coevolution deepneat
(codeepneat), is proposed. (cid:140)e algorithm behind codeepneat
is inspired mainly by hierarchical sane [37] but is also in(cid:131)uenced
by component-evolution approaches esp [13] and cosyne [14].
in codeepneat, two populations of modules and blueprints
are evolved separately, using the same methods as described above
for deepneat. (cid:140)e blueprint chromosome is a graph where each
node contains a pointer to a particular module species. in turn,
each module chromosome is a graph that represents a small dnn.
during (cid:128)tness evaluation, the modules and blueprints are combined

3

node hyperparameter
number of filters
dropout rate
initial weight scaling
kernel size
max pooling
global hyperparameter
learning rate
momentum
hue shi(cid:137)
saturation/value shi(cid:137)
saturation/value scale
cropped image size
spatial scaling
random horizontal flips
variance id172
nesterov accelerated gradient

range
[32, 256]
[0, 0.7]
[0, 2.0]
{1, 3}
{true, false}
range
[0.0001, 0.1]
[0.68, 0.99]
[0, 45]
[0, 0.5]
[0, 0.5]
[26, 32]
[0, 0.3]
{true, false}
{true, false}
{true, false}

table 1: node and global hyperparameters evolved in the
cifar-10 domain.

together to create a larger assembled network figure 1. each node
in the blueprint is replaced with a module chosen randomly from
the species to which that node points. if multiple blueprint nodes
point to the same module species, then the same module is used in
all of them. (cid:140)e assembled networks are evaluated the a manner
similar to deepneat, but the (cid:128)tnesses of the assembled networks
are a(cid:138)ributed back to blueprints and modules as the average (cid:128)tness
of all the assembled networks containing that blueprint or module.
codeepneat can evolve repetitive modular structure e(cid:129)ciently.
furthermore, because small mutations in the modules and blueprints
o(cid:137)en lead to large changes in the assembled network structure,
codeepneat can explore more diverse and deeper architectures
than deepneat. an example application to the cifar-10 domain
is presented next.
3.3 evolving dnns in the cifar-10

benchmark

in this experiment, codeepneat was used to evolve the topology
of a convolutional neural network (id98) to maximize its classi-
(cid:128)cation performance on the cifar-10 dataset, a common image
classi(cid:128)cation benchmark. (cid:140)e dataset consists of 50,000 training
images and 10,000 testing images. (cid:140)e images consist of 32x32 color
pixels and belong to one of 10 classes. for comparison, the neural
network layer types were restricted to those used by snoek et al.
[41] in their bayesian optimization of id98 hyperparameters. also
following snoek et al., data augmentation consisted of converting
the images from rgb to hsv color space, adding random pertur-
bations, distortions, and crops, and converting them back to rgb
color space.

codeepneat was initialized with populations of 25 blueprints
and 45 modules. from these two populations, 100 id98s were as-
sembled for (cid:128)tness evaluation in every generation. each node in the
module chromosome represents a convolutional layer. its hyperpa-
rameters determine the various properties of the layer and whether
additional max-pooling or dropout layers are a(cid:138)ached (table 1).

to simply using recurrent connections in a neural network). lstms
have recently been shown powerful in supervised sequence process-
ing tasks such as id103 [16] and machine translation
[3].

recent research on lstms has focused in two directions: finding
variations of individual lstm memory unit architecture [4, 7, 25,
28], and discovering new ways of stitching lstm layers into a net-
work [8, 26, 53]. both approaches have improved performance over
vanilla lstms, with best recent results achieved through network
design. (cid:140)e codeepneat method incorporates both approaches:
neuroevolution searches for both new lstm units and their con-
nectivity across multiple layers at the same time.

codeepneat was slightly modi(cid:128)ed to make it easier to (cid:128)nd
novel connectivities between lstm layers. multiple lstm layers
are (cid:131)a(cid:138)ened into a neural network graph that is then modi(cid:128)ed by
neuroevolution. (cid:140)ere are two types of mutations: one enables or
disables a connection between lstm layers, and the other adds
or removes skip connections between two lstm nodes. recently,
skip connections have led to performance improvements in deep
neural networks, which suggests that they could be useful for lstm
networks as well. (cid:140)us, neuroevolution modi(cid:128)es both the high-level
network topology and the low-level lstm connections.

in each generation, a population of these network graphs (i.e.
blueprints), consisting of lstm variants (i.e. modules with pos-
sible skip connections), is created. (cid:140)e individual networks are
then trained and tested with the supervised data of the task. (cid:140)e
experimental setup and the id38 task are described
next.

4.2 evolving dnns in the id38

benchmark

one standard benchmark task for lstm network is language mod-
eling, i.e. predicting the next word in a large text corpus. (cid:140)e
benchmark utilizes the penn tree bank (ptb) dataset [34], which
consists of 929k training words, 73k validation words, and 82k test
words. it has 10k words in its vocabulary.

a population of 50 id137 was initialized with uni-
formly random initial connection weights within [-0.05, 0.05]. each
network consisted of two recurrent layers (vanilla lstm or its
variants) with 650 hidden nodes in each layer. (cid:140)e network was
unrolled in time upto 35 steps. (cid:140)e hidden states were initialized
to zero. (cid:140)e (cid:128)nal hidden states of the current minibatch was used
as the initial hidden state of the subsequent minibatch (successive
minibatches sequentially traverse the training set). (cid:140)e size of each
minibatch was 20. for (cid:128)tness evaluation, each network was trained
for 39 epochs. a learning rate decay of 0.8 was applied at the end
of every six epochs; the dropout rate was 0.5. (cid:140)e gradients were
clipped if their maximum norm (normalized by minibatch size)
exceeded 5. training a single network took about 200 minutes on a
geforce gtx 980 gpu card.

a(cid:137)er 25 generations of neuroevolution, the best network im-
proved the performance on ptb dataset by 5% (test-perplexity score
78) as compared to the vanilla lstm [52]. as shown in figure3,
this lstm variant consists of a feedback skip connection between
the memory cells of two lstm layers. (cid:140)is result is interesting

figure 2: top: simpli(cid:128)ed visualization of the best network
evolved by codeepneat for the cifar-10 domain. node
1 is the input layer, while node 2 is the output layer. (cid:135)e
network has repetitive structure because its blueprint reuses
same module in multiple places. bottom: a more detailed vi-
sualization of the same network. (cid:135)e full image is included
in supplementary material.

in addition, a set of global hyperparameters were evolved for the
assembled network. during (cid:128)tness evaluation, the 50,000 images
were split into a training set of 42,500 samples and a validation set
of 7,500 samples. since training a dnn is computationally very ex-
pensive, each network was trained for eight epochs on the training
set. (cid:140)e validation set was then used to determine classi(cid:128)cation
accuracy, i.e. the (cid:128)tness of the network. a(cid:137)er 72 generations of
evolution, the best network in the population was returned.

a(cid:137)er evolution was complete, the best network was trained on
all 50,000 training images for 300 epochs, and the classi(cid:128)cation
error measured. (cid:140)is error was 7.3%, comparable to the 6.4% error
reported by snoek et al. [41]. interestingly, because only limited
training could be done during evolution, the best network evolved
by codeepneat trains very fast. while the network of snoek
et al. takes over 30 epochs to reach 20% test error and over 200
epochs to converge, the best network from evolution takes only 12
epochs to reach 20% test error and around 120 epochs to converge.
(cid:140)is network utilizes the same modules multiple times, resulting in
a deep and repetitive structure typical of many successful dnns
(figure 2).

4 evolution of lstm architectures
recurrent neural networks, in particular those utilizing lstm
nodes, is another powerful approach to dnn. much of the power
comes from repetition of lstm modules and the connectivity be-
tween them. in this section, codeepneat is extended with muta-
tions that allow searching for such connectivity, and the approach
is evaluated in the standard benchmark task of id38.

4.1 extending codeepneat to lstms
long short term memory (lstm) consists of gated memory cells
that can integrate information over longer time scales (as compared

4

global hyperparameter
learning rate
momentum
shared embedding size
embedding dropout
lstm recurrent dropout
nesterov momentum
weight initialization
node hyperparameter
layer type
merge method
layer size
layer activation
layer dropout

range
[0.0001, 0.1]
[0.68, 0.99]
[128, 512]
[0, 0.7]
{true, false}
{true, false}
{glorot normal, he normal}
range
{dense, lstm}
{sum, concat}
{128, 256}
{relu, linear}
[0, 0.7]

table 2: node and global hyperparameters evolved for the
image captioning case study.

figure 3: (cid:135)e best-performing lstm variant a(cid:133)er 25 genera-
tions of neuroevolution. it includes a novel skip connection
between the two memory cells, resulting in 5% improvement
over the vanilla lstm baseline. such improvements are dif-
(cid:128)cult to discover by hand; codeepneat with lstm-speci(cid:128)c
mutation searches for them automatically.

because it is similar to a recent hand-designed architecture that
also outperforms vanilla lstm [8].

(cid:140)e initial results thus demonstrate that codeepneat with just
two lstm-speci(cid:128)c mutations can automatically discover improved
lstm variants. it is likely that expanding the search space with
more mutation types and layer and connection types would lead to
further improvements.

5 application case study: image

captioning for the blind

in a real-world case study, the vision and language capabilities of
codeepneat were combined to build a real-time online image
captioning system. in this application, codeepneat searches for
architectures that learn to integrate image and text representations
to produce captions that blind users can access through existing
screen readers. (cid:140)is application was implemented for a major online
magazine website. evolved networks were trained with the open
source mscoco image captioning dataset [6], along with a new
dataset collected for this website.

5.1 evolving dnns for image captioning
deep learning has recently provided state-of-the-art performance
in image captioning, and several diverse architectures have been
suggested [27, 46, 47, 49, 51]. (cid:140)e input to an image captioning
system is a raw image, and the output is a text caption intended to
describe the contents of the image. in deep learning approaches, a
convolutional network is usually used to process the image, and

recurrent units, o(cid:137)en lstms, to generate coherent sentences with
long-range dependencies.

as is common in existing approaches, the evolved system uses a
pretrained id163 model [45] to produce initial image embed-
dings. (cid:140)e evolved network takes an image embedding as input,
along with a one-hot text input. as usual, in training the text input
contains the previous word of the ground truth caption; in id136
it contains the previous word generated by the model [27, 47].

in the initial codeepneat population the image and text inputs
are fed to a shared embedding layer, which is densely connected
to a so(cid:137)max output over words. from this simple starting point,
codeepneat evolves architectures that include fully connected
layers, lstm layers, sum layers, concatenation layers, and sets of
hyperparameters associated with each layer, along with a set of
global hyperparameters (table 2). in particular, the well-known
show and tell image captioning architecture [47] is in this search
space, providing a baseline with which evolution results can be
compared. (cid:140)ese components and the glue that connects them
are evolved as described in section 3.2, with 100 networks trained
in each generation. since there is no single best accepted metric
for evaluating captions, the (cid:128)tness function is the mean across
three metrics (id7, meteor, and cider; [6]) normalized by their
baseline values. fitness is computed over a holdout set of 5000
images, i.e. 25,000 image-caption pairs.

to keep the computational cost reasonable, during evolution the
networks are trained for only six epochs, and only with a random
100,000 image subset of the 500,000 mscoco image-caption pairs.
as a result, there is evolutionary pressure towards networks that
converge quickly: (cid:140)e best resulting architectures train to near
convergence 6 times faster than the baseline show and tell model
[47]. a(cid:137)er evolution, the optimized learning rate is scaled by one-
(cid:128)(cid:137)h to compensate for the subsampling.

5.2 building the application
(cid:140)e images in mscoco are chosen to depict    common objects in
context   . (cid:140)e focus is on a relatively small set of objects and their
interactions in a relatively small set of se(cid:138)ings. (cid:140)e internet as a
whole, and the online magazine website in particular, contain many

5

figure 4: an iconic image from an online magazine cap-
tioned by an evolved model. (cid:135)e model provides a suitably
detailed description without any unnecessary context.

images that cannot be classi(cid:128)ed as    common objects in context   .
other types of images from the magazine include staged portraits of
people, infographics, cartoons, abstract designs, and iconic images,
i.e. images of one or multiple objects out of context such as on a
white or pa(cid:138)erned background. (cid:140)erefore, an additional dataset
of 17,000 image-caption pairs was constructed for the case study,
targeting iconic images in particular. four thousand images were
(cid:128)rst scraped from the magazine website, and 1000 of them were
identi(cid:128)ed as iconic. (cid:140)en, 16,000 images that were visually similar
to those 1000 were retrieved automatically from a large image
repository. a single ground truth caption for each of these 17k
images was generated by human subjects through spare51. (cid:140)e
holdout set for evaluation consisted of 100 of the original 1000
iconic images, along with 3000 other images.

during evolution, networks were trained and evaluated only on
the mscoco data. (cid:140)e best architecture from evolution was then
trained from scratch on both the mscoco and spare5 datasets in
an iterative alternating approach: one epoch on mscoco, followed
by (cid:128)ve epochs on spare5, until maximum performance was reached
on the spare5 holdout data. id125 was then used to generate
captions from the fully trained models. performance achieved using
the spare5 data demonstrates the ability of evolved architectures
to generalize to domains towards which they were not evolved.

once the model was fully-trained, it was placed on a server where
it can be queried with images to caption. a javascript snippet was
wri(cid:138)en that a developer can embed in his/her site to automatically
query the model to caption all images on a page. (cid:140)is snippet runs in
an existing chrome extension for custom scripts and automatically
captions images as the user browses the web. (cid:140)ese tools add
captions to the    alt    (cid:128)eld of images, which screen readers can then
read to blind internet users (figure 4).

figure 5: (cid:135)e most (cid:128)t architecture found by evolution. (cid:135)e
full image is included in supplementary material. among
the components in its unique structure are six lstm layers,
four summing merge layers, and several skip connections.
a single module consisting of two lstm layers merged by a
sum is repeated three times. (cid:135)ere is a path from the input
through dense layers to the output that bypasses all lstm
layers, providing the so(cid:133)max with a more direct view of the
current input. (cid:135)e motif of skip connections with a sum-
ming merge is similar to residual architectures that are cur-
rently popular in deep learning [19, 44].

model
dngo [41]
baseline [47]
evolved

id7-4 cider meteor
   
23.7
23.8

   
85.5
88.0

26.7
27.7
29.1

table 3: (cid:135)e evolved network improves over the hand-
designed baseline when trained on mscoco alone.

5.3 image captioning results
trained in parallel on about 100 gpus, each generation took around
one hour to complete. (cid:140)e most (cid:128)t architecture was discovered on
generation 37 (figure 5). (cid:140)is architecture performs be(cid:138)er than the

1h(cid:138)ps://mty.ai/computer-vision/

hand-tuned baseline [47] when trained on the mscoco data alone
(table 3).

however, a more important result is the performance of this
network on the magazine website. because no suitable automatic
metrics exist for the types of captions collected for the magazine
website (and existing metrics are very noisy when there is only one

6

6 discussion and future work
(cid:140)e results in this paper show that the evolutionary approach to
optimizing deep neural networks is feasible: (cid:140)e results are com-
parable hand-designed architectures in benchmark tasks, and it is
possible to build real-world applications based on the approach. it
is important to note that the approach has not yet been pushed to
its full potential. it takes a couple of days to train each deep neural
network on a state-of-the-art gpu, and over the course of evolution,
thousands of them need to be trained. (cid:140)erefore, the results are
limited by the available computational power. interestingly, since
it was necessary to train networks only partially during evolution,
evolution is biased towards discovering fast learners instead of top
performers. (cid:140)is is an interesting result on its own: evolution can
be guided with goals other than simply accuracy, including training
time, execution time, or memory requirements of the network.

signi(cid:128)cantly more computational resources are likely to become
available in the near future. already cloud-based services such as
amazon web services o(cid:130)er gpu computation with a reasonable
cost, and e(cid:130)orts to harness idle cycles on gaming center gpus are
underway. at sentient, for example, a distributed ai computing
system called darkcycle is being built that currently utilizes 2m
cpus and 5000 gpus around the world, resulting in a peak perfor-
mance of 9 peta(cid:131)ops, on par with the fastest supercomputers in the
world. not many approaches can take advantage of such power, but
evolution of deep learning neural networks can. (cid:140)e search space
of di(cid:130)erent components and topologies can be extended, and more
hyperparameters be optimized. given the results in this paper, this
approach is likely to discover designs that are superior to those that
can be developed by hand today; it is also likely to make it possible
to apply deep learning to a wider array of tasks and applications in
the future.

7 conclusion
evolutionary optimization makes it possible to construct more
complex deep learning architectures than can be done by hand. (cid:140)e
topology, components, and hyperparameters of the architecture
can all be optimized simultaneously to (cid:128)t the requirements of the
task, resulting in superior performance. (cid:140)is automated design can
make new applications of deep learning possible in vision, speech,
language, and other areas. currently such designs are comparable
with best human designs; with anticipated increases in computing
power, they should soon surpass them, pu(cid:138)ing the power to good
use.

references
[1] pieter abbeel, adam coates, morgan (cid:139)igley, and andrew y. ng. 2007. an ap-
plication of id23 to aerobatic helicopter flight. in advances
in neural information processing systems 19.
james bagnell and je(cid:130) schneider. 2001. autonomous helicopter control using
id23 policy search methods. in proceedings of the interna-
tional conference on robotics and automation 2001. ieee.

[3] d. bahdanau, k. cho, and y. bengio. 2015. id4 by jointly

[2]

learning to align and translate. in in iclr.
j. bayer, d. wierstra, j. togelius, and j. schmidhuber. 2009. evolving memory
cell structures for sequence learning. in in arti(cid:128)cial neural networks icann.
755   764.

[5] zhengping che, sanjay purushotham, kyunghyun cho, david sontag, and yan
liu. 2016. recurrent neural networks for multivariate time series with missing
values. corr abs/1606.01865 (2016). h(cid:138)p://arxiv.org/abs/1606.01865

[4]

figure 6: results for captions generated by an evolved model
for the online magazine images rated from 1 to 4, with
4=correct, 3=mostly correct, 2=mostly incorrect, 1=incor-
rect. le(cid:133): on iconic images, the model is able to get about
one half correct; right: on all images, the model gets about
one (cid:128)(cid:133)h correct. (cid:135)e superior performance on iconic im-
ages shows that it is useful to build supplementary training
sets for speci(cid:128)c image types.

figure 7: top: four good captions. (cid:135)e model is able to ab-
stract about ambiguous images and even describe drawings,
along with photos of objects in context. bottom: four bad
captions. when it fails, the output of the model still con-
tains some correct sense of the image.

reference caption), captions generated by the evolved model on all
3100 holdout images were manually evaluated on a scale from 1
to 4 (figure 6). figure 7 shows some examples of good and bad
captions for these images.

(cid:140)e model is not perfect, but the results are promising. (cid:140)ere are
many known improvements that can be implemented, including en-
sembling diverse architectures generated by evolution, (cid:128)ne-tuning
of the id163 model, using a more recent id163 model, and
performing id125 or scheduled sampling during training
[48]. for this application, it is also important to include methods
for automatically evaluation caption quality and (cid:128)ltering captions
that would give an incorrect impression to a blind user. however,
even without these additions, the results demonstrate that it is now
possible to develop practical applications through evolving dnns.

7

446.7%321.9%23.8%127.6%420.9%316.4%215.7%147.0%[35] risto miikkulainen and neil iscoe. 2017. conversion rate optimization through

evolutionary computation. (2017). working paper.

[39]

[36] david j. montana and lawrence davis. 1989. training feedforward neural
networks using id107. in proceedings of the 11th international
joint conference on arti(cid:128)cial intelligence. san francisco: morgan kaufmann,
762   767.

[37] david e. moriarty and risto miikkulainen. 1997. forming neural networks
(cid:140)rough e(cid:129)cient and adaptive co-evolution. evolutionary computation 5
(1997), 373   399.

[38] andrew y. ng, h. jin kim, michael jordan, and shankar sastry. 2004. autonomous
helicopter flight via id23. in advances in neural information
processing systems 16.
joe yue-hei ng, ma(cid:138)hew j. hausknecht, sudheendra vijayanarasimhan, oriol
vinyals, rajat monga, and george toderici. 2015. beyond short snippets: deep
networks for video classi(cid:128)cation. corr abs/1503.08909 (2015). h(cid:138)p://arxiv.org/
abs/1503.08909

[40] ankur sinha, pekka malo, peng xu, and kalyanmoy deb. 2014. a bilevel optimiza-
tion approach to automated parameter tuning. in proceedings of the genetic and
evolutionary computation conference (gecco 2014). vancouver, bc, canada.
j. snoek, o. rippel, k. swersky, r. kiros, n. satish, n. sundaram, m.m.a. patwary,
m. prabhat, and r. p. adams. 2015. scalable bayesian optimization using deep
neural networks. in proc. of icml. 2171   2180.

[42] kenneth stanley. 2007. compositional pa(cid:138)ern producing networks: a novel
abstraction of development. genetic programming and evolvable machines 8, 2
(june 2007), 131   162.

[43] kenneth o. stanley and risto miikkulainen. 2002. evolving neural networks
through augmenting topologies. evolutionary computation 10 (2002), 99   127.
[44] c. szegedy, s. io(cid:130)e, v. vanhoucke, and a. alemi. 2016. inception-v4, inception-
resnet and the impact of residual connections on learning. arxiv preprint
arxiv:1602.07261 (2016).

[45] c. szegedy, v. vanhoucke, s. io(cid:130)e, j. shlens, , and z. wojna. 2016. rethinking

the inception architecture for id161. in proc. of cvpr. 2818   2826.

[46] r. vedantam, s. bengio, k. murphy, d. parikh, and g. chechik. 2017.
context-aware captions from context-agnostic supervision. arxiv preprint
arxiv/1701.02870 (2017).

[47] o. vinyals, a. toshev, s. bengio, and d. erhan. 2015. show and tell: a neural

[41]

image caption generator. in proc. of cvpr. 3156   3164.

[48] o. vinyals, a. toshev, s. bengio, and d. erhan. 2016. show and tell: lessons
learned from the 2015 mscoco image captioning challenge. trans. on pa(cid:136)ern
analysis and machine intelligence (2016).

[49] k. xu, j. ba, r. kiros, k. cho, a. c. courville, r. salkhutdinov, r. s. zemel, and y.
bengio. 2015. show, a(cid:138)end and tell: neural image id134 with
visual a(cid:138)ention. in proc. of icml. 77   81.

[50] xin yao. 1999. evolving arti(cid:128)cial neural networks. proc. ieee 87, 9 (1999),

[51] q. you, h. jin, z. wang, c. fang, and j. luo. 2016. image captioning with semantic

[53]

[52] w. zaremba, i. sutskever, and oriol vinyals. 2014. recurrent neural network

id173. arxiv preprint arxiv/1409.2329 (2014).
julian g. zilly, rupesh kumar srivastava, jan koutn    k, and j  urgen schmidhuber.
2016. recurrent id199. corr abs/1607.03474 (2016). h(cid:138)p://arxiv.
org/abs/1607.03474

[54] barret zoph and (cid:139)oc v. le. 2016. neural architecture search with reinforce-

ment learning. corr abs/1611.01578 (2016). h(cid:138)p://arxiv.org/abs/1611.01578

[6] x. chen, h. fang, t. y. lin, r. vedantam, s. gupta, p. dollar, and c. l. zitnick.
2015. microso(cid:137) coco captions: data collection and evaluation server. arxiv
preprint arxiv:1504.00325 (2015).

[7] kyunghyun cho, bart van merrienboer, c  aglar g  ulc  ehre, fethi bougares, holger
schwenk, and yoshua bengio. 2014. learning phrase representations using id56
encoder-decoder for id151. corr abs/1406.1078 (2014).
h(cid:138)p://arxiv.org/abs/1406.1078
j. chung, c. gulcehre, k. cho, and y. bengio. 2015. gated feedback recurrent
neural networks. arxiv preprint arxiv/1502.02367 (2015).

[9] ronan collobert and jason weston. 2008. a uni(cid:128)ed architecture for natural lan-
guage processing: deep neural networks with multitask learning. in proceedings
of the 25th international conference on machine learning. acm, 160   167.

[8]

[10] chrisantha fernando, dylan banarse, frederic besse, max jaderberg, david
pfau, malcolm reynolds, marc lactot, and daan wierstra. 2016. convolution
by evolution: di(cid:130)erentiable pa(cid:138)ern producing networks. in proceedings of the
genetic and evolutionary computation conference (gecco 2016). denver, co.
[11] dario floreano, peter d  urr, and claudio ma(cid:138)iussi. 2008. neuroevolution: from

architectures to learning. evolutionary intelligence 1 (2008), 47   62.

[12] faustino gomez and risto miikkulainen. 1997. incremental evolution of complex

general behavior. adaptive behavior 5 (1997), 317   342.

[13] faustino gomez and risto miikkulainen. 1999. solving non-markovian control
tasks with neuroevolution. in proceedings of the 16th international joint confer-
ence on arti(cid:128)cial intelligence. morgan kaufmann, san francisco, 1356   1361.

[14] faustino gomez, j  urgen schmidhuber, and risto miikkulainen. 2008. acceler-
ated neural evolution (cid:140)rough cooperatively coevolved synapses. journal of
machine learning research 9 (2008), 937   965.

[15] c. le goues, t. nguyen, s. forrest, and w. weimer. 2012. genprog: automatic
bug correction in real programs. acm transactions on so(cid:135)ware engineering 38
(2012).

[16] a. graves and n. jaitly. 2014. towards end-to-end id103 with

recurrent neural networks. in in proc. 31st icml. 1764   1772.

[17] alex graves, abdel-rahman mohamed, and geo(cid:130)rey hinton. 2013. speech
recognition with deep recurrent neural networks. in 2013 ieee international
conference on acoustics, speech and signal processing. ieee, 6645   6649.

[18] frederic gruau and darrell whitley. 1993. adding learning to the cellular de-
velopment of neural networks: evolution and the baldwin e(cid:130)ect. evolutionary
computation 1 (1993), 213   233.

[19] k. he, x. zhang, s. ren, and j. sun. 2015. deep residual learning for image

recognition. corr abs/1512.03385 (2015).

[20] kaiming he, xiangyu zhang, shaoqing ren, and jian sun. 2016.

identity
mappings in deep residual networks. corr abs/1603.05027 (2016). h(cid:138)p:
//arxiv.org/abs/1603.05027

[21] geo(cid:130)rey e. hinton and steven j. nowlan. 1987. how learning can guide

evolution. complex systems 1 (1987), 495   502.

[24] christian igel. 2003. neuroevolution for id23 using evolution
strategies. in proceedings of the 2003 congress on evolutionary computation. ieee
press, piscataway, nj, 2588   2595.

[25] r. jozefowicz, w. zaremba, and i. sutskever. 2015. an empirical exploration
of recurrent network architectures. in in proceedings of the 32nd international
conference on machine learning. 2342   2350.

[26] nal kalchbrenner, ivo danihelka, and alex graves. 2015. grid long short-term

memory. corr abs/1507.01526 (2015). h(cid:138)p://arxiv.org/abs/1507.01526

[27] a. karpathy and l. fei-fei. 2015. deep visual-semantic alignments for generating

image descriptions. in proc. of cvpr. 3128   3137.

[28] g. klaus, r. srivastava, j. koutnk, r. steunebrink, and j. schmidhuber. 2014.

lstm: a search space odyssey. arxiv preprint arxiv/1503.04069 (2014).

[29] rogier koppejan and shimon whiteson. 2011. neuroevolutionary reinforcement
learning for generalized control of simulated helicopters. evolutionary intelligence
4 (2011), 219   241.

[30] yann lecun, leon bo(cid:138)ou, yoshua bengio, and patrick ha(cid:130)ner. 1998. gradient-
proc. ieee 86 (1998),

based learning applied to document recognition.
2278(cid:128)(cid:147)2324.
joel lehman and risto miikkulainen. 2013. neuroevolution. scholarpedia 8, 6
(2013), 30977.
jason zhi liang and risto miikkulainen. 2015. evolutionary bilevel optimiza-
tion for complex control tasks. in proceedings of the genetic and evolutionary
computation conference (gecco 2015). madrid, spain.
ilya loshchilov and frank hu(cid:138)er. 2016. cma-es for hyperparameter op-
timization of deep neural networks. corr abs/1604.07269 (2016). h(cid:138)p:
//arxiv.org/abs/1604.07269

[31]

[32]

[33]

[34] m. p. marcus, m. a. marcinkiewicz, and b. santorini. 1993. building a large
annotated corpus of english: (cid:140)e id32. computational linguistics 19(2)
(1993).

8

[22] sepp hochreiter and j  urgen schmidhuber. 1997. long short-term memory. neural

1423   1447.

[23] holger hoos. 2012. programming by optimization. commun. acm 55 (2012),

a(cid:138)ention. in proc. of cvpr. 4651   4659.

computation 9 (1997), 1735   1780.

70   80.

