autoextend: extending id27s to embeddings for synsets

and lexemes

sascha rothe and hinrich sch  utze

center for information & language processing

university of munich

5
1
0
2

 
l
u
j
 

4

 
 
]
l
c
.
s
c
[
 
 

1
v
7
2
1
1
0

.

7
0
5
1
:
v
i
x
r
a

sascha@cis.lmu.de

abstract

we present autoextend, a system to learn
embeddings for synsets and lexemes. it is
   exible in that it can take any word embed-
dings as input and does not need an addi-
tional training corpus. the synset/lexeme
embeddings obtained live in the same vec-
tor space as the id27s. a
sparse tensor formalization guarantees ef-
   ciency and parallelizability. we use
id138 as a lexical resource, but auto-
extend can be easily applied to other
resources like freebase.
autoextend
achieves state-of-the-art performance on
word similarity and word sense disam-
biguation tasks.

1

introduction

unsupervised methods for id27s (also
called    distributed word representations   ) have
become popular in natural language processing
(nlp). these methods only need very large cor-
pora as input to create sparse representations (e.g.,
based on local collocations) and project them into
a lower dimensional dense vector space. examples
for id27s are senna (collobert and
weston, 2008), the hierarchical log-bilinear model
(mnih and hinton, 2009), id97 (mikolov et
al., 2013c) and glove (pennington et al., 2014).
however, there are many other resources that are
undoubtedly useful in nlp, including lexical re-
sources like id138 and wiktionary and knowl-
edge bases like wikipedia and freebase. we will
simply call these resources in the rest of the pa-
per. our goal is to enrich these valuable resources
with embeddings for those data types that are not
words; e.g., we want to enrich id138 with em-
beddings for synsets and lexemes. a synset is a set
of synonyms that are interchangeable in some con-
text. a lexeme pairs a particular spelling or pro-

nunciation with a particular meaning, i.e., a lex-
eme is a conjunction of a word and a synset. our
premise is that many nlp applications will bene-
   t if the non-word data types of resources     e.g.,
synsets in id138     are also available as embed-
dings. for example, in machine translation, en-
riching and improving translation dictionaries (cf.
mikolov et al. (2013b)) would bene   t from these
embeddings because they would enable us to cre-
ate an enriched dictionary for word senses. gen-
erally, our premise is that the arguments for the
utility of embeddings for word forms should carry
over to the utility of embeddings for other data
types like synsets in id138.

the insight underlying the method we propose
is that the constraints of a resource can be formal-
ized as constraints on embeddings and then allow
us to extend id27s to embeddings of
other data types like synsets. for example, the hy-
ponymy relation in id138 can be formalized as
such a constraint.

the advantage of our approach is that it de-
couples embedding learning from the extension of
embeddings to non-word data types in a resource.
if somebody comes up with a better way of learn-
ing embeddings, these embeddings become imme-
diately usable for resources. and we do not rely on
any speci   c properties of embeddings that make
them usable in some resources, but not in others.
an alternative to our approach is to train embed-
dings on annotated text, e.g., to train synset em-
beddings on corpora annotated with synsets. how-
ever, successful embedding learning generally re-
quires very large corpora and sense labeling is too
expensive to produce corpora of such a size.

another alternative to our approach is to add up
all id27 vectors related to a particular
node in a resource; e.g., to create the synset vector
of lawsuit in id138, we can add the word vec-
tors of the three words that are part of the synset
(lawsuit, suit, case). we will call this approach

naive and use it as a baseline (snaive in table 3).

we will focus on id138 (fellbaum, 1998) in
this paper, but our method     based on a formaliza-
tion that exploits the constraints of a resource for
extending embeddings from words to other data
types     is broadly applicable to other resources in-
cluding wikipedia and freebase.

a word in id138 can be viewed as a compo-
sition of several lexemes. lexemes from different
words together can form a synset. when a synset
is given, it can be decomposed into its lexemes.
and these lexemes then join to form words. these
observations are the basis for the formalization of
the constraints encoded in id138 that will be
presented in the next section: we view words as
the sum of their lexemes and, analogously, synsets
as the sum of their lexemes.

another motivation for our formalization stems
from the analogy calculus developed by mikolov
et al. (2013a), which can be viewed as a group
theory formalization of word relations: we have
a set of elements (our vectors) and an operation
(addition) satisfying the properties of a mathemat-
ical group, in particular, associativity and invert-
ibility. for example, you can take the vector of
king, subtract the vector of man and add the vec-
tor of woman to get a vector near queen. in other
words, you remove the properties of man and add
the properties of woman. we can also see the vec-
tor of king as the sum of the vector of man and the
vector of a gender-neutral ruler. the next thing
to notice is that this does not only work for words
that combine several properties, but also for words
that combine several senses. the vector of suit can
be seen as the sum of a vector representing law-
suit and a vector representing business suit. auto-
extend is designed to take word vectors as input
and unravel the word vectors to the vectors of their
lexemes. the lexeme vectors will then give us the
synset vectors.

the main contributions of this paper are:

(i)
we present autoextend, a    exible method that ex-
tends id27s to embeddings of synsets
and lexemes. autoextend is completely general in
that it can be used for any set of embeddings and
for any resource that imposes constraints of a cer-
tain type on the relationship between words and
other data types.
(ii) we show that autoextend
achieves state-of-the-art word similarity and word
sense disambiguation (wsd) performance.
(iii)
we publish the autoextend code for extending

id27s to other data types, the lexeme
and synset embeddings and the software to repli-
cate our wsd evaluation.

this paper is structured as follows. section 2 in-
troduces the model,    rst as a general tensor formu-
lation then as a matrix formulation making addi-
tional assumptions. in section 3, we describe data,
experiments and evaluation. we analyze auto-
extend in section 4 and give a short summary on
how to extend our method to other resources in
section 5. section 6 discusses related work.

2 model

we are looking for a model that extends standard
embeddings for words to embeddings for the other
two data types in id138: synsets and lexemes.
we want all three data types     words, lexemes,
synsets     to live in the same embedding space.

the basic premise of our model is: (i) words are
sums of their lexemes and (ii) synsets are sums of
their lexemes. we refer to these two premises as
synset constraints. for example, the embedding
of the word bloom is a sum of the embeddings of
its two lexemes bloom(organ) and bloom(period);
and the embedding of the synset    ower-bloom-
blossom(organ) is a sum of the embeddings of
its three lexemes    ower(organ), bloom(organ) and
blossom(organ).

the synset constraints can be argued to be the
simplest possible relationship between the three
id138 data types. they can also be motivated
by the way many embeddings are learned from
corpora     for example, the counts in vector space
models are additive, supporting the view of words
as the sum of their senses. the same assumption
is frequently made; for example, it underlies the
group theory formalization of analogy discussed
in section 1.
we denote word vectors as w(i)     rn, synset
vectors as s(j)     rn, and lexeme vectors as l(i,j)    
rn. l(i,j) is that lexeme of word w(i) that is a mem-
ber of synset s(j). we set lexeme vectors l(i,j) that
do not exist to zero. for example, the non-existing
lexeme    ower(truck) is set to zero. we can then
formalize our premise that the two constraints (i)
and (ii) hold as follows:

(cid:88)
(cid:88)

j

i

w(i) =

s(j) =

l(i,j)

l(i,j)

(1)

(2)

these two equations are underspeci   ed. we there-
fore introduce the matrix e(i,j)     rn  n:

l(i,j) = e(i,j)w(i)

(3)

we make the assumption that the dimensions in
eq. 3 are independent of each other, i.e., e(i,j)
is a diagonal matrix. our motivation for this as-
sumption is: (i) this makes the computation tech-
nically feasible by signi   cantly reducing the num-
ber of parameters and by supporting parallelism.
(ii) treating id27s on a per-dimension
basis is a frequent design choice (e.g., kalchbren-
ner et al. (2014)). note that we allow e(i,j) < 0
and in general the distribution weights for each di-
mension (diagonal entries of e(i,j)) will be differ-
ent. our assumption can be interpreted as word
w(i) distributing its embedding activations to its
lexemes on each dimension separately. therefore,
eqs. 1-2 can be written as follows:

(cid:88)
(cid:88)

j

i

w(i) =

s(j) =

e(i,j)w(i)

e(i,j)w(i)

note that from eq. 4 it directly follows that:

(cid:88)

e(i,j) = in    i

j

with in being the identity matrix.
let w be a |w|    n matrix where n is the di-
mensionality of the embedding space, |w| is the
number of words and each row w(i) is a word em-
bedding; and let s be a |s|   n matrix where |s| is
the number of synsets and each row s(j) is a synset
embedding. w and s can be interpreted as linear
maps and a mapping between them is given by the
rank 4 tensor e     r|s|  n  |w|  n. we can then
write eq. 5 as a tensor product:
s = e     w

(7)

(4)

(5)

(6)

= 0 if l(i,j) = 0; i.e., l(i,j) (cid:54)= 0
not exist: ei,d1
j,d2
only if word i has a lexeme that is a member of
synset j. to summarize the sparsity:

ei,d1
j,d2

= 0     d1 (cid:54)= d2     l(i,j) = 0

(9)

2.1 learning
we adopt an autoencoding framework to learn em-
beddings for lexemes and synsets. to this end, we
view the tensor equation s = e     w as the en-
coding part of the autoencoder: the synsets are the
encoding of the words. we de   ne a corresponding
decoding part that decodes the synsets into words
as follows:

s(j) =

(i,j)

l

, w(i) =

(i,j)

l

(10)

i

j

in analogy to e(i,j), we introduce the diagonal ma-
trix d(j,i):

(i,j)

l

= d(j,i)s(j)

(11)

in this case, it is the synset that distributes itself to
its lexemes. we can then rewrite eq. 10 to:

(cid:88)

(cid:88)

s(j) =

d(j,i)s(j), w(i) =

d(j,i)s(j) (12)

i

j

and we also get the equivalent of eq. 6 for d(j,i):

(cid:88)

d(j,i) = in    j

(cid:88)

(cid:88)

i

and in tensor notation:

w = d     s

id172 and sparseness properties for the
decoding part are analogous to the encoding part:

(cid:88)

dj,d2
i,d1

= 1    j, d1, d2

i

dj,d2
i,d1

= 0     d1 (cid:54)= d2     l(i,j) = 0

(13)

(14)

(15)

(16)

while eq. 6 states, that(cid:88)

ei,d1
j,d2

= 1    i, d1, d2

we can state the learning objective of the autoen-
coder as follows:

(8)

argmin

(cid:107)d     e     w     w(cid:107)

(17)

j

e,d

additionally, there is no interaction between dif-
= 0 if d1 (cid:54)= d2. in
ferent dimensions, so ei,d1
j,d2
other words, we are creating the tensor by stacking
the diagonal matrices e(i,j) over i and j. another
sparsity arises from the fact that many lexemes do

under the conditions eq. 8, 9, 15 and 16.

now we have an autoencoder where input and
output layers are the id27s and the
hidden layer represents the synset vectors. a sim-
pli   ed version is shown in figure 1. the tensors e

and d have to be learned. they are rank 4 tensors
of size    1015. however, we already discussed that
they are very sparse, for two reasons: (i) we make
the assumption that there is no interaction between
dimensions.
(ii) there are only few interactions
between words and synsets (only when a lexeme
exists). in practice, there are only    107 elements
to learn, which is technically feasible.

2.2 matrix formalization
based on the assumption that each dimension is
fully independent from other dimensions, a sepa-
rate autoencoder for each dimension can be cre-
ated and trained in parallel. let w     r|w|  n be
a matrix where each row is a id27 and
w(d) = w  ,d the d-th column of w , i.e., a vector
that holds the d-th dimension of each word vector.
in the same way, s(d) = s  ,d holds the d-th di-
  ,d  ,d    
mension of each synset vector and e(d) = e
r|s|  |w|. we can write s = e     w as:

s(d) = e(d)w(d)    d

(18)

i,j = 0 if l(i,j) = 0. the decoding equation

with e(d)
w = d     s takes this form:

w(d) = d(d)s(d)    d

(19)

  ,d  ,d     r|w|  |s| and d(d)

where d(d) = d
j,i = 0 if
l(i,j) = 0. so e and d are symmetric in terms
of non-zero elements. the learning objective be-
comes:

(cid:107)d(d)e(d)w(d)     w(d)(cid:107)    d

(20)

argmin
e(d),d(d)

2.3 lexeme embeddings
the hidden layer s of the autoencoder gives us
synset embeddings. the lexeme embeddings are
de   ned when transitioning from w to s, or more
explicitly by:

l(i,j) = e(i,j)w(i)

(21)

however, there is also a second lexeme embedding
in autoextend when transitioning form s to w :

(i,j)

l

= d(j,i)s(j)

(22)

aligning these two representations seems natural,
so we impose the following lexeme constraints:

(cid:13)(cid:13)(cid:13)e(i,j)w(i)     d(j,i)s(j)(cid:13)(cid:13)(cid:13)

   i, j (23)

argmin
e(i,j),d(j,i)

hypernymy
antonymy
similarity
verb group

noun
84,505
2,154
0
0

verb
13,256
1,093
0
1,744

adj
0
4,024
21,434
0

adv
0
712
0
0

table 1: # of wn relations by part-of-speech

this can also be expressed dimension-wise. the
matrix formulation is given by:

(cid:13)(cid:13)(cid:13)e(d) diag(w(d))    (cid:0)d(d) diag(s(d))(cid:1)t(cid:13)(cid:13)(cid:13)   d

argmin
e(d),d(d)

(24)
with diag(x) being a square matrix having x
on the main diagonal and vector s(d) de   ned by
eq. 18. while we try to align the embeddings,
there are still two different lexeme embeddings. in
all experiments reported in section 4 we will use
the average of both embeddings and in section 4
we will analyze the weighting in more detail.

2.4 wn relations
some id138 synsets contain only a single word
(lexeme). the autoencoder learns based on the
synset constraints, i.e., lexemes being shared by
different synsets (and also words); thus, it is dif-
   cult to learn good embeddings for single-lexeme
synsets. to remedy this problem, we impose the
constraint that synsets related by id138 (wn)
relations should have similar embeddings. table 1
shows relations we used. wn relations are entered
in a new matrix r     rr  |s|, where r is the number
of wn relation tuples. for each relation tuple, i.e.,
row in r, we set the columns corresponding to the
   rst and second synset to 1 and    1, respectively.
the values of r are not updated during training.
we use a squared error function and 0 as target
value. this forces the system to    nd similar val-
ues for related synsets. formally, the wn relation
constraints are:

argmin

(cid:107)re(d)w(d)(cid:107)    d

(25)

e(d)

implementation

2.5
our training objective is minimization of the sum
of synset constraints (eq. 20), weighted by   , the
lexeme constraints (eq. 24), weighted by   , and
the wn relation constraints (eq. 25), weighted by
1              .

the training objective cannot be solved analyt-
ically because it is subject to constraints eq. 8,

figure 1: a small subgraph of id138. the circles are intended to show four different embedding dimensions. these
dimensions are treated as independent. the synset constraints align the input and the output layer. the lexeme constraints align
the second and fourth layers.

eq. 9, eq. 15 and eq. 16. we therefore use back-
propagation. we do not use id173 since
we found that all learned weights are in [   2, 2].

autoextend is implemented in matlab. we
run 1000 iterations of id119. on an in-
tel xeon cpu e7-8857 v2 3.00ghz, one iteration
on one dimension takes less than a minute because
the gradient computation ignores zero entries in
the matrix.

2.6 column id172
our model is based on the premise that a word is
the sum of its lexemes (eq. 1). from the de   ni-
tion of e(i,j), we derived that e     r|s|  n  |w|  n
is normalized over the    rst dimension (eq. 8). so
e(d)     r|s|  |w| is also normalized over the    rst
dimension. in other words, e(d) is a column nor-
malized matrix. another premise of the model is
that a synset is the sum of its lexemes. therefore,
d(d) is also column normalized. a simple way
to implement this is to start the computation with
column normalized matrices and normalize them
again after each iteration as long as the error func-
tion still decreases. when the error function starts
increasing, we stop normalizing the matrices and
continue with a normal id119. this re-
spects that while e(d) and d(d) should be column
normalized in theory, there are a lot of practical
issues that prevent this, e.g., oov words.

id138     id97
54,570
147,478
73,844
117,791
207,272
106,167

words
synsets
lexemes

table 2: # of items in id138 and after intersection with
id97 vectors

3 data, experiments and evaluation

we downloaded 300-dimensional embeddings for
3,000,000 words and phrases trained on google
news, a corpus of    1011 tokens, using id97
cbow (mikolov et al., 2013c). many words
in the id97 vocabulary are not in id138,
e.g., in   ected forms (cars) and proper nouns (tony
blair). conversely, many id138 lemmas are
not in the id97 vocabulary, e.g., 42 (digits
were converted to 0). this results in a number of
empty synsets (see table 2). note however that
autoextend can produce embeddings for empty
synsets because we use wn relation constraints in
addition to synset and lexeme constraints.

we run autoextend on the id97 vectors.
as we do not know anything about a suitable
weighting for the three different constraints, we
set    =    = 0.33. our main goal is to produce
compatible embeddings for lexemes and synsets.
thus, we can compute nearest neighbors across all
three data types as shown in figure 2.

we evaluate the embeddings on wsd and on
similarity performance. our results depend di-
rectly on the quality of the underlying word em-
beddings, in our case id97 embeddings. we
would expect even better evaluation results as
word representation learning methods improve.
using a new and improved set of underlying em-
beddings is simple:
it is a simple switch of the
input    le that contains the id27s.

3.1 id51
for wsd we use the shared tasks of senseval-
2 (kilgarriff, 2001) and senseval-3 (mihalcea et
al., 2004) and a system named ims (zhong and
ng, 2010). senseval-2 contains 139, senseval-3

nearest neighbors of w/suit
(businessman),

(businessman),
s/suit
l/accomodate, s/suit (be acceptable), l/suit (be accept-
able), l/lawsuit, w/lawsuit, s/suit (playing card), l/suit
(playing card), s/suit (petition), s/lawsuit, w/countersuit,
w/complaint, w/counterclaim

l/suit

nearest neighbors of w/lawsuit

s/lawsuit,

l/lawsuit,
l/countersuit,
w/countersuit, w/suit, w/counterclaim, s/counterclaim
(n),
s/counterclaim (v),
l/counterclaim (v), w/sue, s/sue (n), l/sue (n)

l/counterclaim (n),

s/countersuit,

nearest neighbors of s/suit-of-clothes

l/suit-of-clothes, s/zoot-suit, l/zoot-suit, w/zoot-suit,
s/garment, l/garment, s/dress, s/trousers, l/pinstripe,
l/shirt, w/tuxedo, w/gabardine, w/tux, w/pinstripe

figure 2: five nearest word (w/), lexeme (l/) and synset (s/)
neighbors for three items, ordered by cosine

57 different words. they provide 8,611, respec-
tively 8,022 training instances and 4,328, respec-
tively 3,944 test instances. for the system, we
use the same setting as in the original paper. pre-
processing consists of sentence splitting, tokeniza-
tion, id52 and lemmatization; the classi-
   er is a linear id166. in our experiments (table 3),
we run ims with each feature set by itself to as-
sess the relative strengths of feature sets (lines 1   
7) and on feature set combinations to determine
which combination is best for wsd (lines 8, 12   
15).

ims implements three standard wsd feature
sets: part of speech (pos), surrounding word and
local collocation (lines 1   3).

let w be an ambiguous word with k senses. the
three feature sets on lines 5   7 are based on the
autoextend embeddings s(j), 1     j     k, of the
synsets of w and the centroid c of the sentence in
which w occurs. the centroid is simply the sum of
all id97 vectors of the words in the sentence,
excluding stop words.

the s-cosine feature set consists of the k

cosines of centroid and synset vectors:

< cos(c, s(1)), cos(c, s(2)), . . . , cos(c, s(k)) >

the s-product feature set consists of the nk
element-wise products of centroid and synset vec-
tors:

< c1s(1)

1 , . . . , cns(1)

n , . . . , c1s(k)

1 , . . . , cns(k)

n >

where ci (resp. s(j)
) is element i of c (resp. s(j)).
i
the idea is that we let the id166 estimate how im-
portant each dimension is for wsd instead of giv-
ing all equal weight as in s-cosine.

the s-raw feature set simply consists of the
n(k + 1) elements of centroid and synset vectors:

< c1, . . . , cn, s(1)

1 , . . . , s(1)

n , . . . , s(k)

1 , . . . , s(k)

n >

our main goal is to determine if autoextend
features improve wsd performance when added
to standard wsd features. to make sure that
improvements we get are not solely due to the
power of id97, we also investigate a sim-
ple id97 baseline. for s-product, the auto-
extend feature set that performs best in the exper-
iment (cf. lines 6 and 14), we test the alternative
id97-based snaive-product feature set. it has
the same de   nition as s-product except that we
replace the synset vectors s(j) with naive synset
vectors z(j), de   ned as the sum of the id97
vectors of the words that are members of synset j.
lines 1   7 in table 3 show the performance of
each feature set by itself. we see that the synset
feature sets (lines 5   7) have a comparable perfor-
mance to standard feature sets. s-product is the
strongest of them.

lines 8   16 show the performance of different
feature set combinations. mfs (line 8) is the most
frequent sense baseline. lines 9&10 are the win-
ners of senseval. the standard con   guration of
ims (line 11) uses the three feature sets on lines
1   3 (pos, surrounding word, local collocation)
and achieves an accuracy of 65.2% on the english
lexical sample task of senseval-2 and 72.3% on
senseval-3.1 lines 12   16 add one additional fea-
ture set to the ims system on line 11; e.g., the sys-
tem on line 14 uses pos, surrounding word, local
collocation and s-product feature sets. the system
on line 14 outperforms all previous systems, most
of them signi   cantly. while s-raw performs quite
reasonably as a feature set alone, it hurts the per-
formance when used as an additional feature set.
as this is the feature set that contains the largest
number of features (n(k + 1)), over   tting is the
likely reason. conversely, s-cosine only adds k
features and therefore may suffer from under   t-
ting.   

we do a grid search (step size .1) for optimal
values of    and   , optimizing the average score of
senseval-2 and senseval-3. the best performing
feature set combination is soptimized-product with
1zhong and ng (2010) report accuracies of 65.3% /
72.6% for this con   guration.
   in table 3 and table 4, results signi   cantly worse than
the best (bold) result in each column are marked     for    =
.05 and     for    = .10 (one-tailed z-test).

i

t
e
s

e
r
u
t
a
e
f
s
m

pos
s 1
surrounding word
2
local collocation
3
snaive-product
4
s-cosine
5
s-product
6
7
s-raw
8 mfs
9 rank 1 system
10 rank 2 system
11
12
13
14
15
16

ims
ims + snaive-prod.
ims + s-cosine
ims + s-product
ims + s-raw
ims + soptimized-prod.

n
o
s
i
r
a
p
m
o
c
m
e
t
s
y
s

senseval-2
53.6
57.6
58.7
56.5
55.5
58.3
56.8
47.6   
64.2   
63.8   
65.2   
62.6   
65.1   
66.5
62.1   
66.6

senseval-3

58.0   
65.3   
64.7   
62.2   
60.5   
64.3   
63.1   
55.2   
72.9   
72.6   
72.3   
69.4   
72.4   
73.6   
66.8   
73.6   

table 3: wsd accuracy for different feature sets and systems.
best result (excluding line 16) in each column in bold.

   = 0.2 and    = 0.5, with only a small improve-
ment (line 16).

the main result of this experiment is that we
achieve an improvement of more than 1% in wsd
performance when using autoextend.

3.2 synset and lexeme similarity
we use scws (huang et al., 2012) for the similar-
ity evaluation. scws provides not only isolated
words and corresponding similarity scores, but
also a context for each word. scws is based on
id138, but the information as to which synset a
word in context came from is not available. how-
ever, the dataset is the closest we could    nd for
sense similarity. synset and lexeme embeddings
are obtained by running autoextend. based on
the results of the wsd task, we set    = 0.2 and
   = 0.5. lexeme embeddings are the natural
choice for this task as human subjects are provided
with two words and a context for each and then
have to assign a similarity score. but for complete-
ness, we also run experiments for synsets.

for each word, we compute a context vector
c by adding all word vectors of the context, ex-
cluding the test word itself. following reisinger
and mooney (2010), we compute the lexeme (resp.
synset) vector l either as the simple average of
the lexeme (resp. synset) vectors l(ij) (method
avgsim, no dependence on c in this case) or
as the average of the lexeme (resp. synset) vec-
tors weighted by cosine similarity to c (method
avgsimc).

table 4 shows that autoextend lexeme embed-
dings (line 7) perform better than previous work,

tian et al. (2014)

1 huang et al. (2012)
2
3 neelakantan et al. (2014)
4 chen et al. (2014)
5 words (id97)
6
7

synsets
lexemes

avgsim avgsimc
62.8   
   
67.2   
66.2   
66.6   
62.6   
68.9   

65.7   
65.4   
69.3   
68.9   
66.6   
63.7   
69.8   

table 4: spearman correlation (      100) on scws. best re-
sult per column in bold.

including (huang et al., 2012) and (tian et al.,
2014). lexeme embeddings perform better than
synset embeddings (lines 7 vs. 6), presumably be-
cause using a representation that is speci   c to the
actual word being judged is more precise than us-
ing a representation that also includes synonyms.
a simple baseline is to use the underlying
id97 embeddings directly (line 5).
in this
case, there is only one embedding, so there is no
difference between avgsim and avgsimc. it is in-
teresting that even if we do not take the context
into account (method avgsim) the lexeme embed-
dings outperform the original id27s.
as avgsim simply adds up all lexemes of a word,
this is equivalent to the constraint we proposed in
the beginning of the paper (eq. 1). thus, replacing
a word   s embedding by the sum of the embeddings
of its senses could generally improve the quality of
embeddings (cf. huang et al. (2012) for a similar
point). we will leave a deeper evaluation of this
topic for future work.

4 analysis

we    rst look at the impact of the parameters   ,   
(section 2.5) that control the weighting of synset
constraints vs lexeme constraints vs wn relation
constraints. we investigate the impact for three
different tasks. wsd-alone: accuracy of ims
(average of senseval-2 and senseval-3) if only s-
product is used as a feature set (line 6 in table 3).
wsd-additional: accuracy of ims (average of
senseval-2 and senseval-3) if s-product is used
together with the feature sets pos, surrounding
word and local collocation (line 14 in table 3).
scws: spearman correlation on scws (line 7 in
table 4).

for wsd-alone (figure 3, center), the best per-
forming weightings (red) all have high weights
for wn relations and are therefore at the top of
triangle. thus, wn relations are very important
for wsd-alone and adding more weight to the

synset and lexeme constraints does not help. how-
ever, all three constraints are important in wsd-
additional:
the red area is in the middle (corre-
sponding to nonzero weights for all three con-
straints) in the left panel of figure 3. apparently,
strongly weighted lexeme and synset constraints
enable learning of representations that in their in-
teraction with standard wsd feature sets like lo-
cal collocation increase wsd performance. for
scws (right panel), we should not put too much
weight on wn relations as they arti   cially bring
related, but not similar lexemes together. so the
maximum for this task is located in the lower part
of the triangle.

the main result of this analysis is that auto-
extend never achieves its maximum performance
when using only one set of constraints. all three
constraints are important     synset, lexeme and wn
relation constraints     with different weights for
different applications.

we also analyzed the impact of the four differ-
ent wn relations (see table 1) on performance. in
table 3 and table 4, all four wn relations are used
together. we found that any combination of three
relation types performs worse than using all four
together. a comparison of different relations must
be done carefully as they differ in the pos they
affect and in quantity (see table 1). in general, re-
lation types with more relations outperformed re-
lation types with fewer relations.

finally, the relative weighting of l(i,j) and l

(i,j)

when computing lexeme embeddings is also a pa-
rameter that can be tuned. we use simple aver-
aging (   = 0.5) for all experiments reported in
this paper. we found only small changes in per-
formance for 0.2            0.8.

5 resources other than id138

autoextend is broadly applicable to lexical and
knowledge resources that have certain properties.
while we only run experiments with id138 in
this paper, we will brie   y address other resources.
for freebase (bollacker et al., 2008), we could re-
place the synsets with freebase entities. each en-
tity has several aliases, e.g. barack obama, presi-
dent obama, obama. the role of words in word-
net would correspond to these aliases in freebase.
this will give us the synset constraint, as well as
the lexeme constraint of the system. relations are
given by freebase types; e.g., we can add a con-
straint that entity embeddings of the type    presi-

dent of the us    should be similar.

to explorer multilingual id27s we
require the id27s of different lan-
guages to live in the same vector space, which
can easily be achieved by training a transforma-
tion matrix l between two languages using known
translations (mikolov et al., 2013b). let x be a
matrix where each row is a id27 in
language 1 and y a matrix where each row is a
id27 in language 2. for each row the
words of x and y are a translation of each other.
we then want to minimize the following objective:

argmin

(cid:107)lx     y (cid:107)

l

(26)

we can use a id119 to solve this but a
matrix inversion will run faster. the matrix l is
given by:

l = (x t     x)   1(x t     y )

(27)

the matrix l can be used to transform unknown
embeddings into the new vector space, which en-
ables us to use a id73net like ba-
belnet (navigli and ponzetto, 2010) to compute
synset embeddings. we can add cross-linguistic
relationships to our model, e.g., aligning german
and english synset embeddings of the same con-
cept.

6 related work
rumelhart et al. (1988) introduced distributed
word representations, usually called word embed-
dings today. there has been a resurgence of
work on them recently (e.g., bengio et al. (2003)
mnih and hinton (2007), collobert et al. (2011),
mikolov et al. (2013a), pennington et al. (2014)).
these models produce only a single embedding
for each word. all of them can be used as input
for autoextend.

there are several approaches to    nding embed-
dings for senses, variously called meaning, sense
and multiple id27s. sch  utze (1998)
created sense representations by id91 context
representations derived from co-occurrence. the
representation of a sense is simply the centroid of
its cluster. huang et al. (2012) improved this by
learning single-prototype embeddings before per-
forming word sense discrimination on them. bor-
des et al. (2011) created similarity measures for
relations in id138 and freebase to learn en-
tity embeddings. an energy based model was

figure 3: performance of different weightings of the three constraints (wn relations:top, lexemes:left, synsets:right) on the
three tasks wsd-additional, wsd-alone and scws.    x    indicates the maximum;    o    indicates a local minimum.

proposed by bordes et al. (2012) to create dis-
ambiguated meaning embeddings and neelakan-
tan et al. (2014) and tian et al. (2014) extended
the skip-gram model (mikolov et al., 2013a) to
learn multiple id27s. while these em-
beddings can correspond to different word senses,
there is no clear mapping between them and a lexi-
cal resource like id138. chen et al. (2014) also
modi   ed id97 to learn sense embeddings,
each corresponding to a id138 synset. they
use glosses to initialize sense embedding, which
in turn can be used for wsd. the sense disam-
biguated data can again be used to improve sense
embeddings.

this prior work needs a training step to learn
embeddings.
in contrast, we can    autoextend   
any set of given id27s     without
(re)training them.

there is only little work on taking existing
id27s and producing embeddings in
the same space. labutov and lipson (2013) tuned
existing id27s in supervised training,
not to create new embeddings for senses or enti-
ties, but to get better predictive performance on a
task while not changing the space of embeddings.
lexical resources have also been used to im-
prove id27s.
in the relation con-
strained model, yu and dredze (2014) use
id97 to learn embeddings that are optimized
to predict a related word in the resource, with good
evaluation results. bian et al. (2014) used not
only semantic, but also morphological and syn-
tactic knowledge to compute more effective word
embeddings.

another interesting approach to create sense
speci   c id27s uses bilingual resources
(guo et al., 2014). the downside of this approach
is that parallel data is needed.

we used the scws dataset for the word similar-
ity task, as it provides a context. other frequently
used datasets are wordsim-353 (finkelstein et al.,
2001) or men (bruni et al., 2014).

and while we use cosine to compute similar-
ity between synsets, there are also a lot of simi-
larity measures that only rely on a given resource,
mostly id138. these measures are often func-
tions that depend on the provided information like
gloss or the topology like shortest-path. examples
include (wu and palmer, 1994) and (leacock and
chodorow, 1998); blanchard et al. (2005) give a
good overview.

7 conclusion

we presented autoextend, a    exible method to
learn synset and lexeme embeddings from word
embeddings. it is completely general and can be
used for any other set of embeddings and for any
other resource that imposes constraints of a cer-
tain type on the relationship between words and
other data types. our experimental results show
that autoextend achieves state-of-the-art perfor-
mance on word similarity and word sense disam-
biguation. along with this paper, we will pub-
lish autoextend for extending id27s
to other data types; the lexeme and synset em-
beddings used in the experiments; and the code
needed to replicate our wsd evaluation2.

acknowledgments

this work was partially funded by deutsche
forschungsgemeinschaft (dfg schu 2246/2-2).
we are grateful to christiane fellbaum for discus-
sions leading up to this paper and to the anony-
mous reviewers for their comments.
2http://cistern.cis.lmu.de/

references
[bengio et al.2003] yoshua bengio, rejean ducharme,
and pascal vincent. 2003. a neural probabilistic
language model. journal of machine learning re-
search, 3:1137   1155.

[bian et al.2014] jiang bian, bin gao, and tie-yan liu.
2014. knowledge-powered deep learning for word
embedding. in proceedings of ecml pkdd.

[blanchard et al.2005] emmanuel blanchard, mounira
harzallah, henri briand, and pascale kuntz. 2005.
a typology of ontology-based semantic measures.
in proceedings of emoi - interop.

[bollacker et al.2008] kurt bollacker, colin evans,
praveen paritosh, tim sturge, and jamie taylor.
2008. freebase: a collaboratively created graph
database for structuring human knowledge. in pro-
ceedings of acm sigmod.

[bordes et al.2011] antoine bordes, jason weston, ro-
nan collobert, yoshua bengio, et al. 2011. learn-
ing structured embeddings of knowledge bases. in
proceedings of aaai.

[bordes et al.2012] antoine bordes, xavier glorot, ja-
son weston, and yoshua bengio. 2012. joint learn-
ing of words and meaning representations for open-
text id29. in proceedings of aistats.

[bruni et al.2014] elia bruni, nam khanh tran, and
marco baroni. 2014. multimodal distributional se-
mantics. journal of arti   cial intelligence research,
49(1):1   47.

[chen et al.2014] xinxiong chen, zhiyuan liu, and
maosong sun. 2014. a uni   ed model for word
in pro-
sense representation and disambiguation.
ceedings of emnlp.

[collobert and weston2008] ronan collobert and ja-
son weston. 2008. a uni   ed architecture for natu-
ral language processing: deep neural networks with
multitask learning. in proceedings of icml.

[collobert et al.2011] ronan collobert, jason weston,
l  eon bottou, michael karlen, koray kavukcuoglu,
and pavel kuksa.
2011. natural language pro-
cessing (almost) from scratch. journal of machine
learning research, 12:2493   2537.

[fellbaum1998] christiane fellbaum. 1998. id138:

an electronic lexical database. bradford books.

[finkelstein et al.2001] lev

finkelstein,

evgeniy
gabrilovich, yossi matias, ehud rivlin, zach
solan, gadi wolfman, and eytan ruppin. 2001.
placing search in context: the concept revisited. in
proceedings of www.

[gurevych2005] iryna gurevych.

2005. using the
structure of a conceptual network in computing se-
mantic relatedness. in ijcnlp.

[hamp et al.1997] birgit hamp, helmut feldweg, et al.
1997. germanet-a lexical-semantic net for german.
in proceedings of acl, workshops.

[hill et al.2014] felix hill, roi reichart, and anna ko-
rhonen. 2014. siid113x-999: evaluating semantic
models with (genuine) similarity estimation. arxiv
preprint arxiv:1408.3456.

[huang et al.2012] eric h huang, richard socher,
christopher d manning, and andrew y ng. 2012.
improving word representations via global context
in proceedings of
and multiple word prototypes.
acl.

[kalchbrenner et al.2014] nal kalchbrenner, edward
grefenstette, and phil blunsom. 2014. a convo-
lutional neural network for modelling sentences. in
proceedings of acl.

[kilgarriff2001] adam kilgarriff. 2001. english lex-
in proceedings of

ical sample task description.
senseval-2.

[labutov and lipson2013] igor labutov and hod lip-
son. 2013. re-embedding words. in proceedings of
acl.

[leacock and chodorow1998] claudia leacock and
martin chodorow. 1998. combining local con-
text and id138 similarity for word sense identi-
   cation. id138: an electronic lexical database,
49(2):265   283.

[luong et al.2013] minh-thang

richard
socher, and christopher d manning. 2013. better
word representations with id56s
for morphology. in proceedings of conll.

luong,

[mihalcea et al.2004] rada mihalcea,

timothy
the
chklovski, and adam kilgarriff.
senseval-3 english lexical sample task. in proceed-
ings of senseval-3.

2004.

[mikolov et al.2013a] tomas mikolov, kai chen, greg
corrado, and jeffrey dean. 2013a. ef   cient estima-
tion of word representations in vector space. arxiv
preprint arxiv:1301.3781.

[mikolov et al.2013b] tomas mikolov, quoc v le, and
exploiting similarities
arxiv

ilya sutskever.
among languages for machine translation.
preprint arxiv:1309.4168.

2013b.

[mikolov et al.2013c] tomas mikolov, ilya sutskever,
kai chen, greg s corrado, and jeff dean. 2013c.
distributed representations of words and phrases
and their compositionality. in proceedings of nips.

[guo et al.2014] jiang guo, wanxiang che, haifeng
wang, and ting liu. 2014. learning sense-speci   c
id27s by exploiting bilingual resources.
in proceedings of coling, technical papers.

[miller and charles1991] george a miller and wal-
ter g charles. 1991. contextual correlates of se-
mantic similarity. language and cognitive pro-
cesses, 6(1):1   28.

[mnih and hinton2007] andriy mnih and geoffrey
hinton. 2007. three new id114 for
in proceedings of
statistical language modelling.
icml.

[mnih and hinton2009] andriy mnih and geoffrey e
hinton. 2009. a scalable hierarchical distributed
language model. in proceedings of nips.

[navigli and ponzetto2010] roberto navigli and si-
mone paolo ponzetto. 2010. babelnet: building
a very large multilingual semantic network. in pro-
ceedings of acl.

[neelakantan et al.2014] arvind neelakantan, jeevan
shankar, alexandre passos, and andrew mccallum.
2014. ef   cient non-parametric estimation of multi-
ple embeddings per word in vector space. in pro-
ceedings of emnlp.

[pennington et al.2014] jeffrey pennington, richard
socher, and christopher d manning. 2014. glove:
global vectors for word representation. in proceed-
ings of emnlp.

[reisinger and mooney2010] joseph reisinger

and
raymond j mooney. 2010. multi-prototype vector-
space models of word meaning. in proceedings of
naacl.

[rubenstein and goodenough1965] herbert

ruben-
stein and john b goodenough. 1965. contextual
correlates of synonymy. communications of the
acm, 8(10):627   633.

[rumelhart et al.1988] david e rumelhart, geoffrey e
hinton, and ronald j williams. 1988. learning rep-
resentations by back-propagating errors. cognitive
modeling, 5:213   220.

[sch  utze1998] hinrich sch  utze.

1998. automatic
word sense discrimination. computational linguis-
tics, 24(1):97   123.

[tian et al.2014] fei tian, hanjun dai, jiang bian, bin
gao, rui zhang, enhong chen, and tie-yan liu.
2014. a probabilistic model for learning multi-
prototype id27s. in proceedings of col-
ing, technical papers.

[wu and palmer1994] zhibiao wu and martha palmer.
1994. verbs semantics and lexical selection. in pro-
ceedings of acl.

[yu and dredze2014] mo yu and mark dredze. 2014.
improving lexical embeddings with semantic knowl-
edge. in proceedings of acl.

[zesch and gurevych2006] torsten zesch and iryna
gurevych. 2006. automatically creating datasets
for measures of semantic relatedness. in proceed-
ings of the workshop on linguistic distances.

[zhong and ng2010] zhi zhong and hwee tou ng.
2010. it makes sense: a wide-coverage word sense
disambiguation system for free text. in proceedings
of acl, system demonstrations.

