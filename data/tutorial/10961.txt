data distillation for controlling speci   city in dialogue generation

jiwei li, will monroe and dan jurafsky

computer science department

stanford university, stanford, ca, usa,

7
1
0
2

 

b
e
f
2
2

 

 
 
]
l
c
.
s
c
[
 
 

1
v
3
0
7
6
0

.

2
0
7
1
:
v
i
x
r
a

jiweil,wmonroe4,jurafsky@stanford.edu

abstract

1

introduction

people speak at different levels of speci-
   city in different situations.1 a conversa-
tional agent should have this ability and
know when to be speci   c and when to be
general.

we propose an approach that gives a neural
network   based conversational agent this
ability. our approach involves alternating
between data distillation and model train-
ing : removing training examples that are
closest to the responses most commonly
produced by the model trained from the
last round and then retrain the model on
the remaining dataset. dialogue generation
models trained with different degrees of
data distillation manifest different levels of
speci   city.

we then train a id23 sys-
tem for selecting among this pool of gen-
eration models, to choose the best level of
speci   city for a given input. compared to
the original generative model trained with-
out distillation, the proposed system is ca-
pable of generating more interesting and
higher-quality responses, in addition to ap-
propriately adjusting speci   city depending
on the context.

our research constitutes a speci   c case of
a broader approach involving training mul-
tiple subsystems from a single dataset dis-
tinguished by differences in a speci   c prop-
erty one wishes to model. we show that
from such a set of subsystems, one can use
id23 to build a system
that tailors its output to different input con-
texts at test time.

people use different levels of speci   city in their lan-
guage depending on many factors about the context
of a conversation: one   s interlocutor, one   s mood,
how familiar one is with the topic discussed, how
well one understands the other   s utterances, and
so forth all in   uence the decision to respond with
generics or speci   cs. a good dialogue agent should
have a similar ability to vary the level of speci   city
of the responses it generates in an input-dependent
way.

when humans speak, we can imagine that each
has a series of language models in his mind, each
of which is able to generate a sensible response,
but which differ in speci   city. one picks the
appropriate model according to the current situ-
ation (whether one understands the input utterance,
whether one is interested in the topic, etc.) and
generates a dialogue utterance using the selected
model. motivated by this line of thinking, we ask
whether a conversational agent could consider a
pool of dialogue models that vary in language speci-
   city and pick the best one for producing a response
to any given input.

one seemingly straightforward approach would
be to split the training data by language speci-
   city and train separate generation models on each
split. however, this requires classifying data by text
speci   city, a problem which poses signi   cant chal-
lenges. language speci   city has been historically
studied for noun phrases, and a few speci   city-
indicative features have been identi   ed, such as sin-
gular terms, negations, or actual/non-actual moods
(enc  , 1991; lyons, 1995). however, there is no
generally agreed criterion for de   ning the level of
speci   city of an arbitrary unit of natural language,
let alone automatically generating sequences to
have different levels of speci   city.

in this paper, we propose an iterative data
distillation approach for addressing this issue.2

1depending on their knowledge, interlocutors, mood, etc.

2the model is inspired by the concept of distillation in

the proposed system operates as follows: a neu-
ral sequence-to-sequence generation (id195)
model is    rst trained and used to generate (decode)
responses to inputs in a dataset. a list of the most
common responses is constructed, and training ex-
amples with outputs that are semantically close to
these common responses are removed (distilled).
this process is then repeated by training another
id195 model (from scratch) on the remaining
data, decoding using the trained model, collecting
generic responses and distilling more data. as the
process iterates, responses that are generic are grad-
ually distilled, and the trained models gradually
increase in speci   city.

at the end of the entire data distillation pro-
cess, we are presented with a pool of generation
models, all of which are able to produce sensible
responses to input messages but differ in degree
of speci   city. this pool of models is analogous
to speci   city-varying models in a human   s mind.
when presented with an input dialogue message,
the dialogue system needs to pick one model out of
the pool, which model to choose depends on how
well the bot understands the input message, how
knowledgeable it is regarding the topic discussed,
etc.3 to imbue the agent with this ability, we use
id23 to train a model to pick the
an appropriate level of speci   city by selecting one
of pre-trained generative models from the pool.

experimental results show that models trained
from different rounds of data distillation exhibit
a clear spectrum of speci   city. models trained
in early rounds of data distillation yield better re-
sponses. we also show that the reinforcement learn-
ing model is able to choose levels of speci   city that
are appropriate for a variety of inputs.

our research constitutes a speci   c case of a
broader approach involving training multiple sub-
systems from a single dataset distinguished by dif-
ferences in a speci   c property one wishes to model
(here, speci   city), especially when this property is
hard to model in a supervised learning setting. we
show that from such a set of subsystems, one can
use id23 to build a system that
tailors its output to different input contexts at test
time.

chemistry, which separates chemical mixtures by gradually
increasing the temperature to a point at which one or more
compounds in the mixture will vaporize.

3we leave handling other factors that should in   uence
speci   city (such as the current mood of the bot and non-
linguistic characteristics of the interlocutor) for future work.

2 related work
generic responses in open-domain dialogue
end-to-end dialogue systems (ritter et al., 2011;
serban et al., 2016c; vinyals and le, 2015; ser-
ban et al., 2016d,a; asghar et al., 2016; mei et al.,
2016), tend to generate highly generic and com-
monplace responses (sordoni et al., 2015; mou
et al., 2016). the goal of controlling output speci-
   city is closely related to recent attempts to address
this issue. li et al. (2016a) propose using mutual in-
formation as an alternative training objective func-
tion in place of maximum likelihood, in which an
n-best list generated by p(t|s) is reranked by the
backward id203 p(s|t).

the aim of this work is more general: instead
of attempting to always avoid generic responses,
our goal is to provide the system with the    exi-
bility to generate responses at different levels of
speci   city. blindly avoiding generating generic re-
sponses does not re   ect how humans speak: we do
say dull, generic things like i don   t know what you
are talking about, to communicate that we indeed
do not understand part of the conversation, or to
dismiss something as incorrect or nonsensical. a
good dialogue system should have the ability to
decide when to say generic things and when not to.

data manipulation the idea of training with
data distillation is inspired by a variety of work
in the active learning and subdata selection liter-
ature, the key idea of which is to select a subset
of a large dataset to train a classi   er with mini-
mal performance loss, for when the training dataset
is extremely large or training is extremely time-
intensive (wei et al., 2015; zheng et al., 2014;
prasad et al., 2014; ghahramani, 2013; iyer and
bilmes, 2013). the proposed system differs from
these subdata selection methods in both goals and
implementation: we combine a series of models
trained on different subsets of data, with the goal
of increasing model performance rather than pre-
serving the model   s performance while reducing
the size of the training data.

the system we propose is also related to data
manipulation strategies such as boosting (breiman,
1996b), a type of ensemble method (dietterich,
2002; zhou et al., 2002; krogh et al., 1995) that
uses subsets of the original data to produce a series
of models and then    boosts    their performance by
combining them together; and id112 (breiman,
1996a), which generates additional data for train-
ing using the original dataset to produce multisets

of the same size as the original data, decreasing
training variance.

3 data distillation

in the section, we describe the proposed data dis-
tillation model in detail. we use opensubtitles
(tiedemann, 2009) as our training dataset.4

3.1 distilling common responses
we    rst use the following simple example to illus-
trate the core idea of our system: consider a model
that predicts a multinomial distribution over an out-
put variable (e.g., which fruit to choose). the prob-
ability of picking apple is 0.3, orange 0.25, blue-
berry 0.15, blackberry 0.15, and raspberry 0.15.
outputs that are generic are usually highly prob-
able, since the high diversity of speci   c outputs
results in each having smaller id203 mass.
we thus treat apple as the most generic fruit, and
the various berries as more speci   c. maximum like-
lihood estimation at test time will lead the model to
always choose apple, since it has the largest prob-
ability. observing that apple is the most common
output, we will remove all apples from the training
set and retrain the model, which will pick orange
this time, since it has the greatest id203 after
apples are removed. we then remove oranges and
repeat the process. with successive iterations of
this distillation process, we will gradually obtain
models that produce more speci   c outputs.

in the context of dialogue response generation,
our approach works as follows: for each iteration,
we    rst train a id195 model using attention
(bahdanau et al., 2014; luong et al., 2015) on
the original training set. next, we use the trained
model to decode responses to a number of input
examples. we decode only a subset of the training
set, 1 million responses in total. one could also
use a held-out dataset for decoding, but the source
of input messages is fairly unimportant in identi-
fying the most frequent responses. we use greedy
decoding (id125 with beam size 1). we then
collect the most common responses in a list, de-
noted by l. a response is considered generic if
its frequency of occurrence exceeds a threshold,

4opensubtitles is a large, noisy, open-domain dataset of
lines from movie scripts. the noise in the dataset is largely
due to the lack of speaker labels for lines of the subtitles.
following vinyals et al. (2015), we train our models to pre-
dict the current line given the preceding ones, assuming that
each line constitutes a full speaker turn and that consecutive
turns belong to the same conversation. both assumptions are
occasionally untrue but yield reasonable results.

input: training data d
output: sequence of trained models m

m        
for i     1 to n = 8 do

train a id195 model m on d until convergence
m     m + m
decode subset of input messages in d using model m
collect top frequent decoded responses l
for all instances e     d do

compute relevance score r(e) using eq. 1

end for
d       top examples by r(e)
distill d  : d     d     d  

end for
return m

algorithm 1: a brief summary of the proposed data
distillation algorithm.

which is empirically set to 100 in this work. we
then compare each response in the training data
to each highly frequent response from the list l
and assign a relevance score r(e) to each training
example e based on the cosine similarity between
e and the sequence most similar to it in l:

r(e) = maxe(cid:48)   l cos(e, e(cid:48))

(1)

we use the encoder part of the trained encoder-
decoder model to map these sequences to vec-
tor representations, which are used to compute
the cosine similarity. in this way, sentences that
are semantically similar to frequent responses are
assigned high relevance scores.5 we then re-
move (distill) examples from the training data with
the highest relevance scores6 and retrain a new
id195 model on the data that remains. an
outline of the distillation algorithm is shown in
algorithm 1.

3.2 choosing a speci   city model
the data distillation process produces a pool of
id195 models, each trained on the dataset re-
maining after a different data distillation round.
when presented with an input message at test time,
the system has to decide which generation model
from the pool to use to decode a response to the
input. we repeat the data distillation process 8
times, which means we have 8 models in the pool to
choose from.7 the system should have the ability
to choose different models in response to properties

5other options include skip-thought vectors (kiros et al.,
2015) and bag-of-word representations. we    nd using the
trained encoder works decently well.

6the amount to remove is empirically set to 8   10%.
7it requires two tesla k40 gpus to    t the 8 models in

memory.

of different inputs. for example, a good dialogue
system should give concrete responses when asked
things that it is sure about, but generic ones when
the input message is dif   cult to understand.

we use id23 to train a model
to make this choice. given an input message x
from a held-out dataset, we parameterize the action
of choosing the generative model with index i from
the pool g = {gi} of id195 models trained
with data distillation as a policy network   (gi|x),
which produces a distribution over |g| classes. to
compute the distribution, we    rst map the input x
to a vector representation hx using an lstm and
then map hx to a policy distribution over different
gi     g using a softmax function:

  (g = gi|x) =

(cid:80)j=|g|

exp(ht
j=1 exp(ht

x    hgi)

x    hgj )

(2)

where hgi is an output vector for each model gi that
is randomly initialized and then trained. given an
action, namely a choice of a generative model gi,
we start decoding given the input message x using
that model. decoding generates an output response
y, which yields a reward r(y) evaluating response
quality according to some metric. the reward sig-
nal r(y) is used to train the policy network.

we use the reinforce algorithm (williams,
1992), a kind of policy gradient method, to    nd
the optimal policy by maximizing the expected
reward e  (gi|x)[r(y)]. the expectation is approx-
imated by sampling from    and the gradient is
computed using the likelihood ratio (aleksandrov
et al., 1968):

   e(  )     [r(y)     b]    log   (gi|x))

(3)

where b denotes a baseline value. 8

adversarial evaluation for reward calculation
one remaining question is how to assign a reward
r to a generated response y given the input x,
which boils down to the fundamental question of
how to evaluate the general quality of a generated
response. dialogue quality is traditionally evalu-
ated (sordoni et al., 2015, e.g.) using word-overlap
metrics such as id7 and meteor scores used
for machine translation, which have recently been
found to correlate poorly with human evaluations
(liu et al., 2016). recent work has begun using

8the baseline value is estimated using another neural
model. we refer the readers to ranzato et al. (2015) and
zaremba and sutskever (2015) for more details.

more    exible and reliable id74; au-
tomatic prediction of human ratings (lowe et al.,
2016) is one such metric, but this approach requires
a large amount of human labeling effort to train a
prediction model.

we employ adversarial evaluation (li et al.,
2016c; anjuli and oriol, 2016) for reward calcula-
tion. the idea of adversarial evaluation,    rst pro-
posed by bowman et al. (2015), is to train a discrim-
inator (or evaluator) function to labels dialogues as
machine-generated (negative) or human-generated
(positive), a binary classi   cation task. for our sys-
tem, we use positive examples taken directly from
training dialogues, while negative examples are
decoded using generative models from different
rounds of data distillation. to be speci   c, for each
input message, we randomly sample a id195
model from the pool to decode a response to the
input and use the response as a negative example.
the evaluator is a hierarchical neural model (ser-
ban et al., 2016b): dialogue utterances (i.e., source
messages and responses) are    rst mapped to vector
representations using an lstm. another lstm is
applied to the sequence of utterance representations
to produce a dialogue representation, which is then
fed to a binary classi   er.

given a pre-trained evaluator d, an input source
x and a machine generated target y decoded by
the chosen generative model, the reward r used to
update the policy    is the id203 that the evalu-
ator d assigns to labeling y as a human-generated
response. the policy update in   uences the choice
of generative model for decoding the current input
x. we refer readers to (li et al., 2016c) for more
details about the adversarial evaluation.

3.3 stochastic greedy sampling
language speci   city also relates to language diver-
sity. utterances with lower levels of diversity are
usually generic because generic responses are usu-
ally generic in the same way. modeling diversity
also provides an indirect way to handle the issue of
speci   city.

moreover, there is a degree of randomness in
human language production: in the real world, if
we ask a person the same question twice, even
with the same environment and surroundings, it is
unlikely that the person will give the same answer
both times. sampling from the distribution not only
better mimic the way humans generate tokens, but
also provides a way to handle the issue of language
speci   city .

one simple solution is to sample directly from
the distribution p(y|x) in all cases. however, we
observe that sampling leads to incoherent, ungram-
matical, or even irrelevant responses. we expect
there to be a sweet spot on the spectrum of random-
ness, between full sampling on one end and greedy
or id125 on the other.9

we propose a straightforward algorithm called
stochastic greedy sampling, in which instead of
sampling from the full distribution over all candi-
date tokens, the model only samples from the few
(e.g., 5) words with the highest id203. the
model provides with both the    exibility of incorpo-
rating randomness and the rigidity of adhering to a
pre-trained generation model at the same time.

again, we use adversarial evaluation for com-
paring purposes. we report adversuc and machine-
vs-random proposed by anjuli and oriol (2016).
machine-vs-random denotes the the accuracy of dis-
tinguishing between machine-generated responses
and randomly sampled responses using a machine
evaluator, trained in a way similar to the evaluator
in adversuc. table 1 presents results for adversuc
and machine-vs-random results for greedy decod-
ing, pure sampling and the proposed stochastic
greedy model. as can be seen, sampling all the
time obtains the best score for adversuc, but also
extremely low score for machine-vs-random accu-
racy, which indicates the inferiority of the always
sampling strategy. the proposed stochastic greedy
model perform better than always taking greedy
actions as in greedy. this indicates that properly
combining greedy search and sampling will poten-
tially lead to better results.

adversuc machine-vs-random

model
greedy

pure sampling

stochastic greedy

0.042
0.384
0.058

0.935
0.642
0.933

table 1: adversarial evaluation results for different
greedy vs. sampling decoding strategies.

4 experimental results

in this section, we present the results of experi-
ments.

9since greedy decoding has been shown to generate
higher-quality responses than id125 in dialogue re-
sponse generation (li et al., 2016a), we focus on greedy de-
coding. however, all algorithms can be easily adapted to use
beam-search decoding.

iter
1
2
3
4
5
6
7
8

ppl
data size
45.2m 33.2
40.6m 33.3
35.7m 33.7
32.7m 34.3
30.1m 35.0
27.9m 35.5
25.5m 36.7
22.8m 37.2

oracle-ppl

33.2
32.3
31.6
31.2
30.8
30.7
30.5
30.3

div-2
div-1
0.65% 1.57%
0.92% 2.81%
1.18% 3.22%
1.44% 3.60%
1.87% 3.94%
2.21% 4.32%
2.72% 4.65%
3.10% 5.01%

table 2: training set size (examples) after data
distillation in each iteration and perplexity (ppl)
and id165 diversity scores (dis-n) of the trained
generative models on the development set.

4.1 comparing generative models from

different iterations

it is interesting to    rst compare the generative mod-
els and the remaining training data from each of
the 8 rounds of data distillation. we use iter+n to
denote the generation model trained on the dataset
after n repetitions of data distillation.

perplexity and diversity the size of the train-
ing dataset after each round of data distillation and
the perplexity of the corresponding trained models
on the full development set is shown in the    rst
two columns of table 2. perplexity increases for
models trained with more data distillation (as ex-
pected, since distillation removes opportunities for
the model to learn to produce the most common
outputs).

however, we expect models trained with distilla-
tion to complement the model trained on the entire
dataset by better modeling more speci   c outputs.
to quantify the potential of the pool of generation
models to complement each other when used in
different contexts, we also report oracle perplexity
(   oracle-ppl   ) as a function of the number of itera-
tions k: for each example, we identify the genera-
tion model (out of iter1 through iterk) that assigns
the highest id203 to the true output. oracle
perplexity is the perplexity computed using these
maximal probabilities, instead of the probabilities
assigned by any one model. this is equivalent to
the perplexity of a model with an rl policy net-
work that chooses perfectly every time. we expect
to    nd that oracle perplexity on the development
set decreases when adding the models trained in
the    rst few rounds of data distillation, after which
it levels off. this con   rms that there are bene   ts to
be had from choosing smartly among the different
models.

count

response

iter1

145575
84435
36032
23890
19405
16888
16048
12782
11840
11604
11254
9474
9471
8905
7905

41139
34738
20252
16275
16081
13007
11254
6532
5724
5604
5168
4963
4454
4342
3969

i don    t know what you are talking about .
i    m not going to let you go .
i    m sorry i didn    t mean to offend you .
i    m not so sure .
i don    t know what to say .
i    m not going to let you go !
that    s a good idea .
i don    t know what to do .
i    m not going to be able to do that .
i    m sorry i can    t help you .
i    m sure you    re right .
you don    t know what you are saying .
i    m not going to tell you .
i    m not sure i can do it .
i have no idea .

iter3

i    m not an idiot .
i    m not an expert on this .
i    m sorry but i    m not an expert on this .
i    ve got some bad news for you .
i    ll get you a new suit .
i    m not an idiot !
i    m gonna make a big deal out of this .
i    m just an ordinary man .
i    m not an expert on the police .
i    m not an expert on the subject .
i    m not your enemy !
i    m not an expert on the law .
i    m gonna need some more help with this .
i was just about to get my hands on the wall .
i can    t believe you    re still alive .

count

54227
29559
22987
21392
20380
14736
13753
13013
11746
10130
9996
9644
9169
7837
5320

30378
26705
9923
9012
8573
7424
6919
5546
4569
4555
4416
4184
4183
4103
3819

response

iter2
i    m not in the mood .
i    m sorry about the way i acted .
you    re not in the mood .
i    m gonna take a look at the new york times .
i    ll be there in a minute .
i    m gonna take a look at this .
i    ll get the money .
i    m gonna take a shower .
i    m in the middle of a war .
you    re not getting any sleep .
i    m gonna take a look at the other side .
i    m sorry about the way you did .
i    ve been doing a lot of things .
you    re a dead man .
i was just getting a little tired of it .

iter4

i    m not from around here .
i    m not from the future .
i was just talking to my wife .
i    m not doing this .
you    re a goddamn liar .
i    ll be on the way .
i    m sorry ma    am .
i    m going back to the hotel .
i    ll be on my way .
i    m not staying here .
you    re a goddamn genius .
i    m a little tired .
i    m gonna take a look at this .
he    s a bit of a jerk .
he    s a bit of a pain in the ass .

table 3: most frequent responses generated using greedy search at the end of 1   4 rounds of data distillation.
   count    indicates the number of occurrences of a response in 1 million decoded outputs.

table 2 also shows a measure of the diversity
of generated responses, namely, the number of dis-
tinct unigrams (   div-1   ) and bigrams (   div-2   ) in
generated responses as a fraction of the total gener-
ated tokens, as described in (li et al., 2016a). as
can be seen, as the data distillation process pro-
ceeds and more generic responses are distilled, the
system generates increasingly diverse responses.

distilled responses the highest-frequency re-
sponses from different rounds of data distillation
are shown in table 3. top responses are more
generic for models trained in earlier iterations. in
iteration 1, the top responses are broadly generic
statements of uncertainty (   i don   t know   ,    i am
not sure   ) or agreement (   i think you are right    or
   that   s a good idea   ), but the meanings of frequent
responses start diverging as the distillation algo-
rithm proceeds. the number of the occurrences of
the top frequent responses from different iterations
also validates this point, with the number gradually
decreasing.

table 4 presents sampled outputs from the gen-
eration models trained after different rounds of

the distillation. responses from iter1 are usu-
ally generic but safe, mostly i don   t know what
to do/what you are talking about and that   s a good
idea. as the amount of distilled data increases, the
corresponding model generates increasingly con-
crete responses but has a greater risk of outputting
confusing or irrelevant responses.

4.2 choosing the correct model for decoding
next, we present results from the proposed rein-
forcement learning model and analyze how it de-
cides which model to pick from the pool.

the distribution over different models used to
decode input messages in the development set is
shown in figure 1. as can be seen, the rl model
chooses to decode using the model trained on the
entire dataset (i.e., iter1) for 16 percent of all inputs.
the models trained after 2, 3 and 4 rounds are re-
sponsible for decoding responses to approximately
half of the inputs.

human evaluation for human evaluation, we
follow protocols de   ned in li et al. (2016b), em-
ploying crowdsourced judges to evaluate a random

input: hear it ?
iter1: i    m sorry i didn    t hear you .
iter5: that    s the only one who could ever be .
input: it feels like i must have been asleep for weeks .
iter1: i    m sorry i can    t help you .
iter5: and then i felt sorry about it .
input: we lived in railroad apartments inside red brick .
iter1: oh, really ?
iter5: we got to get back to the hotel and get a job .
input: you know you ought to    nd yourself a girl .
iter1: i    m not going to do that .
iter5: i    m gonna make you some of your own kind of girl .
input: the man who does that is not afraid to die .
iter1: i am not afraid of him .
iter5: the man is a man of god who is afraid of god
input: the cellar he was working on something in the cellar .
iter1: i was in the cellar .
iter5: there    s no way he could have gotten into this room .
input: this little lady seems to be alone in the world .
iter1: i    m not going to be able to see her .

iter5: you know i can tell when she is a little bit ... ... but she    s
not very good
input: i didn    t even see you go back there .
iter1: i was just going to see you .
iter5: i got to see your father .
input: i was kinda hoping that you were my dad .
iter1: i was just wondering if you could help me out .
iter5: he    s been a long time since he got here .
input: excuse me but how did we pay for these suits ?
iter1: i don    t know what you are talking about .
iter5: i can    t afford this .
input: maybe his eyes were too big for his stomach.
iter1: he was a big boy .
iter5: i think he was a good kid .
input: like the death zone or the zone of no return .
iter1: i don    t know what to do .
iter5: the man is a man of the universe .
input: home sir .
iter1: that    s great !
iter5: the rest of the crew are also on their way home .
input: i    m sorry to detain you for so long .
iter1: i    m sorry i can    t .
iter5: i    m not leaving until tomorrow .
input: don    t fuckin talk to me that way man .
iter1: i    m not gonna talk to you .
iter5: i    m just sayin that i    m an asshole and that ain    t the way
i talk !
input: can    t you see how they    re exploiting you ?
iter1: i    m not a human being .
iter5: you    re not an idiot anymore .
input: do you have any idea what caused the explosion ?
iter1: i have no idea .
iter5: i    ve never heard of any of these .

rl model choice: iter1
iter2: it    s a little early in the morning for me .
iter7: what    s the meaning of this ?
rl model choice: iter1
iter2: it    s been so long .
iter7: i    m sorry i woke you up
rl model choice: iter1
iter2: we got a lot of stuff in the trunk .
iter7: i lived in a hotel .
rl model choice: iter1
iter2: you know i    m a real looker .
iter7: you    re in a big house !
rl model choice: iter1
iter2: but he    s not afraid of the truth .
iter7: it is my duty to protect the father .
rl model choice: iter2
iter2: i    m going to the cellar .
iter7: we had the whole room .
rl model choice: iter2
iter2: i    m sure she    ll have a good time with the rest of the
crew .
iter7: but she    s not coming here .

rl model choice: iter2
iter2: i didn    t see the man .
iter7: i went back to sleep .
rl model choice: iter2
iter2: you    re the only one who    s ever been in my family .
iter7: so what are you doing with my mom ?
rl model choice: iter2
iter2: i don    t know if i can get a refund on this .
iter7: i    ll pay them 10 000 .
rl model choice: iter2
iter2: he    s got a big mouth .
iter7: he was just trying to kill her .
rl model choice: iter2
iter2: the zone is the only place where the people are .
iter7: but it    s a life zone .
rl model choice: iter5
iter3: the rest of the world is here .
iter7: how    s your wife ? .
rl model choice: iter5
iter2: i    m sorry about the delay .
iter7: i    m glad that    s your name and all .
rl model choice: iter7
iter2: i    m talkin to you motherfucker .
iter7: you    re in no position to talk like that .

rl model choice: iter7
iter2: you    re not a good guy .
iter7: well it    s not that simple .
rl model choice: iter7
iter2: i think it    s the same as a gas pipe .
iter7: the explosion was caused by a meteor disturbance .

table 4: sample of outputs generated by models from different rounds (1,2,5,7) of data distillation, along
with the model that the proposed id23 (rl) algorithm chooses to decode the response.
responses chosen by the rl model are in bold.

sample of 200 items. we present labelers with an
input message and the generated outputs from three
models, iter1, iter2, and rl, and ask them to rank
the three outputs by quality. note that the outputs
from the rl model can be the same as those from
iter1 or iter2 if the rl model chooses that partic-

ular model (iter1 or iter2) for decoding. in these
cases, a tie is automatically recorded. figure 2
shows the proportions of the outputs ranked    rst by
the human labelers. as can be seen, the reinforce-
ment learning model performs best 60 percent of
the time, followed by iter2, which wins 37 percent

adversuc machine-vs-random

model
iter1 (standard)
random
rl

0.058
0.056
0.088

0.933
0.940
0.944

figure 1: distribution of the iteration used by the
rl model to decode responses (dev set).

figure 2: the proportions of outputs from different
models ranked    rst in the human evaluation. note
that the sum is larger than 100 percent due to ties.

pairs

rl vs. iter2
rl vs. iter1
iter2 vs. iter1

win
51
64
62

lose
29
28
38

tie
20
8
-

table 5: pairwise human judgments between the
id23 model (rl) and the    rst two
distillation models (iter1 and iter2).

of the time. table 5 shows pairwise human judge-
ments between the three models extracted from the
three-instance ranking. it is interesting to see that
iter2 generally outperforms iter1, winning on 62
percent of the examples. this is consistent with the
fact that the rl model tends to prefer iter2 more
often.

adversarial evaluation table 6 reports adver-
sarial success and machine-vs-random accuracy
described in li et al. (2016c). adversarial success
(adversuc) refers to the percentage of machine-
generated responses that are able to fool an trained
evaluator model into believe that they are generated
by humans; machine-vs-random accuracy denotes
the accuracy of a trained evaluator model (a differ-
ent evaluator from the one used in adversarial suc-
cess) at distinguishing between machine-generated
responses and human utterances randomly sam-
pled without regard for the input. superior models
should obtain higher values of both adversarial suc-

table 6: adversarial success and machine-vs-
random accuracy for iter1 which always gener-
ating response using the model trained on the full
set, random which randomly samples a model for
generation, and the proposed model.

cess and machine-vs-random accuracy. we refer
readers to li et al. (2016c) for more details. we
observe that the rl model performs better than al-
ways using the model trained on the full dataset
(iter1) or choosing a distillation model at random
(as one would expect, since the rl model is trained
to optimize adversarial success).

analyzing results table 4 shows example
choices made of the rl model in response to dif-
ferent inputs. when input messages are vague and
hard to reply to, the rl model usually picks iter1,
which in turn outputs safe responses like    that
   s great    or    i don    t know what you are talking
about   . the rl model has a tendency to pick mod-
els from the latter stages of distillation training if
all of the generation models from the different iter-
ations of distillation are able to output meaningful
responses, since models from the later stages out-
put produce more diverse and interesting outputs.
we also observe a high correlation between the
number of unknown words in the source sentence
and the choice to use iter1.

5 conclusion

in this paper, we investigate the language speci-
   city issue in dialogue generation. we propose a
data distillation method, which trains a series of
generation models that exhibit different levels of
speci   city and uses a id23 model
to choose the model best suited for decoding de-
pending on the dialogue context.

the success of the proposed system con   rms the
importance of data processing in training a success-
ful open-domain dialogue system. we anticipate
that strategies resembling the one we propose can
be used more generally for controlling properties
of dialogue generation other than speci   city, by
training several models on different subsets of a
single dataset that differ in the desired property,
and choosing among these to produce outputs that
tailor the quality of interest to the situation at hand.

iter1iter2iter3iter4iter5iter6iter7iter8rl model choice051015202530% of examplesreferences
v. m. aleksandrov, v. i. sysoyev, and v. v. shemeneva.
1968. stochastic optimization. engineering cyber-
netics 5:11   16.

kannan anjuli and vinyals oriol. 2016. adversarial

evaluation of dialogue models .

nabiha asghar, pasca poupart, jiang xin, and hang li.
2016. online sequence-to-sequence reinforcement
learning for open-domain conversational agents.
arxiv preprint arxiv:1612.03929 .

dzmitry bahdanau, kyunghyun cho, and yoshua ben-
gio. 2014. id4 by jointly
arxiv preprint
learning to align and translate.
arxiv:1409.0473 .

samuel r bowman, luke vilnis, oriol vinyals, an-
drew m dai, rafal jozefowicz, and samy ben-
gio. 2015. generating sentences from a continuous
space. arxiv preprint arxiv:1511.06349 .

leo breiman. 1996a. id112 predictors. machine

learning 24(2):123   140.

leo breiman. 1996b. bias, variance, and arcing classi-

   ers .

thomas g dietterich. 2002. id108. the
handbook of brain theory and neural networks
2:110   125.

m  urvet enc  . 1991. the semantics of speci   city. lin-

guistic inquiry pages 1   25.

zoubin ghahramani. 2013. scaling the indian buf-
arxiv

fet process via submodular maximization.
preprint arxiv:1304.3285 .

rishabh k iyer and jeff a bilmes. 2013. submodular
optimization with submodular cover and submodu-
lar knapsack constraints. in advances in neural in-
formation processing systems. pages 2436   2444.

ryan kiros, yukun zhu, ruslan r salakhutdinov,
richard zemel, raquel urtasun, antonio torralba,
and sanja fidler. 2015. skip-thought vectors.
in
advances in neural information processing systems.
pages 3294   3302.

anders krogh, jesper vedelsby, et al. 1995. neural net-
work ensembles, cross validation, and active learn-
ing. advances in neural information processing sys-
tems 7:231   238.

jiwei li, michel galley, chris brockett, jianfeng gao,
and bill dolan. 2016a. a diversity-promoting ob-
jective function for neural conversation models. in
proc. of naacl-hlt.

jiwei li, will monroe, tianlin shi, and dan jurafsky.
2016c. adversarial id23 for neu-
ral dialogue generation.

chia-wei liu, ryan lowe, iulian v serban, michael
noseworthy, laurent charlin, and joelle pineau.
2016. how not to evaluate your dialogue system:
an empirical study of unsupervised evaluation met-
rics for dialogue response generation. arxiv preprint
arxiv:1603.08023 .

ryan lowe, michael noseworthy, iulian serban, nico-
las angelard-gontier, yoshua bengio, and joelle
pineau. 2016. towards an automatic turing test:
arxiv
learning to evaluate dialogue responses.
preprint arxiv:1605.05414 .

minh-thang luong, hieu pham, and christopher d
manning. 2015. effective approaches to attention-
based id4. arxiv preprint
arxiv:1508.04025 .

john lyons. 1995. linguistic semantics: an introduc-

tion. cambridge university press.

hongyuan mei, mohit bansal, and matthew r walter.
2016. coherent dialogue with attention-based lan-
guage models. arxiv preprint arxiv:1611.06997 .

lili mou, yiping song, rui yan, ge li, lu zhang,
and zhi jin. 2016. sequence to backward and for-
ward sequences: a content-introducing approach to
generative short-text conversation. arxiv preprint
arxiv:1607.00970 .

adarsh prasad, stefanie jegelka, and dhruv batra.
2014. submodular meets structured: finding di-
verse subsets in exponentially-large structured item
sets. in advances in neural information processing
systems. pages 2645   2653.

marc   aurelio ranzato, sumit chopra, michael auli,
and wojciech zaremba. 2015. sequence level train-
ing with recurrent neural networks. arxiv preprint
arxiv:1511.06732 .

alan ritter, colin cherry, and william b dolan. 2011.
data-driven response generation in social media. in
proceedings of the conference on empirical meth-
ods in natural language processing. association for
computational linguistics, pages 583   593.

iulian v serban,

ii ororbia, g alexander, joelle
pineau, and aaron courville. 2016a.
multi-
modal variational encoder-decoders. arxiv preprint
arxiv:1612.00377 .

iulian v serban, alessandro sordoni, yoshua bengio,
aaron courville, and joelle pineau. 2016b. build-
ing end-to-end dialogue systems using generative hi-
erarchical neural network models. in proceedings of
aaai.

jiwei li, will monroe, alan ritter, and dan jurafsky.
2016b. deep id23 for dialogue
generation. arxiv preprint arxiv:1606.01541 .

iulian vlad serban, ryan lowe, laurent charlin, and
joelle pineau. 2016c. generative deep neural net-
works for dialogue: a short review .

iulian vlad serban, alessandro sordoni, ryan lowe,
laurent charlin, joelle pineau, aaron courville,
and yoshua bengio. 2016d. a hierarchical latent
variable encoder-decoder model for generating dia-
logues. arxiv preprint arxiv:1605.06069 .

alessandro sordoni, michel galley, michael auli,
chris brockett, yangfeng ji, meg mitchell, jian-
yun nie, jianfeng gao, and bill dolan. 2015. a
neural network approach to context-sensitive gener-
ation of conversational responses. in proceedings of
naacl-hlt.

j  org tiedemann. 2009. news from opus     a collec-
tion of multilingual parallel corpora with tools and
interfaces. in recent advances in natural language
processing. volume 5, pages 237   248.

oriol vinyals and quoc le. 2015. a neural conversa-
tional model. in proceedings of icml deep learn-
ing workshop.

kai wei, rishabh iyer, and jeff bilmes. 2015. submod-
ularity in data subset selection and active learning.
in proceedings of the 32nd international conference
on machine learning, lille, fran. pages 6   11.

ronald j williams. 1992. simple statistical gradient-
following algorithms for connectionist reinforce-
ment learning. machine learning 8(3-4):229   256.

wojciech zaremba and ilya sutskever. 2015. rein-
forcement learning id63s. arxiv
preprint arxiv:1505.00521 .

jingjing zheng, zhuolin jiang, rama chellappa, and
jonathon p phillips. 2014. submodular attribute se-
lection for action recognition in video. in advances
in neural information processing systems. pages
1341   1349.

zhi-hua zhou, jianxin wu, and wei tang. 2002. en-
sembling neural networks: many could be better
than all. arti   cial intelligence 137(1):239   263.

