extreme extraction: only one hour per relation

raphael hoffmann
department of computer
science & engineering
university of washington
seattle, wa, u.s.a.
raphaelh@uw.edu

luke zettlemoyer

department of computer
science & engineering
university of washington

seattle, wa, u.s.a.

lsz@cs.washington.edu

daniel s. weld

department of computer
science & engineering
university of washington

seattle, wa, u.s.a.

weld@cs.washington.edu

5
1
0
2

 

n
u
j
 

1
2

 
 
]
l
c
.
s
c
[
 
 

1
v
8
1
4
6
0

.

6
0
5
1
:
v
i
x
r
a

abstract
information extraction (ie) aims to automatically generate a large
knowledge base from natural language text, but progress remains
slow. supervised learning requires copious human annotation, while
unsupervised and weakly supervised approaches do not deliver com-
petitive accuracy. as a result, most    elded applications of ie, as
well as the leading tac-kbp systems, rely on signi   cant amounts
of manual engineering. even    extreme    methods, such as those
reported in freedman et al. [11], require about 10 hours of expert
labor per relation.

this paper shows how to reduce that effort by an order of mag-
nitude. we present a novel system, instaread, that streamlines
authoring with an ensemble of methods: 1) encoding extraction
rules in an expressive and compositional representation, 2) guiding
the user to promising rules based on corpus statistics and mined
resources, and 3) introducing a new interactive development cycle
that provides immediate feedback     even on large datasets. ex-
periments show that experts can create quality extractors in under
an hour and even nlp novices can author good extractors. these
extractors equal or outperform ones obtained by comparably super-
vised and state-of-the-art distantly supervised approaches.

categories and subject descriptors
h.2.8 [database management]: database applications - data min-
ing; h.3.1 [information storage and retrieval]: content anal-
ysis and indexing - linguistic processing; i.2.7 [arti   cial intelli-
gence]: natural language processing - text analysis; i.5.5 [pattern
recognition]: implementation - interactive systems

general terms
experimentation, human factors

keywords
information extraction, rule-based extraction, natural language pro-
cessing, interactive systems

1.

introduction

information extraction (ie), the process of distilling semantic
relations from natural language text, continues to gain attention. if
applied to the web, such ie systems have the potential to create
a large-scale knowledge base which would bene   t important tasks
such as id53 and summarization.

applying information extraction to many relations, however, re-
mains a challenge. one popular approach is supervised learning
of relation-speci   c extractors, but these methods are limited by the
availability of training data and are thus not scalable. unsupervised
and weakly supervised methods have been proposed, but are not
suf   ciently accurate. many successful applications of ie therefore
continue to rely on signi   cant amounts of manual engineering. for
example, the best performing systems of the tac-kbp slot    lling
challenge make central use of manually created rules [21, 36].

in response, freedman et al. [11] proposed extreme extraction,
a combination of techniques which enabled experts to develop    ve
slot-   lling extractors in 50 hours, starting with just 20 examples per
slot type. these extractors outperformed ones learned with manual
supervision and also required less effort, when data labeling costs
were included.

in this work, we seek to dramatically streamline the process of
extractor engineering, while handling the more general task of bi-
nary relations, r(a, b), where both arguments are free. our goal
is to enable researchers to create a high-quality relation extractor
in under one hour, using no prelabeled data. to achieve this goal,
we propose an extractor development tool, instaread, which de-
   nes a user-system interaction based on three key properties. first,
experts can write compositional rules in an expressive logical nota-
tion. second, the system guides the expert to promising rules, for
example through a bootstrap rule induction algorithm which lever-
ages the distribution of the data. third, rules can be tested instantly
even on relatively large datasets.

this paper makes the following contributions:
    we present instaread, an integrated ensemble of methods

for rapid extractor construction.

    we show how these components can be implemented to enable

real-time interactivity over millions of documents.

    we evaluate instaread empirically, showing 1) an expert
user can quickly create high precision rules with large recall.
1 that greatly outperform comparably supervised and state-of-
the-art distantly supervised approaches and require one tenth
the manual effort of freedman   s [11] approach. we also present
2) the cumulative gains due to different instaread features,

1 all rule sets developed as part of this work, the training data
produced by odesk workers, and the output extractions from each
system are available upon request.

as well as 3) an error analysis indicating that more than half
of extractor mistakes stem from problems during preprocess-
ing (e.g., parsing or ner). we further show that 4) even nlp
novices can use instaread to create quality extractors for
many relations.

2. problem definition

engineering competitive information extractors often involves
the development of a carefully selected set of rules. the rules are
then used in a number of ways, for example, to create determin-
istic rule-based extractors [21, 36], or as features or constraints in
learning-based systems [28, 13]. typically, however, the develop-
ment of rules is an iterative process of re   nement that involves (1)
analyzing a development corpus of text for variations of relation
mentions, (2) creating hypotheses for how these can be general-
ized, (3) formulating these hypotheses in a rule language, and (4)
testing the rules on the corpus.

unfortunately, each of the steps in this cycle can be very time
intensive. for example, when analyzing a corpus an expert may
spend much time searching for relevant sentences. when creat-
ing hypotheses, an expert may not foresee possible over- or under-
generalizations. an expert   s intended generalization may also not
be directly expressible in a rule language, and testing may be com-
putationally intensive in which case the expert is unable to obtain
immediate feedback.

our goal in this work is to develop and compare techniques
which accelerate this cycle, so that engineering a competitive ex-
tractor requires less than an hour of expert time.

3. prior work

freedman et al. [11]   s landmark work on    extreme extraction   
   rst articulated the important challenge of investigating the devel-
opment of information extractors within a limited amount of time.
their methods, which allowed an expert to create a question an-
swering system for a new domain in one week, used orders of mag-
nitude less human engineering than the norm for ace2, tac-kbp
and muc3 competitions. key to this improvement was a hybrid
approach that combined a bootstrap learning algorithm and manual
rule writing. freedman et al. showed that this combination yields
higher recall and f1 compared to approaches that used only boot-
strap learning or manual rule writing, but not both.

freedman et al.   s task is related but different from our task; some
of these differences make it harder and others easier. in particu-
lar, freedman et al. sought to extract relations ri(arg1, arg2), in
which one of the arguments was    xed. a small amount of training
data was assumed for each relation, and the task included adapta-
tion of a named entity recognizer and coreference resolution sys-
tem.

with instaread we propose a combination of different, com-
plementary techniques to those of freedman et al., that focus on
streamlining rule authoring. one of these techniques leverages a
re   ned and very effective bootstrap algorithm that keeps the user
in the loop, whereas feedman et al.   s bootstrap learner ran au-
tonomously without user interaction.

a large amount of other work has looked at id64 ex-
tractors from a set of seed examples. carlson et al.   s nell [3]
performs coupled semi-supervised learning to extract a broad set
of instances, relations, and classes from a web-scale corpus. two
of the four relations we report results for in section 8 are cov-
ered by nell, yielding 174 (attendedschool) and 977 (married)
2
3

http://www.itl.nist.gov/iad/mig/tests/ace/

http://www-nlpir.nist.gov/related_projects/muc

instances after 772 iterations. to avoid a decline in precision (on
average 57% after 66 iterations), nell relies on periodic human
supervision of 5 minutes per relation every 10 iterations. other
systems leverage large knowledge bases for supervision. pros-
pera [23] uses maxsat-based constraint reasoning and improves
on the results, but requires that relation arguments be contained in
the yago knowledge base [35]. only one of our four relations
is extracted by prospera (attendedschool), yielding 1,371 in-
stances at 78% precision. 26,280 instances of this relation from
yago were used for supervision. deepdive [26, 27, 30] scales a
markov logic program to the same corpus and uses freebase for
supervision. it reaches an f1 score of 31% on the tac-kbp rela-
tion extraction benchmark. miml-re [37] and multir [14], also
apply distant supervision from a knowledge base but add global
constraints to relax the assumption that every matching sentence
expresses a fact in the knowledge base. except for the latter two
systems, which we compared to, none of the above systems is pub-
licly released, making a direct comparison impossible. in general,
all of the above approaches suffer from relatively low recall and
combat semantic drift by relying on redundancy, global constraints,
large knowledge bases, or validative feedback.

while above approaches attempt to avoid manual input altogether,
other approaches try to make manual input more effective. these
include compositional pattern languages for specifying rule-based
extractors, such as cpsl [1] and tokensregex [4]. rule-based ex-
traction has also been scaled to larger datasets by applying query
optimization [17, 6]. unlike our work, this line of research does not
evaluate the effectiveness of these languages with users, in terms
of development time and extraction quality. another approach to
human input is active learning. miller et al. [20] learn a percep-
tron model for named-entity extraction; unlabeled examples are
ranked by difference in id88 score. riloff [32] proposes an
approach to named-entity extraction, which requires users to    rst
classify documents by domain, and then generates and ranks can-
didate extraction patterns. active learning has also been studied in
more general contexts, for learning probabilistic models with la-
beled instances [38] or labeled features [9]. this work differs from
approaches based on active learning in at least two ways. first, they
have not been evaluated on id36 tasks. second, and
more importantly, their general approach is to consider a particu-
lar type of feedback and then develop algorithms for learning more
accurately from such feedback.
in contrast, our approach is not
to compare algorithms, but to compare different types of manual
feedback.

4. overview of instaread

to evaluate techniques for accelerating the development process
of rule-based extractors, we developed instaread, an interactive
extractor development tool. instaread is designed to address the
inef   ciencies identi   ed in section 2 with the combination of an
expressive rule language, data-driven guidance to new rules, and
instant rule execution.

we next present an example of an expert interacting with the
system, and then in the following sections show how instaread
enables its three key properties.
4.1 example

anna wants to create an extractor for the killed(killer,victim) re-
lation. after selecting a development text corpus she proceeds as
follows.

    to    nd example sentences, anna searches for sentences con-
taining keyword    killed    (figure 1 a). instaread suggests

figure 1: selected interactions (section 4). instaread guides users to sentences and rules by distributionally-similar words (top),
and bootstrap pattern learning (bottom).

to also consider distributionally similar keywords such as
   murder    or    assassin   . within seconds anna obtains many
relevant examples.

    anna compares examples, investigating their syntactic struc-
ture obtained by a parser, and encodes an extraction pattern
as a rule: killed(a, b)     nsubj(c, a)&dobj(c, b)&
token(c,(cid:48) murdered(cid:48)). the system offers to automatically
generalize that rule, so that it also covers the passive form
as well as all tenses.

    anna now has a working extractor which she would like to
re   ne. instaread   s id64 method presents her a
ranked list of new candidate rules based on the extractions of
her existing rule set. anna inspects matches of the suggested
rules and selects several (figure 1 b).

    looking at the rules collected so far, anna notices that many
are similar, differing only in the verb that was used. she

decides to refactor her rule set, so that one rule    rst identi   es
relevant verbs, and others syntactic structure. her rule set is
now more compact and generalizes better.

5. condition-action rules in logic
a rule language should be both simple and expressive, so that
the interaction with the system is quick and direct. to ful   ll this
requirement, instaread uses condition-action rules expressed in
   rst-order logic, combined with a broad and expandable set of built-
in logical predicates. for tractability, instaread requires that
rules translate into safe domain-relational calculus [39].

although such rules could be used to generate statistical mod-
els [8], we currently assume that all rules are deterministic and are
executed in a de   ned order, and leave the integration with learning-
based techniques as future work.

figure 2 presents an example rule set and how it is applied to
a sentence. the predicates used in this example have arguments

that range over tokens and token positions. rules are used to de   ne
predicate killofvictim and that predicate then gets re-used in other
rules to de   ne predicate killed. we call this ability instaread   s
composition feature.

to increase the expressiveness of the language, instaread im-
plements around one hundred built-in predicates, such as tokenbe-
fore and iscapitalized. in addition, it makes available predicates
that encode the output of (currently) four nlp systems, including
a phrase structure parser [5], a typed dependency extractor [19]4, a
coreference resolution system [29], and a named-entity tagger [10].
this allows users to write rules which simultaneously use parse,
coreference, and entity type information.

(a) rules. dependency predicates nn, poss, nsubjpass, prep-by,
prep-for, prep-of and named-entity predicate person are pre-
computed.

killnoun(   murder   )
killnoun(   assassination   )
killnoun(   killing   )
killnoun(   slaughter   )
killofvictim(c, b)     prep-of(c, b)   token(c, d)   killnoun(d)
killofvictim(c, b)     nn(c, b)     token(c, d)     killnoun(d)
killofvictim(c, b)     poss(c, b)     token(c, d)     killnoun(d)
killed(a, b)     person(a)     person(b)     nsubjpass(c, a)   

token(c,    sentenced   )     prep-for(c, d)   
killofvictim(d, b)
killed(a, b)     person(a)     person(b)     prep-by(c, a)   

killofvictim(c, b)

(b) example sentence with typed dependencies.

nsubjpass

root

nn

auxpass

was

prep-for
det

prep-of

mr. williams was sentenced for

the murder of wright

.

(c) predicted ground instances. here, murder-7 refers to the 7th
token in the example sentence.

killofvictim(murder-7, wright-10)

killed(williams-2, wright-10)

figure 2: example rule set executed on sentence.

the rules in figure 2 are all horn clauses, but instaread also
supports disjunction (   ), negation (  ), and existential (   ) and uni-
versial (   ) quanti   cation. while one does not often need these op-
erators, they are sometimes convenient for speci   c lexical ambigu-
ities. for example, in our evaluation discussed in section 8, one
user of instaread created the following rule to extract instances
of the founded(person,organization) relation:

founded(a, b)    nsubj(c, a)     dobj(c, b)     token(c,    built   )   

person(a)     organization(b)

this rule was designed to match sentences such as:    michael dell
built his    rst company in a dorm-room.    however, this rule also in-
4instaread uses collapsed dependencies with propagation of
conjunct dependencies.

correctly matches a number of other sentences such as:    mr. harris
built dell into a formidable competitor to ibm.    while    building
an organization    typically implies a founded relation,    building an
organization into something    does not. this distinction can be cap-
tured in our rule by adding the conjunct   (   d : prep-into(c, d)).

6. guiding experts to effective

rules

while the rule language is important for developing extractors,
many hours of testing on early prototypes of instaread showed
that it is not suf   cient for an effective interaction. with a growing
number of rules, users    nd it increasingly dif   cult to identify rules
for re   nement. more importantly, users don   t know where to focus
their attention when trying to    nd effective rules to add.

feedback.

our small example in figure 2 already demonstrates the prob-
lem: what exactly does each rule do? how much data does each
rule affect? in early testing, we noticed that users would often
write short comments for each rule, consisting of the surface tokens
matched. we therefore designed a technique to automatically gen-
erate such comments (depicted in figure 3) by retrieving matched
sentences, identifying sentence tokens that were explicitly refer-
enced by one of the predicates, and concatenating the tokens in
the order that they appear in a sentence. included are    . . .     place-
holders for the arguments of the rule   s target predicate. figure 3
also shows how instaread displays the number of matches to-
gether with each rule, eg. 257 for    . . . stabbed . . .    , helping users
quickly judge the importance of a rule. although one may also
be interested in precision, that cannot be obtained without anno-
tated data.
instaread also includes visualizations for depen-
dency trees, parse trees, and coreference clusters. such visualiza-
tions do not always convey all information encoded in the logi-
cal representation, but convey (approximate) meaning or relevance
quickly.

figure 3:
instaread shows automatically generated com-
ments and number of extractions together with each rule, al-
lowing users to see (approximate) meaning and relevance with-
out needing to read logical expressions.

bootstrap rule induction.

how does an expert know what rules to write? coming up with
good candidates is surprisingly dif   cult. one approach is auto-
matic rule suggestions based on statistics. this can be done, for
example, using a semi-supervised bootstrap pattern learning algo-

rithm. freedman et al. [11] applied such an algorithm, too, but
found that it was not competitive with manual pattern writing, es-
pecially with regards to recall. instaread   s bootstrap algorithm
therefore makes several changes: first, it instantly returns ranked
bootstrap results over a large corpus. second, it takes into account
coreference information to expand recall (similarly to gabbard et
al. [12]). third, it puts the user into the loop, allowing her to select
appropriate rules after each iteration.

in particular, instaread   s bootstrap technique takes as input a
binary relation predicate r(a, b) together with a set of rules r de   n-
ing instances of r. the output is a ranked list of candidate rules s.
the algorithm works by    rst identifying mentions of r using the
existing rules r and generating the pairs (as, bs) of argument sur-
face strings of these mentions. this set of pairs is then matched to
the entire corpus, retrieving all sentences containing both strings.
similar to dirt [18], instaread then generates syntactic-lexical
extraction patterns from these matches. loosely following mintz
et al. [22], the system    nds a path of syntactic dependencies con-
necting the matched surface strings, and then creates a rule that is
a conjunction of syntactic dependencies and lexical constraints on
that path, as well as entity type constraints (if activated by user).
for examples, refer to figure 1.

rule suggestions, s, are sorted by two scores: pointwise mutual
information of the suggested rule with the original rule set r, and
number of extractions of suggested rule. the latter may show more
irrelevant rules on top, but the relevant ones among them have many
extractions often reducing overall effort. users can switch between
the sort orders.

word-level distributional similarity.

although our enhancements to the bootstrap approach may in-
crease recall, recall is still limited since bootstrap requires that the
same tuples appear multiple times in the corpus. to help experts
   nd additional relation mentions, instaread therefore also in-
cludes another shallow technique: keyword search combined with
keyword suggestions.

keywords are suggested based on distributional similarity to a
seed keyword. for example, the seed    murdered    returns    assas-
sinated   ,    slayed   ,    shot   , and more. speci   cally, each word w in
the text corpus is represented as a vector of weighted words v co-
occurring in sentences with w. the similarity of two words w1, w2
is then de   ned as the cosine similarity of their vector representa-
tions. an additional list of keyword suggestions shows keywords
which contain the seed keyword as pre   x. suggested keywords are
always displayed together with their number of occurrences in the
corpus to guide users to the most relevant keywords.

although this keyword-based approach may be effective in    nd-
ing relevant sentences, early experiments have shown that a long
time is spent to writing extraction rules based on those sentences.
we therefore added a simple interface feature: experts could click
on words to indicate relation arguments, and the system will gener-
ate rule candidates using our bootstrap generation algorithm.

core linguistic rules.

the    nal problem we address is the fact that a relation extractor
typically needs a large number of rules that are not speci   c to the
relation. for example, there exist many syntactic variations that
follow common linguistic patterns. to reduce effort, we seek to
populate the system with such general rules right from the start.

in a    rst step, we encoded a set of grammatical rules: given a
verb base form, instaread can generate rules encoding syntactic-
lexical patterns for 182 combinations of tense, voice, and person.
for example, given subject x, object y and verb    kill   , the system

generates rules to capture phrases such as    y was killed by x   ,    x
regretted killing y   ,    x would later kill y   . to avoid inaccuracies
from using a stemmer, instaread includes in   ection rules and a
corpus of in   ections for 16851 verbs mined from wiktionary. this
grammatical background knowledge is provided to the user through
a set of additional built-in predicates.

7. efficient rule evaluation

to enable its interactivity, instaread must evaluate rules and
guide users to effective rules very quickly, even with compositional
rules and large datasets.

instaread is built on top of an rdbms. variables in its log-
ical expressions are assigned a data type that can be pos (token
position), span (token span), int (integer), str (string), or ref (ref-
erence). each of these data types is internally mapped to a com-
posite sql data type. for example, token spans are mapped to the
sql types integer, byte, byte, where the    rst is used to identify
a sentence and the others indicate start and end positions within a
sentence. predicates are either extensional or intensional. exten-
sional ones materialize instances in relational tables, while inten-
sional ones are de   ned by (partial) sql queries. an example of an
extensional predicate is our killed(a, b) extractor, which stores the
result set of the extraction rules depicted in figure 2. an example
of an intensional predicate is str2span(s, t) which returns all men-
tions of a multi-word string using an inverted index. for details
on how this predicate gets translated into sql, see figure 5 in the
appendix. the key component of instaread   s implementation is
its translation of logical rules into sql queries. the system    rst
parses logical rules into an abstract syntax tree (ast). to ensure
that the rules do not yield in   nite result sets and can be translated
into sql, it checks for safety [39]. it then infers variable types and
links predicates, then translates into an ast of tuple relational cal-
culus, and eventually sql, following the algorithms described in
[39]. for an example translation, see appendix a.

for performance, instaread creates a btree index for each
column of an extensional predicate. built-in predicates (which tend
to contain more instances, e.g. all syntactic dependencies), also use
multi-column indices. a variety of information is pre-computed on
a hadoop cluster, including phrase structure trees, dependencies,
coreference clusters, named-entities, rule candidates for bootstrap-
ping, and distributionally similar words.

this large number of indices and pre-computed information is
important because instaread does not constrain the set of queries
and most queries touch the entire text corpus. it also allows each
iteration of id64 to be performed by a single sql query.
across all of the experiments the median query execution time was
74ms. achieving such interactivity is crucial for quickly building
accurate extractors.

8. experiments

in our evaluation, we measured if instaread   s features enable
an expert to create quality extractors in less than one hour, and
which of the features contribute most to reducing effort. we also
report on an error analysis to get insights into potential future im-
provements. finally, we report early results of a follow-up experi-
ment, in which we evaluated instaread   s usability among engi-
neers without nlp background.
8.1 experimental setup

we evaluated the performance of an expert in a controlled ex-
periment, in which the expert user was given one hour of time per
relation to develop four relation extractors. besides descriptions of

the four relations and a corpus of (unlabeled) news articles, which
was loaded into instaread, no other resources were provided.
our expert was familiar with instaread and nlp in general, but
had no experience with the relations tested. all user and system
actions were logged together with their timestamps.

we were interested in determining the effectiveness of four of
instaread   s features: bootstrap rule induction (bootstrap), word-
level distributional similarity (wordsim), core linguistic rules (lin-
guistics), and the power of rule (de-)composition (composition). in
order to more easily measure the impact of each of these features,
our user was required to use only one at a time and switch to the
next at given time intervals (figure 4).

baselines.

we compare the performance of the extractors created with our

proposed system instaread to three baselines.

miml-re [37] and multir [14] are two state-of-the-art sys-
tems for learning relation extractors by distant supervision from
a database. as a database we use the instances of the relations
contained in freebase [2]. negative examples are generated from
random pairs of entity mentions in a sentence.5

sup is a supervised system which learns a log-linear model us-
ing the set of features for id36 proposed by mintz
et al. [22]. the supervision is provided by four annotators hired
on odesk.com who rated themselves as experts for data entry,
and were encouraged to use any tool of their choice for annotation.
each annotator was asked to spend 1 hour per relation to identify
sentences in the development corpus containing that relation and
marking its arguments. to control the variation related to the or-
der in which relations were presented (users get faster with time),
we used a latin square design and paid for 1 additional hour before
the experiment to allow users to get familiar with the task. negative
examples were added as in the distantly supervised cases.

datasets.

we used the new york times annotated corpus [34] comprising
1.8m news articles (45m sentences) published between 1987 and
2007. a random half of the articles were used for development, the
other half for testing.

relations.

we selected four relations: attendedschool (person,school),
founded (founder,organization), killed (killer,victim), and mar-
ried (spouse1,spouse2). these relations were selected because
they cover a range of domains, they were part in previous evalua-
tions [16, 7, 33], and they do not require recognition of uncommon
entity types.6 for preprocessing, we used the cj parser [5] and
stanford   s dependency [19], coreference [29], and ner [10] sys-
tems.

5we added negative examples at a ratio of 50:1 to positives. in-
creasing this ratio increases precision but reduces the number of
extractions, while decreasing has the opposite effect. we found
that this setting provided a better trade-off than the default used by
these distantly supervised systems on the data by riedel et al. [31],
which returned no extractions in our case.
6instaread   s bootstrap rule induction and core linguistic rules
currently only target binary relations, but not entity types. to iden-
tify named entities of types person and organization, we thus used
the stanford ner system. to handle relation attendedschool we
additionally created a recognizer for type school by listing 30 com-
mon head words such as    university    before the experiment. this
process took under 5 minutes.

attendedschool
instaread (rules) 94
sup (examples)
68

founded killed married
48
52

141
36

97
79

table 2: manual input generated in one hour of time. in the
supervised case, annotators had dif   culty    nding examples for
the killed relation which had fewer mentions in the corpus. in
contrast, instaread   s effort-reducing features, such as rule
suggestions, made it easy to    nd examples and add relevant
rules quickly. our user of instaread actually generated more
rules for this relation, in the allotted time, due to the larger
number of syntactic variations.

metrics.

extractions were counted on a mention level, which means that
an extraction consisted of both a pair of strings representing named
entities as well as a reference to the sentence expressing the rela-
tion. to measure precision, we sampled 100 extractions and manu-
ally created annotations following the ace guidelines [7].
8.2 comparing instaread to baselines

overall results are summarized in table 1. in the case of insta-
read, precision was 90% or higher7 for each of the four relations,
and each extractor returned thousands of tuples. for the three base-
lines, results varied between relations but in all cases signi   cantly
fewer extractions were returned, and in all but two cases precision
was signi   cantly lower. the most challenging of the four relations
was killed, since it can be expressed in many different ways, and
many such expressions have multiple meanings. at the same time,
mentions of the killed relation occur less frequently in the corpus
than mentions of the other three relations. the supervised baseline
did not return results, and the distantly supervised systems could
not be applied because freebase did not contain instances for the
killed relation.

user feedback.

looking more carefully at the feedback supplied by our users,
we found that one hour use of instaread yielded 95 rules on
average. this compares to an average of 59 examples per hour
annotated by users in the supervised case.
instaread   s effort-
reducing features made it easy to    nd relevant sentences and add
rules quickly, which frequently only required con   rmation of a
system-generated suggestion. users in the supervised case had dif-
   culty    nding sentences expressing the relations. two of the anno-
tators reported that they started off reading the text corpus linearly,
but barely found any examples that way. they later searched by
keywords (   college   ) and wildcards (   marr*   ). with 77 and 89 ex-
amples per hour these users found more examples (but not neces-
sarily more variations) than users who scanned the corpus linearly
7the high precision in the case of instaread may seem surpris-
ing, but is in fact easy to attain for many relations. since ev-
ery change the user makes to the rule set immediately triggers a
re-evaluation and visual presentation of extractions and their sen-
tences, the user can quickly adapt the rule set until she is satis   ed
with precision on the training set. there is generally little over   t-
ting, due to the training set being large and the rules not being au-
tomatically selected but created by a human with intuitions about
language.
this contrasts with sup, where a    xed feature set leads to high
precision on one relation (founded), but low precision on another
(attendedschool). without interactive feedback, it is very chal-
lenging to create an effective feature set as well as create effective
annotated examples, especially negative ones.

pr

attendedschool
#e
100% 52,338
14,960
18,480
25,196

9%
26%
12%

founded
pr

#e
91% 20,733
28% 14,960
38% 10,340
100% 2,255

killed
pr

#e
90% 4,728
0*
n/a
0*
n/a
n/a
0

married
pr

#e
90% 63,742
93% 9,900
51% 24,200
44%
7,867

instaread
miml-re
multir
sup

table 1: precision (pr) and number of extractions (#e) for the nytimes test dataset. *cases where extraction could not be performed
because no target database could be found that contained examples required for distant supervision.

figure 4: number of extractions on an independent test set while using instaread for 55 minutes. bootstrap (section 6) captures a
large number of extractions quickly, but does not yield additional gains after a few minutes. wordsim (section 6) enables slow, but
consistent gains. linguistics (section 6) provides a small gain. composition (section 5) is helpful when there exist a large number of
lexical stems that imply a relation (e.g. for the killed relation).

and found 19 and 51 examples per hour.

table 2 shows a breakdown by relation, and reveals a striking
difference between instaread and sup for the killed relation.
in the supervised case, users were able to identify far fewer exam-
ples for this relation than others. in contrast, our user of insta-
read actually generated most rules for this relation. this shows
that instaread did not suffer from the problem of    nding exam-
ples. in fact, as we will see, instaread   s effort-reducing features
were actually most effective for this relation, and the larger number
of rules was necessary to cover a larger set of variations.

impact of effort-reducing features.

figure 4 shows the contribution of each of the four features on
number of extractions. the vast majority of extractions, 84%, were
obtained by rules created during the bootstrap phase. bootstrap
has the ability to aggregate over many potential rules and then rank
those taking into account the number of extractions. this ranking
ensures that user effort is directed to rules which are likely to mat-
ter most. such ranking is not possible with the wordsim feature,
which, however, has a different advantage: it can    nd rarely used

ways of expressing a relation. in contrast, bootstrap only works if
the same relation instance is expressed multiple times in different
ways. we therefore often observe that it provides no more improve-
ment after a few minutes of use. 3.4% of extractions were obtained
by rules created during the wordsim phase, 2.6% during the lin-
guistics phase, and 9.5% during the composition phase.

figure 4 further reveals differences between relations. for mar-
ried, the relatively small number of common variations were al-
ready captured in only 15 minutes, after which wordsim, linguis-
tics, and composition features provided little bene   t. for killed,
however, each of the four effort-reducing features substantially in-
creased the number of extractions. this shows that instaread   s
ensemble of effort-reducing features was effective in guiding our
user to the many variations of the killed relation.

analysis of instaread   s errors.

instaread   s precision errors for the four relations were to a
large degree caused by errors in preprocessing, especially depen-
dency extraction (55%) and ner (24%). only 21% of precision
errors were caused by overly general rules that the expert user had

time(min)extractions0510152025303540455055600200004000060000bootstrap         wordsim       lin       compositionattendedschooltime(min)extractions05101520253035404550556005000100001500020000bootstrap         wordsim       lin        compositionfoundedtime(min)extractions051015202530354045505560010002000300040005000bootstrap          wordsim      lin        compositionkilledtime(min)extractions0510152025303540455055600200004000060000bootstrap          wordsim      lin        compositionmarrieddeveloped. all were due to ambiguities of the words fell, executor,
and built. while the effort-reducing features have been designed to
increase recall, instaread   s focus on only deterministic rules is
not adequate to easily handle such ambiguities     a shortcoming we
would like to address in future work.

which we would like to address in future work. another important
area for improvement is the interface to manage sets of rules. the
subjects found it was often easier for them to manage rule sets in
code (as strings of logical expression), because they could add their
own comments, re-arrange, and keep track of multiple versions.

enhancing supervised extraction.

finally, we are interested in knowing if an increase in time would
let users in the supervised case match instaread   s results. we
therefore combined the annotations of all four annotators; each re-
lation   s examples thus corresponded to four hours of manual ef-
fort. trained on this data, sup returned more extractions (attended-
school     51,492, founded     7,482, killed     220, married     24,866),
but precision remained low and in two cases even decreased slightly
(attendedschool     12%, founded     97%, killed     0%, married    
34%). in summary, additional time does improve performance, but
many more hours of annotation effort would be required to reach
performance comparable to instaread.

the features we selected have been shown to work well for many
relations [22], but it is still possible that better features could im-
prove the supervised learning algorithm   s performance. however,
feature engineering itself takes considerable effort, usually mea-
sured in weeks, which would defeat our goal of building complete
extractors quickly. it will be an important area for future work to
determine if instaread can be adapted to support rapid authoring
of rules that de   ne feature templates, perhaps providing even better
overall performance on a limited engineering budget.

comparing to extreme extraction work.

it is impossible to compare directly to freedman et al [11], since
we were unable to acquire their datasets. while their approach
yielded an average precision of 53% across 5 relations, they used
50 hours of manual engineering and furthermore those hours were
spread across several different experts, each with knowledge of a
speci   c tool.

unlike instaread   s bootstrap feature, their bootstrap learner
ran autonomously without user interaction, but contributed little to
increase overall performance. we suspect that instaread   s user
in the loop, instant execution, integration of coreference informa-
tion, and larger corpus contributed to perceived differences in ef-
fectiveness. section 3 discusses further differences and similarities
of freedman et al   s work and instaread.
8.3 real-world use by engineers

our experiments so far tested instaread   s effectiveness for a
trained expert; in our    nal experiment, we evaluated if the system
was also usable by engineers without nlp background.

we recruited four senior undergraduate students in computer
science who used instaread as part of a quarterly class project
to develop 30 relation extractors for the tac-kbp slot    lling chal-
lenge. in six meetings, usage of the tool was explained and quali-
tative feedback collected.

all four subjects were able to use the system with little instruc-
tion, all were able to develop extractors, and all four subjects re-
ported that the tool made it easier for them than if they had to write
their own code. among the 27 extractors that were created, median
precision was 94% (mean 75%), and median number of extractions
on nytimes data was 2283 (mean 8741). for two relations, no
extractor was created due to the dif   culty in creating custom entity
type recognizers, and for one relation due to an implementation er-
ror. mean precision was negatively affected by six relations which
required custom entity type recognizers. instaread currently has
no support for developing entity type recognizers, a shortcoming

9. conclusions and future work
many successful applications of ie rely on large amounts of
manual engineering, which often requires the laborious selection
of rules to be used as extraction patterns or features.

this paper presents ways to streamline this process, proposing
an ensemble of methods that enable three properties: an expressive
rule language, guidance that leads users to promising rules, and
instant rule testing. our experiments demonstrate that instaread
enables experts to develop quality relation extractors in under one
hour     an order of magnitude reduction in effort from freedman et
al. [11]. to stimulate continued progress in the area, we release our
data as explained in footnote 1.

the experiments also point to two promising directions to further

reduce manual effort:

richness of interactions.

with the bootstrap, wordsim, linguistics, and composition fea-
tures, instaread offered a variety of interactions, all of which
contributed to increased recall while maintaining high-precision.
bootstrap was particularly effective, but did not allow further im-
provements after a few minutes of use. wordsim did not show this
problem, but expanded recall more slowly. composition was very
effective for some relations. linguistics yielded smaller gains, but
required less effort. future improvements to cover additional syn-
tactic variations, such as participle phrases, may increase gains.

we consider such variety of interactions essential, and thus plan
to include interactions for id91 phrases, providing databases
of instances for distant supervision, editing ontologies, providing
validative feedback, and annotating sentences. determining the rel-
ative importance of such interactions will be an important future
challenge.

deep integration of algorithms.

perhaps even greater potential, however, may lie in more tightly
integrating instaread   s components. our analysis of precision
errors revealed that the majority of precision errors were caused by
inaccurate preprocessing, and we believe that jointly taking into ac-
count manually created rules as well as the k best outputs of the pre-
processing components could improve results. we further suspect
learning-based techniques may be particularly important for tasks
such as ner, where there exist many ambiguities, while rule-based
techniques may work well for tasks such as de   ning implicature
between phrases.

instaread   s boostrap feature could also be improved. it cur-
rently already leverages coreference clusters and syntactic depen-
dencies. in fact, coreference information which greatly increases
recall may explain much of bootstrap learning   s observed high ef-
fectiveness compared to freedman et al.   s work. in the future, we
would like to enable bootstrap to also take into account our core
linguistic rules and the ability to decompose rules. such integra-
tion may expand recall, and interestingly, might also simplify the
interaction with the user. since the integrated components enable
rules with higher coverage, fewer, more distinct rules would be re-
turned.

10. references
[1] d. e. appelt and b. onyshkevych. the common pattern

speci   cation language. in proceedings of a workshop held
at tipster 98, pages 23   30. association for computational
linguistics, 1998.

[2] k. d. bollacker, c. evans, p. paritosh, t. sturge, and

j. taylor. freebase: a collaboratively created graph database
for structuring human knowledge. in sigmod conference,
pages 1247   1250, 2008.

[3] a. carlson, j. betteridge, e. r. h. jr., and t. m. mitchell.

coupling semi-supervised learning of categories and
relations. in proceedings of the naacl hlt workskop on
semi-supervised learning for natural language processing,
2009.

[4] a. x. chang and c. d. manning. tokensregex: de   ning

cascaded id157 over tokens. technical report
cstr 2014-02, department of computer science, stanford
university, 2014.

[5] e. charniak and m. johnson. coarse-to-   ne n-best parsing
and maxent discriminative reranking. in proceedings of the
annual meeting of the association for computational
linguistics (acl), 2005.

[6] l. chiticariu, r. krishnamurthy, y. li, s. raghavan,
f. reiss, and s. vaithyanathan. systemt: an algebraic
approach to declarative information extraction. in
proceedings of the annual meetings of the association for
computational linguistics (acl), pages 128   137, 2010.
[7] g. doddington, a. mitchell, m. przybocki, l. ramshaw,

s. strassel, and r. weischedel. ace program - task
de   nitions and performance measures. in proceedings of the
international conference on language resources and
evaluation (lrec), pages 837   840, 2004.

[8] p. domingos and d. lowd. markov logic: an interface
layer for arti   cial intelligence. synthesis lectures on
arti   cial intelligence and machine learning. morgan &
claypool publishers, 2009.

[9] g. druck, b. settles, and a. mccallum. active learning by

labeling features. in proceedings of the conference on
empirical methods in natural language processing
(emnlp), pages 81   90, 2009.

[10] j. r. finkel, t. grenager, and c. manning. incorporating

non-local information into information extraction systems by
id150. in proceedings of the annual meeting of the
association for computational linguistics (acl), pages
363   370, 2005.

[11] m. freedman, l. a. ramshaw, e. boschee, r. gabbard,

g. kratkiewicz, n. ward, and r. m. weischedel. extreme
extraction - machine reading in a week. in proceedings of the
conference on empirical methods in natural language
processing (emnlp), pages 1437   1446, 2011.

[12] r. gabbard, m. freedman, and r. m. weischedel.

coreference for learning to extract relations: yes virginia,
coreference matters. in proceedings of the annual meeting
of the association for computation linguistics (acl), pages
288   293, 2011.

[13] k. ganchev, j. gra  a, j. gillenwater, and b. taskar. posterior

id173 for structured latent variable models. journal
of machine learning research, 11:2001   2049, 2010.

[14] r. hoffmann, c. zhang, x. ling, l. s. zettlemoyer, and

d. s. weld. knowledge-based weak supervision for
information extraction of overlapping relations. in
proceedings of the annual meeting of the association for

computational linguistics (acl), pages 541   550, 2011.
[15] r. hoffmann, c. zhang, and d. s. weld. learning 5000

relational extractors. in proceedings of the annual meeting
of the association for computational linguistics (acl),
pages 286   295, 2010.

[16] h. ji, r. grishman, and h. t. dang. an overview of the

tac2011 knowledge base population track. in proceedings of
the text analysis conference (tac), 2011.

[17] r. krishnamurthy, y. li, s. raghavan, f. reiss,

s. vaithyanathan, and h. zhu. systemt: a system for
declarative information extraction. sigmod record,
37(4):7   13, 2008.

[18] d. lin and p. pantel. dirt - discovery of id136 rules from

text. in proceedings of the acm sigkdd international
conference on knowledge discovery and data mining
(kdd), pages 323   328, 2001.

[19] m.-c. d. marneffe, b. maccartney, and c. d. manning.

generating typed dependency parses from phrase structure
parses. in proceedings of the international conference on
language resources and evaluation (lrec), 2006.

[20] s. miller, j. guinness, and a. zamanian. name tagging with
word clusters and discriminative training. in proceedings of
the human language technology conference of the north
american chapter of the association for computational
linguistics (hlt-naacl), 2004.

[21] b. min, x. li, r. grishman, and a. sun. new york

university 2012 system for kbp slot    lling. in proceedings of
the text analysis conference (tac), 2012.

[22] m. mintz, s. bills, r. snow, and d. jurafsky. distant

supervision for id36 without labeled data. in
proceedings of the annual meeting of the association for
computational linguistics (acl), pages 1003   1011, 2009.

[23] n. nakashole, m. theobald, and g. weikum. scalable

knowledge harvesting with high precision and high recall. in
proceedings of the international conference on web search
and data mining (wsdm), pages 227   236, 2011.

[24] n. nakashole, g. weikum, and f. m. suchanek. discovering

and exploring relations on the web. the proceedings of the
vldb endowment (pvldb), 5(12):1982   1985, 2012.

[25] n. nakashole, g. weikum, and f. m. suchanek. discovering

semantic relations from the web and organizing them with
patty. sigmod record, 42(2):29   34, 2013.

[26] f. niu, c. zhang, c. re, and j. w. shavlik. deepdive:

web-scale knowledge-base construction using statistical
learning and id136. in in proceedings of the second
international workshop on searching and integrating new
web data sources (vlds), pages 25   28, 2012.

[27] f. niu, c. zhang, c. r  , and j. w. shavlik. elementary:

large-scale knowledge-base construction via machine
learning and statistical id136. international journal on
semantic web and information systems, 8(3):42   73, 2012.

[28] h. poon and p. domingos. joint id136 in information

extraction. in proceedings of the aaai conference on
arti   cial intelligence, pages 913   918, 2007.

[29] k. raghunathan, h. lee, s. rangarajan, n. chambers,

m. surdeanu, d. jurafsky, and c. d. manning. a multi-pass
sieve for coreference resolution. in proceedings of the
conference on empirical methods in natural language
processing (emnlp), pages 492   501, 2010.

[30] c. r  , a. a. sadeghian, z. shan, j. shin, f. wang, s. wu,

and c. zhang. feature engineering for knowledge base

construction. ieee data engineering bulletin, 37(3):26   40,
2014.

[31] s. riedel, l. yao, and a. mccallum. modeling relations and

their mentions without labeled text. in proceedings of the
european conference on machine learning and principles
and practice of knowledge discovery in databases
(ecml/pkdd), pages 148   163, 2010.

[32] e. riloff. automatically generating extraction patterns from
untagged text. in aaai/iaai, vol. 2, pages 1044   1049, 1996.
[33] d. roth and w.-t. yih. a id135 formulation

for global id136 in natural language tasks. in
proceedings of the 2004 conference on computational
natural language learning (conll), pages 1   8, 2004.

[34] e. sandhaus. the new york times annotated corpus.

linguistic data consortium, 2008.

[35] f. m. suchanek, g. kasneci, and g. weikum. yago: a large

ontology from wikipedia and id138. elsevier journal of
web semantics, 6(3):203   217, 2008.

[36] a. sun, r. grishman, w. xu, and b. min. new york

university 2011 system for kbp slot    lling. in proceedings of
the text analysis conference (tac), 2011.

[37] m. surdeanu, j. tibshirani, r. nallapati, and c. manning.

multi-instance multi-label learning for id36. in
proceedings of the conference on empirical methods in
natural language processing (emnlp), 2012.

[38] c. a. thompson, m. e. califf, and r. j. mooney. active

learning for natural language parsing and information
extraction. in proceedings of the international conference
on machine learning (icml), pages 406   414, 1999.

[39] j. d. ullman. principles of database and knowledge-base

systems, volume i. computer science press, 1988.

appendix

r(t)     str2span(   lee harvey oswald   , s)   

span2pos(s, p)     nsubj(c, p)   
token(c, t)

         (cid:121) translation

select ti4.tokenid
from tokeninst ti0, tokeninst ti1,

tokeninst ti2, tokeninst ti3,
dependencyinst di0, tokeninst ti4

where ti4.offset = di0.from

and ti4.sentenceid = di0.sentenceid
and di0.to = ti3.offset
and di0.sentenceid = ti3.sentenceid
and di0.dependencyid = 11
and ti3.offset < ti2.offset + 1
and ti3.offset >= ti0.offset
and ti3.sentenceid = ti0.sentenceid
and ti2.tokenid = 79216
and ti1.tokenid = 6058
and ti0.tokenid = 5322
and ti0.offset + 2 = ti2.offset
and ti0.sentenceid = ti2.sentenceid
and ti0.offset + 1 = ti1.offset
and ti0.sentenceid = ti1.sentenceid

figure 5: translation of a (safe) expression in    rst-order logic
to sql. the expression returns verbs for which lee harvey os-
wald appears as subject. str2spans and span2pos are inten-
sional predicates, nsubj and token are extensional. each pred-
icate gets translated into a fragment of sql; the fragments are
then combined into a single sql query, which can be ef   ciently
executed.

killofnom(c, b)     . . .
. . . prep-of(c, b)     token(c,    assassination   )
. . . prep-of(c, b)     token(c,    execution   )
. . . prep-of(c, b)     token(c,    felling   )
. . . prep-of(c, b)     token(c,    killing   )
. . . prep-of(c, b)     token(c,    shooting   )
. . . prep-of(c, b)     token(c,    slaughter   )
. . . prep-of(c, b)     token(c,    slaying   )
. . . prep-of(c, b)     token(c,    stabbing   )
. . . prep-of(c, b)     token(c,    murder   )
. . . nn(c, b)     token(c,    assassination   )
. . . nn(c, b)     token(c,    murder   )
. . .
killerrole(c)     . . .
. . . token(c,    assassin   )
. . . token(c,    murderer   )
. . .
killingbnf(c, b)     . . .
. . . dobj(c, b)     token(c,    assassinate   )
. . . dobj(c, b)     token(c,    murder   )
. . .
killingbinf(d, b)     . . .
. . . dobj(d, b)     token(d,    assassinating   )
. . . dobj(d, b)     token(d,    murdering   )
. . .
killed(a, b)     person(b)     person(a)     (a (cid:54)= b)     . . .
. . . actind(a, c,    confess   )     prepc-to(c, d)     killingbinf(d, b)
. . . actind(a, c,    confess   )     prep-to(c, d)     killofnom(d, b)
. . . actind(a, c,    assassinate   )     dobj(c, b)
. . . actind(a, c,    murder   )     dobj(c, b)
. . .
. . . agent(c, a)     partmod(b, c)     token(c,    assassinated   )
. . . agent(c, a)     partmod(b, c)     token(c,    murdered   )
. . .
. . . agent(c, a)     rcmod(b, c)     token(c,    assassinated   )
. . . agent(c, a)     rcmod(b, c)     token(c,    murdered   )
. . .
. . . appos(a, c)     poss(c, b)     killerrole(c)
. . . appos(a, c)     prep-of(c, b)     killerrole(c)
. . . appos(c, a)     poss(c, b)     killerrole(c)
. . . appos(c, a)     prep-of(c, b)     killerrole(c)
. . . dep(a, c)     dobj(c, b)     token(c,    assassinated   )
. . . dep(a, c)     dobj(c, b)     token(c,    murdered   )
. . . infmod(a, c)     killingbnf(c, b)
. . . nsubj(c, a)     prep-in(c, d)     token(c,    suspect   )     killofnom(d, b)
. . . nsubj(c, a)     xcomp(c, d)     killingbinf(d, b)
. . . partmod(a, c)     killingbinf(c, b)
. . . partmod(a, c)     prepc-for(c, d)     token(c,    sentenced   )     killingbinf(d, b)
. . . partmod(a, c)     prepc-of(c, d)     token(c,    accused   )     killingbinf(d, b)
. . . partmod(a, c)     prepc-of(c, d)     token(c,    convicted   )     killingbinf(d, b)
. . . partmod(a, c)     prepc-with(c, d)     token(c,    charged   )     killingbinf(d, b)
. . . partmod(a, c)     prep-in(c, d)     token(c,    wanted   )     prep-with(d, e)     token(d,    connection   )   
. . . partmod(a, c)     prep-to(c, d)     token(c,    linked   )     killofnom(d, b)
. . . passind(a, c,    accuse   )     prep-of(c, d)     killofnom(d, b)
. . . passind(a, c,    charge   )     prepc-with(c, d)     killingbinf(d, b)
. . . passind(a, c,    charge   )     prep-with(c, d)     killofnom(d, b)
. . . passind(a, c,    convict   )     prepc-for(c, d)     killingbinf(d, b)
. . . passind(a, c,    convict   )     prepc-of(c, d)     killingbinf(d, b)
. . . passind(a, c,    convict   )     prepc-of(c, d)     prep-in(d, e)     token(d,    taking   )     killofnom(e, b)
. . . passind(a, c,    convict   )     prep-for(c, d)     killofnom(d, b)
. . . passind(a, c,    convict   )     prep-in(c, d)     prep-of(d, b)     token(d,    death   )
. . . passind(a, c,    convict   )     prep-of(c, d)     killofnom(d, b)
. . . passind(a, c,    link   )     prep-to(c, d)     killofnom(d, b)
. . . passind(a, c,    sentence   )     prep-for(c, d)     killofnom(d, b)
. . . passind(a, c,    want   )     prep-in(c, d)     prep-with(d, e)     token(d,    connection   )     killofnom(e, b)
. . . passind(b, c,    assassinate   )     agent(c, a)
. . . passind(b, c,    gun   )     prt(c, d)     token(d,    down   )     agent(c, a)
. . . passind(b, c,    murder   )     agent(c, a)
. . . passind(l, c,    take   )     token(l,    life   )     poss(l, b)     agent(c, a)
. . . passind(l, c,    take   )     token(l,    life   )     prep-of(l, b)     agent(c, a)
. . .
. . . poss(c, a)     killofnom(c, b)
. . . poss(c, a)   nsubjpass(d, c)   token(c,    name   )   prep-to(d, e)   token(d,    linked   )   killofnom(e, b)
. . . prep-by(c, a)     killofnom(c, b)
. . . rcmod(a, c)     dobj(c, b)     token(c,    assassinated   )
. . . rcmod(a, c)     dobj(c, b)     token(c,    murdered   )
. . .
. . . token(a,    suspect   )     nsubj(c, a)     prep-in(c, d)     prep-of(d, b)     nn(e, d)     token(e,    murder   )   
. . . xsubj(c, a)     killingbnf(c, b)
. . .
. . .

token(d,    trial   )

killofnom(e, b)

figure 6: selected extraction rules created for relation killed
during the experiment. many extractions were obtained dur-
ing the bootstrap phase, which suggested rules combining syn-
tactic dependencies (eg. nn) and lexical information (eg. token).
users selected from these suggestions, but also adapted them
by adding constraints (eg. prt, (cid:54)=, person). wordsim added lex-
ical variety (eg. killofnom), and linguistics covered additional
verb in   ections (encoded by predicates actind and passind).
composition introduced re-usable components (eg. killerrole,
killingbnf).

