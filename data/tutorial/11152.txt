language understanding for text-based games using deep

id23

karthik narasimhan   

csail, mit

karthikn@csail.mit.edu

tejas d kulkarni   
csail, bcs, mit
tejask@mit.edu

regina barzilay

csail, mit

regina@csail.mit.edu

5
1
0
2

 

p
e
s
1
1

 

 
 
]
l
c
.
s
c
[
 
 

2
v
1
4
9
8
0

.

6
0
5
1
:
v
i
x
r
a

abstract

in this paper, we consider the task of learn-
ing control policies for text-based games.
in these games, all interactions in the vir-
tual world are through text and the un-
derlying state is not observed. the re-
sulting language barrier makes such envi-
ronments challenging for automatic game
players. we employ a deep reinforcement
learning framework to jointly learn state
representations and action policies using
game rewards as feedback. this frame-
work enables us to map text descriptions
into vector representations that capture the
semantics of the game states. we eval-
uate our approach on two game worlds,
comparing against baselines using bag-of-
words and bag-of-bigrams for state rep-
resentations. our algorithm outperforms
the baselines on both worlds demonstrat-
ing the importance of learning expressive
representations. 1

1

introduction

in this paper, we address the task of learning con-
trol policies for text-based strategy games. these
games, predecessors to modern graphical ones,
still enjoy a large following worldwide.2 they of-
ten involve complex worlds with rich interactions
and elaborate textual descriptions of the underly-
ing states (see figure 1). players read descriptions
of the current world state and respond with natural
language commands to take actions. since the un-
derlying state is not directly observable, the player
has to understand the text in order to act, making it

   both authors contributed equally to this work.
1code is available at http://people.csail.mit.

edu/karthikn/mud-play.

2http://mudstats.com/

state 1: the old bridge
you are standing very close to the bridge   s
eastern foundation. if you go east you will
be back on solid ground ... the bridge
sways in the wind.
command: go east
state 2: ruined gatehouse
the old gatehouse is near collapse. part of
its northern wall has already fallen down ...
east of the gatehouse leads out to a small
open area surrounded by the remains of the
castle. there is also a standing archway of-
fering passage to a path along the old south-
ern inner wall.
exits: standing archway, castle corner,
bridge over the abyss

figure 1: sample gameplay from a fantasy world.
the player with the quest of    nding a secret tomb,
is currently located on an old bridge. she then
chooses an action to go east that brings her to a
ruined gatehouse (state 2).

challenging for existing ai programs to play these
games (depristo and zubek, 2001).

in designing an autonomous game player, we
have considerable latitude when selecting an ad-
equate state representation to use. the simplest
method is to use a bag-of-words representation
derived from the text description. however, this
scheme disregards the ordering of words and the
   ner nuances of meaning that evolve from com-
posing words into sentences and paragraphs. for
instance, in state 2 in figure 1, the agent has to
understand that going east will lead it to the cas-
tle whereas moving south will take it to the stand-
ing archway. an alternative approach is to convert
text descriptions to pre-speci   ed representations
using annotated training data, commonly used in
language grounding tasks (matuszek et al., 2013;

kushman et al., 2014).

in contrast, our goal is to learn useful represen-
tations in conjunction with control policies. we
adopt a id23 framework and for-
mulate game sequences as markov decision pro-
cesses. an agent playing the game aims to maxi-
mize rewards that it obtains from the game engine
upon the occurrence of certain events. the agent
learns a policy in the form of an action-value func-
tion q(s, a) which denotes the long-term merit of
an action a in state s.

the action-value function is parametrized us-
ing a deep recurrent neural network, trained us-
ing the game feedback. the network contains two
modules. the    rst one converts textual descrip-
tions into vector representations that act as prox-
ies for states. this component is implemented us-
ing long short-term memory (lstm) networks
(hochreiter and schmidhuber, 1997). the second
module of the network scores the actions given the
vector representation computed by the    rst.

we evaluate our model using two multi-user
dungeon (mud) games (curtis, 1992; amir and
doyle, 2002). the    rst game is designed to pro-
vide a controlled setup for the task, while the sec-
ond is a publicly available one and contains hu-
man generated text descriptions with signi   cant
language variability. we compare our algorithm
against baselines of a random player and mod-
els that use bag-of-words or bag-of-bigrams rep-
resentations for a state. we demonstrate that our
model lstm-id25 signi   cantly outperforms the
baselines in terms of number of completed quests
and accumulated rewards. for instance, on a fan-
tasy mud game, our model learns to complete
96% of the quests, while the bag-of-words model
and a random baseline solve only 82% and 5% of
the quests, respectively. moreover, we show that
the acquired representation can be reused across
games, speeding up learning and leading to faster
convergence of q-values.

2 related work

learning control policies from text is gaining in-
creasing interest in the nlp community. example
applications include interpreting help documenta-
tion for software (branavan et al., 2010), navi-
gating with directions (vogel and jurafsky, 2010;
kollar et al., 2010; artzi and zettlemoyer, 2013;
matuszek et al., 2013; andreas and klein, 2015)
and playing computer games (eisenstein et al.,

2009; branavan et al., 2011a).

games provide a rich domain for grounded lan-
guage analysis. prior work has assumed perfect
knowledge of the underlying state of the game to
learn policies. gorniak and roy (2005) developed
a game character that can be controlled by spoken
instructions adaptable to the game situation. the
grounding of commands to actions is learned from
a transcript manually annotated with actions and
state attributes. eisenstein et al. (2009) learn game
rules by analyzing a collection of game-related
documents and precompiled traces of the game. in
contrast to the above work, our model combines
text interpretation and strategy learning in a single
framework. as a result, textual analysis is guided
by the received control feedback, and the learned
strategy directly builds on the text interpretation.
our work closely relates to an automatic game
player that utilizes text manuals to learn strategies
for civilization (branavan et al., 2011a). similar
to our approach, text analysis and control strate-
gies are learned jointly using feedback provided
by the game simulation. in their setup, states are
fully observable, and the model learns a strategy
by combining state/action features and features
extracted from text. however, in our application,
the state representation is not provided, but has to
be inferred from a textual description. therefore,
it is not suf   cient to extract features from text to
supplement a simulation-based player.

another related line of work consists of auto-
matic video game players that infer state repre-
sentations directly from raw pixels (koutn    k et al.,
2013; mnih et al., 2015). for instance, mnih et
al. (2015) learn control strategies using convolu-
tional neural networks, trained with a variant of
id24 (watkins and dayan, 1992). while
both approaches use deep id23
for training, our work has important differences.
in order to handle the sequential nature of text, we
use id137 to auto-
matically learn useful representations for arbitrary
text descriptions. additionally, we show that de-
composing the network into a representation layer
and an action selector is useful for transferring the
learnt representations to new game scenarios.

3 background

game representation we represent a game by
the tuple (cid:104)h, a, t, r,   (cid:105), where h is the set of
all possible game states, a = {(a, o)} is the set of

all commands (action-object pairs), t (h(cid:48) | h, a, o)
is the stochastic transition function between states
and r(h, a, o) is the reward function. the game
state h is hidden from the player, who only re-
ceives a varying textual description, produced by
a stochastic function    : h     s. speci   cally,
the underlying state h in the game engine keeps
track of attributes such as the player   s location,
her health points, time of day, etc. the function
   (also part of the game framework) then converts
this state into a textual description of the location
the player is at or a message indicating low health.
we do not assume access to either h or    for our
agent during both training and testing phases of
our experiments. we denote the space of all possi-
ble text descriptions s to be s. rewards are gener-
ated using r and are only given to the player upon
completion of in-game quests.
id24 id23 is a com-
monly used framework for learning control poli-
cies in game environments (silver et al., 2007;
amato and shani, 2010; branavan et al., 2011b;
szita, 2012).
the game environment can be
formulated as a sequence of state transitions
(s, a, r, s(cid:48)) of a markov decision process (mdp).
the agent takes an action a in state s by consult-
ing a state-action value function q(s, a), which is
a measure of the action   s expected long-term re-
ward. id24 (watkins and dayan, 1992) is
a model-free technique which is used to learn an
optimal q(s, a) for the agent. starting from a ran-
dom q-function, the agent continuously updates
its q-values by playing the game and obtaining re-
wards. the iterative updates are derived from the
bellman equation (sutton and barto, 1998):
(cid:48)) | s, a]

qi+1(s, a) = e[r +    max

(1)

, a

(cid:48)

a(cid:48) qi(s

where    is a discount factor for future rewards and
the expectation is over all game transitions that in-
volved the agent taking action a in state s.

using these evolving q-values,

the agent
chooses the action with the highest q(s, a) to
maximize its expected future rewards. in practice,
the trade-off between exploration and exploitation
can be achieved following an  -greedy policy (sut-
ton and barto, 1998), where the agent performs a
random action with id203  .
deep q-network in large games, it is often im-
practical to maintain the q-value for all possible
state-action pairs. one solution to this problem

figure 2: architecture of lstm-id25: the rep-
resentation generator (  r) (bottom) takes as input
a stream of words observed in state s and produces
a vector representation vs, which is fed into the
action scorer (  a) (top) to produce scores for all
actions and argument objects.

is to approximate q(s, a) using a parametrized
function q(s, a;   ), which can generalize over
states and actions by considering higher-level at-
tributes (sutton and barto, 1998; branavan et al.,
2011a). however, creating a good parametrization
requires knowledge of the state and action spaces.
one way to bypass this feature engineering is to
use a deep q-network (id25) (mnih et al., 2015).
the id25 approximates the q-value function with
a deep neural network to predict q(s, a) for all
possible actions a simultaneously given the cur-
rent state s. the non-linear function layers of the
id25 also enable it to learn better value functions
than linear approximators.

4 learning representations and control

policies

in this section, we describe our model (id25) and
describe its use in learning good q-value approxi-
mations for games with stochastic textual descrip-
tions. we divide our model into two parts. the
   rst module is a representation generator that con-
verts the textual description of the current state
into a vector. this vector is then input into the
second module which is an action scorer. fig-
ure 2 shows the overall architecture of our model.
we learn the parameters of both the representation
generator and the action scorer jointly, using the
in-game reward feedback.

representation generator (  r) the represen-
tation generator reads raw text displayed to the

mean poolinglstmlstmlstmlstmlinearrelulinearlinearq(s, a)q(s, o)w1w2w3wn rvs aagent and converts it to a vector representation vs.
a bag-of-words (bow) representation is not suf-
   cient to capture higher-order structures of sen-
tences and paragraphs. the need for a better se-
mantic representation of the text is evident from
the average performance of this representation in
playing mud-games (as we show in section 6).

in order to assimilate better representations,
we utilize a long short-term memory network
(lstm) (hochreiter and schmidhuber, 1997) as
a representation generator. lstms are recurrent
neural networks with the ability to connect and
recognize long-range patterns between words in
text. they are more robust than bow to small
variations in word usage and are able to capture
underlying semantics of sentences to some ex-
tent. in recent work, lstms have been used suc-
cessfully in nlp tasks such as machine transla-
tion (sutskever et al., 2014) and sentiment anal-
ysis (tai et al., 2015) to compose vector repre-
sentations of sentences from word-level embed-
dings (mikolov et al., 2013; pennington et al.,
2014). in our setup, the lstm network takes in
id27s wk from the words in a descrip-
tion s and produces output vectors xk at each step.
to get the    nal state representation vs, we add a
mean pooling layer which computes the element-
wise mean over the output vectors xk.3

n(cid:88)

k=1

vs =

1
n

xk

(2)

action scorer (  a) the action scorer module
produces scores for the set of possible actions
given the current state representation. we use a
multi-layered neural network for this purpose (see
figure 2). the input to this module is the vec-
tor from the representation generator, vs =   r(s)
and the outputs are scores for actions a     a.
scores for all actions are predicted simultaneously,
which is computationally more ef   cient than scor-
ing each state-action pair separately. thus, by
combining the representation generator and action
scorer, we can obtain the approximation for the q-
function as q(s, a)       a(  r(s))[a].

an additional complexity in playing mud-
games is that the actions taken by the player are
multi-word natural language commands such as

3we also experimented with considering just the output
vector of the lstm after processing the last word. empiri-
cally, we    nd that mean pooling leads to faster learning, so
we use it in all our experiments.

eat apple or go east. due to computational con-
straints, in this work we limit ourselves to con-
sider commands to consist of one action (e.g. eat)
and one argument object (e.g. apple). this as-
sumption holds for the majority of the commands
in our worlds, with the exception of one class of
commands that require two arguments (e.g. move
red-root right, move blue-root up). we consider all
possible actions and objects available in the game
and predict both for each state using the same net-
work (figure 2). we consider the q-value of the
entire command (a, o) to be the average of the q-
values of the action a and the object o. for the rest
of this section, we only show equations for q(s, a)
but similar ones hold for q(s, o).

parameter learning we learn the parameters
  r of the representation generator and   a of the
action scorer using stochastic id119
with rmsprop (tieleman and hinton, 2012). the
complete training procedure is shown in algo-
rithm 1.
in each iteration i, we update the pa-
rameters to reduce the discrepancy between the
predicted value of the current state q(st, at;   i)
(where   i = [  r;   a]i) and the expected q-value
given the reward rt and the value of the next state
maxa q(st+1, a;   i   1).
we keep track of the agent   s previous experi-
ences in a memory d.4
instead of performing
updates to the q-value using transitions from the
current episode, we sample a random transition
(  s,   a, s(cid:48), r) from d. updating the parameters in
this way avoids issues due to strong correlation
when using transitions of the same episode (mnih
et al., 2015). using the sampled transition and (1),
we obtain the following id168 to minimize:

li(  i) = e  s,  a[(yi     q(  s,   a;   i))2]

(3)
where yi = e  s,  a[r +    maxa(cid:48) q(s(cid:48), a(cid:48);   i   1) |   s,   a]
is the target q-value with parameters   i   1    xed
from the previous iteration.
formed using the following gradient of li(  i):
     ili(  i) = e  s,  a[2(yi     q(  s,   a;   i))     iq(  s,   a;   i)]

the updates on the parameters    can be per-

for each epoch of training, the agent plays several
episodes of the game, which is restarted after ev-
ery terminal state.

4the memory is limited and rewritten in a    rst-in-   rst-out

(fifo) fashion.

initialize game and get start state description s1
for t = 1, t do

algorithm 1 training procedure for id25 with prioritized sampling
1: initialize experience memory d
2: initialize parameters of representation generator (  r) and action scorer (  a) randomly
3: for episode = 1, m do
4:
5:
6:
7:
8:
9:
10:
11:

convert st (text) to representation vst using   r
if random() <   then

compute q(st, a) for all actions using   a(vst)
select at = argmax q(st, a)

select a random action at

else

12:
13:
14:
15:

16:

17:

execute action at and observe reward rt and new state st+1
set priority pt = 1 if rt > 0, else pt = 0
store transition (st, at, rt, st+1, pt) in d
sample random mini batch of transitions (sj, aj, rj, sj+1, pj) from d,
with fraction    having pj = 1
set yj =
perform id119 step on the loss l(  ) = (yj     q(sj, aj;   ))2

rj +    maxa(cid:48) q(sj+1, a(cid:48);   )

if sj+1 is non-terminal

if sj+1 is terminal

(cid:26) rj

mini-batch sampling in practice, online up-
dates to the parameters    are performed over a
mini batch of state transitions, instead of a single
transition. this increases the number of experi-
ences used per step and is also more ef   cient due
to optimized matrix operations.
the simplest method to create these mini-
batches from the experience memory d is to sam-
ple uniformly at random. however, certain ex-
periences are more valuable than others for the
agent to learn from. for instance, rare transitions
that provide positive rewards can be used more of-
ten to learn optimal q-values faster.
in our ex-
periments, we consider such positive-reward tran-
sitions to have higher priority and keep track of
them in d. we use prioritized sampling (inspired
by moore and atkeson (1993)) to sample a frac-
tion    of transitions from the higher priority pool
and a fraction 1        from the rest.

5 experimental setup

game environment for our game environ-
ment, we modify evennia,5 an open-source library
for building online textual mud games. evennia
is a python-based framework that allows one to
easily create new games by writing a batch    le
describing the environment with details of rooms,

5http://www.evennia.com/

stats

home world fantasy world

vocabulary size

avg. words / description
max descriptions / room
# diff. quest descriptions

state transitions

# states (underlying)

branching factor

(# commands / state)

84
10.5

3
12

deterministic

16

40

1340
65.21
100
-
    56

stochastic

222

table 1: various statistics of the two game worlds

objects and actions.
the game engine keeps
track of the game state internally, presenting tex-
tual descriptions to the player and receiving text
commands from the player. we conduct exper-
iments on two worlds - a smaller home world
we created ourselves, and a larger, more com-
plex fantasy world created by evennia   s develop-
ers. the motivation behind home world is to ab-
stract away high-level planning and focus on the
language understanding requirements of the game.
table 1 provides statistics of the game worlds.
we observe that the fantasy world is moderately
sized with a vocabulary of 1340 words and up to
100 different descriptions for a room. these de-
scriptions were created manually by the game de-
velopers. these diverse, engaging descriptions are
designed to make it interesting and exciting for hu-
man players. several rooms have many alternative
descriptions, invoked randomly on each visit by

the player.

comparatively, the home world is smaller:

it
has a very restricted vocabulary of 84 words and
the room descriptions are relatively structured.
however, both the room descriptions (which are
also varied and randomly provided to the agent)
and the quest descriptions were adversarially cre-
ated with negation and conjunction of facts to
force an agent to actually understand the state in
order to play well. therefore, this domain pro-
vides an interesting challenge for language under-
standing.

in both worlds, the agent receives a positive
reward on completing a quest, and negative re-
wards for getting into bad situations like falling
off a bridge, or losing a battle. we also add
small deterministic negative rewards for each non-
terminating step. this incentivizes the agent to
learn policies that solve quests in fewer steps. the
supplementary material has details on the reward
structure.

home world we created home world to mimic
the environment of a typical house.6 the world
consists of four rooms - a living room, a bedroom,
a kitchen and a garden with connecting pathways.
every room is reachable from every other room.
each room contains a representative object that the
agent can interact with. for instance, the kitchen
has an apple that the player can eat. transitions
between the rooms are deterministic. at the start
of each game episode, the player is placed in a ran-
dom room and provided with a randomly selected
quest. the text provided to the player contains
both the description of her current state and that
of the quest. thus, the player can begin in one
of 16 different states (4 rooms    4 quests), which
adds to the world   s complexity.

an example of a quest given to the player in
text is not you are sleepy now but you are hun-
gry now. to complete this quest and obtain a re-
ward, the player has to navigate through the house
to reach the kitchen and eat the apple (i.e type in
the command eat apple). more importantly, the
player should interpret that the quest does not re-
quire her to take a nap in the bedroom. we cre-
ated such misguiding quests to make it hard for
agents to succeed without having an adequate level
of language understanding.

6an illustration is provided in the supplementary material.

fantasy world the fantasy world is consider-
ably more complex and involves quests such as
navigating through a broken bridge or    nding the
secret tomb of an ancient hero. this game also has
stochastic transitions in addition to varying state
descriptions provided to the player. for instance,
there is a possibility of the player falling from the
bridge if she lingers too long on it.

due to the large command space in this game,7
we make use of cues provided by the game itself to
narrow down the set of possible objects to consider
in each state. for instance, in the mud example in
figure 1, the game provides a list of possible exits.
if the game does not provide such clues for the
current state, we consider all objects in the game.

evaluation we use two metrics for measuring
an agent   s performance: (1) the cumulative reward
obtained per episode averaged over the episodes
and (2) the fraction of quests completed by the
agent. the evaluation procedure is as follows. in
each epoch, we    rst train the agent on m episodes
of t steps each. at the end of this training, we
have a testing phase of running m episodes of the
game for t steps. we use m = 50, t = 20 for the
home world and m = 20, t = 250 for the fan-
tasy world. for all evaluation episodes, we run the
agent following an  -greedy policy with   = 0.05,
which makes the agent choose the best action ac-
cording to its q-values 95% of the time. we report
the agent   s performance at each epoch.

baselines we compare our lstm-id25 model
with three baselines. the    rst is a random agent
that chooses both actions and objects uniformly at
random from all available choices.8 the other two
are bow-id25 and bi-id25, which use a bag-
of-words and a bag-of-bigrams representation of
the text, respectively, as input to the id25 action
scorer. these baselines serve to illustrate the im-
portance of having a good representation layer for
the task.
settings for our id25 models, we used d =
100000,    = 0.5. we use a learning rate of 0.0005
for rmsprop. we anneal the   for  -greedy from
1 to 0.2 over 100000 transitions. a mini-batch
gradient update is performed every 4 steps of the
gameplay. we roll out the lstm (over words) for

7we consider 222 possible command combinations of 6

actions and 37 object arguments.

8in the case of the fantasy world, the object choices are

narrowed down using game clues as described earlier.

reward (home)

quest completion (home)

id21 (home)

reward (fantasy)

quest completion (fantasy)

prioritized sampling (home)

figure 3: left: graphs showing the evolution of average reward and quest completion rate for bow-
id25, lstm-id25 and a random baseline on the home world (top) and fantasy world (bottom). note
that the reward is shown in log scale for the fantasy world. right: graphs showing effects of transfer
learning and prioritized sampling on the home world.

a maximum of 30 steps on the home world and for
100 steps on the fantasy world. for the prioritized
sampling, we used    = 0.25 for both worlds. we
employed a mini-batch size of 64 and word em-
bedding size d = 20 in all experiments.

6 results
home world figure 3 illustrates the perfor-
mance of lstm-id25 compared to the baselines.
we can observe that the random baseline per-
forms quite poorly, completing only around 10%
of quests on average9 obtaining a low reward of
around    1.58. the bow-id25 model performs
signi   cantly better and is able to complete around
46% of the quests, with an average reward of 0.20.
the improvement in reward is due to both greater
quest success rate and a lower rate of issuing in-
valid commands (e.g. eat apple would be invalid
in the bedroom since there is no apple). we no-
tice that both the reward and quest completion
graphs of this model are volatile. this is because
the model fails to pick out differences between
quests like not you are hungry now but you are
sleepy now and not you are sleepy now but you

9averaged over the last 10 epochs.

are hungry now. the bi-id25 model suffers from
the same issue although it performs slightly bet-
ter than bow-id25 by completing 48% of quests.
in contrast, the lstm-id25 model does not suf-
fer from this issue and is able to complete 100%
of the quests after around 50 epochs of training,
achieving close to the optimal reward possible.10
this demonstrates that having an expressive rep-
resentation for text is crucial to understanding the
game states and choosing intelligent actions.

in addition, we also investigated the impact of
using a deep neural network for modeling the ac-
tion scorer   a. figure 4 illustrates the perfor-
mance of the bow-id25 and bi-id25 models
along with their simpler versions bow-lin and
bi-lin, which use a single linear layer for   a. it
can be seen that the id25 models clearly achieve
better performance than their linear counterparts,
which points to them modeling the control policy
better.

fantasy world we evaluate all the models on
the fantasy world in the same manner as before
and report reward, quest completion rates and q-
10note that since each step incurs a penalty of    0.01, the

best reward (on average) a player can get is around 0.98.

020406080100epochs2.01.51.00.50.00.51.0rewardlstm-id25bi-id25bow-id25random020406080100epochs0.00.20.40.60.81.01.2quest completionlstm-id25bi-id25bow-id25random01020304050epochs1.51.00.50.00.51.0rewardno transfertransfer010203040506070epochs5.55.04.54.03.53.02.52.01.5reward (log scale)lstm-id25bi-id25bow-id25random010203040506070epochs0.00.20.40.60.81.01.2quest completionlstm-id25bi-id25bow-id25random020406080100epochs2.01.51.00.50.00.51.0rewarduniformprioritizedfigure 4: quest completion rates of id25 vs. lin-
ear models on home world.

values. the quest we evaluate on involves crossing
the broken bridge (which takes a minimum of    ve
steps), with the possibility of falling off at random
(a 5% chance) when the player is on the bridge.
the game has an additional quest of reaching a
secret tomb. however, this is a complex quest that
requires the player to memorize game events and
perform high-level planning which are beyond the
scope of this current work. therefore, we focus
only on the    rst quest.

from figure 3 (bottom), we can see that the
random baseline does poorly in terms of both av-
erage per-episode reward11 and quest completion
rates. bow-id25 converges to a much higher av-
erage reward of    12.68 and achieves around 82%
quest completion. again, the bow-id25 is often
confused by varying (10 different) descriptions of
the portions of the bridge, which re   ects in its er-
ratic performance on the quest. the bi-id25 per-
forms very well on quest completion by    nishing
97% of quests. however, this model tends to    nd
sub-optimal solutions and gets an average reward
of    26.68, even worse than bow-id25. one rea-
son for this is the negative rewards the agent ob-
tains after falling off the bridge. the lstm-id25
model again performs best, achieving an average
reward of    11.33 and completing 96% of quests
on average. though this world does not con-
tain descriptions adversarial to bow-id25 or bi-
id25, the lstm-id25 obtains higher average re-
ward by completing the quest in fewer steps and
showing more resilience to variations in the state
descriptions.
id21 we would like the represen-
tations learnt by   r to be generic enough and

11note that the rewards graph is in log scale.

figure 5: id167 visualization of the word embed-
dings (except stopwords) after training on home
world. the embedding values are initialized ran-
domly.

transferable to new game worlds. to test this,
we created a second home world with the same
rooms, but a completely different map, changing
the locations of the rooms and the pathways be-
tween them. the main differentiating factor of
this world from the original home world lies in the
high-level planning required to complete quests.

we initialized the lstm part of an lstm-
id25 agent with parameters   r learnt from the
original home world and trained it on the new
world.12 figure 3 (top right) demonstrates that
the agent with transferred parameters is able to
learn quicker than an agent starting from scratch
initialized with random parameters (no transfer),
reaching the optimal policy almost 20 epochs ear-
lier. this indicates that these simulated worlds can
be used to learn good representations for language
that transfer across worlds.

prioritized sampling we also investigate the ef-
fects of different minibatch sampling procedures
on the parameter learning. from figure 3 (bottom
right), we observe that using prioritized sampling
signi   cantly speeds up learning, with the agent
achieving the optimal policy around 50 epochs
faster than using uniform sampling. this shows
promise for further research into different schemes
of assigning priority to transitions.

representation analysis we analyzed the rep-
resentations learnt by the lstm-id25 model on
the home world. figure 5 shows a visualization

12the parameters for the action scorer (  a) are initialized

randomly.

0102030405060epochs0.10.20.30.40.50.60.7quest completionbi-id25bow-id25bi-linbow-lin   kitchen      living room      bedroom      garden   description
you are halfways out on the unstable bridge. from the castle
you hear a distant howling sound, like that of a large dog or
other beast.
the ruins opens up to the sky in a small open area, lined by
columns.
... to the west is the gatehouse and entrance to the
castle, whereas southwards the columns make way for a wide
open courtyard.

nearest neighbor
the bridge slopes precariously where it extends westwards to-
wards the lowest point - the center point of the hang bridge. you
clasp the ropes    rmly as the bridge sways and creaks under you.
the old gatehouse is near collapse. .... east the gatehouse leads
out to a small open area surrounded by the remains of the cas-
tle. there is also a standing archway offering passage to a path
along the old southern inner wall.

table 2: sample descriptions from the fantasy world and their nearest neighbors (nn) according to their
vector representations from the lstm representation generator. the nns are often descriptions of the
same or similar (nearby) states in the game.

of learnt id27s, reduced to two di-
mensions using id167 (van der maaten and hin-
ton, 2008). all the vectors were initialized ran-
domly before training. we can see that semanti-
cally similar words appear close together to form
coherent subspaces. in fact, we observe four dif-
ferent subspaces, each for one type of room along
with its corresponding object(s) and quest words.
for instance, food items like pizza and rooms like
kitchen are very close to the word hungry which
appears in a quest description. this shows that
the agent learns to form meaningful associations
between the semantics of the quest and the envi-
ronment. table 2 shows some examples of de-
scriptions from fantasy world and their nearest
neighbors using cosine similarity between their
corresponding vector representations produced by
lstm-id25. the model is able to correlate de-
scriptions of the same (or similar) underlying
states and project them onto nearby points in the
representation subspace.

7 conclusions

we address the task of end-to-end learning of con-
trol policies for text-based games. in these games,
all interactions in the virtual world are through
text and the underlying state is not observed. the
resulting language variability makes such envi-
ronments challenging for automatic game play-
ers. we employ a deep id23
framework to jointly learn state representations
and action policies using game rewards as feed-
back. this framework enables us to map text de-
scriptions into vector representations that capture
the semantics of the game states. our experiments
demonstrate the importance of learning good rep-
resentations of text in order to play these games
well. future directions include tackling high-level

planning and strategy learning to improve the per-
formance of intelligent agents.

acknowledgements

we are grateful to the developers of evennia, the
game framework upon which this work is based.
we also thank nate kushman, clement gehring,
gustavo goretkin, members of mit   s nlp group
and the anonymous emnlp reviewers for insight-
ful comments and feedback. t. kulkarni was gra-
ciously supported by the leventhal fellowship.
we would also like to acknowledge mit   s cen-
ter for brains, minds and machines (cbmm) for
support.

references
[amato and shani2010] christopher amato and guy
shani. 2010. high-level id23 in
strategy games. in proceedings of the 9th interna-
tional conference on autonomous agents and multi-
agent systems: volume 1, pages 75   82. international
foundation for autonomous agents and multiagent
systems.

[amir and doyle2002] eyal amir and patrick doyle.
2002. adventure games: a challenge for cognitive
robotics. in proc. int. cognitive robotics workshop,
pages 148   155.

2015.

[andreas and klein2015] jacob andreas

and dan
klein.
alignment-based compositional
semantics for instruction following. in proceedings
of the conference on empirical methods in natural
language processing.

[artzi and zettlemoyer2013] yoav artzi

and luke
zettlemoyer. 2013. weakly supervised learning of
semantic parsers for mapping instructions to actions.
transactions of the association for computational
linguistics, 1(1):49   62.

[branavan et al.2010] srk branavan, luke s zettle-
moyer, and regina barzilay. 2010. reading be-

tween the lines: learning to map high-level instruc-
tions to commands. in proceedings of the 48th an-
nual meeting of the association for computational
linguistics, pages 1268   1277. association for com-
putational linguistics.

[branavan et al.2011a] srk branavan, david silver,
and regina barzilay. 2011a. learning to win by
reading manuals in a monte-carlo framework.
in
proceedings of the 49th annual meeting of the asso-
ciation for computational linguistics: human lan-
guage technologies-volume 1, pages 268   277. as-
sociation for computational linguistics.

[branavan et al.2011b] srk branavan, david silver,
non-linear
and regina barzilay.
monte-carlo search in civilization ii.
aaai
press/international joint conferences on arti   cial
intelligence.

2011b.

[curtis1992] pavel curtis. 1992. mudding: social phe-
nomena in text-based virtual realities. high noon
on the electronic frontier: conceptual issues in cy-
berspace, pages 347   374.

[depristo and zubek2001] mark a depristo
being-in-the-world.

and
2001.
in
the 2001 aaai spring sympo-
intelligence and interactive

robert zubek.
proceedings of
sium on arti   cial
entertainment, pages 31   34.

[eisenstein et al.2009] jacob eisenstein, james clarke,
dan goldwasser, and dan roth. 2009. reading
to learn: constructing features from semantic ab-
stracts. in proceedings of the conference on empiri-
cal methods in natural language processing, pages
958   967, singapore, august. association for com-
putational linguistics.

[gorniak and roy2005] peter gorniak and deb roy.
2005. speaking with your sidekick: understanding
situated speech in computer role playing games. in
r. michael young and john e. laird, editors, pro-
ceedings of the first arti   cial intelligence and inter-
active digital entertainment conference, june 1-5,
2005, marina del rey, california, usa, pages 57   
62. aaai press.

[hochreiter and schmidhuber1997] sepp hochreiter
and j  urgen schmidhuber. 1997. long short-term
memory. neural computation, 9(8):1735   1780.

[kollar et al.2010] thomas kollar, stefanie tellex, deb
2010. toward under-
roy, and nicholas roy.
in human-
standing natural language directions.
robot interaction (hri), 2010 5th acm/ieee inter-
national conference on, pages 259   266. ieee.

[koutn    k et al.2013] jan koutn    k, giuseppe cuccu,
j  urgen schmidhuber, and faustino gomez. 2013.
evolving large-scale neural networks for vision-
based id23. in proceedings of the
15th annual conference on genetic and evolutionary
computation, pages 1061   1068. acm.

[kushman et al.2014] nate kushman, yoav artzi, luke
zettlemoyer, and regina barzilay. 2014. learning
to automatically solve algebra word problems. acl
(1), pages 271   281.

[matuszek et al.2013] cynthia matuszek, evan herbst,
luke zettlemoyer, and dieter fox. 2013. learning
to parse natural language commands to a robot con-
trol system. in experimental robotics, pages 403   
415. springer.

[mikolov et al.2013] tomas mikolov, kai chen, greg
corrado, and jeffrey dean. 2013. ef   cient estima-
tion of word representations in vector space. arxiv
preprint arxiv:1301.3781.

[mnih et al.2015] volodymyr

mnih,

koray
kavukcuoglu, david silver, andrei a. rusu, joel
veness, marc g. bellemare, alex graves, martin
riedmiller, andreas k. fidjeland, georg ostrovski,
stig petersen, charles beattie, amir sadik, ioannis
antonoglou, helen king, dharshan kumaran, daan
wierstra, shane legg, and demis hassabis. 2015.
human-level control through deep reinforcement
learning. nature, 518(7540):529   533, 02.

[moore and atkeson1993] andrew w moore

and
christopher g atkeson. 1993. prioritized sweep-
ing: id23 with less data and less
time. machine learning, 13(1):103   130.

[pennington et al.2014] jeffrey pennington, richard
socher, and christopher d manning. 2014. glove:
global vectors for word representation. proceedings
of the empiricial methods in natural language pro-
cessing (emnlp 2014), 12.

[silver et al.2007] david silver, richard s sutton, and
martin m  uller. 2007. id23 of
local shape in the game of go. in ijcai, volume 7,
pages 1053   1058.

[sutskever et al.2014] ilya sutskever, oriol vinyals,
and quoc vv le. 2014. sequence to sequence
learning with neural networks. in advances in neu-
ral information processing systems, pages 3104   
3112.

[sutton and barto1998] richard s sutton and an-
drew g barto. 1998. introduction to reinforcement
learning. mit press.

[szita2012] istv  an szita. 2012. reinforcement learn-
in id23, pages

ing in games.
539   577. springer.

[tai et al.2015] kai sheng tai, richard socher, and
christopher d. manning. 2015. improved semantic
representations from tree-structured long short-term
memory networks. in proceedings of the 53rd an-
nual meeting of the association for computational
linguistics and the 7th international joint confer-
ence on natural language processing (volume 1:
long papers), pages 1556   1566, beijing, china,
july. association for computational linguistics.

[tieleman and hinton2012] tijmen tieleman and ge-
offrey hinton. 2012. lecture 6.5-rmsprop: divide
the gradient by a running average of its recent mag-
nitude. coursera: neural networks for machine
learning, 4.

[van der maaten and hinton2008] laurens van

der
maaten and geoffrey hinton. 2008. visualizing
journal of machine learning
data using id167.
research, 9(2579-2605):85.

[vogel and jurafsky2010] adam vogel and dan juraf-
sky. 2010. learning to follow navigational direc-
in proceedings of the 48th annual meeting
tions.
of the association for computational linguistics,
pages 806   814. association for computational lin-
guistics.

[watkins and dayan1992] christopher

jch watkins
and peter dayan. 1992. id24. machine learn-
ing, 8(3-4):279   292.

