5
1
0
2

 

g
u
a
0
1

 

 
 
]
l
c
.
s
c
[
 
 

1
v
1
3
1
2
0

.

8
0
5
1
:
v
i
x
r
a

learning structural kernels for natural language processing

daniel beck

department of computer science

university of shef   eld, united kingdom

trevor cohn

computing and information systems
university of melbourne, australia

debeck1@sheffield.ac.uk

t.cohn@unimelb.edu.au

christian hardmeier

lucia specia

department of linguistics and philology

department of computer science

uppsala university, sweden

university of shef   eld, united kingdom

christian.hardmeier@lingfil.uu.se

l.specia@sheffield.ac.uk

abstract

structural kernels are a    exible learning
paradigm that has been widely used in natural
language processing. however, the problem
of model selection in kernel-based methods
is usually overlooked. previous approaches
mostly rely on setting default values for ker-
nel hyperparameters or using grid search,
which is slow and coarse-grained.
in con-
trast, bayesian methods allow ef   cient model
selection by maximizing the evidence on the
training data through gradient-based methods.
in this paper we show how to perform this
in the context of structural kernels by using
gaussian processes. experimental results on
tree kernels show that this procedure results
in better prediction performance compared to
hyperparameter optimization via grid search.
the framework proposed in this paper can be
adapted to other structures besides trees, e.g.,
strings and graphs, thereby extending the util-
ity of kernel-based methods.

introduction

1
kernel-based methods are a staple machine learning
approach in natural language processing (nlp).
frequentist kernel methods like the support vector
machine (id166) pushed the state of the art in many
nlp tasks, especially classi   cation and regression.
one interesting aspect of kernels is their ability to
be de   ned directly on structured objects like strings,
trees and graphs. this approach has the potential to
move the modelling effort from feature engineering
to kernel engineering. this is useful when we do
not have much prior knowledge about how the data

behaves, as we can more readily de   ne a similarity
metric between inputs instead of trying to character-
ize which features are the best for the task at hand.
kernels are a very    exible framework: they can
be combined and parameterized in many different
ways. complex kernels, however, lead to the prob-
lem of model selection, where the aim is to obtain
the best kernel con   guration in terms of hyperpa-
rameter values. the usual approach for model selec-
tion in frequentist methods is to employ grid search
on some development data disjoint from the training
data. this approach can rapidly become impracti-
cal when using complex kernels which increase the
number of model hyperparameters. grid search also
requires the user to explicitly set the grid values,
making it dif   cult to    ne tune the hyperparameters.
recent advances in model selection tackle some of
these issues, but have several limitations (see   6 for
details).

our proposed approach for model selection re-
lies on gaussian processes (gps) (rasmussen and
williams, 2006), a widely used bayesian kernel ma-
chine. gps allow ef   cient and    ne-grained model
selection by maximizing the evidence on the training
data using gradient-based methods, dropping the re-
quirement for development data. as a bayesian pro-
cedure, gps also naturally balance between model
capacity and generalization. gps have been shown
to achieve state of the art performance in various re-
gression tasks (hensman et al., 2013; cohn and spe-
cia, 2013). therefore, we base our approach on this
framework.

while prediction performance is important

to
consider (as we show in our experiments), we are

mainly interested in two other signi   cant aspects
that are enabled by our approach:

    gradient-based methods are more ef   cient than
grid search for high dimensional spaces. this
allows us to easily propose new rich kernel ex-
tensions that rely on a large number of hyper-
parameters, which in turn can result in better
modelling capacity.

    since the model selection process is now    ne-
grained, we can interpret the resulting hyperpa-
rameter values, depending on how the kernel is
de   ned.

in this work we focus on tree kernels, which have
been successfully used in a number of nlp tasks
(see   6). in most cases, these kernels are used as an
id166 component and model selection is not consid-
ered an important issue. hyperparameters are usu-
ally set to default values, which work reasonably
well in terms of prediction performance. however,
this is only possible due to the small number of hy-
perparameters these kernels contain.
we perform experiments comprising synthetic
data (  4) and two real nlp regression tasks: emo-
tion analysis (  5.1) and translation quality estima-
tion (  5.2). our    ndings show that our approach out-
performs id166s using the same kernels.

(2006).

2 gaussian process regression
our de   nition of gps closely follows that of
rasmussen and williams
consider
a setting where we have a dataset x =
{(x1, y1), (x2, y2), . . . , (xn, yn)}, where xi is a d-
dimensional input and yi the corresponding out-
put. our goal is to infer an underlying function
f : rd     r to explain this data, i.e. f (xi)     yi.
formally, f is drawn from a gp prior,

f (x)     gp(  (x), k(x, x(cid:48))),

where   (x) is the mean function, which is usually
the 0 constant, and k(x, x(cid:48)) is the id81.
in a regression setting, we assume that the res-
ponse variables are noisy latent function evaluations,
i.e., yi = f (xi) +   , where        n (0,   2
n) is
added white noise. we assume a gaussian likeli-
hood, which allows us to obtain a closed formula

solution for the posterior, namely
y        n (k   (k +   ni)   1yt ,

k(x   , x   )     kt    (k +   ni)   1k   ),

where x    and y    are respectively the test input
and its response variable, k is the gram matrix
corresponding to the training inputs and k    =
[(cid:104)x1, x   (cid:105),(cid:104)x2, x   (cid:105), . . . ,(cid:104)xn, x   (cid:105)]
is the vector of
kernel evaluations between the test input and each
training input.

a key property of gp models is their ability to
perform ef   cient model selection. this is achieved
by employing gradient-based methods to maximize
the marginal likelihood,

p(y|x,   ) =

p(y|x,   , f )p(f )df,

(cid:90)

where    represents the vector of model hyperparam-
eters and y is the vector of response variables from
the training data. for a gaussian likelihood, we can
take the log of the expression above to obtain in
closed-form1,

log p(y|x,   ) =
yt g   1y

    1
2

(cid:124)

(cid:123)(cid:122)

data    t

(cid:125)

log |g|

    1
2

(cid:124)

(cid:123)(cid:122)

(cid:125)

complexity penalty

log 2  

(cid:124)

(cid:123)(cid:122)

    n
2
constant

(cid:125)

where g = k +   ni. the data    t term is dependent
on the training response variables, while the com-
plexity penalty term relies only on the kernel and
training inputs. since the    rst two terms have con-
   icting objectives, optimizing the log marginal like-
lihood will naturally achieve a compromise and thus
limit over   tting (without the need for any validation
step or additional data).

to enable gradient-based optimization we need to

derive the gradients w.r.t. the hyperparameters:

log p(y|x,   ) =

   
     j

yt g   1    g
     j

g   1y

(cid:18)

1
2
    1
2

trace

g   1    g
     j

(cid:19)

.

1see rasmussen and williams (2006, pp. 113-114) for de-
tails on the derivation of this formula and also its correspondent
gradient calculation.

the gradients of g depend on the underlying ker-
nel. therefore we can employ any kind of valid
kernel in this procedure as long as its gradients can
be computed. this not only allows for    ne-tuning
of hyperparameters but also allows for kernel exten-
sions which are richly parameterized.

3 tree kernels
the seminal work on convolution kernels by haus-
sler (1999) de   nes a broad class of kernels on dis-
crete structures by counting and weighting the num-
ber of substructures they share. applying haussler   s
formulation to trees we reach a general formula for
a tree kernel between two trees t1 and t2, namely

k(t1, t2) =

w(f )c1(f )c2(f ),

(1)

(cid:88)

f   f

where f is the set of all tree fragments, c1(f ) and
c2(f ) return the counts for fragment f in trees t1 and
t2, respectively, and w(f ) assigns a weight to frag-
ment f. in other words, we can consider the ker-
nel a weighted dot product over vectors of fragment
counts. the actual fragment set f is deliberately
left unde   ned: different concepts of tree fragments
de   ne different tree kernels.

in this paper, we will focus on subset tree ker-
nels (henceforth sstk),    rst introduced by collins
and duffy (2001). this kernel considers tree frag-
ments that contains complete grammar rules (see
figure 1 for an example). consider the set of nodes
in the two trees as n1 and n2 respectively. we de-
   ne ii(n) as an indicator function that returns 1 if
fragment fi     f has root n and 0 otherwise. a
sstk can then be de   ned as:

k(t1, t2) =

   (n1, n2) ,

(2)

(cid:88)

(cid:88)
|f|(cid:88)

n1   n1

n2   n2

where    (n1, n2) =

s(i)

2 ii(n1)ii(n2)

  

i=1

and s(i) is the number of fragments in i with at least
one child2.

the formulation in equation 2 is the same as the
one shown in equation 1, except that we are now
restricting the weights w(f ) to be a function of a

2see pighin and moschitti (2010) for details and a proof on

this derivation.

tree

s

fragments

a

b

s

s

s

s

a

b

a

b

ba

ba

a

b

a

b

a

b

a

b

a

b

figure 1: an example tree and the respective set of tree
fragments de   ned by a sstk.

hyperparameter   . the original goal of    is to act
as a decay factor that penalizes contributions from
larger fragments cf smaller ones (and therefore, it
should be in the [0, 1] interval). without this factor,
the resulting distribution over tree pairs is skewed,
giving extremely large values when trees are equal
and rapidly decreasing for small differences over
fragment counts. the decay factor helps to spread
this distribution, effectively giving smaller weights
to larger fragments.

the function     can be de   ned recursively,

                                 

0
  

pr(n1) (cid:54)= pr(n2)
pr(n1) = pr(n2)    
preterm(n1)

  g(n1, n2) otherwise,

   (n1, n2) =

where pr(n) is the grammar production at node n
and preterm(n) returns true if n is a pre-terminal
node. the function g is de   ned as follows:

g(n1, n2) =

(   +    (ci

n1, ci

n2)) ,

(3)

i=1

where |n| is the number of children of node n and
n is the ith child of node n. this recursive de   ni-
ci
tion is calculated ef   ciently by employing dynamic
programming to cache intermediate     results.

equation 3 also adds another hyperparameter,   .
this hyperparameter was introduced by moschitti
(2006b)3 as a way to select between two differ-
ent tree kernels.
if    = 1, we get the original
sstk, if    = 0, then we obtain the subtree kernel,
which only allows fragments with terminal symbols

3in his original formulation, this hyperparameter was named
   but here we use    to not confuse it with the gp noise hyper-
parameter.

|n1|(cid:89)

as leaves. we can also interpret the subtree kernel
as a    sparse    version of the sstk, where the    non-
subtree    fragments have their weights equal to zero.
even though fragment weights are affected by
both kernel hyperparameters, previous work did not
discuss their effects. the usual procedure    xes    to
1 (selecting the original sstk) and sets    to a de-
fault value (around 0.4). as explained in   2, the gp
model selection procedure enables us to learn    ne-
grained values for these hyperparameters, which can
lead to better performing models and aid interpreta-
tion. furthermore, it also allows us to extend these
kernels by adding new hyperparameters. we pro-
pose one such kernel in the next section.

3.1 symbol-aware subset tree kernel
while varying the sstk hyperparameters can lead
to different weight schemes, they do that in a very
coarse way. for some applications, it may be nec-
essary to give more weight to speci   c fragments
or set of fragments (e.g., nps being more impor-
tant than advp in an information extraction set-
ting). the symbol-aware subset tree kernel (hence-
forth, sasstk), which we introduce here, allows a
more    ne-grained control over the weights by em-
ploying one    and one    hyperparameter for each
non-terminal symbol in the training data. the calcu-
lation uses a similar recursive formula to the sstk,
namely:

pr(n1) (cid:54)= pr(n2)
pr(n1) = pr(n2)    
preterm(n1)

   (n1, n2) =

  xgx(n1, n2) otherwise,

where x is the symbol at node n1 and

                                 

0
  x

|n1|(cid:89)

gx(n1, n2) =

(  x +    (ci

n1, ci

n2)) .

(4)

i=1

the sasstk can be interpreted as a generaliza-
tion of the sstk: we can recover the latter by tying
all    and setting all    = 1. by employing different
hyperparameter values for each speci   c symbol, we
can effectively modify the weights of all fragments
where the symbol appears. table 1 shows an exam-
ple where we unrolled a kernel computation into its
corresponding feature space, showing the resulting
weighted counts for each feature.

  s = 1
  a = 1
  b = 1
1
1
1
1
1
1
6

  s = .5
  a = 1
  b = 1
1
1
0.5
0.5
0.5
0.5
3

  s = 2
  a = 1
  b = 1
1
1
2
2
2
2
18

a     a
b     b
s     a b
s     (a a) b
s     a (b b)
s     (a a) (b b)
k(t, t)

table 1: resulting fragment weighted counts for the ker-
nel evaluation k(t, t), for different values of hyperparam-
eters, where t is the tree in figure 1.

3.2 kernel gradients
to enable hyperparameter optimization via gradient
descent we must provide gradients for the kernels.
in this section we derive the gradients for sasstk.
from equation 2 we know that the kernel is a dou-
ble summation over the     function. therefore all
gradients are also double summations, but over the
gradients of    . we can obtain these in a vectorized
way, by considering the gradients of the hyperpa-
rameter vectors    and    over    . let k be the num-
ber of symbols considered in the model and    and
   be k-dimensional vectors containing the respec-
tive hyperparameters.

n1, ci

in the following, we use the notation    i as a
n2) and we also omit the pa-

shorthand for    (ci
rameters of gx. we start with the    gradient:
pr(n1) (cid:54)= pr(n2)
pr(n1) = pr(n2)    
preterm(n1)
otherwise,

                                       

   (  xgx)

      
     

0
u

=

     

where x is the symbol at n1, gx is de   ned in equa-
tion 4 and u is the k-dimensional unit vector with
the element corresponding to symbol x equal to 1
and all others equal to 0. the gradient in the third
case is de   ned recursively,

   (  xgx)

     

= ugx +   x

= ugx +   x

   gx
     

|n1|(cid:88)

i=1

gx

  x +    i

      i
     

.

the    gradient is derived in a similar way,

                     

0

      
     

=

   (  xgx)

     

pr(n1) (cid:54)= pr(n2)    
preterm(n1)
otherwise,

and the gradient at the second case is also de   ned
recursively,

   (  xgx)

     

=   x

=   x

   gx
     

|n1|(cid:88)

i=1

(cid:18)

u +

(cid:19)

.

      i
     

gx

  x +    i

gradients can be ef   ciently obtained using dy-
namic programming. in fact, they can be calculated
at the same time as     to improve performance since
they all share many terms in their derivations. fi-
nally, we can easily obtain the gradients for the orig-
inal sstk by letting u = 1.

3.3 kernel id172
it is common practice when using tree kernels to nor-
malize the kernel. this helps reduce the random ef-
fect of tree size. id172 can be achieved us-
ing the following, where   k is the normalized kernel:

  k(t1, t2) =

(cid:112)k(t1, t1)k(t2, t2)

k(t1, t2)

.

to apply this normalized version in the optimiza-
tion procedure we must also derive gradients for the
id172 function. in the following equation,
we use kij and   kij as a shorthand for k(ti, tj) and
  k(ti, tj), respectively:

     k12
     

=

   k12
        
k11k22

   k11
     

      k12

k22 + k11

2k11k22

   k22
     

.

3.4 other extensions
many other structural kernels rely on recursive def-
initions and id145 to perform their
calculations. examples include other tree kernels
like the partial tree kernel (moschitti, 2006a) and
string kernels like the ones de   ned on character n-
grams (lodhi et al., 2002) or word sequences (can-
cedda et al., 2003). while in this paper we focus

on the sstk (and our proposed sasstk), our ap-
proach can easily be extended to these other kernels,
as long as all the corresponding recursive de   nitions
are differentiable.

4 synthetic data experiments

a natural question that arises in the proposed
method is how much data is needed to accurately
learn the kernel hyperparameters. to answer this
question, we run a set of experiments using synthetic
data. we generate this data by using a set of 1000
natural language syntactic trees, where we    x a ran-
dom subset of 200 instances for testing and use the
remaining 800 instances as training. for each train-
ing set size we de   ne a gp over the full dataset, sam-
ple a function from it and use the function output as
the response variable for each tree. we try two dif-
ferent gp priors, one using the sstk and another
one using the sasstk.

the conditions above provide a controlled envi-
ronment to check the modelling capacities of our ap-
proach since we know the exact distribution where
the data comes from. the reasoning behind these
experiments is that to be able to provide bene   ts in
real tasks, where the data distribution is not known,
our models have to be learnable in this controlled
setting as well using a reasonable amount of data.

finally, we also provide an empirical evaluation
comparing the speed performance between our ap-
proach and grid search.

4.1 sstk prior
our    rst experiments use a sstk as the kernel with
   = 0.001,    = 1 and   2
n = 0.01. after obtaining
the input trees and their sampled labels, we de   ne a
new gp model using only the training data plus the
obtained response variables, this time using a sstk
with randomized hyperparameter values. then we
optimize the gp and check if the learned hyperpa-
rameters are close to the original ones, using 10 ran-
dom restarts to limit the effect of local optima. we
also use the optimized gp to predict response vari-
ables on the test set and measure root mean squared
error (rmse). our hypothesis is that with a reason-
able sample size we can retrieve the original hyper-
parameter values and obtain low rmse. for each
training set size, we repeat the experiment 20 times.

figure 2 shows the results of these experiments.
for small sizes the variance in the resulting hyperpa-
rameter values is large but as soon as we reach 200
instances we are able to retrieve the original values
with high con   dence. in other words, in an ideal set-
ting 200 instances are enough to learn the kernel. it
is also interesting to note that test rmse after opti-
mization steadily decreases as we increase training
data size. this shows that if one is more interested
in predictions themselves, it is still worth optimizing
hyperparameters even if the training data is small.

4.2 sasstk prior

the large number of hyperparameters of
the
sasstk makes it more prone to optimization and
over   tting issues when compared to the sstk. this
raises the question of how much data is needed to
justify its use. to address this question, we run sim-
ilar experiments to those above for the sstk, except
that now we sample from a gp using a sasstk as
the kernel.

instead of optimizing all hyperparameters freely
we use a simpler version where we tie    and    for
each symbol to the same value, except for the sym-
bol    s   . effectively this version has one extra    and
one extra    (henceforth   s and   s) when compared
to the sstk. the gp prior hyperparameter values
are set to    = 0.001,   s = 0.5,    = 0.1,   s = 1
and   2
n = 0.01. for each training set size, we train
two gps, one using this sasstk and one using
the original sstk, optimize them using 10 random
restarts and measure rmse on the test set.

results are shown in figure 3. for all training set
sizes the sasstk reaches lower rmse than sstk,
with a substantial difference after reaching 100 in-
stances. this shows that even for small datasets our
proposed kernel manages to capture aspects which
can not be explained by the original sstk. note that
this is an ideal setting, and real datasets may need to
be larger to realize gains from sasstk. neverthe-
less, these are promising results since they give evi-
dence of a small lower bound on the dataset size for
sasstk to be effective.

figure 2: results of synthetic experiments optimizing
sstk. the x axes correspond to different training set
sizes and the the y axes are the obtained hyperparame-
ter values in the    rst three plots and rmse in the last
plot. dashed lines show the original hyperparameter val-
ues. points are offset in rmse chart for legibility.

figure 3: results from synthetic experiments comparing
sstk and sasstk. the x axis is training set size while
the y axis corresponds to rmse.

4.3 performance experiments
to provide an overview of how ef   cient is the
gradient-based method compared to grid search we
also run a set of experiments measuring wall clock
training time vs. rmse on a test set. for both gp
and id166 models we employ the sstk as the kernel
and we use the same synthetic data from the previ-
ous experiments4. we perform 20 runs, keeping the
test set as the same 200 instances for all runs and
randomly sampling 200 instances from the remain-
ing instances as training data.

figure 4 shows the curves for both gp and id166
models. the gp curve is obtained by increasing the
maximum number of iterations of the gradient-based
method (in this case, l-bfgs) and the id166 curve
is obtained by increasing the granularity of the grid
size.

figure 4: results from performance experiments. the x
axis corresponds to wall clock time in seconds and it is in
log scale. the y axis shows rmse on the test set. the
blue dashed line corresponds to the rmse value obtained
after l-bfgs converged. error bars are obtained by mea-
suring one standard deviation over the 20 runs made in
each experiment.

we can see that optimizing the gp model is con-
sistently much faster than doing grid search on the
id166 model (notice the logarithmic scale), even
though it shows some variance when letting l-bfgs
run for a larger number of iterations. the gp model
also is able to better predictions in general. even
when taking the variances into account, grid search
would still need around 10 times more computation

4for speci   c details on the id166 models used in all experi-
ments performed in this paper we refer the reader to appendix
a.

time to achieve the same predictions obtained by the
gp model. in real settings, id166s predictions tend
to be more on par with the ones provided by a gp
(as shown in   5) but nevertheless these    gures show
that the gp can be much more time ef   cient when
optimizing hyperparameters of a tree kernel.

an important performance aspect to take into ac-
count is parallelization. grid search is embarass-
ingly parallelizable since each grid point can run in
a different core. however, the gp optimization can
also bene   t from multiple cores by running each ker-
nel computation inside the gram matrix in parallel.
to keep the comparisons simpler, the results shown
in this section use a single core but all experiments in
  5 employ parallelization in the gram matrix com-
putation level (for both id166 and gp models).

5 nlp experiments

our experiments with nlp data address two regres-
sion tasks: emotion analysis and quality estima-
tion. for both tasks, we use the stanford parser
(manning et al., 2014) to obtain constituency trees
for all sentences. also, rather than using data of   cial
splits, we perform 5-fold cross-validation in order to
obtain more reliable results.

5.1 emotion analysis
the goal of emotion analysis is to automatically de-
tect emotions in a text (strapparava and mihalcea,
2008). this problem is closely related to opinion
mining (pang and lee, 2008), with similar appli-
cations, but it is usually done at a more    ne-grained
level and involves the prediction of a set of labels for
each text (one for each emotion) instead of a single
label.

beck et al. (2014a) used a multi-task gp for this
task with a bag-of-words feature representation. in
theory, it is possible to combine their multi-task ker-
nel with our tree kernels, but to keep the focus of the
experiments on testing tree kernel approaches, here
we use independently trained models, one per emo-
tion.

dataset we use the dataset provided by the    af-
fective text    shared task in semeval2007 (strap-
parava and mihalcea, 2007), which is composed of
1000 news headlines annotated in terms of six emo-
tions: anger, disgust, fear, joy, sadness and sur-

prise. for each emotion, a score between 0 and 100
is given, 0 meaning total lack of emotion and 100,
maximally emotional. scores are mean-normalized
before training the models.

even though the optimized marginal likelihood was
higher. this is evidence that the sasstkfull model
is over   tting the training data, probably due to its
large number of hyperparameters.

models we perform experiments using the follow-
ing tree kernels:

    sstk: the sstk formulation introduced by

moschitti (2006b);

    sasstkfull:

sstk;

our proposed symbol-aware

    sasstks: same as before, but using only two
   and two    hyperparameters: one for sym-
bols corresponding to full sentences5 and an-
other for all other symbols. this con   guration
is similar to that in section 4.2.

for all kernels, we also use a variation    xing the   
hyperparameters to 1 to emulate the original sstk.

baselines and evaluation our results are com-
pared against three baselines:

    id166 sstk: a id166 using an sstk kernel.
    id166 bow: same as before, but using an rbf

kernel with a bag-of-words representation.

    gp bow: same as id166 bow but using a gp

instead.

the id166 models are trained using a wrapper for
libid1666 (chang and lin, 2001) provided by the
scikit-learn toolkit7 (pedregosa et al., 2011) and op-
timized via grid search. following previous work,
we use pearson   s correlation coef   cient as evalua-
tion metric. pearson   s scores are obtained by con-
catenating all six emotions outputs together.

table 2 shows the results. the best gp model
with tree kernels outperforms the id166s, showing
that the    ne-grained model selection procedure pro-
vided by the gp models is helpful when dealing with
tree kernels. however, using the sasstk models
do not help in the case of free    and the sasstkfull
actually performs worse than the original sstk,

5in this dataset, symbols are s, sq, sbarq and sin v .
6www.csie.ntu.edu.tw/  cjlin/libid166
7http://scikit-learn.org

id166 bow
id166 sstk
gp bow
(free   )
gp sstk
gp sasstkfull
gp sasstks
(   xed    = 1)
gp sstk
gp sasstkfull
gp sasstks

pearson   s
0.5690
0.5254
0.5891

0.5713
0.5118
0.5710

0.5093
0.5435
0.5225

table 2: pearson   s correlation scores for the emotion
analysis task (higher is better).

another interesting    nding in table 2 is that    x-
ing the    values often harms performance. inspect-
ing the free    models showed that the values found
by the optimizer were very close to zero. this in-
dicates that the model selection procedure prefer
towards giving smaller weights to incomplete tree
fragments. we can interpret this as the model se-
lecting a more lexicalized feature space, which also
explains why the gp rbf model on bag-of-words
performed the best in this task.

finally, to understand how the optimized kernels
could provide more interpretability, table 3 shows
the top 15    values obtained by the sasstkfull
(   xed    variant) with their corresponding symbols.
in this speci   c case the kernel does not give the best
performance so there are limitations in doing a full
linguistic analysis. nevertheless, we believe this ex-
ample shows the potential for developing more in-
terpretable kernels. this is especially interesting be-
cause these models take into account a much richer
feature space than what it is allowed by parametric
models.

5.2 quality estimation
the goal of quality estimation is to provide a qual-
ity prediction for new, unseen machine translated
texts (blatz et al., 2004; bojar et al., 2014). exam-

jjr
prp$
wdt
rbr
vbg

0.8333
0.6933
0.6578
0.5445
0.5163

whadvp
qp
jjs
nns
.

0.5004
0.5001
0.4996
0.4961
0.4777

vbp
whnp
nn
jj
sq

0.4653
0.4508
0.4274
0.4021
0.4000

table 3: top 15 symbols sorted according to their ob-
tained    values in the sasstkfull model with    xed   .
the numbers are the corresponding    values, averaged
over all six emotions.

ples of applications include    ltering machine trans-
lated sentences that would require more post-editing
effort than translation from scratch (specia et al.,
2009), selecting the best translation from different
mt systems (specia et al., 2010) or between an mt
system and a translation memory (he et al., 2010),
and highlighting segments that need revision (bach
et al., 2011). while various quality metrics exist,
here we focus on post-editing time prediction.

tree kernels have been used before in this task
(with id166s) by hardmeier (2011) and hardmeier
et al. (2012). while their best models combine tree
kernels with a set of explicit features, they also show
good results using only the tree kernels. this makes
quality estimation a good benchmark task to test
our models.

datasets we use two publicly available datasets
containing post-edited machine translated sentences.
both are composed of a set of source sentences, their
machine translated outputs and the corresponding
post-editing time.

    french-english (fr-en): this dataset, de-
scribed in (specia, 2011), contains 2524 french
sentences translated into english and post-
edited by a novice translator.

    english-spanish (en-es): this dataset was
used in the wmt14 quality estimation shared
task (bojar et al., 2014), containing 858 sen-
tences translated from english into spanish and
post-edited by an expert translator.

for each dataset, post-editing times are    rst di-
vided by the translation output length (obtaining the
post-editing time per word) and then mean normal-
ized.

models since our data consists of pairs of trees,
our models in this task use a pair of tree kernels.
we combine these two kernels by either summing
or multiplying them. as for underlying tree ker-
nels, we try both sstk and sasstks. as in the
emotion analysis task, we also experiment with a
set of kernel con   gurations with the    hyperparam-
eters    xed at 1. we also test models that combine
our tree kernels with an rbf kernel on a set of 17
features extracted using the quest framework (spe-
cia et al., 2013). these features are part of a strong
baseline model used by the wmt14 shared task.

baselines and evaluation we compare our results
with a number of id166 models:

    id166 sstk: same as in the emotion analysis
task, using either a sum (+) or a product (  ) of
sstks.

    id166 rbf: this is an id166 trained on the 17

features extracted by quest.

    id166 rbf sstk: a combination of the two

models above.

for further comparison, we also show results ob-
tained using a gp model and an rbf kernel on the
quest-only features. following previous work, we
measure prediction performance using both mean
absolute error (mae) and rmse.

the prediction results are given in table 4. they

indicate a number of interesting    ndings:

    for the fr-en dataset, the gp models combining
tree kernels with an rbf kernel outperform all
other models. results for the en-es dataset are
less consistent, probably due to the small size
of the dataset, but on average they are better
than their id166 counterparts.

    the id166s using a combination of kernels
performs worse than using the rbf kernel
alone.
inspecting the models, we found that
grid search actually harms performance. for
instance, for the fr-en dataset, mae and rmse
for the rbf + sstk    model before grid
search are 0.4681 and 0.6016, respectively. on
the other hand, for this dataset all gp models
achieve better results after optimization.

    unlike in the emotion analysis task,    xing   
results in better performance, even though the
resulting models have lower marginal likeli-
hood than the ones with free   . the same effect
happened when comparing the sasstk mod-
els with the sstk ones for the en-es dataset.
both cases are evidence of model over   tting.

french-english
mae
rmse

english-spanish
mae
rmse

0.4610
0.4710
0.4681
0.5146
0.5186
0.4555

(id166)
rbf
sstk +
sstk   
rbf sstk +
rbf sstk   
gp rbf
(gp free   )
sstk +
sstk   
sasstks +
sasstks   
(gp    xed    = 1)
sstk +
sstk   
sasstks +
sasstks   
(gp    xed    = 1)
0.4408
rbf sstk +
rbf sstk   
0.4443
rbf sasstks + 0.4406
rbf sasstks    0.4440

0.4789
0.4804
0.4756
0.4797

0.4694
0.4708
0.4758
0.4699

0.5944
0.6006
0.6016
0.6267
0.6299
0.5830

0.5912
0.5843
0.5889
0.5868

0.5808
0.5733
0.5888
0.5751

0.5651
0.5659
0.5648
0.5658

0.7831
0.7777
0.7884
0.8077
0.8367
0.7842

0.7551
0.7440
0.8096
0.7484

0.7614
0.7205
0.8242
0.7469

0.7591
0.7389
0.7692
0.7682

1.0238
1.0820
1.1044
1.0295
1.0427
1.0735

1.0281
1.0008
1.0754
1.0102

1.0019
0.9870
1.0912
1.0280

1.0469
1.0302
1.0682
1.0628

table 4: error scores for the quality estimation task
(lower is better). results are in terms of post-editing time
per word. bold scores are the best ones for each dataset.

we also inspect the resulting hyperparameters to
obtain insights about the features used by the model.
table 5 shows the optimized    values for the gp
sstk models with    xed    for the fr-en dataset. the
   values obtained are higher for the target sentence
kernels than for the source sentence ones. we can
interpret this as the model giving preference to fea-
tures from the target trees instead of the source trees,
which is what we would expect for this task.

5.3 over   tting
both nlp tasks show evidence that the gp models
with large number of hyperparameters (sasstkfull
in the case of emotion analysis and the free    mod-
els in quality estimation) are over   tting the cor-
responding datasets. while the bayesian formula-

  src
gp sstk + 0.1394
gp sstk    0.1405

  tgt
0.3108
0.2641

table 5: learned hyperparameters for the gp sstk mod-
els in the fr-en dataset, with       xed at 1.   src and   tgt
are the hyperparameters corresponding to the kernels on
the source and target parse trees, respectively. the values
shown are averaged over the cross-validation results.

tion for the marginal likelihood does help limiting
over   tting, it does not prevent it completely. small
datasets or invalid assumptions about the gaussian
distribution of the data may still lead to poorly    tting
models. another means of reducing over   tting is by
taking a fully bayesian approach in which hyperpa-
rameters are considered as random variables and are
marginalized out (osborne, 2010); this is a research
direction we plan to pursue in the future.8

5.4 extensions to other tasks
the gp framework introduced in section 2 can
be extended to non-regression problems by chang-
ing the likelihood function. for instance, models
for classi   cation (rasmussen and williams, 2006,
chap. 3), ordinal regression (chu and ghahramani,
2005) and id170 (altun et al., 2004;
brati`eres et al., 2013) were proposed in the liter-
ature. since the likelihood is independent of the
kernel, a natural future step is to apply the kernels
and models introduced in this paper to different nlp
tasks.

in light of that, we did initial experiments in con-
stituency parsing reranking9. the    rst results were
inconclusive but we do believe this is because we
employed naive approaches using classi   cation (1-
best result vs. all) and regression (using parseval
metrics as the response variable) models. a more
appropriate way to tackle this task is by employing a
reranking-based likelihood and this is a direction we
plan to pursue in the future.

6 related work

interest in model selection procedures for kernel-
based methods has been growing in the last years.

8see also rasmussen and williams (2006, chap. 5) for an

in-depth discussion on this issue.

9we thank the anonymous reviewers for this suggestion.

one widely used approach for that is multiple ker-
nel learning (mkl) (g  onen and alpayd  n, 2011).
mkl is based on the idea of using combinations
of kernels to model the data and developing algo-
rithms to tune the kernel coef   cients. this is dif-
ferent from our method, where we focus on learning
the hyperparameters of a single structural kernel. an
approach similar to ours was proposed by igel et al.
(2007). they combine oligo kernels (a kind of n-
gram kernel) with mkl, derive their gradients and
optimize towards a kernel alignment metric. com-
pared to our approach, they restrict the length of
the id165s being considered, while we rely on dy-
namic programming to explore the whole substruc-
ture space. also, their method does not take into
account the underlying learning algorithm. another
recent approach proposed for model selection is ran-
dom search (bergstra and bengio, 2012). like grid
search, it has the drawback of not employing gra-
dient information, as it is designed for any kind of
hyperparameters (including categorical ones).

structural kernels have been successfully em-
ployed in a number of nlp tasks. the original
sstk proposed by collins and duffy (2001) was
used to rerank the output of syntactic parsers. re-
cently, this reranking idea was also applied to dis-
course parsing (joty and moschitti, 2014). other
tree kernel applications include semantic role la-
belling (moschitti et al., 2008) and relation extrac-
tion (plank and moschitti, 2013). string kernels
were mostly used in text classi   cation (lodhi et
al., 2002; cancedda et al., 2003), while graph ker-
nels have been used for recognizing textual entail-
ment (zanzotto and dell   arciprete, 2009). how-
ever, these previous works focused on frequentist
methods like id166 or voted id88 while we
employ a bayesian approach.

gaussian processes are a major

framework
in machine learning nowadays:
applications in-
clude robotics (ko et al., 2007), geolocation
(schwaighofer et al., 2004) and id161
(sinz et al., 2004). only very recently they have
been successfully employed in a few nlp tasks such
as translation quality estimation (cohn and specia,
2013; beck et al., 2014b), detection of temporal pat-
terns in text (preot  iuc-pietro and cohn, 2013), se-
mantic similarity (rios and specia, 2014) and emo-
tion analysis (beck et al., 2014a). in terms of feature

representations, previous work focused on the vecto-
rial inputs and applied well-known kernels for these
inputs, e.g. the rbf kernel. as shown on   5.2, our
approach is orthogonal to these previous ones, since
kernels can be easily combined in different ways.

it is important to note that we are not the    rst ones
to combine gps with kernels on structured inputs.
driessens et al. (2006) employed a combination of
gps and graph kernels for id23.
however, unlike our approach, they did not attempt
model selection, evaluating only a few hyperparam-
eter values empirically.

7 conclusions
this paper describes a bayesian approach for struc-
tural kernel learning, based on gaussian processes
for easy model selection. experiments applying our
models to synthetic data showed that it is possible
to learn structural kernel hyperparameters using a
fairly small amount of data. furthermore we ob-
tained promising results in two nlp tasks, includ-
ing quality estimation, where we beat the state of
the art. finally, we showed how these rich parame-
terizations can lead to more interpretable kernels.

beyond empirical improvements, an important
goal of this paper is to present a method that en-
ables new kernel developments through the exten-
sion of the number of hyperparameters. we focused
on the subset tree kernel, proposing an extension
and then deriving its gradients. this approach can
be applied to any structural kernel, as long as gradi-
ents are available. it is our hope that this work will
serve as a starting point for future developments in
these research directions.

references
[altun et al.2004] yasemin altun, thomas hofmann, and
alexander j. smola. 2004. gaussian process classi   -
cation for segmenting and annotating sequences. in
proceedings of icml.

[bach et al.2011] nguyen bach, fei huang, and yaser al-
onaizan. 2011. goodness: a method for measuring
in proceedings of
machine translation con   dence.
acl, pages 211   219.

[beck et al.2014a] daniel beck, trevor cohn, and lucia
specia. 2014a. joint emotion analysis via multi-task
gaussian processes. in proceedings of emnlp, pages
1798   1803.

[beck et al.2014b] daniel beck, kashif shah, and lucia
specia. 2014b. shef-lite 2.0 : sparse multi-task
gaussian processes for translation quality estima-
tion. in proceedings of wmt14, pages 307   312.

[bergstra and bengio2012] james bergstra and yoshua
bengio. 2012. random search for hyper-parameter
optimization. journal of machine learning research,
13:281   305.

[blatz et al.2004] john blatz, erin fitzgerald, and george
foster.
2004. con   dence estimation for machine
translation. in proceedings of the 20th conference on
computational linguistics, pages 315   321.

[bojar et al.2014] ondej bojar, christian buck, christian
federmann, barry haddow, philipp koehn, johannes
leveling, christof monz, pavel pecina, matt post,
herve saint-amand, radu soricut, lucia specia, and
ale  s tamchyna. 2014. findings of the 2014 work-
shop on id151. in proceed-
ings of wmt14, pages 12   58.

[brati`eres et al.2013] s  ebastien

novi
quadrianto, and zoubin ghahramani. 2013. bayesian
id170 using gaussian processes.
arxiv:1307.3846, pages 1   17.

brati`eres,

[cancedda et al.2003] nicola cancedda, eric gaussier,
cyril goutte, and jean-michel renders. 2003. word-
sequence kernels. the journal of machine learning
research, 3:1059   1082.

[chang and lin2001] chih-chung chang and chih-jen
lin. 2001. libid166 : a library for support vector
machines. acm transactions on intelligent systems
and technology (tist), 2(3):1   39.

[chu and ghahramani2005] wei chu

zoubin
ghahramani. 2005. gaussian processes for ordinal
regression. journal of machine learning research,
6:1019   1041.

and

[cohn and specia2013] trevor cohn and lucia specia.
2013. modelling annotator bias with multi-task
gaussian processes: an application to machine
in proceedings of
translation quality estimation.
acl, pages 32   42.

[collins and duffy2001] michael collins

duffy.
language. in proceedings of nips, pages 625   632.

and nigel
convolution kernels for natural

2001.

[driessens et al.2006] kurt driessens, jan ramon, and
thomas g  artner. 2006. graph kernels and gaus-
sian processes for relational id23.
machine learning, 64(1-3):91   119.

[g  onen and alpayd  n2011] mehmet g  onen and ethem
alpayd  n. 2011. multiple kernel learning algorithms.
journal of machine learning research, 12:2211   
2268.

[hardmeier et al.2012] christian hardmeier,

joakim
2012. tree kernels

nivre, and j  org tiedemann.

for machine translation quality estimation.
proceedings of wmt12, pages 109   113.

in

[hardmeier2011] christian hardmeier. 2011. improving
machine translation quality prediction with syntactic
in proceedings of eamt, pages 233   
tree kernels.
240.

[haussler1999] david haussler. 1999. convolution ker-
nels on discrete structures. technical report, univer-
sity of california at santa cruz.

[he et al.2010] yifan he, yanjun ma, josef van genabith,
and andy way. 2010. bridging smt and tm with
translation recommendation. in proceedings of acl,
pages 622   630.

[hensman et al.2013] james hensman, nicol`o fusi, and
neil d. lawrence. 2013. gaussian processes for big
data. in proceedings of uai, pages 282   290.

[igel et al.2007] christian igel, tobias glasmachers,
britta mersch, and nico pfeifer. 2007. gradient-
based optimization of kernel-target alignment for
sequence kernels applied to bacterial gene start de-
ieee/acm transactions on computational
tection.
biology and bioinformatics, 4(2):216   226.

[joty and moschitti2014] sha   q joty and alessandro
moschitti. 2014. discriminative reranking of dis-
course parses using tree kernels. in emnlp, pages
2049   2060.

[ko et al.2007] jonathan ko, daniel j. klein, dieter fox,
and dirk haehnel. 2007. gaussian processes and re-
inforcement learning for identi   cation and control of
in proceedings of ieee in-
an autonomous blimp.
ternational conference on robotics and automation,
pages 742   747.

[lodhi et al.2002] huma lodhi, craig saunders, john
shawe-taylor, nello cristianini, and chris watkins.
2002. text classi   cation using string kernels. the
journal of machine learning research, 2:419   444.

john bauer,

[manning et al.2014] christopher d. manning, mihai
surdeanu,
jenny finkel, steven j.
bethard, and david mcclosky. 2014. the stanford
corenlp natural language processing toolkit.
in
proceedings of acl demo session, pages 55   60.

[moschitti et al.2008] alessandro moschitti, daniele
pighin, and roberto basili. 2008. tree kernels for
id14. computational linguistics,
pages 1   32.

[moschitti2006a] alessandro moschitti. 2006a. ef   cient
convolution kernels for dependency and constituent
syntactic trees. in proceedings of ecml, pages 318   
329.

[moschitti2006b] alessandro moschitti. 2006b. making
tree kernels practical for natural language learning.
in eacl, pages 113   120.

[osborne2010] michael osborne. 2010. bayesian gaus-
sian processes for sequential prediction, optimisation
and quadrature. ph.d. thesis, university of oxford.

[pang and lee2008] bo pang and lillian lee.

2008.
opinion mining and id31. foundations
and trends in information retrieval, 2(12):1   135.

[pedregosa et al.2011] fabian pedregosa, ga  el varo-
quaux, alexandre gramfort, vincent michel, bertrand
thirion, olivier grisel, mathieu blondel, peter pret-
tenhofer, ron weiss, vincent duborg, jake vander-
plas, alexandre passos, david cournapeau, matthieu
brucher, matthieu perrot, and   edouard duchesnay.
2011. scikit-learn: machine learning in python. jour-
nal of machine learning research, 12:2825   2830.

[pighin and moschitti2010] daniele pighin and alessan-
dro moschitti. 2010. on reverse feature engineering
of syntactic tree kernels. in proceedings of conll,
pages 223   233.

[plank and moschitti2013] barbara plank and alessandro
moschitti. 2013. embedding semantic similarity in
tree kernels for id20 of relation ex-
traction. in proceedings of acl, pages 1498   1507.

[preot  iuc-pietro and cohn2013] daniel

preot  iuc-pietro
and trevor cohn. 2013. a temporal model of text pe-
riodicities using gaussian processes. in proceedings
of emnlp, pages 977   988.

[rasmussen and williams2006] carl edward rasmussen
and christopher k. i. williams. 2006. gaussian pro-
cesses for machine learning, volume 1. mit press
cambridge.

[rios and specia2014] miguel rios and lucia specia.
2014. uow : id72 gaussian process
for semantic textual similarity. in proceedings of se-
meval, pages 779   784.

[schwaighofer et al.2004] anton schwaighofer, marian
grigoras, volker tresp, and clemens hoffmann.
2004. gpps: a gaussian process positioning system
for cellular networks. in proceedings of nips, pages
579   586.

[sinz et al.2004] fabian h. sinz, joaquin qui  nonero can-
dela, g  okhan h. bak  r, carl e. rasmussen, and
matthias o. franz.
2004. learning depth from
stereo. pattern recognition, pages 1   8.

[specia et al.2009] lucia specia, nicola cancedda, marc
dymetman, marco turchi, and nello cristianini.
2009. estimating the sentence-level quality of ma-
in proceedings of eamt,
chine translation systems.
pages 28   35.

[specia et al.2010] lucia specia, dhwaj raj, and marco
turchi. 2010. machine translation evaluation versus
quality estimation. machine translation, 24(1):39   
50.

[specia et al.2013] lucia specia, kashif shah, jos  e g.
c. de souza, and trevor cohn. 2013. quest - a trans-
in proceedings
lation quality estimation framework.
of acl demo session, pages 79   84.

[specia2011] lucia specia. 2011. exploiting objective
annotations for measuring translation post-editing
effort. in proceedings of eamt, pages 73   80.

[strapparava and mihalcea2007] carlo strapparava and
rada mihalcea. 2007. semeval-2007 task 14 : af-
fective text. in proceedings of semeval, pages 70   74.
[strapparava and mihalcea2008] carlo strapparava and
rada mihalcea. 2008. learning to identify emotions
in text. in proceedings of the 2008 acm symposium
on applied computing, pages 1556   1560.

[zanzotto and dell   arciprete2009] fabio massimo zan-
zotto and lorenzo dell   arciprete. 2009. ef   cient ker-
nels for sentence pair classi   cation. in proceedings of
emnlp, pages 91   100.

a details on id166 baselines
all id166 baselines employ the  -insensitve loss
function. grid search optimization is done via 3-
fold cross-validation on the respective training set
and use rmse as the metric to be minimized. after
obtained the best hyperparameter values, the id166
is retrained using these values on the full respec-
tive training set. the speci   c intervals used in grid
search depend on the task.
for the performance experiments on synthetic
data, we employed an interval of [10   2, 10] for c
(id173 coef   cient) and  , [10   8, 1] for    and
[10   4, 2] for   .
in each run we incrementally in-
crease the size of the grid by adding intermediate
values on each interval. we keep a linear scale for
the sstk hyperparameters and a logarithmic scale
for c and  . as an example, table 6 shows the re-
sulting grids when the grid value is 4 for each hyper-
parameter. for all nlp experiments the grid is    xed
for all hyperparameters (including   , the lengthscale
value in the rbf kernel), with its corresponding val-
ues shown on table 7.

c /  

  
  

[10   2, 10   1, 1, 10]
[10   8, 0.33, 0.67, 1]
[10   4, 0.67, 1.33, 2]

table 6: resulting grids for the performance experiments
when grid size is set to 4 for each hyperparameter.

[10   2, 1, 100]

[10   2, 10   1, 1, 10]
[10   16, 0.25, 0.5]

[1] (   xed)

[10   3, 0.0178, 0.316, 5.62, 100]

c
 
  
  
  

table 7: grid values for the nlp experiments.

