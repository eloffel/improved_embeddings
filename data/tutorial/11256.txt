6
1
0
2

 

b
e
f
6
2

 

 
 
]
i

a
.
s
c
[
 
 

2
v
0
3
1
8
0

.

1
1
5
1
:
v
i
x
r
a

a roadmap towards machine intelligence

tomas mikolov1, armand joulin1 and marco baroni1,2

1facebook ai research
2university of trento

abstract

the development of intelligent machines is one of the biggest unsolved chal-
lenges in computer science. in this paper, we propose some fundamental prop-
erties these machines should have, focusing in particular on communication and
learning. we discuss a simple environment that could be used to incrementally
teach a machine the basics of natural-language-based communication, as a pre-
requisite to more complex interaction with human users. we also present some
conjectures on the sort of algorithms the machine should support in order to
pro   tably learn from the environment.

1

introduction

a machine capable of performing complex tasks without requiring laborious program-
ming would be tremendously useful in almost any human endeavor, from performing
menial jobs for us to helping the advancement of basic and applied research. given
the current availability of powerful hardware and large amounts of machine-readable
data, as well as the widespread interest in sophisticated machine learning methods,
the times should be ripe for the development of intelligent machines.

still, since    solving ai    seems too complex a task to be pursued all at once, in the
last decades the computational community has preferred to focus on solving relatively
narrow empirical problems that are important for speci   c applications, but do not
address the overarching goal of developing general-purpose intelligent machines. in this
article, we propose an alternative approach: we    rst de   ne the general characteristics
we think intelligent machines should possess, and then we present a concrete roadmap
to develop them in realistic, small steps, that are however incrementally structured in
such a way that, jointly, they should lead us close to the ultimate goal of implementing
a powerful ai.

the article is organized as follows. in section 2 we specify the two fundamental
characteristics that we consider crucial for developing intelligence   at least the sort
of intelligence we are interested in   namely communication and learning. our goal is

1

to build a machine that can learn new concepts through communication at a similar
rate as a human with similar prior knowledge. that is, if one can easily learn how
subtraction works after mastering addition, the intelligent machine, after grasping the
concept of addition, should not    nd it di   cult to learn subtraction as well. since,
as we said, achieving the long-term goal of building an intelligent machine equipped
with the desired features at once seems too di   cult, we need to de   ne intermediate
targets that can lead us in the right direction. we specify such targets in terms of
simpli   ed but self-contained versions of the    nal machine we want to develop. at
any time during its    education   , the target machine should act like a stand-alone
intelligent system, albeit one that will be initially very limited in what it can do. the
bulk of our proposal (section 3) thus consists in the plan for an interactive learning
environment fostering the incremental development of progressively more intelligent
behavior. section 4 brie   y discusses some of the algorithmic capabilities we think a
machine should possess in order to pro   tably exploit the learning environment. finally,
section 5 situates our proposal in the broader context of past and current attempts to
develop intelligent machines. as that review should make clear, our plan encompasses
many ideas that have already appeared in di   erent research strands. what we believe
to be novel in our approach is the way in which we are combining such ideas into a
coherent program.

2 desiderata for an intelligent machine

rather than attempting to formally characterize intelligence, we propose here a set of
desiderata we believe to be crucial for a machine to be able to autonomously make itself
helpful to humans in their endeavors. the guiding principles we implicitly considered
in formulating the desiderata are to minimize the complexity of the machine, and to
maximize interpretability of its behavior by humans.

2.1 ability to communicate

any practical realization of an intelligent machine will have to communicate with us.
it would be senseless to build a machine that is supposed to perform complex opera-
tions if there is no way for us to specify the aims of these operations, or to understand
the output of the machine. while other communication means could be entertained,
natural language is by far the easiest and most powerful communication device we pos-
sess, so it is reasonable to require an intelligent machine to be able to communicate
through language. indeed, the intelligent machine we aim for could be seen as a com-
puter that can be programmed through natural language, or as the interface between
natural language and a traditional programming language. importantly, humans have
encoded a very large portion of their knowledge into natural language (ranging from
mathematics treatises to cooking books), so a system mastering natural language will
have access to most of the knowledge humans have assembled over the course of their

2

history.

communication is, by its very nature, interactive: the possibility to hold a conver-
sation is crucial both to gather new information (asking for explanation, clari   cation,
instructions, feedback, etc.) and to optimize its transmission (compare a good lecture
or studying with a group of peers to reading a book alone). our learning environment
will thus emphasize the interactive nature of communication.

natural language can also channel, to a certain extent, non-linguistic information,
because much of the latter can be conveyed through linguistic means. for example, we
can use language to talk about what we perceive with our senses, or to give instructions
on how to operate in the world (see louwerse, 2011, among others, for evidence that
language encodes many perceptual aspects of our knowledge). analogously, in the
simulation we discuss below, a teacher uses natural language to teach the learner (the
intelligent machine being trained) a more limited and explicit language (not unlike
a simple programming language) in which the learner can issue instructions to its
environment through the same communication channels it uses to interact with the
teacher. the intelligent machine can later be instructed to browse the internet by
issuing commands in the appropriate code through its usual communication channels,
mastering in this way a powerful tool to interact with the world at large. language
can also serve as an interface to perceptual components, and thus update the machine
about its physical surroundings. for example, an object recognition system could
transform raw pixel data into object labels, allowing the machine to    see    its real-life
environment through a controlled-language modality.

still, we realize that our focus on the language-mediated side of intelligence may
limit the learning machine in the development of skills that we naturally gain by ob-
serving the world around us. there seems to be a fundamental di   erence between
the symbolic representations of language and the continuous nature of the world as
we perceive it. if this will turn out to be an issue, we can extend the training phase
of the machine (its development in a simulated environment such as the one we will
sketch below) with tasks that are more perception-oriented. while in the tasks we
will describe here the machine will be taught how to use its i/o channels to receive
and transmit linguistic symbols, the machine could also be exposed, through the same
interface, to simple encodings (bit streams) of continuous input signals, such as im-
ages. the machine could thus be trained,    rst, to understand the basic properties of
continuous variables, and then to perform more complex operations in a continuous
space, such as identifying shapes in 2d images. note that including such tasks would
not require us to change the design of our learning framework, only to introduce novel
scripts.

one big advantage of the single-interface approach we are currently pursuing is
that the machine only needs to be equipped with bit-based i/o channels, thus being
maximally simple in its interface. the machine can learn an unlimited number of new
codes enabling it to interface, through the same channels, with all sorts of interlocu-
tors (people, other machines, perceptual data encoded as described above, etc.). by

3

equipping the machine with only a minimalistic i/o bit-stream interface, we ensure
moreover that no prior knowledge about the challenges the machine will encounter
is encoded into the structure of the input and output representations, harming the
generality of the strategies the machine will learn (compare the di   culty of processing
an image when it   s already encoded into pixels vs. as raw bits).

finally, while we propose language as the general interface to the machine, we are
agnostic about the nature of the internal representations the machine must posit to
deal with the challenges it faces. in particular, we are not making claims about the
internal representations of the machine being based on an interpretable    language of
thought    (fodor, 1975). in other words, we are not claiming that the machine should
carry out its internal reasoning in a linguistic form: only that its input and output are
linguistic in nature.

to give a few examples of how a communication-based intelligent machine can
be useful, consider a machine helping a scientist with research. first of all, the
communication-endowed machine does not need to pre-encode a large static database
of facts, since it can retrieve the relevant information from the internet. if the scientist
asks a simple question such as: what is the density of gold?, the machine can search
the web to answer: 19.3g/cm3.

most questions will however require the machine to put together multiple sources
of information. for example, one may ask: what is a good starting point to study
id23?. the machine might visit multiple web sites to search for
materials and get an idea of their relative popularity. moreover, interaction can make
even a relatively simple query such as the latter more successful. for example, the
machine can ask the user if she prefers videos or articles, what is the mathematical
background to be assumed, etc.

however, what we are really interested in is a machine that can signi   cantly speed
up research progress by being able to address questions such as: what is the most
promising direction to cure cancer, and where should i start to meaningfully con-
tribute? this question may be answered after the machine reads a signi   cant number
of research articles online, while keeping in mind the perspective of the person asking
the question. interaction will again play a central role, as the best course of action
for the intelligent machine might involve entering a conversation with the requester,
to understand her motivation, skills, the time she is willing to spend on the topic, etc.
going further, in order to ful   ll the request above, the machine might even conduct
some independent research by exploiting information available online, possibly consult
with experts, and direct the budding researcher, through multiple interactive sessions,
towards accomplishing her goal.

2.2 ability to learn

arguably, the main    aw of    good old    symbolic ai research (haugeland, 1985) lied
in the assumption that it would be possible to program an intelligent machine largely

4

by hand. we believe it is uncontroversial that a machine supposed to be helping us
in a variety of scenarios, many unforeseen by its developers, should be endowed with
the capability of learning. a machine that does not learn cannot adapt or modify
itself based on experience, as it will react in the same way to a given situation for its
whole lifetime. however, if the machine makes a mistake that we want to correct, it
is necessary for it to change its behavior   thus, learning is a mandatory component.

together with learning comes motivation. learning allows the machine to adapt
itself to the external environment, helping it to produce outputs that maximize the
function de   ned by its motivation. since we want to develop machines that make
themselves useful to humans, the motivation component should be directly controlled
by users through the communication channel. by specifying positive and negative
rewards, one may shape the behavior of the machine so that it can become useful
for concrete tasks (this is very much in the spirit of id23, see, e.g.,
sutton and barto, 1998, and discussion in section 5 below).

note that we will often refer to human learning as a source of insight and an
ideal benchmark to strive for. this is natural, since we would like our machines to
develop human-like intelligence. at the same time, children obviously grow in a very
di   erent environment from the one in which we tutor our machines, they soon develop
a sophisticated sensorimotor system to interact with the world, and they are innately
endowed with many other cognitive capabilities. an intelligent machine, on the other
hand, has no senses, and it will start its life as a tabula rasa, so that it will have to
catch up not only on human ontogeny, but also on their phylogeny (the history of
ai indicates that letting a machine learn from data is a more e   ective strategy than
manually pre-encoding    innate    knowledge into it). on the positive side, the machine
is not subject to the same biological constraints of children, and we can, for example,
expose it to explicit tutoring at a rate that would not be tolerable for children. thus,
while human learning can provide useful inspiration, we are by no means trying to let
our machines develop in human-like ways, and we claim no psychological plausibility
for the methods we propose.

3 a simulated ecosystem to educate communicat-

ion-based intelligent machines

in this section, we describe a simulated environment designed to teach the basics of
linguistic interaction to an intelligent machine, and how to use it to learn to operate
in the world. the simulated ecosystem should be seen as a    kindergarten    providing
basic education to intelligent machines. the machines are trained in this controlled
environment to later be connected to the real world in order to learn how to help
humans with their various needs.

the ecosystem i/o channels are controlled by an automatic mechanism, avoiding
the complications that would arise from letting the machine interact with the    real

5

world    from the very beginning, and allowing us to focus on challenges that should
directly probe the e   ectiveness of new machine learning techniques.

the environment must be challenging enough to force the machine to develop
sophisticated learning strategies (essentially, it should need to    learn how to learn   ).
at the same time, complexity should be manageable, i.e., a human put into a similar
environment should not    nd it unreasonably di   cult to learn to communicate and
act within it, even if the communication takes place in a language the human is not
yet familiar with. after mastering the basic language and concepts of the simulated
environment, the machine should be able to interact with and learn from human
teachers. this puts several restrictions on the kind of learning the machine must
come to be able to perform: most importantly, it will need to be capable to extract
the correct generalizations from just a few examples, at a rate comparable to human
learners.

our ecosystem idea goes against received wisdom from the last decades of ai re-
search. this received wisdom suggests that systems should be immediately exposed to
real-world problems, so that they don   t get stuck into arti   cial    blocks worlds    (wino-
grad, 1971), whose experimenter-designed properties might di   er markedly from those
characterizing realistic setups. our strategy is based on the observation, that we will
discuss in section 4, that current machine learning techniques cannot handle the sort
of genuinely incremental learning of algorithms that is necessary for the development
of intelligent machines, because they lack the ability to store learned skills in long-term
memory and compose them. to bring about an advance in such techniques, we have
of course many choices. it seems sensible to pick the simplest one. the environment
we propose is su   cient to demonstrate the de   ciencies of current techniques, yet it
is simple enough that we can fully control the structure and nature of the tasks we
propose to the machines, make sure they have a solution, and use them to encourage
the development of novel techniques. suppose we were instead to work in a more
natural environment from the very beginning, for example from video input. this
would impose large infrastructure requirements on the developers, it would make data
pre-processing a big challenge in itself, and training even the simplest models would be
very time-consuming. moreover, it would be much more di   cult to formulate interre-
lated tasks in a controlled way, and de   ne the success criterion. once we have used our
ecosystem to develop a system capable of learning compositional skills from extremely
sparse reward, it should be simple to plug in more natural signals, e.g., through com-
munication with real humans and internet access, so that the system would learn how
to accomplish the tasks that people really want it to perform.

the fundamental di   erence between our approach and classic ai blocks worlds is
that we do not intend to use our ecosystem to script an exhaustive set of functionalities,
but to teach the machine the fundamental ability to learn how to e   ciently learn by
creatively combining already acquired skills. once such machine gets connected with
the real world, it should quickly learn to perform any new task its teacher will choose.
our environment can be seen as analogous to explicit schooling. pupils are taught

6

math in primary school through rather arti   cial problems. however, once they have
interiorized basic math skills in this setup, they can quickly adapt them to the problems
they encounter in their real life, and rely on them to rapidly acquire more sophisticated
mathematical techniques.

3.1 high-level description of the ecosystem

agents to develop an arti   cial system that is able to incrementally acquire new
skills through linguistic interaction, we should not look at the training data as a static
set of labeled examples, as in common machine learning setups. we propose instead
a dynamic ecosystem akin to that of a computer game. the learner (the system to
be trained) is an actor in this ecosystem.

the second fundamental agent in the ecosystem is the teacher. the teacher
assigns tasks and rewards the learner for desirable behaviour, and it also provides
helpful information, both spontaneously and in response to learner   s requests. the
teacher   s behaviour is entirely scripted by the experimenters. again, this might be
worryingly reminiscent of entirely hand-coded good-old ais. however, the teacher
need not be a very sophisticated program.
in particular, for each task it presents
to the learner, it will store a small set of expected responses, and only reward the
learner if its behaviour exactly matches one response. similarly, when responding to
learner   s requests, the teacher is limited to a    xed list of expressions it knows how
to respond to. the reason why this su   ces is that the aim of our ecosystem is to
kickstart the learner   s e   cient learning capabilities, and not to provide enough direct
knowledge for it to be self-su   cient in the world. for example, given the limitations
of the scripted teacher, the learner will only be able to acquire a very impoverished
version of natural language in the ecosystem. at the same time, the learner should
acquire powerful learning and generalization strategies. using the minimal linguistic
skills and strong learning abilities it acquired, the learner should then be able to
extend its knowledge of language fast, once it is put in touch with actual human users.
like in classic text-based adventure games (wikipedia, 2015b), the environment is
entirely linguistically de   ned, and it is explored by the learner by giving orders, asking
questions and receiving feedback (although graphics does not play an active role in our
simulation, it is straightforward to visualize the 2d world in order to better track the
learner   s behaviour, as we show through some examples below). the environment
is best seen as the third fundamental agent in the ecosystem. the environment
behaviour is also scripted. however, since interacting with the environment serves
the purpose of observation and navigation of the learner surroundings (   sensorimotor
experience   ), the environment uses a controlled language that, compared to that of
the teacher, is more restricted, more explicit and less ambiguous. one can thus think
of the learner as a higher-level programming language, that accepts instructions from
the programmer (the teacher) in a simple form of natural language, and converts them
into the machine code understood by the environment.

7

in the examples to follow, we assume the world de   ned by the environment to be
split into discrete cells that the learner can traverse horizontally and vertically. the
world includes barriers, such as walls and water, and a number of objects the learner
can interact with (a pear, a mug, etc).

note that, while we do not explore this possibility here, it might be useful to add
other actors to the simulation:
for example, training multiple learners in parallel,
encouraging them to teach/communicate with each other, while also interacting with
the scripted teacher.

interface channels the learner experience is entirely de   ned by generic input and
output channels. the teacher, the environment and any other language-endowed
agent write to the input stream. reward (a scalar value, as discussed next) is also
written to the input stream (we assume, however, that the learner does not need
to discover which bits encode reward, as it will need this information to update its
objective function). ambiguities are avoided by pre   xing a unique string to the mes-
sages produced by each actor (e.g., messages from the teacher might be pre   xed by
the string t:, as in our examples below). the learner writes to its output channel,
and it is similarly taught to use unambiguous pre   xes to address the teacher, the
environment and any other agent or service it needs to communicate with. having
only generic input and output communication channels should facilitate the seaid113ss
addition of new interactive entities, as long as the learner is able to learn the language
they communicate in.

reward reward can be positive or negative (1/-1), the latter to be used to speed
up instruction by steering away the learner from dead ends, or even damaging be-
haviours. the teacher, and later human users, control reward in order to train the
learner. we might also let the environment provide feedback through hard-coded
rewards, simulating natural events such as eating or getting hurt. like in realistic
biological scenarios, reward is sparse, mostly being awarded after the learner has ac-
complished some task. as intelligence grows, we expect the reward to become very
sparse, with the learner able to elaborate complex plans that are only rewarded on
successful completion, and even displaying some degree of self-motivation. indeed, the
learner should be taught that short-term positive reward might lead to loss at a later
stage (e.g., hoarding on food with poor nutrition value instead of seeking further away
for better food), and that sometimes reward can be maximized by engaging in activ-
ities that in the short term provide no bene   t (learning to read might be boring and
time-consuming, but it can enormously speed up problem solving   and the consequent
reward accrual    by making the learner autonomous in seeking useful information on
the internet). going even further, during the learner    adulthood    explicit external
reward could stop completely. the learner will no longer be directly motivated to
learn in new ways, but ideally the policies it has already acquired will include strate-
gies such as curiosity (see below) that would lead it to continue to acquire new skills

8

for its own sake. note that, when we say that reward could stop completely, we mean
that users do not need to provide explicit reward, in the form of a scalar value, to
the learner. however, from a human perspective, we can look at this as the stage
in which the learner has interiorized its own sources of reward, and no longer needs
external stimuli.

we assume binary reward so that human users need not worry about relative
amounts of reward to give to the learner (if they do want to control the amount of
reward, they can simply reward the learner multiple times). the learner objective
should however maximize average reward over time, naturally leading to di   erent
degrees of cumulative reward for di   erent courses of action (this is analogous to the
notion of expected cumulative reward in id23, which is a possible
way to formalize the concept). even if two solutions to a task are rewarded equally
on its completion, the faster strategy will be favored, as it leaves the learner more
time to accumulate further reward. this automatically ensures that e   cient solutions
are preferred over wasteful ones. moreover, by measuring time independently from
the number of simulation steps, e.g., using simple wall-clock time, one should penalize
ine   cient learners spending a long time performing o   ine computations.

as already mentioned, our approach to reward-based learning shares many proper-
ties with id23. indeed, our setup    ts into the general formulation of
the id23 problem (kaelbling et al., 1996; sutton and barto, 1998)   
see section 5 for further discussion of this point.

incremental structure in keeping with the game idea, it is useful to think of the
learner as progressing through a series of levels, where skills from earlier levels are
required to succeed in later ones. within a level, there is no need to impose a strict
ordering of tasks (even when our intuition suggests a natural incremental progression
across them), and we might let the learner discover its own optimal learning path by
cycling multiple times through blocks of them.

at the beginning, the teacher trains the learner to perform very simple tasks in or-
der to kick-start linguistic communication and the discovery of very simple algorithms.
the teacher    rst rewards the learner when the latter repeats single characters, then
words, delimiters and other control strings. the learner is moreover taught how to
repeat and manipulate longer sequences. in a subsequent block of tasks, the teacher
leads the learner to develop a semantics for linguistic symbols, by encouraging it to
associate linguistic expressions with actions. this is achieved through practice sessions
in which the learner is trained to repeat strings that function as environment com-
mands, and it is rewarded only when it takes notice of the e   ect the commands have
on its state (we present concrete examples below). at this stage, the learner should
become able to associate linguistic strings to primitive moves and actions (turn left).
next, the teacher will assign tasks involving action sequences (   nd an apple), and the
learner should convert them into sets of primitive commands (simple    programs   ).
the teacher will, increasingly, limit itself to specify an abstract end goal (bring back

9

food ), but not recipes to accomplish it, in order to spur creative thinking on behalf of
the learner (e.g., if the learner gets trapped somewhere while looking for food, it may
develop a strategy to go around obstacles). in the process of learning to parse and
execute higher-level commands, the learner should also be trained to ask clari   cation
questions to the teacher (e.g., by initially granting reward when it spontaneously ad-
dresses the teacher, and by the repetition-based strategy we illustrate in the examples
below). with the orders becoming more general and complex, the language of the
teacher will also become (within the limits of what can be reasonably scripted) richer
and more ambiguous, challenging the learner capability to handle restricted speci-
mens of common natural language phenomena such as polysemy, vagueness, anaphora
and quanti   cation.

to support user scenarios such as the ones we envisaged in section 2 above and
those we will discuss at the end of this section, the teacher should eventually teach
the learner how to    read    natural text, so that the learner, given access to the inter-
net, can autonomously seek for information online. incidentally, notice that once the
machine can read text, it can also exploit distributional learning from large amounts
of text (erk, 2012; mikolov et al., 2013; turney and pantel, 2010) to induce word and
phrase representations addressing some of the challenging natural language phenomena
we just mentioned, such as polysemy and vagueness.

the learner must take its baby steps    rst, in which it is carefully trained to
accomplish simple tasks such as learning to compose basic commands. however, for
the learner to have any hope to develop into a fully-functional intelligent machine, we
need to aim for a    snow-balling    e   ect to soon take place, such that later tasks, despite
being inherently more complex, will require a lot less explicit coaching, thanks to a
combinatorial explosion in the background abilities the leaner can creatively compose
(like for humans, learning how to surf the web should take less time than learning
how to spell).

time o    throughout the simulation, we foresee phases in which the learner is free
to interact with the environment and the teacher without a de   ned task. systems
should learn to exploit this time o    for undirected exploration, that should in turn
lead to better performance in active training stages, just like, in the dead phases of a
video-game, a player is more likely to try out her options than to just sit waiting for
something to happen, or when arriving in a new city we   d rather go sightseeing than
staying in the hotel. since curiosity is bene   cial in many situations, such behaviour
should naturally lead to higher later rewards, and thus be learnable. time o    can also
be used to    think    or    take a nap   , in which the learner can replay recent experiences
and possibly update its inner structure based on a more global view of the knowledge
it has accumulated, given the extra computational resources that the free time policy
o   ers.

10

evaluation learners can be quantitatively evaluated and compared in terms of the
number of new tasks they accomplish successfully in a    xed amount of time, a mea-
sure in line with the reward-maximization-over-time objective we are proposing. since
the interactive, multi-task environment setup does not naturally support a distinc-
tion between a training and a test phase, the machine must carefully choose reward-
maximizing actions from the very beginning.
in contrast, evaluating the machine
only on its    nal behavior would overlook the number of attempts it took to reach
the solution. such alternative evaluation would favor models which are simply able
to memorize patterns observed in large amounts of training data. in many practical
domains, this approach is    ne, but we are interested in machines capable of learning
truly general problem-solving strategies. as the tasks become incrementally more dif-
   cult, the amount of required computational resources for naive memorization-based
approaches scales exponentially, so only a machine that can e   ciently generalize can
succeed in our environment. we will discuss the limitations of machines that rely on
memorization instead of algorithmic learning further in section 4.3 below.

we would like to foster the development of intelligent machines by employing our
ecosystem in a public competition. given what we just said, the competition would
not involve distributing a static set of training/development data similar in nature
to the    nal test set. we foresee instead a setup in which developers have access to
the full pre-programmed environment for a    xed amount of time. the learners are
then evaluated on a set of new tasks that are considerably di   erent from the ones
exposed in the development phase. examples of how test tasks might di   er from
those encountered during development include the teacher speaking a new language,
a di   erent environment topography, new obstacles and objects with new a   ordances,
and novel domains of endeavor (e.g., test tasks might require selling and buying things,
when the learner was not previously introduced to the rules of commerce).

3.2 early stages of the simulation

preliminaries at the very beginning, the learner has to learn to pay attention to
the teacher, to identify the basic units of language (   nd regularity in bit patterns, learn
characters, then words and so on). it must moreover acquire basic sequence repetition
and manipulation skills, and develop skills to form memory and learn e   ciently. these
very initial stages of learning are extremely important, as we believe they constitute
the building blocks of intelligence.

however, as bit sequences do not make for easy readability, we focus here on an
immediately following phase, in which the learner has already learned how to pay
attention to the teacher and manipulate character strings. we show how the teacher
guides the learner from these basic skills to being able to solve relatively sophisticated
environment navigation problems by exploiting interactive communication. because
of the    fractal-like    structure we envisage in the acquisition of increasingly higher-level
skills, these steps will illustrate many of the same points we could have demonstrated

11

through the lower-level initial routines. the tasks we describe are also incrementally
structured, starting with the learner learning to issue environment commands, then
being led to take notice of the e   ect these commands have, then understanding com-
mand structure, in order to generalize across categories of actions and objects, leading
it in turn to being able to process higher-level orders. at this point, the learner is
initiated to interactive communication.

note that we only illustrate here    polite    turn-taking, in which messages do not
overlap, and agents start writing to the communication channels only after the end-
of-message symbol has been issued. we do not however assume that interaction must
be constrained in this way. on the contrary, there are advantages in letting entities
write to the communication channels whenever they want: for example, the teacher
might interrupt the learner to prevent him from completing a command that would
have disastrous consequences, or the learner may interrupt the teacher as soon as
it    gured out what to do, in order to speed up reward (a simple priority list can be
de   ned to solve con   icts, e.g., teacher   s voice is    louder    than that of environment,
etc.).

note also that our examples are meant to illustrate speci   c instances from a larger
set of trials following similar templates, that should involve a variety of objects, obsta-
cles and possible actions. moreover, the presented examples do not aim to exhaustively
cover all learning-fostering strategies that might be implemented in the ecosystem. fi-
nally, we stress again that we are not thinking of a strict ordering of tasks (not least
because it would be di   cult to    x, a priori, an ordering that is based on some ob-
jective, learning-model-independent di   culty criterion), but rather about clusters of
related tasks organized into levels, such that the learner could cycle through them
and discover its own optimal progression to solve them.

notation we present the input to the learner (messages from teacher and environ-
ment, as well as reward, pre   xed by t:, e: and r:, respectively) in the left column,
and the learner output on the right (messages addressed to the teacher are pre   xed
by @t:, those for the environment are pre   xed by @e:). we assume di   erent i/o
identi   cation pre   xes to disambiguate meta-linguistic statements (e.g.,    t: give order
@e: i move.    in the    rst exchange below, where it   s only the teacher speaking all
the way). the full stop serves as end-of-message delimiter (line breaks are used for
formatting purposes, and should be treated as white space; similarly, hyphens are in-
serted for readability and should be ignored). we use an ellipsis (three dots) to mark
a sequence of messages on any channel we do not report (e.g., the learner exploring
a number of solutions before zeroing in on the right one). finally, we interleave the
conversations with comments, shown in grey.

the learner learns to issue environment commands we start with the teacher
teaching the learner to produce environment commands,    rst by rote repetition chan-
neled to the right message recipient (@e), then by encouraging it to translate from

12

the teacher   s own natural language to the controlled environment language. at this
stage, reward is not tied to understanding what happened (the    semantics    of the
commands). still, a good learner might take note of the actions triggered by the
commands. the following are example conversations that may happen during the
learning process:

input:
t: give order @e: i move.

output:

character soup without addressee, no reward

fdakjf13ktj53u9gs5 5 3#.

. . .

@t: dsfjkasjfk;aljsf.

character soup with wrong addressee, no reward

. . .

@e: fglk4$3wfgg.

right addressee, character soup, no reward

. . .

give order @e: i move.

e: you moved.
r: 1.
learner moves and is rewarded, although the solution is ine   cient
t: give order @e: i move.

. . .

@e: i move.

e: you moved.
r: 1.
learner    gured out minimal string leading to reward

further skills the learner will need to develop include segmentation of teacher   s
input, and production of separate commands for the environment. at    rst, this may
be rather trivial, as shown in this example:

input:
t: give orders @e: i move and @e: i
look.

output:

no reward, because environment does not parse complex commands

@e: i move and @e: i look.

t: give orders @e: i move and @e: i
look.

. . .

e: you moved.

e: there is an apple.

@e: i move.

@e: i look.

13

input:
r: 1.

output:

eventually, the learner should learn to switch    uently between teacher and en-
vironment communication codes, translating the teacher   s linguistic messages into
motor commands to the environment (an example of such exchange is visualized in
figure 1).

associating language to actions next, the learner is encouraged to take notice
of what happens in the environment and associate the teacher   s language to states of
the world, by being rewarded only when its orders result in the corresponding actions
being e   ectively carried out in the world. an example task is illustrated in figure 2,
where the learner will not get reward because it is no longer su   cient for it to correctly
translate instructions into environment commands: the commands must also have the
intended e   ect on the world. in this speci   c case, order execution fails because the
learner encountered a barrier.

learning to generalize by adding su   cient variety to the trials above, the learner
should start to get hold of the compositional nature of commands (turn right and turn
left share systematic characteristics, e.g., they both cause a change in what the learner
sees; the learner can pick x only when x is in the cell in front of him, etc.). the next
trials help the learner further move away from literal command string memorization,
and generalize across categories of actions and objects (turn left/right are instances
of turning, apples and pears are objects, etc.). this is demonstrated in the following
example:

input:
t: turn and move.

e: (no action)

e: you turned left.

e: you can   t move.
there is a barrier in front of learner

e: you turned right.

e: you moved.
r: 1.

output:

@e: i turn.

@e: i turn left.

@e: i move.

@e: i turn right.

@e: i move.

. . .

. . .

14

input:
t: move and look.

output:

input:
e: you moved.

@e: i move.

output:

@e: i look.

e: there is an apple.
r: 1.

figure 1: example of how the simulation might be visualized to help developers track
learner   s behaviour. the left panel represents the environment at the stage in which
learner issues the move command, the right panel depicts the environment after this
command is executed. a lighter shade of green marks the cell the learner occupies,
and the one it is turned towards. these cells are directly observable. (best viewed in
color.)

input:
t: move, turn right and move. e: you moved.

output:

input:

output:

input:
e: you turned right.

output:

@e: i move.

@e: i turn right.

@e: i move.

e: you can   t move.

figure 2: the teacher gives the order move, turn right and move. the learner is
however blocked by a barrier after it turns right, and reward is delayed, because the
order is not executed. (best viewed in color.)

15

in the next example, the learner is asked to pick some object that is in front of
him, without specifying what the object is (we assume that the simple, unambiguous
language of the environment has no words for general categories such as that of object,
so the learner must eventually    nd out that it must name speci   c objects instead):

input:
t: pick an object.

e: (no response)

e: (no response)

e: you picked the pear.
r: 1.

output:

@e: i pick an object.

@e: i pick the apple.

@e: i pick the pear.

as we just illustrated, initially the learner will apply an exhaustive search strategy,
listing all objects it knows of to    nd one it can pick. later, the teacher should teach
the look command, and the learner should be able to discover a faster strategy than
exhaustive search:

input:
t: pick an object.

e: you see a pear.

e: you picked the pear.
r: 1.

output:

@e: i look.

@e: i pick the pear.

learning new strategies of course does not imply that the learner can safely forget
the ones it has previously acquired. for example, in some tasks the look command
might not work (because, say, it is too dark and the learner cannot see what is in
front of him). in such case, an e   cient learner should    nd it easy to re-use previously
learned skills, such as exhaustive search.

understanding higher-level orders the next batch of trials aims at developing
the ability to decompose higher-level commands into a sequence of basic actions,    rst
   xed (move twice), then    exible (   nd an apple). the general teaching strategy is to
provide sets of paired trials: in the    rst trial, the teacher describes the task explicitly
as a sequence of primitive actions, and gives the high-level name of the order.
in
the second trial, the teacher issues an equivalent high-level order, and the learner is
rewarded if it goes through the same sequence as in the    rst trial (we are aware that
many complex linguistic expressions are not amenable to a straightforward decompo-
sitional analysis, see, e.g., boleda and erk, 2015: we will use some that are in order to

16

teach the learner about how to decompose complex concepts into step-by-step plans).
the teacher could start by teaching iteration counters:

input:
t: move and move.

e: you moved.

e: you moved.
r: 1.
t: this is called move two times.

t: move two times.

e: you moved.

e: you moved.
r: 1.

t: move and move and move.

e: you moved.

e: you moved.

e: you moved.
r: 1.
t: this is called move three times.

t: move three times.

e: you moved.

e: you moved.

e: you moved.
r: 1.

output:

@e: i move.

@e: i move.

. . .

. . .

. . .

. . .

. . .

@e: i move.

@e: i move.

@e: i move.

@e: i move.

@e: i move.

@e: i move.

@e: i move.

@e: i move.

the learner should eventually be able to apply modi   ers productively to di   erent

actions without much further training (e.g., apply three times to turn left).

next, the teacher can show how to segment high-level tasks, such as    nding some-

17

thing, into atomic action sequences. for example, to    nd an apple, one can develop a
simple strategy of going forward until an apple is found. the teacher might initiate
the learner to this new skill as follows:

input:
t: move and look.

e: you moved.

e: you see grass.
t: move and look.

e: you moved.

e: you see an apple.
r: 1.
t: this is called    nd an apple.

output:

@e: i move.

@e: i look.

@e: i move.

@e: i look.

note that one such example is not su   cient for the learner to understand what
exactly we call    nding an apple, as multiple interpretations are valid: maybe we just
wanted it to execute the given commands twice. thus, there should be multiple
training sequences of variable length, to clarify that the task is really to apply an
until loop, i.e., to iterate move and look commands until the object the learner is
searching for is found.

further tasks can de   ne composite skills, such as getting an apple, which would
consist of    rst    nding an apple, and then picking it up. another generalization would
be to include multiple objects the learner should be searching for. adding obstacles
to the environment would further complicate the challenge. the previous strategy of
simply going forward until an object is found will not work anymore, as the learner
would stop at the    rst obstacle. we can either expect the learner to independently
develop better search strategies involving turning, or we can add further examples
where the teacher shows the learner how to improve through more direct supervision.

interactive communication tasks such as    nding an apple without directions
might involve a long random search. thus, we want to kick-start interactive commu-
nication, so that the learner can be e   ciently directed by the teacher (and eventually
by humans) to the right cell. in a    rst set of trials, the learner is rewarded for re-
peating a how to request uttered by the teacher (addressing it back to the teacher
via the @t: pre   x), and following the precise instructions produced by the teacher
in response to the request:

input:
t: ask me how to    nd an apple.

output:

18

input:

output:
@e: ask me how to    nd an apple.

wrong addressee, wrong request pre   x

. . .

@t: how to    nd an apple.

t: turn right and move and move and
pick the apple.

e: you turned right.

e: you moved.

e: you moved.

e: you picked the apple.
r: 1.

@e: i turn right.

@e: i move.

@e: i move.

@e: i pick the apple.

trials such as this one are later interspersed with trials where the learner is as-
signed a task it can in principle accomplish by random search, but taking the initiative
by issuing a how to request and then following the precise directions provided by the
teacher will considerably speed up reward.

algorithmic knowledge some tasks illustrated above require understanding basic
control    ow structures. for example, parsing action modi   ers implies a simple form of
counting, and in order to    nd things the learner must implement an until (equiva-
lently, while not) loop. similarly, the command get out of the grass calls for a while
loop. e   cient completion of more advanced tasks, e.g., return home, implies devel-
opment of more complex algorithms, such as path-   nding. after acquiring a bank of
such algorithms (which might be encoded in the internal machine representation by
something very di   erent from programming language constructs), the learner should
be able, in advanced stages of the simulation, to productively combine them in order
to succeed in full-   edged novel missions that involve accomplishing a large number
of hierarchically-structured sub-goals (   nd somebody who will trade two apples for a
banana).

as we discussed in section 3.1, the learner   s functionality could essentially be
interpreted as learning how to compose programs based on the descriptions given in
natural language by the teacher. the programs produce very simple instructions that
are understood by the environment, which can be seen as a sort of cpu. from this
point of view, the intelligent system we aim to train is a bridge between the teacher
(later to be replaced by a human operator) and a traditional computer that under-
stands only a limited set of basic commands and needs to be manually programmed for
each single task. thus, we believe that successful construction of intelligent machines

19

could automate computer programming, which will likely be done in the future simply
through communication in natural language.

3.3 interacting with the trained intelligent machine

to conclude the illustration of our plan, we provide a motivating example of how an
intelligent machine schooled in our ecosystem could later make itself useful in the real
world. we consider a scenario in which the machine works as an assistant to alice, an
elderly person living alone. bob is alice   s son, and he also interacts with the machine.
we assume that, as part of its training, the machine has been taught how to issue
internet commands and process their outcomes. in the example dialogue, we give a
general idea of how the machine would interface to the internet, without attempting to
precisely de   ne the syntax of this interaction. most importantly, the internet queries
in the example are meant to illustrate how the machine does not need to store all the
knowledge it needs to accomplish its duties, as it can retrieve useful information from
the web on demand, and reason about it.

input:
bob: i just spoke to the doctor, who
said my mother needs to move for at
least one hour per day, please make
sure she does get enough exercise.

output:

following conversation takes place the next day:

. . .

alice: yes, but no more than 15 min-
utes, please.

shortly afterwards. . .

a few hours later. . .
alice: i   m going out to buy groceries.

@alice: are you in the mood for some
light physical exercise today?

@internet: [query search engine
for keywords elderly, light activity, 15
minutes]

@alice:
i have downloaded a
youtube video with a 15-minute yoga
routine, please watch it whenever you
can.

@internet: [query search engine
with keywords average walking speed,
elderly person]

20

input:

output:
@internet: [search maps app for
distance to grocery stores in alice   s
neighborhood]
@alice: hey, why don   t you walk to
the yummy food market today?
it
should take you about 45 minutes to
and from, so you   ll get the rest of your
daily exercise.

@alice: thanks for the suggestion.

the communication-based intelligent machine should adapt to a whole range of
tasks it was not explicitly programmed for. if necessary, the user can give it further
explicit positive and negative reward to motivate it to change its behavior. this
may be needed only rarely, as the machine should be shipped to the end users after
it already mastered good communication abilities, and further development should
mostly occur through language. for example, when the user says no, don   t do this
again, the machine will understand that repeating the same type of behavior might
lead to negative reward, and it will change its course of action even when no explicit
reward signal is given (again, another way to put this is that the machine should
associate similar linguistic strings to an    interiorized    negative reward).

the range of tasks for intelligent machines can be very diverse: besides the everyday-
life assistant we just considered, it could explain students how to accomplish home-
work assignments, gather statistical information from the internet to help medical
researchers (see also the examples in section 2.1 above),    nd bugs in computer pro-
grams, or even write programs on its own.
intelligent machines should extend our
intellectual abilities in the same way current computers already function as an exten-
sion to our memory. this should enable us to perform intellectual tasks beyond what
is possible today.

we realize the intelligent machines we aim to construct could become powerful tools
that may be possibly used for dubious purposes (the same could be said about any
advanced technology, including airplanes, space rockets and computers). we believe
the perception of ai is skewed by popular science    ction movies. instead of thinking
of computers that take over the world for their own reasons, we think ai will be
realized as a tool: a machine that will extend our capability to reason and solve
complex problems. further, given the current state of the technology, we believe any
discussion on    friendliness    of the ai is at this moment premature. we expect it will
take years, if not decades to scale basic intelligent machines to become competitive
with humans, giving us enough time to discuss any possible existential threats.

21

4 towards the development of intelligent machines

in this section, we will outline some of our ideas about how to build intelligent machines
that would bene   t from the learning environment we described. while we do not have
a concrete proposal yet about how exactly such machines should be implemented, we
will discuss some of the properties and components we think are needed to support
the desired functionalities. we have no pretense of completeness, we simply want
to provide some food for thought. as in the previous sections, we try to keep the
complexity of the machine at the minimum, and only consider the properties that
seem essential.

4.1 types of learning

there are many types of behavior that we collectively call learning, and it is useful to
discuss some of them    rst. suppose our goal is to build an intelligent machine working
as a translator between two languages (we take here a simpli   ed word-based view of
the translation task). first, we will teach the machine basic communication skills in
our simulated environment so that it can react to requests given by the user. then,
we will start teaching it, by example, how various words are translated.

there are di   erent kinds of learning happening here. to master basic communica-
tion skills, the machine will have to understand the concept of positive and negative
reward, and develop complex strategies to deal with novel linguistic inputs. this
requires discovery of algorithms, and the ability to remember facts, skills and even
learning strategies.

next, in order to translate, the machine needs to store pairs of words. the number
of pairs is unknown and a    exible growing mechanism may be required. however, once
the machine understands how to populate the dictionary with examples, the learning
left to do is of a very simple nature: the machine does not have to update its learn-
ing strategy, but only to store and organize the incoming information into long-term
memory using previously acquired skills. finally, once the vocabulary memorization
process is    nished and the machine starts working as a translator, no further learning
might be required, and the functionality of the machine can be    xed.

the more specialized and narrow the functionality of the machine is, the less learn-
ing is required. for very specialized forms of behavior, it should be possible to program
the solution manually. however, as we move from roles such as a simple translator of
words, a calculator, a chess player, etc., to machines with open-ended goals, we need
to rely more on general learning from a limited number of examples.

one can see the current state of the art in machine learning as being somewhere in
the middle of this hierarchy. tasks such as automatic id103, classi   cation
of objects in images or machine translation are already too hard to be solved purely
through manual programming, and the best systems rely on some form of statistical
learning, where parameters of hand-coded models are estimated from large datasets
of examples. however, the capabilities of state-of-the-art machine learning systems

22

are severely limited, and only allow a small degree of adaptability of the machine   s
functionality. for example, a id103 system will never be able to per-
form speech translation by simply being instructed to do so   a human programmer is
required to implement additional modules manually.

4.2 long-term memory and compositional learning skills

we see a special kind of long-term memory as the key component of the intelligent
machine. this long-term memory should be able to store facts and algorithms cor-
responding to learned skills, making them accessible on demand.
in fact, even the
ability to learn should be seen as a set of skills that are stored in the memory. when
the learning skills are triggered by the current situation, they should compose new
persistent structures in the memory from the existing ones. thus, the machine should
have the capacity to extend itself.

without being able to store previously learned facts and skills, the machine could
not deal with rather trivial assignments, such as recalling the solution to a task that
has been encountered before. moreover, it is often the case that the solution to a new
task is related to that of earlier tasks. consider for example the following sequence of
tasks in our simulated environment:

       nd and pick an apple;
    bring the apple back home;
       nd two apples;
       nd one apple and two bananas and bring them home.

skills required to solve these tasks include:
    the ability to search around the current location;
    the ability to pick things;
    the ability to remember the location of home and return to it;
    the ability to understand what one and two mean;
    the ability to combine the previous skills (and more) to deal with di   erent re-

quests.

the    rst four abilities correspond to simple facts or skills to be stored in memory: a
sequence of symbols denoting something, the steps needed to perform a certain action,
etc. the last ability is an example of a compositional learning skill, with the capability
of producing new structures by composing together known facts and skills. thanks to
such learning skills, the machine will be able to combine several existing abilities to

23

create a new one, often on the    y. in this way, a well-functioning intelligent machine
will not need a myriad of training examples whenever it faces a slightly new request,
but it could succeed given a single example of the new functionality. for example,
when the teacher asks the learner to    nd one apple and two bananas and bring them
home, if the learner already understands all the individual abilities involved, it can
retrieve the relevant compositional learning skill to put together a plan and execute it
step by step. the teacher may even call the new skill generated in this way prepare
breakfast, and refer to it later as such. understanding this new concept should not
require any further training of the learner, and the latter should simply store the new
skill together with its label in its long-term memory.

as we have seen in the previous examples, the learner can continue extending its
knowledge of words, commands and skills in a completely unsupervised way once it
manages to acquire skills that allow it to compose structures in its long-term memory.
it may be that discovering the basic learning skills, something we usually take for
granted, is much more intricate than it seems to us. but once we will be able to build
a machine which can e   ectively construct itself based on the incoming signals    even
when no explicit supervision in the form of rewards is given, as discussed above    we
should be much closer to the development of intelligent machines.

4.3 computational properties of intelligent machines

another aspect of the intelligent machine that deserves discussion is the computational
model that the machine will be based on. we are convinced that such model should
be unrestricted, that is, able to represent any pattern in the data. humans can think
of and talk about algorithms without obvious limitations (although, to apply them,
they might need to rely on external supports, such as paper and pencil). a useful
intelligent machine should be able to handle such algorithms as well.

a more precise formulation of our claim in the context of the theory of computation
is that the intelligent machine needs to be based on a turing-complete computational
model. that is, it has to be able to represent any algorithm in    xed length, just like
the turing machine (the very fact that humans can describe turing-complete systems
shows that they are, in practical terms, turing-complete:
it is irrelevant, for our
purposes, whether human online processing capabilities are strictly turing-complete   
what matters is that their reasoning skills, at least when aided by external supports,
are). note that there are many turing-complete computational systems, and turing
machines in particular are a lot less e   cient than some alternatives, e.g., random
access machines. thus, we are not interested in building the intelligent machine
around the concept of the turing machine; we just aim to use a computational model
that does not have obvious limitations in ability to represent patterns.

a system that is weaker than turing-complete cannot represent certain patterns in
the data e   ciently, which in turn means it cannot truly learn them in a general sense.
however, it is possible to memorize such complex patterns up to some    nite level

24

of complexity. thus, even a computationally restricted system may appear to work
as intended up to some level of accuracy, given that a su   cient number of training
examples is provided.

for example, we may consider a sequence repetition problem. the machine is
supposed to remember a sequence of symbols and reproduce it later. further, let   s
assume the machine is based on a model with the representational power of    nite
state machines. such system is not capable to represent the concept of storing and
reproducing a sequence. however, it may appear to do so if we design our experiment
imperfectly. assume there is a signi   cant overlap between what the machine sees
as training data, and the test data we use to evaluate performance of the machine.
a trivial machine that can function as a look-up table may appear to work, simply
by storing and recalling the training examples. with an in   nite number of training
examples, a look-up-table-based machine would appear to learn any regularity.
it
will work indistinguishably from a machine that can truly represent the concept of
repetition; however, it will need to have in   nite size. clearly, such memorization-
based system will not perform well in our setting, as we aim to test the learner   s
ability to generalize from a few examples.

since there are many turing-complete computational systems, one may wonder
which one should be preferred as the basis for machine intelligence. we cannot answer
this question yet, however we hypothesize that the most natural choice would be a
system that performs computation in a parallel way, using elementary units that can
grow in number based on the task at hand. the growing property is necessary to
support the long-term memory, if we assume that the basic units themselves are    nite.
an example of an existing computational system with many of the desired properties
is the cellular automaton of von neumann et al. (1966). we might also be inspired by
string rewriting systems, for example some versions of the l-systems (prusinkiewicz
and lindenmayer, 2012).

an apparent alternative would be to use a non-growing model with immensely
large capacity. there is however an important di   erence. in a growing model, the
new cells can be connected to those that spawned them, so that the model is naturally
able to develop a meaningful topological structure based on functional connectivity.
we conjecture that such structure would in itself contribute to learning in a crucial
way. on the other hand, it is not clear if such topological structure can arise in a
large-capacity unstructured model. interestingly, some of the more e   ective machine-
learning models available today, such as recurrent and convolutional neural networks,
are characterized by (manually constrained) network topologies that are well-suited to
the domains they are applied to.

5 related ideas

we owe, of course, a large debt to the seminal work of turing (1950). note that,
while turing   s paper is most often cited for the    imitation game   , there are other very

25

interesting ideas in it, worthy of more attention from curious readers, especially in
the last section on learning machines. turing thought that a good way to construct a
machine capable of passing his famous test would be to develop a child machine, and
teach it further skills through various communication channels. these would include
sparse rewards shaping the behavior of the child machine, and other information-rich
channels such as language input from a teacher and sensory information.

we share turing   s goal of developing a child machine capable of independent com-
munication through natural language, and we also stress the importance of sparse
rewards. the main distinction between his and our vision is that turing assumed
that the child machine would be largely programmed (he gives an estimate of sixty
programmers working on it for    fty years). we rather think of starting with a machine
only endowed with very elementary skills, and focus on the capability to learn as the
fundamental ability that needs to be developed. this further assumes educating the
machine at    rst in a simulated environment where an arti   cial teacher will train it, as
we outlined in our roadmap. we also diverge with respect to the imitation game, since
the purpose of our intelligent machine is not to fool human judges into believing it is
actually a real person. instead, we aim to develop a machine that can perform a sim-
ilar set of tasks to those a human can do by using a computer, an internet connection
and the ability to communicate.

there has been a recent revival of interest in tasks measuring computational intel-
ligence, spurred by the empirical advances of powerful machine-learning architectures
such as multi-layered neural networks (lecun et al., 2015), and by the patent inade-
quacy of the classic version of turing test (wikipedia, 2015c). for example, levesque
et al. (2012) propose to test systems on their ability to resolve coreferential ambiguities
(the trophy would not    t in the brown suitcase because it was too big. . . what was too
big? ). geman et al. (2015) propose a    visual    turing test in which a computational
system is asked to answer a set of increasingly speci   c questions about objects, at-
tributes and relations in a picture (is there a person in the blue region? is the person
carrying something? is the person interacting with any other object? ). similar initia-
tives di   er from ours in that they focus on a speci   c set of skills (coreference, image
parsing) rather than testing if an agent can learn new skills. moreover, these are tra-
ditional evaluation benchmarks, unlike the hybrid learning/evaluation ecosystem we
are proposing.

the idea of developing an ai living in a controlled synthetic environment and in-
teracting with other agents through natural language is quite old. the blocks world
of winograd (1971) is probably the most important example of early research in this
vein. the approach was later abandoned, when it became clear that the agents devel-
oped within this framework did not scale up to real-world challenges (see, e.g., morelli
et al., 1992). the knowledge encoded in the systems tested by these early simulations
was manually programmed by their creators, since they had very limited learning ca-
pabilities. consequently, scaling up to the real world implied manual coding of all
the knowledge necessary to cope with it, and this proved infeasible. our simulation

26

is instead aiming at systems that encode very little prior knowledge and have strong
capabilities to learn from data. importantly, our plan is not to try to manually pro-
gram all possible scripts our system might encounter later, as in some of the classic ai
systems. we plan to program only the initial environment, in order to kickstart the
machine   s ability to learn and adapt to di   erent problems and scenarios. after the
simulated environment is mastered, scaling up the functionality of our learner will
not require further manual work on scripting new situations, but will rather focus on
integrating real world inputs, such as those coming from human users. the toy world
itself is already designed to feature novel tasks of increasing complexity, explicitly
testing the abilities of systems to autonomously scale up.

still, we should not underestimate the drawbacks of synthetic simulations. the
tasks in our environment might directly address some challenging points in the de-
velopment of ai, such as learning with very weak supervision, being able to form a
structured long-term memory, and the ability of the child machine to grow in size and
complexity when encountering new problems. however, simulating the real world can
only bring us so far, and we might end up overestimating the importance of some arbi-
trary phenomena at the expense of others, that might turn out to be more common in
natural settings. it may be important to bring reality into the picture relatively soon.
our toy world should let the intelligent machine develop to the point at which it is able
to learn from and cooperate with actual humans. interaction with real-life humans
will then naturally lead the machine to deal with real-world problems. the issue of
when exactly a machine trained in our controlled synthetic environment is ready to
go out in the human world is open, and it should be explored empirically. however,
at the same time, we believe that having the machine interact with humans before it
can deal with basic problems in the controlled environment would be pointless, and
possibly even strongly misleading.

our intelligent machine shares some of its desired functionalities with the current
generation of automated personal assistants such as apple   s siri ad microsoft   s cor-
tana. however, these are heavily engineered systems that aim to provide a natural
language interface for human users to perform a varied but    xed set of tasks (similar
considerations also apply to arti   cial human companions and digital pets such as tam-
agotchi, see wikipedia, 2015a). such systems can be developed by de   ning the most
frequent use cases, choosing those that can be solved with the current technology (e.g.,
book an air ticket, look at the weather forecast and set the alarm clock for tomorrow   s
morning), and implementing speci   c solutions for each such use case. our intelligent
machine is not intended to handle just a    xed set of tasks. as exempli   ed by the
example in section 3.3, the machine should be capable to learn e   ciently how to per-
form tasks such as those currently handled by personal assistants, and more, just from
interaction with the human user (without a programmer or machine learning expert
in the loop).

architectures for software agents, and more speci   cally intelligent agents, are
widely studied in ai and related    elds (nwana, 1996; russell and norvig, 2009). we

27

cannot review this ample literature here, in order to position our proposal precisely
with respect to it. we simply remark that we are not aware of other architectures that
are as centered on learning and communication as ours. interaction plays a central
role in the study of multiagent systems (shoham and leyton-brown, 2009). however,
the emphasis in this research tradition is on how con   ict resolution and distributed
problem solving evolve in typically large groups of simple, mostly scripted agents. for
example, tra   c modeling is a classic application scenario for multiagent systems. this
is very di   erent from our emphasis on linguistic interaction for the purposes of training
a single agent that should become independently capable of very complex behaviours.
tenenbaum (2015), like us, emphasizes the need to focus on basic abilities that
form the core of intelligence. however, he takes naive physics problems as the starting
point, and discusses speci   c classes of probabilistic models, rather than proposing
a general learning scenario. there are also some similarities between our proposal
and the research program of luc steels (e.g., steels, 2003, 2005), who lets robots
evolve vocabularies and grammatical constructions through interaction in a situated
environment. however, on the one hand his agents are actual robots subject to the
practical hardware limitations imposed by the need to navigate a complex natural
environment from the start; on the other, the focus of the simulations is narrowly on
id146, with no further aim to develop broadly intelligent agents.

we have several points of contact with the id29 literature, such as nav-
igation tasks in an arti   cial world (macmahon et al., 2006) and reward-based learning
from natural language instructions (chen and mooney, 2011; artzi and zettlemoyer,
2013). the agents developed in this area can perform tasks, such as learning to execute
instructions in natural environments by interacting with humans (thomason et al.,
2015), or improving performance on real-life video-games by consulting the instruc-
tion manual (branavan et al., 2012), that we would want our intelligent machines to
also be able to carry out. however, current semantic-parsing-based systems achieve
these impressive feats by exploiting architectures tuned to the speci   c tasks at hand,
and they rely on a fair amount of hard-wired expert knowledge, in particular about
language structures (although recent work is moving towards a more knowledge-lean
direction, see for example narasimhan et al., 2015, who train a neural network to play
text-based adventure games using only text descriptions as input and game reward
as signal). our framework is meant to encourage the development of systems that
should eventually be able to perform similar tasks, but getting there incrementally,
starting with almost no prior knowledge and    rst learning from their environment a
set of simpler skills, and how to creatively merge them to tackle more ambitious goals.
the last twenty years have witnessed several related proposals on learning to learn
(thrun and pratt, 1997), lifelong learning (silver et al., 2013) and continual learning
(ring, 1997). much of this work is theoretical in nature and focuses on algorithms
rather than on empirical challenges for the proposed models. still, the general ideas
being pursued are in line with our program. ring (1997), in particular, de   nes a
continual-learning agent whose experiences    occur sequentially, and what it learns at

28

one time step while solving one task, it can use later, perhaps to solve a completely
di   erent task.    ring   s desiderata for the continual learner are remarkably in line
with ours. it is    an autonomous agent. it senses, takes actions, and responds to the
rewards in its environment. it learns behaviors and skills while solving its tasks. it
learns incrementally. there is no    xed training set; learning occurs at every time step;
and the skills the agent learns now can be used later. it learns hierarchically. skills
it learns now can be built upon and modi   ed later. it is a black box. the internals
of the agent need not be understood or manipulated. all of the agent   s behaviors are
developed through training, not through direct manipulation.
its only interface to
the world is through its senses, actions, and rewards. it has no ultimate,    nal task.
what the agent learns now may or may not be useful later, depending on what tasks
come next.    our program is de   nitely in the same spirit, with an extra emphasis on
interaction.

mitchell et al. (2015) discuss nell, the most fully realized concrete implementa-
tion of a lifelong learning architecture. nell is an agent that has been    reading the
web    for several years to extract a large knowledge base. emphasis is on the never-
ending nature of the involved tasks, on their incremental re   nement based on what
nell has learned, and on sharing information across tasks. in this latter respect,
this project is close to id72 (ando and zhang, 2005; caruana, 1997;
collobert et al., 2011), that focuses on the idea of parameter sharing across tasks. it
is likely that a successful learner in our framework will exploit similar strategies, but
our current focus lies on de   ning the tasks, rather than on how to pursue them.

bengio et al. (2009) propose the related idea of curriculum learning, whereby train-
ing data for a single task are ordered according to a di   culty criterion, in the hope that
this will lead to better learning. this is motivated by the observation that humans
learn incrementally when developing complex skills, an idea that has also previously
been studied in the context of recurrent neural network training by elman (1993).
the principle of incremental learning is also central to our proposal. however, the
fundamental aspect for us is not a strict ordering of the training data for a speci   c
task, but incrementality in the skills that the intelligent machine should develop. this
sort of incrementality should in turn be boosted by designing separate tasks with a
compositional structure, such that the skills acquired from the simpler tasks will help
to solve the more advanced ones more e   ciently.

the idea of incremental learning, motivated by the same considerations as in the
papers we just mentioned, also appears in solomono    (2002), a work which has much
earlier roots in research on program induction (solomono   , 1964, 1997; schmidhu-
ber, 2004). within this tradition, schmidhuber (2015) reviews a large literature and
presents some general ideas on learning that might inspire our search for novel algo-
rithms. genetic programming (poli et al., 2008) also focuses on the reuse of previously
found sub-solutions, speeding up the search procedure in this way. our proposal is
also related to that of bottou (2014), in its vision of compositional machine learn-
ing, although he only considers composition in limited domains, such as sentence and

29

image processing.

we share many ideas with the id23 framework (sutton and barto,
1998). in id23, the agent chooses actions in an environment in order
to maximize some cumulative reward over time. id23 is particularly
popular for problems where the agent can collect information only by interacting
with the environment. given how broad this de   nition is, our framework could be
considered as a particular instance of it. our proposal is however markedly di   erent
from standard id23 work (kaelbling et al., 1996) in several respects.
speci   cally, we emphasize language-mediated, interactive communication, we focus
on incremental strategies that encourage agents to solve tasks by reusing previously
learned knowledge and we aim to limit the number of trials an agent gets in order to
accomplish a certain goal.

mnih et al. (2015) recently presented a single neural network architecture capable
of learning a set of classic atari games using only pixels and game scores as input
(see also the related idea of    general game playing   , e.g., genesereth et al., 2005). we
pursue a similar goal of learning from a low-level input stream and reward. however,
unlike these authors, we do not aim for a single architecture that can, disjointly, learn
an array of separate tasks, but for one that can incrementally build on skills learned
on previous tasks to perform more complex ones. moreover, together with reward,
we emphasize linguistic interaction as a fundamental mean to foster skill extension.
sukhbaatar et al. (2015) introduce a sandbox to design games with the explicit purpose
to train computational agents in planning and reasoning tasks. moreover, they stress a
curriculum strategy to foster learning (making the agent progress through increasingly
more di   cult versions of the game). their general program is aligned with ours,
and the sandbox might be useful to develop our environment. however, they do
not share our emphasis on communication and interaction, and their approach to
incremental learning is based on increasingly more di   cult versions of the same task
(e.g., increasing the number of obstacles), rather than on de   ning progressively more
complex tasks, such that solving the later ones requires composing solutions to earlier
ones, as we are proposing. furthermore, the tasks currently considered within the
sandbox do not seem to be challenging enough to require new learning approaches,
and may be solvable with current techniques or minor modi   cations thereof.

mikolov (2013) originally discussed a preliminary version of the incremental task-
in a similar spirit, weston et al.
based approach we are more fully outlying here.
(2015) present a set of id53 tasks based on synthetically generated
stories. they also want to foster non-incremental progress in ai, but their approach
di   ers from ours in several crucial aspects. again, there is no notion of interactive,
language-mediated learning, a classic train/test split is enforced, and the tasks are not
designed to encourage compositional skill learning (although weston and colleagues do
emphasize that the same system should be used for all tasks). finally, the evaluation
metric is notably di   erent from ours - while we aim to minimize the number of trials
it takes for the machine to master the tasks, their goal is to have a good performance

30

on held out data. this could be a serious drawback for works that involve arti   cial
tasks, as in our view the goal should be to develop a machine that can learn as fast
as possible, to have any hope to scale up and be able to generalize in more complex
scenarios.

one could think of solving sequence-manipulation problems such as those consti-
tuting the basis of our learning routine with relatively small extensions of established
machine learning techniques (graves et al., 2014; grefenstette et al., 2015; joulin and
mikolov, 2015). as discussed in the previous section, for simple tasks that involve only
a small,    nite number of con   gurations, one could be apparently successful even just
by using a look-up table storing all possible combinations of inputs and outputs. the
above mentioned works, that aim to learn algorithms from data, also add a long-term
memory (e.g., a set of stacks), but they use it to store the data only, not the learned
algorithms. thus, such approaches fail to generalize in environments where solutions
to new tasks are composed of already learned algorithms.

similar criticism holds for approaches that try to learn certain algorithms by using
an architecture with a strong prior towards their discovery, but not general enough
to represent even small modi   cations. to give an example from our own work: a
recurrent neural network augmented with a stack structure can form a simple kind of
long-term memory and learn to memorize and repeat sequences in the reversed order,
but not in the original one (joulin and mikolov, 2015). we expect a valid solution
to the algorithmic learning challenge to utilize a small number of training examples,
and to learn tasks that are closely related at an increasing speed, i.e., to require less
and less examples to master new skills that are related to what is already known. we
are not aware of any current technique addressing these issues, which were the very
reason why algorithmic tasks were originally proposed by mikolov (2013). we hope
that this paper will motivate the design of the genuinely novel methods we need in
order to develop intelligent machines.

6 conclusion

we de   ned basic desiderata for an intelligent machine, stressing learning and commu-
nication as its fundamental abilities. contrary to common practice in current machine
learning, where the focus is on modeling single skills in isolation, we believe that all
aspects of intelligence should be holistically addressed within a single system.

we proposed a simulated environment that requires the intelligent machine to
acquire new facts and skills through communication. in this environment, the machine
must learn to perform increasingly more ambitious tasks, being naturally induced to
develop complex linguistic and reasoning abilities.

we also presented some conjectures on the properties of the computational system
that the intelligent machine may be based on. these include learning of algorithmic
patterns from a few examples without strong supervision, and development of a long-
term memory to store both data and learned skills. we tried to put this in contrast with

31

currently accepted paradigms in machine learning, to show that current methods are
far from adequate, and we must strive to develop non-incrementally novel techniques.
this roadmap constitutes only the beginning of a long journey towards ai, and we

hope other researchers will be joining it in pursuing the goals it outlined.

acknowledgments

we thank l  eon bottou, yann lecun, gabriel synnaeve, arthur szlam, nicolas usunier,
laurens van der maaten, wojciech zaremba and others from the facebook ai research
team, as well as gemma boleda, katrin erk, germ  an kruszewski, angeliki lazaridou,
louise mcnally, hinrich sch  utze and roberto zamparelli for many stimulating discus-
sions. an early version of this proposal has been discussed in several research groups
since 2013 under the name incremental learning of algorithms (mikolov, 2013).

references

ando, r. and zhang, t. (2005). a framework for learning predictive structures from
multiple tasks and unlabeled data. journal of machine learning research, 5:1817   
1853.

artzi, y. and zettlemoyer, l. (2013). weakly supervised learning of semantic parsers
for mapping instructions to actions. transactions of the association for computa-
tional linguistics, 1(1):49   62.

bengio, y., louradour, j., collobert, r., and weston, j. (2009). curriculum learning.

in proceedings of icml, pages 41   48, montreal, canada.

boleda, g. and erk, k. (2015). distributional semantic features as semantic
primitives   or not.
in proceedings of the aaai spring symposium on knowledge
representation and reasoning: integrating symbolic and neural approaches, pages
2   5, stanford, ca.

bottou, l. (2014). from machine learning to machine reasoning: an essay. machine

learning, 94:133   149.

branavan, s., silver, d., and barzilay, r. (2012). learning to win by reading manuals
in a monte-carlo framework. journal of arti   cial intelligence research, 43:661   704.

caruana, r. (1997). multitask learning. machine learning, 28:41   75.

chen, d. and mooney, r. (2011). learning to interpret natural language naviga-
tion instructions from observations. in proceedings of aaai, pages 859   865, san
francisco, ca.

32

collobert, r., weston, j., bottou, l., karlen, m., kavukcuoglu, k., and kuksa, p.
(2011). natural language processing (almost) from scratch. journal of machine
learning research, 12:2493   2537.

elman, j. (1993). learning and development in neural networks: the importance of

starting small. cognition, 48:71   99.

erk, k. (2012). vector space models of word meaning and phrase meaning: a survey.

language and linguistics compass, 6(10):635   653.

fodor, j. (1975). the language of thought. crowell press, new york.

geman, d., geman, s., hallonquist, n., and younes, l. (2015). visual turing test
for id161 systems. proceedings of the national academy of sciences,
112(12):3618   3623.

genesereth, m., love, n., and pell, b. (2005). general game playing: overview of the

aaai competition. ai magazine, 26(2):62   72.

graves, a., wayne, g., and danihelka, i. (2014). id63s. http:

//arxiv.org/abs/1410.5401.

grefenstette, e., hermann, k., suleyman, m., and blunsom, p. (2015). learning to
transduce with unbounded memory. in proceedings of nips, montreal, canada. in
press.

haugeland, j. (1985). arti   cial intelligence: the very idea. mit press, cambridge,

ma.

joulin, a. and mikolov, t. (2015).

inferring algorithmic patterns with stack-

augmented recurrent nets. in proceedings of nips, montreal, canada. in press.

kaelbling, l. p., littman, m. l., and moore, a. w. (1996). id23:

a survey. journal of arti   cial intelligence research, pages 237   285.

lecun, y., bengio, y., and hinton, g. (2015). deep learning. nature, 521:436   444.

levesque, h. j., davis, e., and morgenstern, l. (2012). the winograd schema chal-

lenge. in proceedings of kr, pages 362   372, rome, italy.

louwerse, m. (2011). symbol interdependency in symbolic and embodied cognition.

topics in cognitive science, 3:273   302.

macmahon, m., stankiewicz, b., and kuipers, b. (2006). walk the talk: connecting
in proceedings of aaai,

language, knowledge, and action in route instructions.
pages 1475   1482, boston, ma.

mikolov, t. (2013). incremental learning of algorithms. unpublished manuscript.

33

mikolov, t., chen, k., corrado, g., and dean, j. (2013). e   cient estimation of word

representations in vector space. http://arxiv.org/abs/1301.3781/.

mitchell, t., cohen, w., hruschka, e., talukdar, p., betteridge, j., carlson, a.,
mishra, b., gardner, m., kisiel, b., krishnamurthy, j., lao, n., mazaitis, k.,
mohamed, t., nakashole, n., platanios, e., ritter, a., samadi, m., settles, b.,
wang, r., wijaya, d., gupta, a., chen, x., saparov, a., greaves, m., and welling,
j. (2015). never-ending learning. in proceedings of aaai, pages 2302   2310, austin,
tx.

mnih, v., kavukcuoglu, k., silver, d., rusu, a., veness, j., bellemare, m., graves,
a., riedmiller, m., fidjeland, a., ostrovski, g., petersen, s., beattie, c., sadik,
a., antonoglou, i., king, h., kumaran, d., wierstra, d., legg, s., and hassabis, d.
(2015). human-level control through deep id23. nature, 518:529   
533.

morelli, r., brown, m., anselmi, d., haberlandt, k., and lloyd, d., editors (1992).
minds, brains, and computers: perspectives in cognitive science and arti   cial
intelligence. ablex, norwood, nj.

narasimhan, k., kulkarni, t., and barzilay, r. (2015). language understanding for
in proceedings of emnlp,

text-based games using deep id23.
pages 1   11, lisbon, portugal.

nwana, h. (1996). software agents: an overview. knowledge engineering review,

11(2):1   40.

poli, r., langdon, w., mcphee, n., and koza, j. (2008). a    eld guide to genetic

programming. http://www.gp-field-guide.org.uk.

prusinkiewicz, p. and lindenmayer, a. (2012). the algorithmic beauty of plants.

springer science & business media.

ring, m. (1997). child: a    rst step towards continual learning. machine learning,

28:77   104.

russell, s. and norvig, p. (2009). arti   cial intelligence: a modern approach, 3d ed.

pearson education, new york.

schmidhuber, j. (2004). optimal ordered problem solver. machine learning,

54(3):211   254.

schmidhuber, j. (2015). on learning to think: algorithmic id205 for
novel combinations of id23 controllers and recurrent neural world
models. http://arxiv.org/abs/1511.09249.

34

shoham, y. and leyton-brown, k. (2009). multiagent systems. cambridge university

press, cambridge.

silver, d., yang, q., and li, l. (2013). lifelong machine learning systems: beyond
in proceedings of the aaai spring symposium on lifelong

learning algorithms.
machine learning, pages 49   55, stanford, ca.

solomono   , r. j. (1964). a formal theory of inductive id136. part i. information

and control, 7(1):1   22.

solomono   , r. j. (1997). the discovery of algorithmic id203. journal of com-

puter and system sciences, 55(1):73   88.

solomono   , r. j. (2002). progress in incremental machine learning. in nips workshop

on universal learning algorithms and optimal search, whistler, bc. citeseer.

steels, l. (2003). social language learning. in tokoro, m. and steels, l., editors, the

future of learning, pages 133   162. ios, amsterdam.

steels, l. (2005). what triggers the emergence of grammar? in proceedings of eelc,

pages 143   150, hat   eld, uk.

sukhbaatar, s., szlam, a., synnaeve, g., chintala, s., and fergus, r. (2015). maze-

base: a sandbox for learning from games. http://arxiv.org/abs/1511.07401.

sutton, r. and barto, a. (1998). id23: an introduction. mit

press, cambridge, ma.

tenenbaum, j. (2015). cognitive foundations for id99 in ai.
presented at the aaai spring symposium on id99 and rea-
soning.

thomason, j., zhang, s., mooney, r., and stone, p. (2015). learning to interpret
in proceedings ijcai,

natural language commands through human-robot dialog.
pages 1923   1929, buenos aires, argentina.

thrun, s. and pratt, l., editors (1997). learning to learn. kluwer, dordrecht.

turing, a. (1950). computing machinery and intelligence. mind, 59:433   460.

turney, p. and pantel, p. (2010). from frequency to meaning: vector space models of

semantics. journal of arti   cial intelligence research, 37:141   188.

von neumann, j., burks, a. w., et al. (1966). theory of self-reproducing automata.

ieee transactions on neural networks, 5(1):3   14.

35

weston, j., bordes, a., chopra, s., and mikolov, t. (2015). towards ai-complete
id53: a set of prerequisite toy tasks. http://arxiv.org/abs/1502.
05698.

wikipedia (2015a). arti   cial human companion.

https://en.wikipedia.org/
w/index.php?title=artificial_human_companion&oldid=685507143. accessed
15-october-2015.

wikipedia (2015b). interactive    ction. https://en.wikipedia.org/w/index.php?

title=interactive_fiction&oldid=693926750. accessed 19-december-2015.

wikipedia (2015c). turing test. https://en.wikipedia.org/w/index.php?title=

turing_test&oldid=673582926. accessed 30-july-2015.

winograd, t. (1971). procedures as a representation for data in a computer pro-
gram for understanding natural language. technical report ai 235, massachusetts
institute of technology.

36

