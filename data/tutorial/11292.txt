learning language games through interaction

sida i. wang

percy liang

christopher d. manning

computer science department

stanford university

{sidaw,pliang,manning}@cs.stanford.edu

6
1
0
2

 

n
u
j
 

8

 
 
]
l
c
.
s
c
[
 
 

1
v
7
4
4
2
0

.

6
0
6
1
:
v
i
x
r
a

abstract

we introduce a new language learning
setting relevant to building adaptive nat-
ural language interfaces.
it is inspired
by wittgenstein   s language games: a hu-
man wishes to accomplish some task
(e.g., achieving a certain con   guration of
blocks), but can only communicate with a
computer, who performs the actual actions
(e.g., removing all red blocks). the com-
puter initially knows nothing about lan-
guage and therefore must learn it from
scratch through interaction, while the hu-
man adapts to the computer   s capabilities.
we created a game called shrdlurn in
a blocks world and collected interactions
from 100 people playing it. first, we an-
alyze the humans    strategies, showing that
using compositionality and avoiding syn-
onyms correlates positively with task per-
formance. second, we compare computer
strategies, showing that modeling prag-
matics on a id29 model accel-
erates learning for more strategic players.

introduction

1
wittgenstein (1953) famously said that language
derives its meaning from use, and introduced the
concept of language games to illustrate the    uid-
ity and purpose-orientedness of language. he de-
scribed how a builder b and an assistant a can use
a primitive language consisting of four words   
   block   ,    pillar   ,    slab   ,    beam      to successfully
communicate what block to pass from a to b. this
is only one such language; many others would also
work for accomplishing the cooperative goal.

this paper operationalizes and explores the idea
of language games in a learning setting, which we
call interactive learning through language games

figure 1: the shrdlurn game: the objective
is to transform the start state into the goal state.
the human types in an utterance, and the computer
(which does not know the goal state) tries to in-
terpret the utterance and perform the correspond-
ing action. the computer initially knows nothing
about the language, but through the human   s feed-
back, learns the human   s language while making
progress towards the game goal.

(illg). in the illg setting, the two parties do not
initially speak a common language, but nonethe-
less need to collaboratively accomplish a goal.
speci   cally, we created a game called shrd-
lurn,1 in homage to the seminal work of wino-
grad (1972). as shown in figure 1, the objective
is to transform a start state into a goal state, but
the only action the human can take is entering an
utterance. the computer parses the utterance and
produces a ranked list of possible interpretations
according to its current model. the human scrolls
through the list and chooses the intended one, si-
multaneously advancing the state of the blocks and
providing feedback to the computer. both the hu-
man and the computer wish to reach the goal state

1demo: http://shrdlurn.sidaw.xyz

(only known to the human) with as little scrolling
as possible. for the computer to be successful, it
has to learn the human   s language quickly over the
course of the game, so that the human can accom-
plish the goal more ef   ciently. conversely, the hu-
man must also accommodate the computer, at least
partially understanding what it can and cannot do.
we model the computer in the illg as a se-
mantic parser (section 3), which maps natural lan-
guage utterances (e.g.,    remove red   ) into logical
forms (e.g., remove(with(red))). the seman-
tic parser has no seed lexicon and no annotated
logical forms, so it just generates many candidate
logical forms. based on the human   s feedback, it
performs online gradient updates on the parame-
ters corresponding to simple lexical features.

during development,

it became evident that
while the computer was eventually able to learn
the language, it was learning less quickly than
one might hope. for example, after learning that
   remove red    maps to remove(with(red)),
it would think that    remove cyan    also mapped
to remove(with(red)), whereas a human
would likely use mutual exclusivity to rule out that
hypothesis (markman and wachtel, 1988). we
therefore introduce a pragmatics model in which
the computer explicitly reasons about the human,
in the spirit of previous work on pragmatics (gol-
land et al., 2010; frank and goodman, 2012;
smith et al., 2013). to make the model suitable
for our illg setting, we introduce a new online
learning algorithm. empirically, we show that our
pragmatic model improves the online accuracy by
8% compared to our best non-pragmatic model on
the 10 most successful players (section 5.3).

what is special about the illg setting is the
real-time nature of learning, in which the human
also learns and adapts to the computer. while
the human can teach the computer any language   
english, arabic, polish, a custom programming
language   a good human player will choose to
use utterances that the computer is more likely to
learn quickly. in the parlance of communication
theory, the human accommodates the computer
(giles, 2008; ireland et al., 2011). using ama-
zon mechanical turk, we collected and analyzed
around 10k utterances from 100 games of shrd-
lurn. we show that successful players tend to
use compositional utterances with a consistent vo-
cabulary and syntax, which matches the inductive
biases of the computer (section 5.2). in addition,

through this interaction, many players adapt to the
computer by becoming more consistent, more pre-
cise, and more concise.

on the practical side, natural language systems
are often trained once and deployed, and users
must live with their imperfections. we believe
that studying the illg setting will be integral for
creating adaptive and customizable systems, es-
pecially for resource-poor languages and new do-
mains where starting from close to scratch is un-
avoidable.

2 setting

(e.g.

we now describe the interactive learning of lan-
guage games (illg) setting formally. there are
two players, the human and the computer. the
game proceeds through a    xed number of levels.
in each level, both players are presented with a
starting state s     y, but only the human sees
the goal state t     y.
in shrdlurn, y
is the set of all con   gurations of blocks). the
human transmits an utterance x (e.g.,    remove
red   ) to the computer. the computer then con-
structs a ranked list of candidate actions z =
[z1, . . . , zk]     z (e.g., remove(with(red)),
add(with(orange)), etc.), where z is all
possible actions. for each zi     z, it computes

yi =(cid:74)zi(cid:75)s, the successor state from executing ac-

tion zi on state s. the computer returns to the hu-
man the ordered list y = [y1, . . . , yk] of succes-
sor states. the human then chooses yi from the list
y (we say the computer is correct if i = 1). the
state then updates to s = yi. the level ends when
s = t, and the players advance to the next level.

since only the human knows the goal state t and
only the computer can perform actions, the only
way for the two to play the game successfully is
for the human to somehow encode the desired ac-
tion in the utterance x. however, we assume the
two players do not have a shared language, so the
human needs to pick a language and teach it to the
computer. as an additional twist, the human does
not know the exact set of actions z (although they
might have some preconception of the computer   s
capabilities).2 finally, the human only sees the
outcomes of the computer   s actions, not the actual
logical actions themselves.

we expect the game to proceed as follows: in
the beginning, the computer does not understand

2this is often the case when we try to interact with a new

software system or service before reading the manual.

what the human is saying and performs arbitrary
actions. as the computer obtains feedback and
learns, the two should become more pro   cient at
communicating and thus playing the game. herein
lies our key design principle: language learning
should be necessary for the players to achieve
good game performance.
shrdlurn. let us now describe the details
of our speci   c game, shrdlurn. each state
s     y consists of stacks of colored blocks ar-
ranged in a line (figure 1), where each stack
is a vertical column of blocks.
the actions
z are de   ned compositionally via the gram-
mar in table 1.
each action either adds to
or removes from a set of stacks, and a set of
stacks is computed via various set operations
and selecting by color. for example, the action
remove(leftmost(with(red))) removes the
top block from the leftmost stack whose topmost
block is red. the compositionality of the actions
gives the computer non-trivial capabilities. of
course, the human must teach a language to har-
ness those capabilities, while not quite knowing
the exact extent of the capabilities. the actual
game proceeds according to a curriculum, where
the earlier levels only need simpler actions with
fewer predicates.

we designed shrdlurn in this way for sev-
eral reasons. first, visual block manipulations are
intuitive and can be easily crowdsourced, and it
can be fun as an actual game that people would
play. second, the action space is designed to be
compositional, mirroring the structure of natural
language. third, many actions z lead to the same

successor state y =(cid:74)z(cid:75)s; e.g., the    leftmost stack   

might coincide with the    stack with red blocks    for
some state s and therefore an action involving ei-
ther one would result in the same outcome. since
the human only points out the correct y, the com-
puter must grapple with this indirect supervision,
a re   ection of real language learning.
3 id29 model
following zettlemoyer and collins (2005) and
most recent work on id29, we use
a log-linear model over logical forms (actions)
z     z given an utterance x:

p  (z | x)     exp(  t  (x, z)),

(1)
where   (x, z)     rd is a feature vector and        rd
is a parameter vector. the denotation y (succes-

sor state) is obtained by executing z on a state s;

formally, y =(cid:74)z(cid:75)s.

features. our features are id165s (including
skip-grams) conjoined with tree-grams on the log-
ical form side.
speci   cally, on the utterance
side (e.g.,    stack red on orange   ), we use uni-
grams (   stack   ,   ,   ), bigrams (   red   ,    on   ,   ), tri-
grams (   red   ,    on   ,    orange   ), and skip-trigrams
(   stack   ,   ,    on   ). on the logical form side, fea-
tures corresponds to the predicates in the logical
forms and their arguments. for each predicate h,
let h.i be the i-th argument of h. then, we de-
   ne tree-gram features   (h, d) for predicate h and
depth d = 0, 1, 2, 3 recursively as follows:
  (h, 0) = {h},
  (h, d) = {(h, i,   (h.i, d     1)) | i = 1, 2, 3}.

the set of all features is just the cross product
of utterance features and logical form features.
if x =    enlever tout    and z =
for example,
remove(all()), then features include:

(   enlever   , all)
(   enlever   , remove)
(   enlever   , (remove, 1, all))
(   tout   , (remove, 1, all))

(   tout   , all)
(   tout   , remove)

note that we do not model an explicit alignment
or derivation compositionally connecting the utter-
ance and the logical form, in contrast to most tradi-
tional work in id29 (zettlemoyer and
collins, 2005; wong and mooney, 2007; liang
et al., 2011; kwiatkowski et al., 2010; berant
et al., 2013), instead following a looser model of
semantics similar to (pasupat and liang, 2015).
modeling explicit alignments or derivations is
only computationally feasible when we are learn-
ing from annotated logical forms or have a seed
lexicon, since the number of derivations is much
larger than the number of logical forms.
in the
illg setting, neither are available.
generation/parsing. we generate logical forms
from smallest
to largest using id125.
speci   cally, for each size n = 1, . . . , 8, we con-
struct a set of logical forms of size n (with ex-
actly n predicates) by combining logical forms of
smaller sizes according to the grammar rules in ta-
ble 1. for each n, we keep the 100 logical forms z
with the highest score   t  (x, z) according to the
current model   . let z be the set of logical forms
on the    nal beam, which contains logical forms
of all sizes n. during training, due to pruning at

description
all stacks

rule
semantics
set
all()
color
cyan|brown|red|orange primitive color
color     set
with(c)
set     set
not(s)
set     set
leftmost|rightmost(s)
set color     act add(s, c)
set     act

remove(s)

stacks whose top block has color c
all stacks except those in s
leftmost/rightmost stack in s
add block with color c on each stack in s
remove the topmost block of each stack in s

table 1: the formal grammar de   ning the compositional action space z for shrdlurn.
for example, one action that we
we use c to denote a color, and s to denote a set.
(cid:55)   
have in shrdlurn is:
add(not(leftmost(with(brown))),orange).

   add an orange block to all but

the leftmost brown block   

intermediate sizes, z is not guaranteed to contain
the logical form that obtains the observed state y.
to mitigate this effect, we use a curriculum so that
only simple actions are needed in the initial levels,
giving the human an opportunity to teach the com-
puter about basic terms such as colors    rst before
moving to larger composite actions.

the system executes all of the logical forms on
the    nal beam z, and orders the resulting denota-
tions y by the maximum id203 of any logical
form that produced it.3

learning. when the human provides feedback
in the form of a particular y, the system forms the
following id168:

(cid:96)(  , x, y) =     log p  (y | x, s) +   ||  ||1,
p  (y | x, s) =

p  (z | x).

(2)
(3)

(cid:88)
z:(cid:74)z(cid:75)s=y

then it makes a single gradient update using ada-
grad (duchi et al., 2010), which maintains a per-
feature step size.

4 modeling pragmatics

in our initial experience with the semantic pars-
ing model described in section 3, we found
that it was able to learn reasonably well, but
lacked a reasoning ability that one    nds in hu-
man learners. to illustrate the point, consider
the beginning of a game when    = 0 in the
log-linear model p  (z
suppose that
human utters    remove red    and then identi   es
3 we tried ordering based on the sum of the probabilities
(which corresponds to marginalizing out the logical form),
but this had the degenerate effect of assigning too much prob-
ability mass to y being the set of empty stacks, which can
result from many actions.

| x).

zrm-red = remove(with(red)) as the cor-
rect logical form. the computer then performs
a gradient update on the id168 (2), up-
weighting features such as (   remove   , remove)
and (   remove   , red).

next, suppose the human utters    remove cyan   .
note that zrm-red will score higher than all other
formulas since the (   remove   , red) feature will
   re again. while statistically justi   ed, this be-
havior fails to meet our intuitive expectations for
a smart language learner. moreover, this behav-
ior is not speci   c to our model, but applies to any
statistical model that simply tries to    t the data
without additional prior knowledge about the spe-
ci   c language. while we would not expect the
(cid:55)   
computer to magically guess    remove cyan   
remove(with(cyan)), it should at least push
down the id203 of zrm-red because zrm-red
intuitively is already well-explained by another ut-
terance    remove red   .

this phenomenon, mutual exclusivity, was stud-
ied by markman and wachtel (1988). they found
that children, during their id146
process, reject a second label for an object and
treat it instead as a label for a novel object.
the pragmatic computer. to model mutual ex-
clusivity formally, we turn to probabilistic mod-
els of pragmatics (golland et al., 2010; frank and
goodman, 2012; smith et al., 2013; goodman and
lassiter, 2015), which operationalize the ideas of
grice (1975). the central idea in these models is
to treat language as a cooperative game between
a speaker (human) and a listener (computer) as
we are doing, but where the listener has an ex-
plicit model of the speaker   s strategy, which in
turn models the listener. formally, let s(x | z) be
the speaker   s strategy and l(z | x) be the listener   s

zrm-red

   remove red   
   remove cyan   

0.8
0.6

   remove red   
   remove cyan   

0.57
0.43

z3, z4, . . .

0.1
0.2

0.33
0.67

zrm-cyan
p  (z | x)
0.1
0.2
s(x | z)
0.33
0.67
l(z | x)
0.27
0.38

0.27
0.38

0.46
0.24

   remove red   
   remove cyan   
table 2: suppose the computer saw one exam-
ple of    remove red    (cid:55)   zrm-red, and then the hu-
man utters    remove cyan   .
the literal lis-
tener, p  (z | x), mistakingly chooses zrm-red
over zrm-cyan. middle:
the pragmatic speaker,
s(x | z), assigns a higher id203 to to    remove
cyan    given zrm-cyan; bottom: the pragmatic lis-
tener, l(z | x) correctly assigns a lower probabil-
ity to zrm-red where p(z) is uniform.

top:

strategy. the speaker takes into account the literal
id29 model p  (z | x) as well as a prior
over utterances p(x), while the listener considers
the speaker s(x | z) and a prior p(z):
s(x | z)     (p  (z | x)p(x))   ,
l(z | x)     s(x | z)p(z),

(4)
(5)
where        1 is a hyperparameter that sharpens
the distribution (smith et al., 2013). the com-
puter would then use l(z | x) to rank candidates
rather than p  . note that our pragmatic model only
affects the ranking of actions returned to the hu-
man and does not affect the gradient updates of
the model p  .

let us walk through a simple example to see the
effect of modeling pragmatics. table 2 shows that
the literal listener p  (z | x) assigns high probabil-
ity to zrm-red for both    remove red    and    remove
cyan   . assuming a uniform p(x) and    = 1, the
pragmatic speaker s(x | z) corresponds to normal-
izing each column of p  . note that if the pragmatic
speaker wanted to convey zrm-cyan, there is a de-
cent chance that they would favor    remove cyan   .
next, assuming a uniform p(z), the pragmatic lis-
tener l(z | x) corresponds to normalizing each
row of s(x | z). the result is that conditioned on
   remove cyan   , zrm-cyan is now more likely than
zrm-red, which is the desired effect.

the pragmatic listener models the speaker as a
cooperative agent who behaves in a way to max-
imize communicative success. certain speaker

behaviors such as avoiding synonyms (e.g., not
   delete cardinal   ) and using a consistent word or-
dering (e.g, not    red remove   ) fall out of the game
theory.4 for speakers that do not follow this strat-
egy, our pragmatic model is incorrect, but as we
get more data through game play, the literal lis-
tener p  (z | x) will sharpen, so that the literal lis-
tener and the pragmatic listener will coincide in
the limit.

   z, c(z)     0
   z, q(z)      
repeat

q(z) p  (z | x)  

receive utterance x from human
l(z | x)     p (z)
send human a list y ranked by l(z | x)
receive y     y from human
                     (cid:96)(  , x, y)
q(z)     q(z) + p  (z | x)  
p (z)    

c(z)     c(z) + p  (z | x,(cid:74)z(cid:75)s = y)

(cid:0)c(z(cid:48))+  (cid:1)

(cid:80)

c(z)+  

z(cid:48):c(z(cid:48))>0

until game ends

algorithm 1: online learning algorithm that
updates the parameters of the semantic parser
   as well as counts c, q required to perform
pragmatic reasoning.

stant(cid:80)

online learning with pragmatics. to imple-
ment the pragmatic listener as de   ned in (5), we
need to compute the speaker   s id172 con-
x p  (z | x)p(x) in order to compute s(x |
z) in (4). this requires parsing all utterances x
based on p  (z | x). to avoid this heavy computa-
tion in an online setting, we propose algorithm 1,
where some approximations are used for the sake
of ef   ciency. first, to approximate the intractable
sum over all utterances x, we only use the exam-
ples that are seen to compute the id172
i p  (z | xi).
then, in order to avoid parsing all previous exam-
ples again using the current parameters for each
i p  i(z | xi)  ,
where   i is the parameter after the model updates
on the ith example xi. while   i is different from
the current parameter   , p  (z | xi)     p  i(z | xi)
for the relevant example xi, which is accounted for

constant (cid:80)
x p  (z | x)p(x)     (cid:80)
new example, we store q(z) = (cid:80)

4 of course, synonyms and variable word order occur in
real language. we would need a more complex game com-
pared to shrdlurn to capture this effect.

by both   i and   .

in algorithm 1, the pragmatic listener l(z | x)
can be interpreted as an importance-weighted ver-
sion of the sharpened literal listener p  
   , where it
is downweighted by q(z), which re   ects which
z   s the literal listener prefers, and upweighted by
p (z), which is just a smoothed estimate of the ac-
tual distribution over logical forms p(z). by con-
struction, algorithm 1 is the same as (4) except
that it uses the id172 constant q based on
stale parameters   i after seeing example, and it
uses samples to compute the sum over x. follow-
ing (5), we also need p(z), which is estimated by
p (z) using add-   smoothing on the counts c(z).
note that q(z) and c(z) are updated after the
model parameters are updated for the current ex-
ample.

lastly, there is a small complication due to only
observing the denotation y and not the logical
form z. we simply give each consistent logical

form {z | (cid:74)z(cid:75)s = y} a pseudocount based on
the model: c(z)     c(z) + p  (z | x,(cid:74)z(cid:75)s = y)
where p  (z | x,(cid:74)z(cid:75)s = y)     exp(  t  (x, z)) for
(cid:74)z(cid:75)s = y (0 otherwise).

l(z|x)     p  (z|x) as (cid:80)

compared to prior work where the setting is
speci   cally designed to require pragmatic infer-
ence, pragmatics arises naturally in illg. we
think that this form of pragmatics is the most im-
portant during learning, and becomes less impor-
tant if we had more data. indeed, if we have a lot
of data and a small number of possible zs, then
x p  (z|x)p(x)     p(z)
when    = 1.5 however, for id29,
we would not be in this regime even if we have
a large amount of training data. in particular, we
are nowhere near that regime in shrdlurn, and
most of our utterances / logical forms are seen only
once, and the importance of modeling pragmatics
remains.

5 experiments
5.1 setting
data. using amazon mechanical turk (amt),
we paid 100 workers 3 dollars each to play shrd-
lurn. in total, we have 10223 utterances along
with their starting states s. of these, 8874 ut-
terances are labeled with their denotations y; the
rest are unlabeled, since the player can try any ut-
terance without accepting an action. 100 players
completed the entire game under identical settings.

5technically, we also need p   to be well-speci   ed.

we deliberately chose to start from scratch for ev-
ery worker, so that we can study the diversity of
strategies that different people used in a controlled
setting.

each game consists of 50 blocks tasks divided
into 5 levels of 10 tasks each, in increasing com-
plexity. each level aims to reach an end goal
given a start state. each game took on average
89 utterances to complete.6 it only took 6 hours
to complete these 100 games on amt and each
game took around an hour on average according to
amt   s work time tracker (which does not account
for multi-tasking players). the players were pro-
vided minimal instructions on the game controls.
importantly, we gave no example utterances in or-
der to avoid biasing their language use. around
20 players were confused and told us that the in-
structions were not clear and gave us mostly spam
utterances. fortunately, most players understood
the setting and some even enjoyed shrdlurn
as re   ected by their optional comments:

ever done on mturk.

    that was probably the most fun thing i have
    wow this was one mind bending games [sic].
metrics. we use the number of scrolls as a mea-
sure of game performance for each player. for
each example, the number of scrolls is the position
in the list y of the action selected by the player. it
was possible to complete this version of shrd-
lurn by scrolling (all actions can be found in
the    rst 125 of y )   22 of the 100 players failed to
teach an actual language, and instead    nished the
game mostly by scrolling. let us call them spam
players, who usually typed single letters, random
words, digits, or random phrases (e.g.    how are
you   ). overall, spam players had to scroll a lot:
21.6 scrolls per utterance versus only 7.4 for the
non-spam players.

5.2 human strategies
some example utterances can be found in table 3.
most of the players used english, but vary in their
adherence to conventions such as use of determin-
ers, plurals, and proper word ordering. 5 players
invented their own language, which are more pre-
cise, more consistent than general english. one
player used polish, and another used polish nota-
tion (bottom of table 3).

6 this number is not 50 because some block tasks need
multiple steps and players are also allowed to explore without
reaching the goal.

rem cy pos 1, stack or blk pos 4, rem
blk pos 2 thru 5, rem blk pos 2 thru 4,
stack bn blk pos 1 thru 2,    ll bn blk,
stack or blk pos 2 thru 6, rem cy blk
pos 2    ll rd blk (3.01)

most successful players (1st   20th)
remove the brown block, remove all
orange blocks, put brown block on
orange blocks, put orange blocks on
all blocks, put blue block on leftmost
blue block in top row (2.78)

average players (21th   50th)

remove the center block, remove the
red block, remove all red blocks,
remove the    rst orange block, put a
brown block on the    rst brown block,
add blue block on    rst blue block
(2.72)

reinsert pink, take brown, put in pink,
remove two pink from second layer,
add two red to second layer in odd
intervals, add    ve pink to second
layer, remove one blue and one
brown from bottom layer (9.17)

remove red, remove 1 red, remove 2 4
orange, add 2 red, add 1 2 3 4 blue,
emove 1 3 5 orange, add 2 4 orange,
add 2 orange, remove 2 3 brown, add
1 2 3 4 5 red, remove 2 3 4 5 6,
remove 2, add 1 2 3 4 6 red (8.37)

move second cube, double red with
blue, double    rst red with red, triple
second and fourth with orange, add
red, remove orange on row two, add
blue to column two, add brown on
   rst and third (7.18)

holdleftmost, holdbrown,
holdleftmost, blueonblue,
brownonblue1, blueonorange,
holdblue, holdorange2, blueonred2 ,
holdends1, holdrightend, hold2,
orangeonorangerightmost (14.15)

least successful players (51th   )
   add red cubes on center left, center
right, far left and far right   ,    remove
blue blocks on row two column two,
row two column four   , remove red
blocks in center left and center right
on second row (12.6)

spam players (    85th   100)

laugh with me, red blocks with one
aqua, aqua red alternate, brown red
red orange aqua orange, red brown
red brown red brown, space red
orange red, second level red space red
space red space (14.32)

next, hello happy, how are you, move, gold, build goal blocks, 23,house, gabboli, x, run   xav, d, j, xcv, dulicate goal (21.7)

most interesting

rm scat + 1 c, + 1 c, rm sh, + 1 2 4 sh,
+ 1 c, - 4 o, rm 1 r, + 1 3 o, full    ll c,
rm o, full    ll sh, - 1 3, full    ll sh, rm
sh, rm r, + 2 3 r, rm o, + 3 sh, + 2 3
sh, rm b, - 1 o, + 2 c,

usu  n br   azowe klocki, postaw
pomara  nczowy klocek na pierwszym
klocku, postaw czerwone klocki na
pomara  nczowych, usu  n
pomara  nczowe klocki w g  rnym
rz  edzie
table 3: example utterances, along with the average number of scrolls for that player in parentheses.
success is measured by the number of scrolls, where the more successful players need less scrolls. 1)
the 20 most successful players tend to use consistent and concise language whose semantics is similar
to our logical language. 2) average players tend to be slightly more verbose and inconsistent (left and
right), or signi   cantly different from our logical langauge (middle). 3) reasons for being unsuccessful
vary. left: no id121, middle: used a coordinate system and many conjunctions; right: confused in
the beginning, and used a language very different from our logical language.

mbrown,mblue,morange
red+orange  orange,
brown+brownm1+brownm3,
orange +brown
+orange  m1+ orange  m3 +
brown    2 + brown    4

overall, we    nd that many players adapt in
illg by becoming more consistent, less verbose,
and more precise, even if they used standard en-
glish at the beginning. for example, some players
became more consistent over time (e.g. from us-
ing both    remove    and    discard    to only using    re-
move   ). in terms of verbosity, removing function
words like determiners as the game progresses is
a common adaptation.
in each of the following
examples from different players, we compare an
utterance that appeared early in the game to a sim-
ilar utterance that appeared later:    remove the red
ones    became    remove red.   ;    add brown on top of
red    became    add orange on red   ;    add red blocks
to all red blocks    became    add red to red   ;    dark
red    became    red   ; one player used    the    in all of
the    rst 20 utterances, and then never used    the    in
the last 75 utterances.

players also vary in precision, ranging from
overspeci   ed (e.g.    remove the orange cube at the
left   ,    remove red blocks from top row   ) to under-
speci   ed or requiring context (e.g.    change col-
ors   ,    add one blue   ,    build more blocus   ,    move
the blocks fool   ,   add two red cubes   ). we found
that some players became more precise over time,
as they gain a better understanding of illg.

most players use utterances that actually do not
match our logical language in table 1, even the
successful players. in particular, numbers are of-
ten used. while some concepts always have the
same effect in our blocks world (e.g.       rst block   
means leftmost), most are different. more con-
cretely, of the top 10 players, 7 used numbers of
some form and only 3 players matched our logical
language. some players who did not match the
logical language performed quite well neverthe-

less. one possible explanation is because the ac-
tion required is somewhat constrained by the logi-
cal language and some tokens can have unintended
interpretations. for example, the computer can
correctly interpret numerical positional references,
as long as the player only refers to the leftmost
and rightmost positions. so if the player says    rem
blk pos 4    and    rem blk pos 1   , the computer can
interpret    pos    as rightmost and interpret the
bigram (   pos   ,    1   ) as leftmost. on the other
hand, players who deviated signi   cantly by de-
scribing the desired state declaratively (e.g.    red
orange red   ,    246   ) rather than using actions, or
a coordinate system (e.g.    row two column two   )
performed poorly. although players do not have
to match our logical language exactly to perform
well, being similar is de   nitely helpful.

compositionality. as far as we can tell, all
players used a compositional language; no one in-
vented unrelated words for each action. interest-
ingly, 3 players did not put spaces between words.
since we assume monomorphemic words sepa-
rated by spaces, they had to do a lot of scrolling
as a result (e.g., 14.15 with utterances like    or-
angeonorangerightmost   ).

5.3 computer strategies
we now present quantitative results on how
quickly the computer can learn, where our goal is
to achieve high accuracy on new utterances as we
make just a single pass over the data. the num-
ber of scrolls used to evaluate player is sensitive to
outliers and not as intuitive as accuracy. instead,
we consider online accuracy, described as follows.
formally, if a player produced t utterances x(j)
and labeled them y(j), then

,

j=1

1
t

online accuracy def=

y(j) =(cid:74)z(j)(cid:75)s(j)
where z(j) = arg maxz p  (j   1)(z|x(j)) is the
model prediction based on the previous parame-
ter   (j   1). note that the online accuracy is de-
   ned with respect to the player-reported labels,
which only corresponds to the actual accuracy if
the player is precise and honest. this is not true
for most spam players.

t(cid:88)

i(cid:104)

(cid:105)

compositionality. to study the importance of
compositionality, we consider
two baselines.
first, consider a non-compositional model (mem-

(a)

(b)

figure 2: pragmatics improve online accuracy. in
these plots, each marker is a player. red o: play-
ers who ranked 1   20 in terms of minimizing num-
ber of scrolls, green x: players 20   50; blue +:
lower than 50 (includes spam players). marker
sizes correspond to player rank, where better play-
ers are depicted with larger markers. 2a: online
accuracies with and without pragmatics on the full
model; 2b: same for the half model.

method
memorize
half model
half + prag
full model
full + prag

players ranked by # of scrolls

top 10
25.4
38.7
43.7
48.6
52.8

top 20
24.5
38.4
42.7
47.8
49.8

top 50
22.5
36.0
39.7
44.9
45.8

all 100
17.6
27.0
29.4
33.3
33.8

table 4: average online accuracy under vari-
ous settings. memorize:
featurize entire utter-
ance and logical form non-compositionally; half
model: featurize the utterances with unigrams, bi-
grams, and skip-grams but conjoin with the entire
logical form; full model: the model described in
section 3; +prag: the models above, with our on-
line pragmatics algorithm described in section 4.
both compositionality and pragmatics improve ac-
curacy.

orize) that just remembers pairs of complete ut-
terance and logical forms. we implement this
using indicator features on features (x, z), e.g.,
(   remove all the red blocks   , zrm-red), and use a
large learning rate.
second, we consider a
model (half ) that treats utterances composition-
ally with unigrams, bigrams, and skip-trigrams
features, but the logical forms are regarded as
non-compositional, so we have features such as
(   remove   , zrm-red), (   red   , zrm-red), etc.

table 4 shows that the full model (section 3)
signi   cantly outperforms both the memorize and
half baselines. the learning rate    = 0.1 is se-
lected via cross validation, and we used    = 1
and    = 3 following smith et al. (2013).

0.00.10.20.30.40.50.6full model accuracy0.00.10.20.30.40.50.6full+pragmatics accuracy0.00.10.20.30.40.50.6half model accuracy0.00.10.20.30.40.50.6half+pragmatics accuracypragmatics. next, we study the effect of prag-
matics on online accuracy.
figure 2 shows
that modeling pragmatics helps successful players
(e.g., top 10 by number of scrolls) who use precise
and consistent languages. interestingly, our prag-
matics model did not help and can even hurt the
less successful players who are less precise and
consistent. this is expected behavior: the prag-
matics model assumes that the human is coopera-
tive and behaving rationally. for the bottom half
of the players, this assumption is not true, in which
case the pragmatics model is not useful.

6 related work and discussion

our work connects with a broad body of work on
grounded language, in which language is used in
some environment as a means towards some goal.
examples include playing games (branavan et al.,
2009, 2010; reckman et al., 2010) interacting with
robotics (tellex et al., 2011, 2014), and following
instructions (vogel and jurafsky, 2010; chen and
mooney, 2011; artzi and zettlemoyer, 2013) se-
mantic parsing utterances to logical forms, which
we leverage, plays an important role in these set-
tings (kollar et al., 2010; matuszek et al., 2012;
artzi and zettlemoyer, 2013).

what makes this work unique is our new inter-
active learning of language games (illg) setting,
in which a model has to learn a language from
scratch through interaction. while online gradient
descent is frequently used, for example in seman-
tic parsing (zettlemoyer and collins, 2007; chen,
2012), we using it in a truly online setting, taking
one pass over the data and measuring online accu-
racy (cesa-bianchi and lugosi, 2006).

to speed up learning, we leverage computa-
tional models of pragmatics (j  ger, 2008; golland
et al., 2010; frank and goodman, 2012; smith
et al., 2013; vogel et al., 2013). the main differ-
ence is these previous works use pragmatics with
a trained base model, whereas we learn the model
online. monroe and potts (2015) uses learning
to improve the pragmatics model.
in contrast,
we use pragmatics to speed up the learning pro-
cess by capturing phenomena like mutual exclu-
sivity (markman and wachtel, 1988). we also dif-
fer from prior work in several details. first, we
model pragmatics in the online learning setting
where we use an online update for the pragmat-
ics model. second, unlikely the reference games
where pragmatic effects plays an important role by

design, shrdlurn is not speci   cally designed
to require pragmatics. the improvement we get
is mainly due to players trying to be consistent in
their language use. finaly, we treat both the utter-
ance and the logical forms as featurized composi-
tional objects. smith et al. (2013) treats utterances
(i.e. words) and logical forms (i.e. objects) as cat-
egories; monroe and potts (2015) used features,
but also over    at categories.

looking forward, we believe that the illg set-
ting is worth studying and has important implica-
tions for id139. today, these
systems are trained once and deployed.
if these
systems could quickly adapt to user feedback in
real-time as in this work, then we might be able
to more readily create systems for resource-poor
languages and new domains, that are customizable
and improve through use.

acknowledgments

darpa communicating with computers (cwc)
program under aro prime contract no. w911nf-
15-1-0462. the    rst author is supported by a
nserc pgs-d fellowship. in addition, we thank
will monroe, and chris potts for their insightful
comments and discussions on pragmatics.

reproducibility

all code, data, and experiments for this paper are
available on the codalab platform:
https://worksheets.
codalab.org/worksheets/
0x9fe4d080bac944e9a6bd58478cb05e5e
the client side code is here:
https://github.com/sidaw/shrdlurn/tree/
acl16-demo
and a demo: http://shrdlurn.sidaw.xyz

references

y. artzi and l. zettlemoyer. 2013. weakly super-
vised learning of semantic parsers for mapping
instructions to actions. transactions of the as-
sociation for computational linguistics (tacl)
1:49   62.

j. berant, a. chou, r. frostig, and p. liang. 2013.
id29 on freebase from question-
answer pairs. in empirical methods in natural
language processing (emnlp).

s. branavan, h. chen, l. s. zettlemoyer, and
r. barzilay. 2009. id23 for

in associa-
mapping instructions to actions.
tion for computational linguistics and inter-
national joint conference on natural language
processing (acl-ijcnlp). pages 82   90.

s. branavan, l. zettlemoyer, and r. barzilay.
2010. reading between the lines: learning
to map high-level instructions to commands.
in association for computational linguistics
(acl). pages 1268   1277.

n. cesa-bianchi and g. lugosi. 2006. predic-
tion, learning, and games. cambridge univer-
sity press.

d. l. chen. 2012. fast online lexicon learning for
grounded id146. in association
for computational linguistics (acl).

d. l. chen and r. j. mooney. 2011. learning
to interpret natural language navigation instruc-
tions from observations. in association for the
advancement of arti   cial intelligence (aaai).
pages 859   865.

j. duchi, e. hazan, and y. singer. 2010. adap-
tive subgradient methods for online learning
and stochastic optimization. in conference on
learning theory (colt).

m. frank and n. d. goodman. 2012. predicting
pragmatic reasoning in language games. sci-
ence 336:998   998.

h. giles. 2008. communication accommodation

theory. sage publications, inc.

d. golland, p. liang, and d. klein. 2010. a game-
theoretic approach to generating spatial descrip-
in empirical methods in natural lan-
tions.
guage processing (emnlp).

n. goodman and d. lassiter. 2015. probabilistic
semantics and pragmatics: uncertainty in lan-
guage and thought. the handbook of contem-
porary semantic theory, 2nd edition wiley-
blackwell.

h. p. grice. 1975. logic and conversation. syntax

and semantics 3:41   58.

m. e. ireland, r. b. slatcher, p. w. eastwick, l. e.
scissors, e. j. finkel, and j. w. pennebaker.
2011. language style matching predicts rela-
tionship initiation and stability. psychological
science 22(1):39   44.

g. j  ger. 2008. game theory in semantics and
pragmatics. technical report, university of
t  bingen.

t. kollar, s. tellex, d. roy, and n. roy. 2010.
grounding verbs of motion in natural language
commands to robots. in international sympo-
sium on experimental robotics (iser).

t. kwiatkowski, l. zettlemoyer, s. goldwater,
and m. steedman. 2010. inducing probabilistic
id35 grammars from logical form with higher-
in empirical methods in
order uni   cation.
natural language processing (emnlp). pages
1223   1233.

p. liang, m. i. jordan, and d. klein. 2011.
learning dependency-based compositional se-
mantics. in association for computational lin-
guistics (acl). pages 590   599.

e. markman and g. f. wachtel. 1988. children   s
use of mutual exclusivity to constrain the mean-
ings of words. cognitive psychology 20:125   
157.

c. matuszek, n. fitzgerald, l. zettlemoyer,
l. bo, and d. fox. 2012. a joint model of
language and perception for grounded attribute
in international conference on ma-
learning.
chine learning (icml). pages 1671   1678.

w. monroe and c. potts. 2015. learning in the
rational speech acts model. in proceedings of
20th amsterdam colloquium.

p. pasupat and p. liang. 2015. compositional se-
mantic parsing on semi-structured tables. in as-
sociation for computational linguistics (acl).
h. reckman, j. orkin, and d. roy. 2010. learning
meanings of words and constructions, grounded
in conference on natural
in a virtual game.
language processing (konvens).

n. j. smith, n. d. goodman, and m. c. frank.
2013. learning and using language via re-
cursive pragmatic reasoning about other agents.
in advances in neural information processing
systems (nips).

s. tellex, r. knepper, a. li, d. rus, and n. roy.
2014. asking for help using inverse semantics.
in robotics: science and systems (rss).

s. tellex, t. kollar, s. dickerson, m. r. walter,
a. g. banerjee, s. j. teller, and n. roy. 2011.
understanding natural language commands for
robotic navigation and mobile manipulation. in
association for the advancement of arti   cial
intelligence (aaai).

a. vogel, m. bodoia, c. potts, and d. juraf-
sky. 2013. emergence of gricean maxims from

in north ameri-
multi-agent decision theory.
can association for computational linguistics
(naacl). pages 1072   1081.

a. vogel and d. jurafsky. 2010. learning to fol-
low navigational directions. in association for
computational linguistics (acl). pages 806   
814.

t. winograd. 1972. understanding natural lan-

guage. academic press.

l. wittgenstein. 1953. philosophical investiga-

tions. blackwell, oxford.

y. w. wong and r. j. mooney. 2007. learn-
ing synchronous grammars for id29
with id198. in association for com-
putational linguistics (acl). pages 960   967.

l. s. zettlemoyer and m. collins. 2005. learn-
ing to map sentences to logical form: struc-
tured classi   cation with probabilistic categorial
in uncertainty in arti   cial intelli-
grammars.
gence (uai). pages 658   666.

l. s. zettlemoyer and m. collins. 2007. online
learning of relaxed id35 grammars for parsing
to logical form. in empirical methods in nat-
ural language processing and computational
natural language learning (emnlp/conll).
pages 678   687.

