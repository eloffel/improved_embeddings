a primer on neural network models

for natural language processing

yoav goldberg
draft as of october 5, 2015.

the most up-to-date version of this manuscript is available at http://www.cs.biu.
ac.il/  yogo/nnlp.pdf. major updates will be published on arxiv periodically.
i welcome any comments you may have regarding the content and presentation. if you
spot a missing reference or have relevant work you   d like to see mentioned, do let me know.
first.last@gmail

abstract

over the past few years, neural networks have re-emerged as powerful machine-learning
models, yielding state-of-the-art results in    elds such as image recognition and speech
processing. more recently, neural network models started to be applied also to textual
natural language signals, again with very promising results. this tutorial surveys neural
network models from the perspective of natural language processing research, in an attempt
to bring natural-language researchers up to speed with the neural techniques. the tutorial
covers input encoding for natural language tasks, feed-forward networks, convolutional
networks, recurrent networks and recursive networks, as well as the computation graph
abstraction for automatic gradient computation.

1. introduction

for a long time, core nlp techniques were dominated by machine-learning approaches that
used linear models such as support vector machines or id28, trained over very
high dimensional yet very sparse feature vectors.

recently, the    eld has seen some success in switching from such linear models over
sparse inputs to non-linear neural-network models over dense inputs. while most of the
neural network techniques are easy to apply, sometimes as almost drop-in replacements of
the old linear classi   ers, there is in many cases a strong barrier of entry. in this tutorial i
attempt to provide nlp practitioners (as well as newcomers) with the basic background,
jargon, tools and methodology that will allow them to understand the principles behind
the neural network models and apply them to their own work. this tutorial is expected
to be self-contained, while presenting the di   erent approaches under a uni   ed notation and
framework.
it also points to
external sources for more advanced topics when appropriate.

it repeats a lot of material which is available elsewhere.

this primer is not intended as a comprehensive resource for those that will go on and
develop the next advances in neural-network machinery (though it may serve as a good entry
point). rather, it is aimed at those readers who are interested in taking the existing, useful
technology and applying it in useful and creative ways to their favourite nlp problems. for
more in-depth, general discussion of neural networks, the theory behind them, advanced

1

optimization methods and other advanced topics, the reader is referred to other existing
resources. in particular, the book by bengio et al (2015) is highly recommended.

scope the focus is on applications of neural networks to language processing tasks. how-
ever, some subareas of language processing with neural networks were decidedly left out of
scope of this tutorial. these include the vast literature of id38 and acoustic
modeling, the use of neural networks for machine translation, and multi-modal applications
combining language and other signals such as images and videos (e.g. id134).
caching methods for e   cient runtime performance, methods for e   cient training with large
output vocabularies and id12 are also not discussed. id27s are dis-
cussed only to the extent that is needed to understand in order to use them as inputs for
other models. other unsupervised approaches, including autoencoders and recursive au-
toencoders, also fall out of scope. while some applications of neural networks for language
modeling and machine translation are mentioned in the text, their treatment is by no means
comprehensive.

a note on terminology the word    feature    is used to refer to a concrete, linguistic
input such as a word, a su   x, or a part-of-speech tag. for example, in a    rst-order part-
of-speech tagger, the features might be    current word, previous word, next word, previous
part of speech   . the term    input vector    is used to refer to the actual input that is fed
to the neural-network classi   er. similarly,    input vector entry    refers to a speci   c value
of the input. this is in contrast to a lot of the neural networks literature in which the
word    feature    is overloaded between the two uses, and is used primarily to refer to an
input-vector entry.

mathematical notation i use bold upper case letters to represent matrices (x, y,
z), and bold lower-case letters to represent vectors (b). when there are series of related
matrices and vectors (for example, where each matrix corresponds to a di   erent layer in
the network), superscript indices are used (w1, w2). for the rare cases in which we want
indicate the power of a matrix or a vector, a pair of brackets is added around the item to
be exponentiated: (w)2, (w3)2. unless otherwise stated, vectors are assumed to be row
vectors. we use [v1; v2] to denote vector concatenation.

2

2. neural network architectures

neural networks are powerful learning models. we will discuss two kinds of neural network
architectures, that can be mixed and matched     feed-forward networks and recurrent /
recursive networks. feed-forward networks include networks with fully connected layers,
such as the multi-layer id88, as well as networks with convolutional and pooling
layers. all of the networks act as classi   ers, but each with di   erent strengths.

fully connected feed-forward neural networks (section 4) are non-linear learners that
can, for the most part, be used as a drop-in replacement wherever a linear learner is used.
this includes binary and multiclass classi   cation problems, as well as more complex struc-
tured prediction problems (section 8). the non-linearity of the network, as well as the
ability to easily integrate pre-trained id27s, often lead to superior classi   cation
accuracy. a series of works (chen & manning, 2014; weiss, alberti, collins, & petrov,
2015; pei, ge, & chang, 2015; durrett & klein, 2015) managed to obtain improved syntac-
tic parsing results by simply replacing the linear model of a parser with a fully connected
feed-forward network. straight-forward applications of a feed-forward network as a classi-
   er replacement (usually coupled with the use of pre-trained word vectors) provide bene   ts
also for id35 id55 (lewis & steedman, 2014), dialog state tracking (henderson,
thomson, & young, 2013), pre-ordering for id151 (de gispert,
iglesias, & byrne, 2015) and id38 (bengio, ducharme, vincent, & janvin,
2003; vaswani, zhao, fossum, & chiang, 2013). iyyer et al (2015) demonstrate that multi-
layer feed-forward networks can provide competitive results on sentiment classi   cation and
factoid id53.

networks with convolutional and pooling layers (section 9) are useful for classi   cation
tasks in which we expect to    nd strong local clues regarding class membership, but these
clues can appear in di   erent places in the input. for example, in a document classi   cation
task, a single key phrase (or an ngram) can help in determining the topic of the document
(johnson & zhang, 2015). we would like to learn that certain sequences of words are good
indicators of the topic, and do not necessarily care where they appear in the document.
convolutional and pooling layers allow the model to learn to    nd such local indicators,
regardless of their position. convolutional and pooling architecture show promising results
on many tasks, including document classi   cation (johnson & zhang, 2015), short-text cat-
egorization (wang, xu, xu, liu, zhang, wang, & hao, 2015a), sentiment classi   cation
(kalchbrenner, grefenstette, & blunsom, 2014; kim, 2014), relation type classi   cation be-
tween entities (zeng, liu, lai, zhou, & zhao, 2014; dos santos, xiang, & zhou, 2015), event
detection (chen, xu, liu, zeng, & zhao, 2015; nguyen & grishman, 2015), paraphrase iden-
ti   cation (yin & sch  utze, 2015) id14 (collobert, weston, bottou, karlen,
kavukcuoglu, & kuksa, 2011), id53 (dong, wei, zhou, & xu, 2015), predict-
ing box-o   ce revenues of movies based on critic reviews (bitvai & cohn, 2015) modeling
text interestingness (gao, pantel, gamon, he, & deng, 2014), and modeling the relation
between character-sequences and part-of-speech tags (santos & zadrozny, 2014).

in natural language we often work with structured data of arbitrary sizes, such as
sequences and trees. we would like to be able to capture regularities in such structures,
or to model similarities between such structures.
in many cases, this means encoding
the structure as a    xed width vector, which we can then pass on to another statistical

3

learner for further processing. while convolutional and pooling architectures allow us to
encode arbitrary large items as    xed size vectors capturing their most salient features,
they do so by sacri   cing most of the structural information. recurrent (section 10) and
recursive (section 12) architectures, on the other hand, allow us to work with sequences
and trees while preserving a lot of the structural information. recurrent networks (elman,
1990) are designed to model sequences, while recursive networks (goller & k  uchler, 1996)
are generalizations of recurrent networks that can handle trees. we will also discuss an
extension of recurrent networks that allow them to model stacks (dyer, ballesteros, ling,
matthews, & smith, 2015; watanabe & sumita, 2015).

recurrent models have been shown to produce very strong results for language model-
ing, including (mikolov, kara     at, burget, cernocky, & khudanpur, 2010; mikolov, kom-
brink, luk  a  s burget,   cernocky, & khudanpur, 2011; mikolov, 2012; duh, neubig, sudoh,
& tsukada, 2013; adel, vu, & schultz, 2013; auli, galley, quirk, & zweig, 2013; auli &
gao, 2014); as well as for sequence tagging (irsoy & cardie, 2014; xu, auli, & clark, 2015;
ling, dyer, black, trancoso, fermandez, amir, marujo, & luis, 2015b), machine transla-
tion (sundermeyer, alkhouli, wuebker, & ney, 2014; tamura, watanabe, & sumita, 2014;
sutskever, vinyals, & le, 2014; cho, van merrienboer, gulcehre, bahdanau, bougares,
schwenk, & bengio, 2014b), id33 (dyer et al., 2015; watanabe & sumita,
2015), id31 (wang, liu, sun, wang, & wang, 2015b), noisy text normal-
ization (chrupala, 2014), dialog state tracking (mrk  si  c,   o s  eaghdha, thomson, gasic, su,
vandyke, wen, & young, 2015), response generation (sordoni, galley, auli, brockett, ji,
mitchell, nie, gao, & dolan, 2015), and modeling the relation between character sequences
and part-of-speech tags (ling et al., 2015b).

recursive models were shown to produce state-of-the-art or near state-of-the-art re-
sults for constituency (socher, bauer, manning, & andrew y., 2013) and dependency (le
& zuidema, 2014; zhu, qiu, chen, & huang, 2015a) parse re-ranking, discourse parsing
(li, li, & hovy, 2014), semantic relation classi   cation (hashimoto, miwa, tsuruoka, &
chikayama, 2013; liu, wei, li, ji, zhou, & wang, 2015), political ideology detection
based on parse trees (iyyer, enns, boyd-graber, & resnik, 2014b), sentiment classi   cation
(socher, perelygin, wu, chuang, manning, ng, & potts, 2013; hermann & blunsom, 2013),
target-dependent sentiment classi   cation (dong, wei, tan, tang, zhou, & xu, 2014) and
id53 (iyyer, boyd-graber, claudino, socher, & daum  e iii, 2014a).

4

3. feature representation

before discussing the network structure in more depth, it is important to pay attention
to how features are represented. for now, we can think of a feed-forward neural network
as a function n n (x) that takes as input a din dimensional vector x and produces a dout
dimensional output vector. the function is often used as a classi   er, assigning the input
x a degree of membership in one or more of dout classes. the function can be complex,
and is almost always non-linear. common structures of this function will be discussed
in section 4. here, we focus on the input, x. when dealing with natural language, the
input x encodes features such as words, part-of-speech tags or other linguistic information.
perhaps the biggest jump when moving from sparse-input linear models to neural-network
based models is to stop representing each feature as a unique dimension (the so called
one-hot representation) and representing them instead as dense vectors. that is, each core
feature is embedded into a d dimensional space, and represented as a vector in that space.1
the embeddings (the vector representation of each core feature) can then be trained like
the other parameter of the function n n . figure 1 shows the two approaches to feature
representation.

the feature embeddings (the values of the vector entries for each feature) are treated
as model parameters that need to be trained together with the other components of the
network. methods of training (or obtaining) the feature embeddings will be discussed later.
for now, consider the feature embeddings as given.

the general structure for an nlp classi   cation system based on a feed-forward neural

network is thus:

1. extract a set of core linguistic features f1, . . . , fk that are relevant for predicting the

output class.

2. for each feature fi of interest, retrieve the corresponding vector v(fi).

3. combine the vectors (either by concatenation, summation or a combination of both)

into an input vector x.

4. feed x into a non-linear classi   er (feed-forward neural network).

the biggest change in the input, then, is the move from sparse representations in which
each feature is its own dimension, to a dense representation in which each feature is mapped
to a vector. another di   erence is that we extract only core features and not feature com-
binations. we will elaborate on both these changes brie   y.

dense vectors vs. one-hot representations what are the bene   ts of representing
our features as vectors instead of as unique ids? should we always represent features as
dense vectors? let   s consider the two kinds of representations:

one hot each feature is its own dimension.

    dimensionality of one-hot vector is same as number of distinct features.

1. di   erent feature types may be embedded into di   erent spaces. for example, one may represent word

features using 100 dimensions, and part-of-speech features using 20 dimensions.

5

figure 1: sparse vs. dense feature representations. two encodings of the informa-
tion: current word is    dog   ; previous word is    the   ; previous pos-tag is    det   .
(a) sparse feature vector. each dimension represents a feature. feature combi-
nations receive their own dimensions. feature values are binary. dimensionality
is very high. (b) dense, embeddings-based feature vector. each core feature is
represented as a vector. each feature corresponds to several input vector en-
tries. no explicit encoding of feature combinations. dimensionality is low. the
feature-to-vector mappings come from an embedding table.

    features are completely independent from one another. the feature    word is

   dog        is as dis-similar to    word is    thinking        than it is to    word is    cat       .

dense each feature is a d-dimensional vector.

    dimensionality of vector is d.
    similar features will have similar vectors     information is shared between similar

features.

one bene   t of using dense and low-dimensional vectors is computational: the majority
of neural network toolkits do not play well with very high-dimensional, sparse vectors.
however, this is just a technical obstacle, which can be resolved with some engineering
e   ort.

the main bene   t of the dense representations is in generalization power: if we believe
some features may provide similar clues, it is worthwhile to provide a representation that
is able to capture these similarities. for example, assume we have observed the word    dog   
many times during training, but only observed the word    cat    a handful of times, or not at

6

all. if each of the words is associated with its own dimension, occurrences of    dog    will not
tell us anything about the occurrences of    cat   . however, in the dense vectors representation
the learned vector for    dog    may be similar to the learned vector from    cat   , allowing the
model to share statistical strength between the two events. this argument assumes that
   good    vectors are somehow given to us. section 5 describes ways of obtaining such vector
representations.

in cases where we have relatively few distinct features in the category, and we believe
there are no correlations between the di   erent features, we may use the one-hot representa-
tion. however, if we believe there are going to be correlations between the di   erent features
in the group (for example, for part-of-speech tags, we may believe that the di   erent verb
in   ections vb and vbz may behave similarly as far as our task is concerned) it may be
worthwhile to let the network    gure out the correlations and gain some statistical strength
by sharing the parameters. it may be the case that under some circumstances, when the
feature space is relatively small and the training data is plentiful, or when we do not wish to
share statistical information between distinct words, there are gains to be made from using
the one-hot representations. however, this is still an open research question, and there are
no strong evidence to either side. the majority of work (pioneered by (collobert & weston,
2008; collobert et al., 2011; chen & manning, 2014)) advocate the use of dense, trainable
embedding vectors for all features. for work using neural network architecture with sparse
vector encodings see (johnson & zhang, 2015).

finally, it is important to note that representing features as dense vectors is an integral
part of the neural network framework, and that consequentially the di   erences between
using sparse and dense feature representations are subtler than they may appear at    rst.
in fact, using sparse, one-hot vectors as input when training a neural network amounts
to dedicating the    rst layer of the network to learning a dense embedding vector for each
feature based on the training data. we touch on this in section 4.4.

variable number of features: continuous bag of words feed-forward networks
assume a    xed dimensional input. this can easily accommodate the case of a feature-
extraction function that extracts a    xed number of features: each feature is represented
as a vector, and the vectors are concatenated. this way, each region of the resulting
input vector corresponds to a di   erent feature. however, in some cases the number of
features is not known in advance (for example, in document classi   cation it is common
that each word in the sentence is a feature). we thus need to represent an unbounded
number of features using a    xed size vector. one way of achieving this is through a so-
called continuous bag of words (cbow) representation (mikolov, chen, corrado, & dean,
2013). the cbow is very similar to the traditional bag-of-words representation in which
we discard order information, and works by either summing or averaging the embedding
vectors of the corresponding features:2

2. note that if the v(fi)s were one-hot vectors rather than dense feature representations, the cbow and
w cbow equations above would reduce to the traditional (weighted) bag-of-words representations,
which is in turn equivalent to a sparse feature-vector representation in which each binary indicator
feature corresponds to a unique    word   .

7

cbow (f1, ..., fk) =

k(cid:88)

i=1

1
k

v(fi)

a simple variation on the cbow representation is weighted cbow, in which di   erent

vectors receive di   erent weights:

w cbow (f1, ..., fk) =

1(cid:80)k

i=1 ai

k(cid:88)

i=1

aiv(fi)

here, each feature fi has an associated weight ai, indicating the relative importance of
the feature. for example, in a document classi   cation task, a feature fi may correspond to
a word in the document, and the associated weight ai could be the word   s tf-idf score.

distance and position features the linear distance in between two words in a sentence
may serve as an informative feature. for example, in an event extraction task3 we may be
given a trigger word and a candidate argument word, and asked to predict if the argument
word is indeed an argument of the trigger. the distance (or relative position) between the
trigger and the argument is a strong signal for this prediction task. in the    traditional    nlp
setup, distances are usually encoded by binning the distances into several groups (i.e. 1, 2,
3, 4, 5   10, 10+) and associating each bin with a one-hot vector. in a neural architecture,
where the input vector is not composed of binary indicator features, it may seem natural to
allocate a single input vector entry to the distance feature, where the numeric value of that
entry is the distance. however, this approach is not taken in practice. instead, distance
features are encoded similarly to the other feature types: each bin is associated with a
d-dimensional vector, and these distance-embedding vectors are then trained as regular
parameters in the network (zeng et al., 2014; dos santos et al., 2015; zhu et al., 2015a;
nguyen & grishman, 2015).

feature combinations note that the feature extraction stage in the neural-network
settings deals only with extraction of core features. this is in contrast to the traditional
linear-model-based nlp systems in which the feature designer had to manually specify not
only the core features of interests but also interactions between them (e.g., introducing not
only a feature stating    word is x    and a feature stating    tag is y    but also combined feature
stating    word is x and tag is y    or sometimes even    word is x, tag is y and previous word
is z   ). the combination features are crucial in linear models because they introduce more
dimensions to the input, transforming it into a space where the data-points are closer to
being linearly separable. on the other hand, the space of possible combinations is very
large, and the feature designer has to spend a lot of time coming up with an e   ective
set of feature combinations. one of the promises of the non-linear neural network models
is that one needs to de   ne only the core features. the non-linearity of the classi   er, as
de   ned by the network structure, is expected to take care of    nding the indicative feature
combinations, alleviating the need for feature combination engineering.

3. the event extraction task involves identi   cation of events from a prede   ned set of event types. for
example identi   cation of    purchase    events or    terror-attack    events. each event type can be triggered
by various triggering words (commonly verbs), and has several slots (arguments) that needs to be    lled
(i.e. who purchased? what was purchased? at what amount?).

8

kernel methods (shawe-taylor & cristianini, 2004), and in particular polynomial kernels
(kudo & matsumoto, 2003), also allow the feature designer to specify only core features,
leaving the feature combination aspect to the learning algorithm. in contrast to neural-
network models, kernels methods are convex, admitting exact solutions to the optimization
problem. however, the classi   cation e   ciency in kernel methods scales linearly with the
size of the training data, making them too slow for most practical purposes, and not suitable
for training with large datasets. on the other hand, neural network classi   cation e   ciency
scales linearly with the size of the network, regardless of the training data size.

dimensionality how many dimensions should we allocate for each feature? unfortu-
nately, there are no theoretical bounds or even established best-practices in this space.
clearly, the dimensionality should grow with the number of the members in the class (you
probably want to assign more dimensions to id27s than to part-of-speech embed-
dings) but how much is enough? in current research, the dimensionality of word-embedding
vectors range between about 50 to a few hundreds, and, in some extreme cases, thousands.
since the dimensionality of the vectors has a direct e   ect on memory requirements and
processing time, a good rule of thumb would be to experiment with a few di   erent sizes,
and choose a good trade-o    between speed and task accuracy.

vector sharing consider a case where you have a few features that share the same
vocabulary. for example, when assigning a part-of-speech to a given word, we may have a
set of features considering the previous word, and a set of features considering the next word.
when building the input to the classi   er, we will concatenate the vector representation of
the previous word to the vector representation of the next word. the classi   er will then
be able to distinguish the two di   erent indicators, and treat them di   erently. but should
the two features share the same vectors? should the vector for    dog:previous-word    be the
same as the vector of    dog:next-word   ? or should we assign them two distinct vectors?
this, again, is mostly an empirical question. if you believe words behave di   erently when
they appear in di   erent positions (e.g., word x behaves like word y when in the previous
position, but x behaves like z when in the next position) then it may be a good idea to
use two di   erent vocabularies and assign a di   erent set of vectors for each feature type.
however, if you believe the words behave similarly in both locations, then something may
be gained by using a shared vocabulary for both feature types.

network   s output for multi-class classi   cation problems with k classes, the network   s
output is a k-dimensional vector in which every dimension represents the strength of a
particular output class. that is, the output remains as in the traditional linear models    
scalar scores to items in a discrete set. however, as we will see in section 4, there is a d   k
matrix associated with the output layer. the columns of this matrix can be thought of as
d dimensional embeddings of the output classes. the vector similarities between the vector
representations of the k classes indicate the model   s learned similarities between the output
classes.

historical note representing words as dense vectors for input to a neural network was
introduced by bengio et al (bengio et al., 2003) in the context of neural id38.
it was introduced to nlp tasks in the pioneering work of collobert, weston and colleagues

9

(2008, 2011). using embeddings for representing not only words but arbitrary features was
popularized following chen and manning (2014).

10

4. feed-forward neural networks

a brain-inspired metaphor as the name suggest, neural-networks are inspired by the
brain   s computation mechanism, which consists of computation units called neurons. in the
metaphor, a neuron is a computational unit that has scalar inputs and outputs. each input
has an associated weight. the neuron multiplies each input by its weight, and then sums4
them, applies a non-linear function to the result, and passes it to its output. the neurons
are connected to each other, forming a network: the output of a neuron may feed into the
inputs of one or more neurons. such networks were shown to be very capable computational
devices. if the weights are set correctly, a neural network with enough neurons and a non-
linear activation function can approximate a very wide range of mathematical functions (we
will be more precise about this later).

output

layer

hidden

layer

hidden

layer

y1

y2

y3

(cid:82)

(cid:82)

(cid:82)

(cid:82)

(cid:82)

(cid:82)

(cid:82)

(cid:82)

(cid:82)

(cid:82)

(cid:82)

input layer

x1

x2

x3

x4

figure 2: feed-forward neural network with two hidden layers.

a typical feed-forward neural network may be drawn as in figure 2. each circle is a
neuron, with incoming arrows being the neuron   s inputs and outgoing arrows being the neu-
ron   s outputs. each arrow carries a weight, re   ecting its importance (not shown). neurons
are arranged in layers, re   ecting the    ow of information. the bottom layer has no incom-
ing arrows, and is the input to the network. the top-most layer has no outgoing arrows,
and is the output of the network. the other layers are considered    hidden   . the sigmoid
shape inside the neurons in the middle layers represent a non-linear function (typically a
1/(1 + e   x)) that is applied to the neuron   s value before passing it to the output. in the
   gure, each neuron is connected to all of the neurons in the next layer     this is called a
fully-connected layer or an a   ne layer.

4. while summing is the most common operation, other functions, such as a max, are also possible

11

while the brain metaphor is sexy and intriguing, it is also distracting and cumbersome
to manipulate mathematically. we therefore switch to using more concise mathematic no-
tation. the values of each row of neurons in the network can be thought of as a vector. in
figure 2 the input layer is a 4 dimensional vector (x), and the layer above it is a 6 dimen-
sional vector (h1). the fully connected layer can be thought of as a linear transformation
from 4 dimensions to 6 dimensions. a fully-connected layer implements a vector-matrix
multiplication, h = xw where the weight of the connection from the ith neuron in the
input row to the jth neuron in the output row is wij.5 the values of h are then trans-
formed by a non-linear function g that is applied to each value before being passed on to the
next input. the whole computation from input to output can be written as: (g(xw1))w2
where w1 are the weights of the    rst layer and w2 are the weights of the second one.

in mathematical notation from this point on, we will abandon the brain metaphor
and describe networks exclusively in terms of vector-matrix operations.
the simplest neural network is the id88, which is a linear function of its inputs:

n np erceptron(x) = xw + b

x     rdin, w     rdin  dout, b     rdout

w is the weight matrix, and b is a bias term.6 in order to go beyond linear functions, we
introduce a non-linear hidden layer (the network in figure 2 has two such layers), resulting
in the 1-layer multi layer id88 (mlp1). a one-layer feed-forward neural network
has the form:

n nm lp 1(x) = g(xw1 + b1)w2 + b2

x     rdin, w1     rdin  d1, b1     rd1, w2     rd1  d2, b2     rd2

here w1 and b1 are a matrix and a bias term for the    rst linear transformation of the
input, g is a non-linear function that is applied element-wise (also called a non-linearity or
an activation function), and w2 and b2 are the matrix and bias term for a second linear
transform.

breaking it down, xw1+b1 is a linear transformation of the input x from din dimensions
to d1 dimensions. g is then applied to each of the d1 dimensions, and the matrix w2 together
with bias vector b2 are then used to transform the result into the d2 dimensional output
vector. the non-linear activation function g has a crucial role in the network   s ability to
represent complex functions. without the non-linearity in g, the neural network can only
represent linear transformations of the input.7

we can add additional linear-transformations and non-linearities, resulting in a 2-layer

mlp (the network in figure 2 is of this form):

n nm lp 2(x) = (g2(g1(xw1 + b1)w2 + b2))w3

of hj is then hj =(cid:80)4

i=1 xi    wij.

5. to see why this is the case, denote the weight of the ith input of the jth neuron in h as wij. the value

6. the network in    gure 2 does not include bias terms. a bias term can be added to a layer by adding to

it an additional neuron that does not have any incoming connections, whose value is always 1.
7. to see why, consider that a sequence of linear transformations is still a linear transformation.

12

it is perhaps clearer to write deeper networks like this using intermediary variables:

n nm lp 2(x) =y

h1 =g1(xw1 + b1)
h2 =g2(h1w2 + b2)
y =h2w3

the vector resulting from each linear transform is referred to as a layer. the outer-most
linear transform results in the output layer and the other linear transforms result in hidden
layers. each hidden layer is followed by a non-linear activation. in some cases, such as in
the last layer of our example, the bias vectors are forced to 0 (   dropped   ).

layers resulting from linear transformations are often referred to as fully connected, or
a   ne. other types of architectures exist. in particular, image recognition problems bene   t
from convolutional and pooling layers. such layers have uses also in language processing,
and will be discussed in section 9. networks with more than one hidden layer are said to
be deep networks, hence the name deep learning.

when describing a neural network, one should specify the dimensions of the layers and
the input. a layer will expect a din dimensional vector as its input, and transform it into a
dout dimensional vector. the dimensionality of the layer is taken to be the dimensionality
of its output. for a fully connected layer l(x) = xw + b with input dimensionality din and
output dimensionality dout, the dimensions of x is 1    din, of w is din    dout and of b is
1    dout.
the output of the network is a dout dimensional vector. in case dout = 1, the network   s
output is a scalar. such networks can be used for regression (or scoring) by considering
the value of the output, or for binary classi   cation by consulting the sign of the output.
networks with dout = k > 1 can be used for k-class classi   cation, by associating each
dimension with a class, and looking for the dimension with maximal value. similarly, if
the output vector entries are positive and sum to one, the output can be interpreted as
a distribution over class assignments (such output id172 is typically achieved by
applying a softmax transformation on the output layer, see section 4.3).

the matrices and the bias terms that de   ne the linear transformations are the parame-
ters of the network. it is common to refer to the collection of all parameters as   . together
with the input, the parameters determine the network   s output. the training algorithm is
responsible for setting their values such that the network   s predictions are correct. training
is discussed in section 6.

4.1 representation power

in terms of representation power, it was shown by (hornik, stinchcombe, & white, 1989;
cybenko, 1989) that mlp1 is a universal approximator     it can approximate with any
desired non-zero amount of error a family of functions8 that include all continuous functions

8. speci   cally, a feed-forward network with linear output layer and at least one hidden layer with a    squash-
ing    activation function can approximate any borel measurable function from one    nite dimensional space
to another.

13

on a closed and bounded subset of rn, and any function mapping from any    nite dimensional
discrete space to another. this may suggest there is no reason to go beyond mlp1 to more
complex architectures. however, the theoretical result does not state how large the hidden
layer should be, nor does it say anything about the learnability of the neural network (it
states that a representation exists, but does not say how easy or hard it is to set the
parameters based on training data and a speci   c learning algorithm).
it also does not
guarantee that a training algorithm will    nd the correct function generating our training
data. since in practice we train neural networks on relatively small amounts of data, using
a combination of the id26 algorithm and variants of stochastic id119,
and use hidden layers of relatively modest sizes (up to several thousands), there is bene   t
to be had in trying out more complex architectures than mlp1. in many cases, however,
mlp1 does indeed provide very strong results. for further discussion on the representation
power of feed-forward neural networks, see (bengio et al., 2015, section 6.5).

4.2 common non-linearities

the non-linearity g can take many forms. there is currently no good theory as to which
non-linearity to apply in which conditions, and choosing the correct non-linearity for a
given task is for the most part an empirical question. i will now go over the common non-
linearities from the literature: the sigmoid, tanh, hard tanh and the recti   ed linear unit
(relu). some nlp researchers also experimented with other forms of non-linearities such
as cube and tanh-cube.

sigmoid the sigmoid activation function   (x) = 1/(1 + e   x) is an s-shaped function,
transforming each value x into the range [0, 1].

hyperbolic tangent (tanh) the hyperbolic tangent tanh(x) = e2x   1
tion is an s-shaped function, transforming the values x into the range [   1, 1].
hard tanh the hard-tanh activation function is an approximation of the tanh function
which is faster to compute and take derivatives of:

e2x+1 activation func-

                  1 x <    1

x > 1
otherwise

1
x

hardtanh(x) =

recti   er (relu) the recti   er activation function (glorot, bordes, & bengio, 2011),
also known as the recti   ed linear unit is a very simple activation function that is easy to
work with and was shown many times to produce excellent results.9 the relu unit clips
each value x < 0 at 0. despite its simplicity, it performs well for many tasks, especially
when combined with the dropout id173 technique (see section 6.4).

9. the technical advantages of the relu over the sigmoid and tanh id180 is that it does not
involve expensive-to-compute functions, and more importantly that it does not saturate. the sigmoid
and tanh activation are capped at 1, and the gradients at this region of the functions are near zero,
driving the entire gradient near zero. the relu activation does not have this problem, making it
especially suitable for networks with multiple layers, which are susceptible to the vanishing gradients
problem when trained with the saturating units.

14

relu (x) = max(0, x) =

(cid:40)

0 x < 0
x otherwise

as a rule of thumb, relu units work better than tanh, and tanh works better than

sigmoid.10

4.3 output transformations

in many cases, the output layer vector is also transformed. a common transformation is
the softmax :

sof tmax(xi) =

x =x1, . . . , xk

exi(cid:80)k

j=1 exj

the result is a vector of non-negative real numbers that sum to one, making it a discrete

id203 distribution over k possible outcomes.

the sof tmax output transformation is used when we are interested in modeling a prob-
ability distribution over the possible output classes. to be e   ective, it should be used in
conjunction with a probabilistic training objective such as cross-id178 (see section 4.5
below).

when the softmax transformation is applied to the output of a network without a hidden
layer, the result is the well known multinomial id28 model, also known as a
maximum-id178 classi   er.

4.4 embedding layers

up until now, the discussion ignored the source of x, treating it as an arbitrary vector.
in an nlp application, x is usually composed of various embeddings vectors. we can be
explicit about the source of x, and include it in the network   s de   nition. we introduce c(  ),
a function from core features to an input vector.
it is common for c to extract the embedding vector associated with each feature, and

concatenate them:

10. in addition to these id180, recent works from the nlp community experiment with and
reported success with other forms of non-linearities. the cube activation function, g(x) = (x)3, was
suggested by (chen & manning, 2014), who found it to be more e   ective than other non-linearities in
a feed-forward network that was used to predict the actions in a greedy transition-based dependency
parser. the tanh cube activation function g(x) = tanh((x)3 + x) was proposed by (pei et al., 2015),
who found it to be more e   ective than other non-linearities in a feed-forward network that was used as
a component in a structured-prediction graph-based dependency parser.

the cube and tanh-cube id180 are motivated by the desire to better capture interac-
tions between di   erent features. while these id180 are reported to improve performance
in certain situations, their general applicability is still to be determined.

15

x = c(f1, f2, f3) =[v(f1); v(f2); v(f3)]

n nm lp 1(x) =n nm lp 1(c(f1, f2, f3))

=n nm lp 1([v(f1); v(f2); v(f3)])
=(g([v(f1); v(f2); v(f3)]w1 + b1))w2 + b2

another common choice is for c to sum the embedding vectors (this assumes the em-

bedding vectors all share the same dimensionality):

x = c(f1, f2, f3) =v(f1) + v(f2) + v(f3)

n nm lp 1(x) =n nm lp 1(c(f1, f2, f3))

=n nm lp 1(v(f1) + v(f2) + v(f3))
=(g((v(f1) + v(f2) + v(f3))w1 + b1))w2 + b2

the form of c is an essential part of the network   s design. in many papers, it is common
to refer to c as part of the network, and likewise treat the id27s v(fi) as resulting
from an    embedding layer    or    lookup layer   . consider a vocabulary of |v | words, each
embedded as a d dimensional vector. the collection of vectors can then be thought of as a
|v |    d embedding matrix e in which each row corresponds to an embedded feature. let
fi be a |v |-dimensional vector, which is all zeros except from one index, corresponding to
the value of the ith feature, in which the value is 1 (this is called a one-hot vector). the
multiplication fie will then    select    the corresponding row of e. thus, v(fi) can be de   ned
in terms of e and fi:

and similarly:

v(fi) = fie

cbow (f1, ..., fk) =

k(cid:88)

i=1

k(cid:88)

(fie) = (

i=1

fi)e

the input to the network is then considered to be a collection of one-hot vectors. while
this is elegant and well de   ned mathematically, an e   cient implementation typically involves
a hash-based data structure mapping features to their corresponding embedding vectors,
without going through the one-hot representation.

in this tutorial, we take c to be separate from the network architecture: the network   s
inputs are always dense real-valued input vectors, and c is applied before the input is passed
the network, similar to a    feature function    in the familiar linear-models terminology. how-
ever, when training a network, the input vector x does remember how it was constructed,
and can propagate error gradients back to its component embedding vectors, as appropriate.

a note on notation when describing network layers that get concatenated vectors x,
y and z as input, some authors use explicit concatenation ([x; y; z]w + b) while others use
an a   ne transformation (xu + yv + zw + b). if the weight matrices u, v, w in the
a   ne transformation are di   erent than one another, the two notations are equivalent.

16

a note on sparse vs. dense features consider a network which uses a    traditional   
sparse representation for its input vectors, and no embedding layer. assuming the set of all
available features is v and we have k    on    features f1, . . . , fk, fi     v , the network   s input
is:

and so the    rst layer (ignoring the non-linear activation) is:

k(cid:88)

i=1

x =

fi

xw + b = (

x     n|v |+
k(cid:88)

fi)w

i=1

w     r|v |  d, b     rd

this layer selects rows of w corresponding to the input features in x and sums them,
then adding a bias term. this is very similar to an embedding layer that produces a cbow
representation over the features, where the matrix w acts as the embedding matrix. the
main di   erence is the introduction of the bias vector b, and the fact that the embedding
layer typically does not undergo a non-linear activation but rather passed on directly to the
   rst layer. another di   erence is that this scenario forces each feature to receive a separate
vector (row in w) while the embedding layer provides more    exibility, allowing for example
for the features    next word is dog    and    previous word is dog    to share the same vector.
however, these di   erences are small and subtle. when it comes to multi-layer feed-forward
networks, the di   erence between dense and sparse inputs is smaller than it may seem at
   rst sight.

4.5 id168s

when training a neural network (more on training in section 6 below), much like when
training a linear classi   er, one de   nes a id168 l(  y, y), stating the loss of predicting
  y when the true output is y. the training objective is then to minimize the loss across the
di   erent training examples. the loss l(  y, y) assigns a numerical score (a scalar) for the
network   s output   y given the true expected output y.11 the loss is always positive, and
should be zero only for cases where the network   s output is correct.

the parameters of the network (the matrices wi, the biases bi and commonly the em-
beddings e) are then set in order to minimize the loss l over the training examples (usually,
it is the sum of the losses over the di   erent training examples that is being minimized).

the loss can be an arbitrary function mapping two vectors to a scalar. for practical
purposes of optimization, we restrict ourselves to functions for which we can easily compute
gradients (or sub-gradients). in most cases, it is su   cient and advisable to rely on a common
id168 rather than de   ning your own. for a detailed discussion on id168s for
neural networks see (lecun, chopra, hadsell, ranzato, & huang, 2006; lecun & huang,
2005; bengio et al., 2015). we now discuss some id168s that are commonly used in
neural networks for nlp.

11. in our notation, both the model   s output and the expected output are vectors, while in many cases it is
more natural to think of the expected output as a scalar (class assignment). in such cases, y is simply
the corresponding one-hot vector.

17

hinge (binary) for binary classi   cation problems, the network   s output is a single scalar
  y and the intended output y is in {+1,   1}. the classi   cation rule is sign(  y), and a
classi   cation is considered correct if y      y > 0, meaning that y and   y share the same sign.
the hinge loss, also known as margin loss or id166 loss, is de   ned as:

lhinge(binary)(  y, y) = max(0, 1     y      y)

the loss is 0 when y and   y share the same sign and |  y|     1. otherwise, the loss is linear.
in other words, the binary hinge loss attempts to achieve a correct classi   cation, with a
margin of at least 1.

hinge (multiclass) the hinge loss was extended to the multiclass setting by crammer
and singer (2002). let   y =   y1, . . . ,   yn be the network   s output vector, and y be the one-hot
vector for the correct output class.

the classi   cation rule is de   ned as selecting the class with the highest score:

prediction = arg max

i

  yi

,

denote by t = arg maxi yi the correct class, and by k = arg maxi(cid:54)=t   yi the highest scoring

class such that k (cid:54)= t. the multiclass hinge loss is de   ned as:

lhinge(multiclass)(  y, y) = max(0, 1     (  yt       yk))

the multiclass hinge loss attempts to score the correct class above all other classes with a
margin of at least 1.

both the binary and multiclass hinge losses are intended to be used with a linear output
layer. the hinge losses are useful whenever we require a hard decision rule, and do not
attempt to model class membership id203.

log loss the log loss is a common variation of the hinge loss, which can be seen as a
   soft    version of the hinge loss with an in   nite margin (lecun et al., 2006).

llog(  y, y) = log(1 + exp(   (  yt       yk))

categorical cross-id178 loss the categorical cross-id178 loss (also referred to as
negative log likelihood ) is used when a probabilistic interpretation of the scores is desired.
let y = y1, . . . , yn be a vector representing the true multinomial distribution over the
labels 1, . . . , n, and let   y =   y1, . . . ,   yn be the network   s output, which was transformed by the
sof tmax activation function, and represent the class membership conditional distribution
  yi = p (y = i|x). the categorical cross id178 loss measures the dissimilarity between
the true label distribution y and the predicted label distribution   y, and is de   ned as cross
id178:

(cid:88)

i

yi log(  yi)

lcross   id178(  y, y) =    

18

for hard classi   cation problems in which each training example has a single correct
class assignment, y is a one-hot vector representing the true class. in such cases, the cross
id178 can be simpli   ed to:

lcross   id178(hard classi   cation)(  y, y) =     log(  yt)

where t is the correct class assignment. this attempts to set the id203 mass assigned
to the correct class t to 1. because the scores   y have been transformed using the sof tmax
function and represent a conditional distribution, increasing the mass assigned to the correct
class means decreasing the mass assigned to all the other classes.

the cross-id178 loss is very common in the neural networks literature, and produces a
multi-class classi   er which does not only predict the one-best class label but also predicts a
distribution over the possible labels. when using the cross-id178 loss, it is assumed that
the network   s output is transformed using the sof tmax transformation.

ranking losses
in some settings, we are not given supervision in term of labels, but
rather as pairs of correct and incorrect items x and x(cid:48), and our goal is to score correct
items above incorrect ones. such training situations arise when we have only positive
examples, and generate negative examples by corrupting a positive example. a useful loss
in such scenarios is the margin-based ranking loss, de   ned for a pair of correct and incorrect
examples:

lranking(margin)(x, x(cid:48)) = max(0, 1     (n n (x)     n n (x(cid:48))))

where n n (x) is the score assigned by the network for input vector x. the objective is to
score (rank) correct inputs over incorrect ones with a margin of at least 1.

a common variation is to use the log version of the ranking loss:

lranking(log)(x, x(cid:48)) = log(1 + exp(   (n n (x)     n n (x(cid:48)))))

examples using the ranking hinge loss in language tasks include training with the aux-
iliary tasks used for deriving pre-trained id27s (see section 5), in which we are
given a correct word sequence and a corrupted word sequence, and our goal is to score
the correct sequence above the corrupt one (collobert & weston, 2008). similarly, van
de cruys (2014) used the ranking loss in a selectional-preferences task, in which the net-
work was trained to rank correct verb-object pairs above incorrect, automatically derived
ones, and (weston, bordes, yakhnenko, & usunier, 2013) trained a model to score correct
(head,relation,trail) triplets above corrupted ones in an information-extraction setting. an
example of using the ranking log loss can be found in (gao et al., 2014). a variation of the
ranking log loss allowing for a di   erent margin for the negative and positive class is given
in (dos santos et al., 2015).

19

5. id27s

a main component of the neural-network approach is the use of embeddings     representing
each feature as a vector in a low dimensional space. but where do the vectors come from?
this section will survey the common approaches.

5.1 random initialization

when enough supervised training data is available, one can just treat the feature embeddings
the same as the other model parameters: initialize the embedding vectors to random values,
and let the network-training procedure tune them into    good    vectors.

some care has to be taken in the way the random initialization is performed. the method
used by the e   ective id97 implementation (mikolov et al., 2013; mikolov, sutskever,
chen, corrado, & dean, 2013) is to initialize the word vectors to uniformly sampled random
(cid:104)
numbers in the range [    1
2d ] where d is the number of dimensions. another option is to
use xavier initialization (see section 6.3) and initialize with uniformly sampled values from
   

2d , 1

   6   d

   6   d

(cid:105)

,

.

in practice, one will often use the random initialization approach to initialize the em-
bedding vectors of commonly occurring features, such as part-of-speech tags or individual
letters, while using some form of supervised or unsupervised pre-training to initialize the
potentially rare features, such as features for individual words. the pre-trained vectors can
then either be treated as    xed during the network training process, or, more commonly,
treated like the randomly-initialized vectors and further tuned to the task at hand.

5.2 supervised task-speci   c pre-training

if we are interested in task a, for which we only have a limited amount of labeled data (for
example, syntactic parsing), but there is an auxiliary task b (say, part-of-speech tagging)
for which we have much more labeled data, we may want to pre-train our word vectors so
that they perform well as predictors for task b, and then use the trained vectors for training
task a. in this way, we can utilize the larger amounts of labeled data we have for task b.
when training task a we can either treat the pre-trained vectors as    xed, or tune them
further for task a. another option is to train jointly for both objectives, see section 7 for
more details.

5.3 unsupervised pre-training

the common case is that we do not have an auxiliary task with large enough amounts of
annotated data (or maybe we want to help bootstrap the auxiliary task training with better
vectors). in such cases, we resort to    unsupervised    methods, which can be trained on huge
amounts of unannotated text.

the techniques for training the word vectors are essentially those of supervised learning,
but instead of supervision for the task that we care about, we instead create practically

20

unlimited number of supervised training instances from raw text, hoping that the tasks
that we created will match (or be close enough to) the    nal task we care about.12

the key idea behind the unsupervised approaches is that one would like the embedding
vectors of    similar    words to have similar vectors. while word similarity is hard to de   ne
and is usually very task-dependent, the current approaches derive from the distributional
hypothesis (harris, 1954), stating that words are similar if they appear in similar contexts.
the di   erent methods all create supervised training instances in which the goal is to either
predict the word from its context, or predict the context from the word.

an important bene   t of training id27s on large amounts of unannotated
data is that it provides vector representations for words that do not appear in the super-
vised training set. ideally, the representations for these words will be similar to those of
related words that do appear in the training set, allowing the model to generalize better on
unseen events. it is thus desired that the similarity between word vectors learned by the un-
supervised algorithm captures the same aspects of similarity that are useful for performing
the intended task of the network.

common unsupervised word-embedding algorithms include id97 13 (mikolov et al.,
2013, 2013), glove (pennington, socher, & manning, 2014) and the collobert and weston
(2008, 2011) embeddings algorithm. these models are inspired by neural networks and
are based on stochastic gradient training. however, they are deeply connected to another
family of algorithms which evolved in the nlp and ir communities, and that are based on
id105 (see (levy & goldberg, 2014b; levy et al., 2015) for a discussion).

arguably, the choice of auxiliary problem (what is being predicted, based on what kind
of context) a   ects the resulting vectors much more than the learning method that is being
used to train them. we thus focus on the di   erent choices of auxiliary problems that are
available, and only skim over the details of the training methods. several software packages
for deriving word vectors are available, including id9714 and gensim15 implementing
the id97 models with word-windows based contexts, id97f16 which is a modi   ed
version of id97 allowing the use of arbitrary contexts, and glove17 implementing the
glove model. many pre-trained word vectors are also available for download on the web.

while beyond the scope of this tutorial, it is worth noting that the id27s
derived by unsupervised training algorithms have a wide range of applications in nlp
beyond using them for initializing the word-embeddings layer of a neural-network model.

5.4 training objectives

given a word w and its context c, di   erent algorithms formulate di   erent auxiliary tasks.
in all cases, each word is represented as a d-dimensional vector which is initialized to a
random value. training the model to perform the auxiliary tasks well will result in good

12. the interpretation of creating auxiliary problems from raw text is inspired by ando and zhang (ando

& zhang, 2005a, 2005b).

13. while often treated as a single algorithm, id97 is actually a software package including various
training objectives, optimization methods and other hyperparameters. see (rong, 2014; levy, goldberg,
& dagan, 2015) for a discussion.

14. https://code.google.com/p/id97/
15. https://radimrehurek.com/gensim/
16. https://bitbucket.org/yoavgo/id97f
17. http://nlp.stanford.edu/projects/glove/

21

id27s for relating the words to the contexts, which in turn will result in the
embedding vectors for similar words to be similar to each other.

language-modeling inspired approaches such as those taken by (mikolov et al., 2013;
mnih & kavukcuoglu, 2013) as well as glove (pennington et al., 2014) use auxiliary tasks
in which the goal is to predict the word given its context. this is posed in a probabilistic
setup, trying to model the id155 p (w|c).
other approaches reduce the problem to that of binary classi   cation. in addition to
the set d of observed word-context pairs, a set   d is created from random words and
context pairings. the binary classi   cation problem is then: does the given (w, c) pair
come from d or not? the approaches di   er in how the set   d is constructed, what is
the structure of the classi   er, and what is the objective being optimized. collobert and
weston (2008, 2011) take a margin-based binary ranking approach, training a feed-forward
neural network to score correct (w, c) pairs over incorrect ones. mikolov et al (2013, 2014)
take instead a probabilistic version, training a log-bilinear model to predict the id203
p ((w, c)     d|w, c) that the pair come from the corpus rather than the random sample.

5.5 the choice of contexts

in most cases, the contexts of a word are taken to be other words that appear in its
surrounding, either in a short window around it, or within the same sentence, paragraph
or document. in some cases the text is automatically parsed by a syntactic parser, and
the contexts are derived from the syntactic neighbourhood induced by the automatic parse
trees. sometimes, the de   nitions of words and context change to include also parts of words,
such as pre   xes or su   xes.

neural id27s originated from the world of id38, in which a
network is trained to predict the next word based on a sequence of preceding words (bengio
et al., 2003). there, the text is used to create auxiliary tasks in which the aim is to predict
a word based on a context the k previous words. while training for the id38
auxiliary prediction problems indeed produce useful embeddings, this approach is needlessly
restricted by the constraints of the id38 task, in which one is allowed to look
only at the previous words. if we do not care about id38 but only about the
resulting embeddings, we may do better by ignoring this constraint and taking the context
to be a symmetric window around the focus word.

5.5.1 window approach

the most common approach is a sliding window approach, in which auxiliary tasks are
created by looking at a sequence of 2k + 1 words. the middle word is callled the focus word
and the k words to each side are the contexts. then, either a single task is created in which
the goal is to predict the focus word based on all of the context words (represented either
using cbow (mikolov et al., 2013) or vector concatenation (collobert & weston, 2008)),
or 2k distinct tasks are created, each pairing the focus word with a di   erent context word.
the 2k tasks approach, popularized by (mikolov et al., 2013) is referred to as a skip-gram
model. skip-gram based approaches are shown to be robust and e   cient to train (mikolov
et al., 2013; pennington et al., 2014), and often produce state of the art results.

22

e   ect of window size the size of the sliding window has a strong e   ect on the re-
sulting vector similarities. larger windows tend to produce more topical similarities (i.e.
   dog   ,    bark    and    leash    will be grouped together, as well as    walked   ,    run    and    walk-
ing   ), while smaller windows tend to produce more functional and syntactic similarities (i.e.
   poodle   ,    pitbull   ,    rottweiler   , or    walking   ,   running   ,   approaching   ).

positional windows when using the cbow or skip-gram context representations, all
the di   erent context words within the window are treated equally. there is no distinction
between context words that are close to the focus words and those that are farther from
it, and likewise there is no distinction between context words that appear before the focus
words to context words that appear after it. such information can easily be factored in by
using positional contexts: indicating for each context word also its relative position to the
focus words (i.e. instead of the context word being    the    it becomes    the:+2   , indicating
the word appears two positions to the right of the focus word). the use of positional context
together with smaller windows tend to produce similarities that are more syntactic, with
a strong tendency of grouping together words that share a part of speech, as well as being
functionally similar in terms of their semantics. positional vectors were shown by (ling,
dyer, black, & trancoso, 2015a) to be more e   ective than window-based vectors when used
to initialize networks for part-of-speech tagging and syntactic id33.

variants many variants on the window approach are possible. one may lemmatize words
before learning, apply text id172,    lter too short or too long sentences, or remove
capitalization (see, e.g., the pre-processing steps described in (dos santos & gatti, 2014).
one may sub-sample part of the corpus, skipping with some id203 the creation of tasks
from windows that have too common or too rare focus words. the window size may be
dynamic, using a di   erent window size at each turn. one may weigh the di   erent positions
in the window di   erently, focusing more on trying to predict correctly close word-context
pairs than further away ones. each of these choices will e   ect the resulting vectors. some
of these hyperparameters (and others) are discussed in (levy et al., 2015).

5.5.2 sentences, paragraphs or documents

using a skip-grams (or cbow) approach, one can consider the contexts of a word to be all
the other words that appear with it in the same sentence, paragraph or document. this is
equivalent to using very large window sizes, and is expected to result in word vectors that
capture topical similarity (words from the same topic, i.e. words that one would expect to
appear in the same document, are likely to receive similar vectors).

5.5.3 syntactic window

some work replace the linear context within a sentence with a syntactic one (levy &
goldberg, 2014a; bansal, gimpel, & livescu, 2014). the text is automatically parsed
using a dependency parser, and the context of a word is taken to be the words that are
in its proximity in the parse tree, together with the syntactic relation by which they are
connected. such approaches produce highly functional similarities, grouping together words
than can    ll the same role in a sentence (e.g. colors, names of schools, verbs of movement).

23

the grouping is also syntactic, grouping together words that share an in   ection (levy &
goldberg, 2014a).

5.5.4 multilingual

another option is using multilingual, translation based contexts (hermann & blunsom,
2014; faruqui & dyer, 2014). for example, given a large amount of sentence-aligned parallel
text, one can run a bilingual alignment model such as the ibm model 1 or model 2 (i.e.
using the giza++ software), and then use the produced alignments to derive word contexts.
here, the context of a word instance are the foreign language words that are aligned to it.
such alignments tend to result in synonym words receiving similar vectors. some authors
work instead on the sentence alignment level, without relying on word alignments. an
appealing method is to mix a monolingual window-based approach with a multilingual
approach, creating both kinds of auxiliary tasks. this is likely to produce vectors that are
similar to the window-based approach, but reducing the somewhat undesired e   ect of the
window-based approach in which antonyms (e.g. hot and cold, high and low) tend to receive
similar vectors (faruqui & dyer, 2014).

5.5.5 character-based and sub-word representations

an interesting line of work attempts to derive the vector representation of a word from the
characters that compose it. such approaches are likely to be particularly useful for tasks
which are syntactic in nature, as the character patterns within words are strongly related
to their syntactic function. these approaches also have the bene   t of producing very small
model sizes (only one vector for each character in the alphabet together with a handful of
small matrices needs to be stored), and being able to provide an embedding vector for every
word that may be encountered. dos santos and gatti (2014) and dos santos and zadrozny
(2014) model the embedding of a word using a convolutional network (see section 9) over
the characters. ling et al (2015b) model the embedding of a word using the concatenation
of the    nal states of two id56 (lstm) encoders (section 10), one reading the characters
from left to right, and the other from right to left. both produce very strong results for
part-of-speech tagging. the work of ballesteros et al (2015) show that the two-lstms
encoding of (ling et al., 2015b) is bene   cial also for representing words in dependency
parsing of morphologically rich languages.

deriving representations of words from the representations of their characters is moti-
vated by the unknown words problem     what do you do when you encounter a word for
which you do not have an embedding vector? working on the level of characters alleviates
this problem to a large extent, as the vocabulary of possible characters is much smaller
than the vocabulary of possible words. however, working on the character level is very
challenging, as the relationship between form (characters) and function (syntax, semantics)
in language is quite loose. restricting oneself to stay on the character level may be an
unnecessarily hard constraint. some researchers propose a middle-ground, in which a word
is represented as a combination of a vector for the word itself with vectors of sub-word
units that comprise it. the sub-id27s then help in sharing information between
di   erent words with similar forms, as well as allowing back-o    to the subword level when
the word is not observed. at the same time, the models are not forced to rely solely on

24

form when enough observations of the word are available. botha and blunsom (2014) sug-
gest to model the embedding vector of a word as a sum of the word-speci   c vector if such
vector is available, with vectors for the di   erent morphological components that comprise
it (the components are derived using morfessor (creutz & lagus, 2007), an unsupervised
morphological segmentation method). gao et al (gao et al., 2014) suggest using as core
features not only the word form itself but also a unique feature (hence a unique embedding
vector) for each of the letter-trigrams in the word.

25

6. neural network training

neural network training is done by trying to minimize a id168 over a training set,
using a gradient-based method. roughly speaking, all training methods work by repeatedly
computing an estimate of the error over the dataset, computing the gradient with respect
to the error, and then moving the parameters in the direction of the gradient. models di   er
in how the error estimate is computed, and how    moving in the direction of the gradient   
is de   ned. we describe the basic algorithm, stochastic id119 (sgd), and then
brie   y mention the other approaches with pointers for further reading. gradient calculation
is central to the approach. gradients can be e   ciently and automatically computed using
reverse mode di   erentiation on a computation graph     a general algorithmic framework for
automatically computing the gradient of any network and id168.

6.1 stochastic gradient training

the common approach for training neural networks is using the stochastic id119
(sgd) algorithm (bottou, 2012; lecun, bottou, orr, & muller, 1998a) or a variant of it.
sgd is a general optimization algorithm. it receives a function f parameterized by   , a
id168, and desired input and output pairs. it then attempts to set the parameters   
such that the loss of f with respect to the training examples is small. the algorithm works
as follows:

algorithm 1 online stochastic id119 training

1: input: function f (x;   ) parameterized with parameters   .
2: input: training set of inputs x1, . . . , xn and outputs y1, . . . , yn.
3: input: id168 l.
4: while stopping criteria not met do
sample a training example xi, yi
5:
compute the loss l(f (xi;   ), yi)
  g     gradients of l(f (xi;   ), yi) w.r.t   
          +   k  g

6:

7:

8:
9: return   

(cid:80)n

the goal of the algorithm is to set the parameters    so as to minimize the total loss
i=1 l(f (xi;   ), yi) over the training set. it works by repeatedly sampling a training exam-
ple and computing the gradient of the error on the example with respect to the parameters
   (line 7)     the input and expected output are assumed to be    xed, and the loss is treated
as a function of the parameters   . the parameters    are then updated in the direction of
the gradient, scaled by a learning rate   k (line 8). for further discussion on setting the
learning rate, see section 6.3.

note that the error calculated in line 6 is based on a single training example, and is thus
just a rough estimate of the corpus-wide loss that we are aiming to minimize. the noise in
the loss computation may result in inaccurate gradients. a common way of reducing this
noise is to estimate the error and the gradients based on a sample of m examples. this
gives rise to the minibatch sgd algorithm:

26

algorithm 2 minibatch stochastic id119 training
1: input: function f (x;   ) parameterized with parameters   .
2: input: training set of inputs x1, . . . , xn and outputs y1, . . . , yn.
3: input: id168 l.
4: while stopping criteria not met do
5:

sample a minibatch of m examples {(x1, y1), . . . , (xm, ym)}
  g     0
for i = 1 to m do

compute the loss l(f (xi;   ), yi)
  g       g + gradients of 1

m l(f (xi;   ), yi) w.r.t   

6:

7:

8:

9:

10:
11: return   

          +   k  g

in lines 6     9 the algorithm estimates the gradient of the corpus loss based on the
minibatch. after the loop,   g contains the gradient estimate, and the parameters    are
updated toward   g. the minibatch size can vary in size from m = 1 to m = n. higher
values provide better estimates of the corpus-wide gradients, while smaller values allow
more updates and in turn faster convergence. besides the improved accuracy of the gradients
estimation, the minibatch algorithm provides opportunities for improved training e   ciency.
for modest sizes of m, some computing architectures (i.e. gpus) allow an e   cient parallel
implementation of the computation in lines 6   9. with a small enough learning rate, sgd is
guaranteed to converge to a global optimum if the function is convex. however, it can also
be used to optimize non-convex functions such as neural-network. while there are no longer
guarantees of    nding a global optimum, the algorithm proved to be robust and performs
well in practice.

when training a neural network, the parameterized function f is the neural network,
and the parameters    are the layer-transfer matrices, bias terms, embedding matrices and
so on. the gradient computation is a key step in the sgd algorithm, as well as in all
other neural network training algorithms. the question is, then, how to compute the
gradients of the network   s error with respect to the parameters. fortunately, there is an easy
solution in the form of the id26 algorithm (rumelhart, hinton, & williams, 1986;
lecun, bottou, bengio, & ha   ner, 1998b). the id26 algorithm is a fancy name
for methodologically computing the derivatives of a complex expression using the chain-
rule, while caching intermediary results. more generally, the id26 algorithm
is a special case of the reverse-mode automatic di   erentiation algorithm (neidinger, 2010,
section 7), (baydin, pearlmutter, radul, & siskind, 2015; bengio, 2012).the following
section describes reverse mode automatic di   erentiation in the context of the computation
graph abstraction.

beyond sgd while the sgd algorithm can and often does produce good results, more
advanced algorithms are also available. the sgd+momentum (polyak, 1964) and nesterov
momentum (sutskever, martens, dahl, & hinton, 2013) algorithms are variants of sgd in
which previous gradients are accumulated and a   ect the current update. adaptive learning
rate algorithms including adagrad (duchi, hazan, & singer, 2011), adadelta (zeiler, 2012),

27

rmsprop (tieleman & hinton, 2012) and adam (kingma & ba, 2014) are designed to
select the learning rate for each minibatch, sometimes on a per-coordinate basis, potentially
alleviating the need of    ddling with learning rate scheduling. for details of these algorithms,
see the original papers or (bengio et al., 2015, sections 8.3, 8.4). as many neural-network
software frameworks provide implementations of these algorithms, it is easy and sometimes
worthwhile to try out di   erent variants.

6.2 the computation graph abstraction

while one can compute the gradients of the various parameters of a network by hand and
implement them in code, this procedure is cumbersome and error prone. for most pur-
poses, it is preferable to use automatic tools for gradient computation (bengio, 2012). the
computation-graph abstraction allows us to easily construct arbitrary networks, evaluate
their predictions for given inputs (forward pass), and compute gradients for their parameters
with respect to arbitrary scalar losses (backward pass).

a computation graph is a representation of an arbitrary mathematical computation as
a graph. it is a directed acyclic graph (dag) in which nodes correspond to mathematical
operations or (bound) variables and edges correspond to the    ow of intermediary values
between the nodes. the graph structure de   nes the order of the computation in terms of
the dependencies between the di   erent components. the graph is a dag and not a tree, as
the result of one operation can be the input of several continuations. consider for example
a graph for the computation of (a     b + 1)     (a     b + 2):

the computation of a    b is shared. we restrict ourselves to the case where the computation
graph is connected.
since a neural network is essentially a mathematical expression, it can be represented

as a computation graph.

for example, figure 3a presents the computation graph for a 1-layer mlp with a soft-
max output transformation. in our notation, oval nodes represent mathematical operations
or functions, and shaded rectangle nodes represent parameters (bound variables). network
inputs are treated as constants, and drawn without a surrounding node. input and param-
eter nodes have no incoming arcs, and output nodes have no outgoing arcs. the output of
each node is a matrix, the dimensionality of which is indicated above the node.

this graph is incomplete: without specifying the inputs, we cannot compute an output.
figure 3b shows a complete graph for an mlp that takes three words as inputs, and predicts
the distribution over part-of-speech tags for the third word. this graph can be used for
prediction, but not for training, as the output is a vector (not a scalar) and the graph does
not take into account the correct answer or the loss term. finally, the graph in 3c shows the
computation graph for a speci   c training example, in which the inputs are the (embeddings

28

ab12*++*figure 3: computation graph for mlp1. (a) graph with unbound input. (b) graph
with concrete input. (c) graph with concrete input, expected output, and loss
node.

of) the words    the   ,    black   ,    dog   , and the expected output is    noun    (whose index is
5).

once the graph is built, it is straightforward to run either a forward computation (com-
pute the result of the computation) or a backward computation (computing the gradients),
as we show below. constructing the graphs may look daunting, but is actually very easy
using dedicated software libraries and apis.

forward computation the forward pass computes the outputs of the nodes in the
graph. since each node   s output depends only on itself and on its incoming edges, it is
trivial to compute the outputs of all nodes by traversing the nodes in a topological order and
computing the output of each node given the already computed outputs of its predecessors.
more formally, in a graph of n nodes, we associate each node with an index i according
to their topological ordering. let fi be the function computed by node i (e.g. multiplication.
addition, . . . ). let   (i) be the parent nodes of node i, and      1(i) = {j | i       (j)} the
children nodes of node i (these are the arguments of fi). denote by v(i) the output of node

29

x1  150w1150  20mul1  20add1  20b11  20tanh1  20w220  17b21  17mul1  17add1  17softmax1  17(a)concat1  150lookup1  50lookup1  50lookup1  50   the      black      dog   e|v|  50w1150  20mul1  20add1  20b11  20tanh1  20w220  17b21  17mul1  17add1  17softmax1  17(b)concat1  150lookup1  50lookup1  50lookup1  50   the      black      dog   e|v|  50w1150  20mul1  20add1  20b11  20tanh1  20w220  17b21  17mul1  17add1  17softmax1  17pick1  15log1  1neg1  1(c)i, that is, the application of fi to the output values of its arguments      1(i). for variable
and input nodes, fi is a constant function and      1(i) is empty. the forward algorithm
computes the values v(i) for all i     [1, n ].
algorithm 3 computation graph forward pass

1: for i = 1 to n do
2:

let a1, . . . , am =      1(i)
v(i)     fi(v(a1), . . . , v(am))

3:

backward computation (derivatives, backprop) the backward pass begins by des-
ignating a node n with scalar (1   1) output as a loss-node, and running forward computa-
tion up to that node. the backward computation will computes the gradients with respect

. the id26 algorithm is

to that node   s value. denote by d(i) the quantity

used to compute the values d(i) for all nodes i.
the backward pass    lls a table d(i) as follows:

   n
   i

algorithm 4 computation graph backward pass (id26)
1: d(n )     1
2: for i = n-1 to 1 do

(cid:80)

3:

d(i)    

j     (i) d(j)   

   fj
   i

   fj
   i

is the partial derivative of fj(     1(j)) w.r.t the argument i          1(j).
the quantity
this value depends on the function fj and the values v(a1), . . . , v(am) (where a1, . . . , am =
     1(j)) of its arguments, which were computed in the forward pass.

thus, in order to de   ne a new kind of node, one need to de   ne two methods: one for
calculating the forward value v(i) based on the nodes inputs, and the another for calculating
   fi
   x

for each x          1(i).
for further information on automatic di   erentiation see (neidinger, 2010, section 7),
(baydin et al., 2015). for more in depth discussion of the id26 algorithm and
computation graphs (also called    ow graphs) see (bengio et al., 2015, section 6.4), (lecun
et al., 1998b; bengio, 2012). for a popular yet technical presentation, see chris olah   s
description at http://colah.github.io/posts/2015-08-backprop/.

software several software packages implement the computation-graph model, including
theano18, chainer19, penne20 and id98/pyid9821. all these packages support all the es-
sential components (node types) for de   ning a wide range of neural network architectures,
covering the structures described in this tutorial and more. graph creation is made almost
transparent by use of operator overloading. the framework de   nes a type for representing
graph nodes (commonly called expressions), methods for constructing nodes for inputs and

18. http://deeplearning.net/software/theano/
19. http://chainer.org
20. https://bitbucket.org/ndnlp/penne
21. https://github.com/clab/id98

30

parameters, and a set of functions and mathematical operations that take expressions as
input and result in more complex expressions. for example, the python code for creating
the computation graph from figure (3c) using the pyid98 framework is:

from pyid98 import *
# model initialization.
model = model()
model.add_parameters("w1", (20,150))
model.add_parameters("b1", 20)
model.add_parameters("w2", (17,20))
model.add_parameters("b2", 17)
model.add_lookup_parameters("words", (100, 50))

# building the computation graph:
renew_cg() # create a new graph.
# wrap the model parameters as graph-nodes.
w1 = parameter(model["w1"])
b1 = parameter(model["b1"])
w2 = parameter(model["w2"])
b2 = parameter(model["b2"])
def get_index(x): return 1
# generate the embeddings layer.
vthe
vblack = lookup(model["words"], get_index("black"))
vdog

= lookup(model["words"], get_index("the"))

= lookup(model["words"], get_index("dog"))

# connect the leaf nodes into a complete graph.
x = concatenate([vthe, vblack, vdog])
output = softmax(w2*(tanh(w1*x)+b1)+b2)
loss = -log(pick(output, 5))

loss_value = loss.forward()
loss.backward() # the gradient is computed

# and stored in the corresponding
# parameters.

most of the code involves various initializations: the    rst block de   nes model parameters
that are be shared between di   erent computation graphs (recall that each graph corresponds
to a speci   c training example). the second block turns the model parameters into the graph-
node (expression) types. the third block retrieves the expressions for the embeddings of the
input words. finally, the fourth block is where the graph is created. note how transparent
the graph creation is     there is an almost a one-to-one correspondence between creating
the graph and describing it mathematically. the last block shows a forward and backward
pass. the other software frameworks follow similar patterns.

theano involves an optimizing compiler for computation graphs, which is both a blessing
and a curse. on the one hand, once compiled, large graphs can be run e   ciently on either
the cpu or a gpu, making it ideal for large graphs with a    xed structure, where only the
inputs change between instances. however, the compilation step itself can be costly, and it
makes the interface a bit cumbersome to work with. in contrast, the other packages focus on
building large and dynamic computation graphs and executing them    on the    y    without a
compilation step. while the execution speed may su   er with respect to theano   s optimized
version, these packages are especially convenient when working with the recurrent and

31

recursive networks described in sections 10, 12 as well as in id170 settings
as described in section 8.

implementation recipe using the computation graph abstraction, the pseudo-code for
a network training algorithm is given in algorithm 5.

algorithm 5 neural network training with computation graph abstraction (using mini-
batches of size 1)

1: de   ne network parameters.
2: for iteration = 1 to n do
3:

for training example xi, yi in dataset do

4:

5:

6:

7:

loss node     build computation graph(xi, yi, parameters)
loss node.forward()
gradients     loss node().backward()
parameters     update parameters(parameters, gradients)

8: return parameters.

here, build computation graph is a user-de   ned function that builds the computation
graph for the given input, output and network structure, returning a single loss node.
update parameters is an optimizer speci   c update rule. the recipe speci   es that a new
graph is created for each training example. this accommodates cases in which the network
structure varies between training example, such as recurrent and id56s,
to be discussed in sections 10     12. for networks with    xed structures, such as an mlps, it
may be more e   cient to create one base computation graph and vary only the inputs and
expected outputs between examples.

network composition as long as the network   s output is a vector (1    k matrix), it
is trivial to compose networks by making the output of one network the input of another,
creating arbitrary networks. the computation graph abstractions makes this ability explicit:
a node in the computation graph can itself be a computation graph with a designated output
node. one can then design arbitrarily deep and complex networks, and be able to easily
evaluate and train them thanks to automatic forward and gradient computation. this makes
it easy to de   ne and train networks for structured outputs and multi-objective training, as
we discuss in section 7, as well as complex recurrent and recursive networks, as discussed
in sections 10   12.

6.3 optimization issues

once the gradient computation is taken care of, the network is trained using sgd or another
gradient-based optimization algorithm. the function being optimized is not convex, and for
a long time training of neural networks was considered a    black art    which can only be done
by selected few. indeed, many parameters a   ect the optimization process, and care has to
be taken to tune these parameters. while this tutorial is not intended as a comprehensive
guide to successfully training neural networks, we do list here a few of the prominent issues.
for further discussion on optimization techniques and algorithms for neural networks, refer
to (bengio et al., 2015, chapter 8). for some theoretical discussion and analysis, refer

32

to (glorot & bengio, 2010). for various practical tips and recommendations, see (lecun
et al., 1998a; bottou, 2012).

initialization the non-convexity of the id168 means the optimization procedure
may get stuck in a local minimum or a saddle point, and that starting from di   erent initial
points (e.g. di   erent random values for the parameters) may result in di   erent results. thus,
it is advised to run several restarts of the training starting at di   erent random initializations,
and choosing the best one based on a development set.22 the amount of variance in the
results is di   erent for di   erent network formulations and datasets, and cannot be predicted
in advance.

the magnitude of the random values has an important e   ect on the success of training.
an e   ective scheme due to glorot and bengio (2010), called xavier initialization after

glorot   s    rst name, suggests initializing a weight matrix w     rdin  dout as:

(cid:34)

(cid:35)

   6

   6

w     u

   

   din + dout

, +

   din + dout

where u [a, b] is a uniformly sampled random value in the range [a, b]. this advice works
well on many occasions, and is the preferred default initialization method by many.

analysis by he et al (2015) suggests that when using relu non-linearities, the weights
should be initialized by sampling from a zero-mean gaussian distribution whose standard
deviation is
. this initialization was found by he et al to work better than xavier
initialization in an image classi   cation task, especially when deep networks were involved.

din

(cid:113) 2

vanishing and exploding gradients
in deep networks, it is common for the error
gradients to either vanish (become exceedingly close to 0) or explode (become exceedingly
high) as they propagate back through the computation graph. the problem becomes more
severe in deeper networks, and especially so in recursive and recurrent networks (pascanu,
mikolov, & bengio, 2012). dealing with the vanishing gradients problem is still an open
research question. solutions include making the networks shallower, step-wise training (   rst
train the    rst layers based on some auxiliary output signal, then    x them and train the upper
layers of the complete network based on the real task signal), or specialized architectures
that are designed to assist in gradient    ow (e.g., the lstm and gru architectures for
recurrent networks, discussed in section 11). dealing with the exploding gradients has
a simple but very e   ective solution: clipping the gradients if their norm exceeds a given
threshold. let   g be the gradients of all parameters in the network, and (cid:107)  g(cid:107) be their l2
norm. pascanu et al (2012) suggest to set:   g     threshold
saturation and dead neurons layers with tanh and sigmoid activations can become
saturated     resulting in output values for that layer that are all close to one, the upper-
limit of the activation function. saturated neurons have very small gradients, and should
be avoided. layers with the relu activation cannot be saturated, but can    die        most or
all values are negative and thus clipped at zero for all inputs, resulting in a gradient of zero
for that layer. if your network does not train well, it is advisable to monitor the network
for layers with many saturated or dead neurons. saturated neurons are caused by too large

  g if (cid:107)  g(cid:107) > threshold.

(cid:107)  g(cid:107)

22. when debugging, and for reproducibility of results, it is advised to used a    xed random seed.

33

values entering the layer. this may be controlled for by changing the initialization, scaling
the range of the input values, or changing the learning rate. dead neurons are caused by
all weights entering the layer being negative (for example this can happen after a large
gradient update). reducing the learning rate will help in this situation. for saturated
layers, another option is to normalize the values in the saturated layer after the activation,
i.e.
. layer id172 is an e   ective
measure for countering saturation, but is also expensive in terms of gradient computation.

instead of g(h) = tanh(h) using g(h) = tanh(h)
(cid:107)tanh(h)(cid:107)

shu   ing the order in which the training examples are presented to the network is im-
portant. the sgd formulation above speci   es selecting a random example in each turn.
in practice, most implementations go over the training example in order. it is advised to
shu   e the training examples before each pass through the data.

learning rate selection of the learning rate is important. too large learning rates
will prevent the network from converging on an e   ective solution. too small learning
rates will take very long time to converge. as a rule of thumb, one should experiment
with a range of initial learning rates in range [0, 1], e.g. 0.001, 0.01, 0.1, 1. monitor
the network   s loss over time, and decrease the learning rate once the network seem to be
stuck in a    xed region. learning rate scheduling decrease the rate as a function of the
number of observed minibatches. a common schedule is dividing the initial learning rate
by the iteration number. l  eon bottou (2012) recommends using a learning rate of the form
  t =   0(1 +   0  t)   1 where   0 is the initial learning rate,   t is the learning rate to use on
the tth training example, and    is an additional hyperparameter. he further recommends
determining a good value of   0 based on a small sample of the data prior to running on the
entire dataset.

minibatches parameter updates occur either every training example (minibatches of size
1) or every k training examples. some problems bene   t from training with larger minibatch
sizes. in terms of the computation graph abstraction, one can create a computation graph
for each of the k training examples, and then connecting the k loss nodes under an averaging
node, whose output will be the loss of the minibatch. large minibatched training can also
be bene   cial in terms of computation e   ciency on specialized computing architectures such
as gpus. this is beyond the scope of this tutorial.

6.4 id173

neural network models have many parameters, and over   tting can easily occur. over   tting
can be alleviated to some extent by id173. a common id173 method is
l2 id173, placing a squared penalty on parameters with large values by adding
an additive   
2(cid:107)  (cid:107)2 term to the objective function to be minimized, where    is the set of
model parameters, (cid:107)    (cid:107)2 is the squared l2 norm (sum of squares of the values), and    is a
hyperparameter controlling the amount of id173.
a recently proposed alternative id173 method is dropout (hinton, srivastava,
krizhevsky, sutskever, & salakhutdinov, 2012). the dropout method is designed to prevent
the network from learning to rely on speci   c weights. it works by randomly dropping (set-
ting to 0) half of the neurons in the network (or in a speci   c layer) in each training example.
work by wager et al (2013) establishes a strong connection between the dropout method

34

and l2 id173. gal and gharamani (2015) show that a multi-layer id88 with
dropout applied at every layer can be interpreted as bayesian model averaging.

the dropout technique is one of the key factors contributing to very strong results of
neural-network methods on image classi   cation tasks (krizhevsky, sutskever, & hinton,
2012), especially when combined with relu activation units (dahl, sainath, & hinton,
2013). the dropout technique is e   ective also in nlp applications of neural networks.

35

7. cascading and id72

the combination of online training methods with automatic gradient computations using
the computation graph abstraction allows for an easy implementation of model cascading,
parameter sharing and id72.

model cascading is a powerful technique in which large networks are built by composing
them out of smaller component networks. for example, we may have a feed-forward network
for predicting the part of speech of a word based on its neighbouring words and/or the
characters that compose it. in a pipeline approach, we would use this network for predicting
parts of speech, and then feed the predictions as input features to neural network that does
syntactic chunking or parsing. instead, we could think of the hidden layers of this network
as an encoding that captures the relevant information for predicting the part of speech. in
a cascading approach, we take the hidden layers of this network and connect them (and not
the part of speech prediction themselves) as the inputs for the syntactic network. we now
have a larger network that takes as input sequences of words and characters, and outputs a
syntactic structure. the computation graph abstraction allows us to easily propagate the
error gradients from the syntactic task loss all the way back to the characters.

to combat the vanishing gradient problem of deep networks, as well as to make better
use of available training material, the individual component network   s parameters can be
bootstrapped by training them separately on a relevant task, before plugging them in to
the larger network for further tuning. for example, the part-of-speech predicting network
can be trained to accurately predict parts-of-speech on a relatively large annotated corpus,
before plugging its hidden layer into the syntactic parsing network for which less training
data is available. in case the training data provide direct supervision for both tasks, we can
make use of it during training by creating a network with two outputs, one for each task,
computing a separate loss for each output, and then summing the losses into a single node
from which we backpropagate the error gradients.

model cascading is very common when using convolutional, recursive and recurrent
neural networks, where, for example, a recurrent network is used to encode a sentence into
a    xed sized vector, which is then used as the input of another network. the supervision
signal of the recurrent network comes primarily from the upper network that consumes the
recurrent network   s output as it inputs.

id72 is used when we have related prediction tasks that do not neces-
sarily feed into one another, but we do believe that information that is useful for one type
of prediction can be useful also to some of the other tasks. for example, chunking, named
entity recognition (ner) and id38 are examples of synergistic tasks. infor-
mation for predicting chunk boundaries, named-entity boundaries and the next word in the
sentence all rely on some shared underlying syntactic-semantic representation. instead of
training a separate network for each task, we can create a single network with several out-
puts. a common approach is to have a multi-layer feed-forward network, whose    nal hidden
layer (or a concatenation of all hidden layers) is then passed to di   erent output layers. this
way, most of the parameters of the network are shared between the di   erent tasks. useful
information learned from one task can then help to disambiguate other tasks. again, the
computation graph abstraction makes it very easy to construct such networks and compute

36

the gradients for them, by computing a separate loss for each available supervision signal,
and then summing the losses into a single loss that is used for computing the gradients. in
case we have several corpora, each with di   erent kind of supervision signal (e.g. we have
one corpus for ner and another for chunking), the training procedure will shu   e all of the
available training example, performing gradient computation and updates with respect to
a di   erent loss in every turn. id72 in the context of language-processing is
introduced and discussed in (collobert et al., 2011).

37

8. structured output prediction

many problems in nlp involve structured outputs: cases where the desired output is not
a class label or distribution over class labels, but a structured object such as a sequence,
a tree or a graph. canonical examples are sequence tagging (e.g. part-of-speech tagging)
sequence segmentation (chunking, ner), and syntactic parsing. in this section, we discuss
how feed-forward neural network models can be used for structured tasks. in later sections
we discuss specialized neural network models for dealing with sequences (section 10) and
trees (section 12).

8.1 greedy id170

the greedy approach to id170 is to decompose the structure prediction
problem into a sequence of local prediction problems and training a classi   er to perform
each local decision. at test time, the trained classi   er is used in a greedy manner. examples
of this approach are left-to-right tagging models (gim  enez & m`arquez, 2004) and greedy
transition-based parsing (nivre, 2008). such approaches are easily adapted to use neural
networks by simply replacing the local classi   er from a linear classi   er such as an id166 or a
id28 model to a neural network, as demonstrated in (chen & manning, 2014;
lewis & steedman, 2014).

the greedy approaches su   er from error propagation, where mistakes in early decisions
carry over and in   uence later decisions. the overall higher accuracy achievable with non-
linear neural network classi   ers helps in o   setting this problem to some extent. in addition,
training techniques were proposed for mitigating the error propagation problem by either
attempting to take easier predictions before harder ones (the easy-   rst approach (goldberg
& elhadad, 2010)) or making training conditions more similar to testing conditions by
exposing the training procedure to inputs that result from likely mistakes (hal daum  e iii,
langford, & marcu, 2009; goldberg & nivre, 2013). these are e   ective also for training
greedy neural network models, as demonstrated by ma et al (ma, zhang, & zhu, 2014)
(easy-   rst tagger) and (?) (dynamic oracle training for greedy id33).

8.2 search based id170

the common approach to predicting natural language structures is search based. for in-
depth discussion of search-based structure prediction in nlp, see the book by smith (smith,
2011). the techniques can easily be adapted to use a neural-network. in the neural-networks
literature, such models were discussed under the framework of energy based learning (lecun
et al., 2006, section 7). they are presented here using setup and terminology familiar to
the nlp community.

search-based id170 is formulated as a search problem over possible struc-

tures:

predict(x) = arg max
y   y(x)

score(x, y)

where x is an input structure, y is an output over x (in a typical example x is a sentence
and y is a tag-assignment or a parse-tree over the sentence), y(x) is the set of all valid

38

structures over x, and we are looking for an output y that will maximize the score of the
x, y pair.

the scoring function is de   ned as a linear model:

where    is a feature extraction function and w is a weight vector.

score(x, y) =   (x, y)    w

in order to make the search for the optimal y tractable, the structure y is decomposed
into parts, and the feature function is de   ned in terms of the parts, where   (p) is a part-local
feature extraction function:

(cid:88)

  (x, y) =

  (p)
p   parts(x,y)

each part is scored separately, and the structure score is the sum of the component

parts scores:

score(x, y) =w      (x, y) = w   

(cid:88)

p   y

  (p) =

(cid:88)

p   y

w      (p) =

(cid:88)

p   y

score(p)

where p     y is a shorthand for p     parts(x, y). the decomposition of y into parts is such
that there exists an id136 algorithm that allows for e   cient search for the best scoring
structure given the scores of the individual parts.

one can now trivially replace the linear scoring function over parts with a neural-

network:

score(x, y) =

(cid:88)

where c(p) maps the part p into a din dimensional vector.

in case of a one hidden-layer feed-forward network:

score(p) =

n n (c(p))

p   y

p   y

score(x, y) =

n nm lp 1(c(p)) =

(g(c(p)w1 + b1))w

c(p)     rdin, w1     rdin  d1, b1     rd1, w     rd1. a common objective in structured
prediction is making the gold structure y score higher than any other structure y(cid:48), leading
to the following (generalized id88) loss:

y(cid:48) score(x, y(cid:48))     score(x, y)
max

in terms of implementation, this means: create a computation graph cgp for each of
the possible parts, and calculate its score. then, run id136 over the scored parts to
   nd the best scoring structure y(cid:48). connect the output nodes of the computation graphs
corresponding to parts in the gold (predicted) structure y (y(cid:48)) into a summing node cgy
(cg(cid:48)y). connect cgy and cg(cid:48)y using a    minus    node, cgl, and compute the gradients.

as argued in (lecun et al., 2006, section 5), the generalized id88 loss may not
be a good id168 when training id170 neural networks as it does not
have a margin, and a margin-based hinge loss is preferred:

39

(cid:88)

(cid:88)

p   y

(cid:88)

p   y

max(0, m + score(x, y)     max
(cid:54)=y

y(cid:48)

score(x, y(cid:48)))

it is trivial to modify the implementation above to work with the hinge loss.

note that in both cases we lose the nice properties of the linear model. in particular, the
model is no longer convex. this is to be expected, as even the simplest non-linear neural
network is already non-convex. nonetheless, we could still use standard neural-network
optimization techniques to train the structured model.

training and id136 is slower, as we have to evaluate the neural network (and take

gradients) |parts(x, y)| times.
id170 is a vast    eld and is beyond the scope of this tutorial, but loss func-
tions, regularizers and methods described in, e.g., (smith, 2011), such as cost-augmented
decoding, can be easily applied or adapted to the neural-network framework.23

probabilistic objective (crf)
in a probabilistic framework (   crf   ), we treat each
of the parts scores as a clique potential (see (smith, 2011)) and de   ne the score of each
structure y to be:

(cid:80)
(cid:80)
p   y en n (c(p))
rameters of the network such that corpus conditional log likelihood(cid:80)

(cid:80)
(cid:80)
p   y escore(p)

the scoring function de   nes a conditional distribution p (y|x), and we wish to set the pa-

scorecrf (x, y) = p (y|x) =

p   y(cid:48) en n (c(p))

p   y(cid:48) escore(p)

(cid:80)

(cid:80)

   y(x)

   y(x)

=

y(cid:48)

y(cid:48)

(xi,yi)   training log p (yi|xi)

is maximized.

the loss for a given training example (x, y) is then:     log scorecrf (x, y). taking the
gradient with respect to the loss is as involved as building the associated computation
graph. the tricky part is the denominator (the partition function) which requires summing
over the potentially exponentially many structures in y. however, for some problems, a
id145 algorithm exists for e   ciently solving the summation in polynomial
time. when such an algorithm exists, it can be adapted to also create a polynomial-size
computation graph.

when an e   cient enough algorithm for computing the partition function is not available,
approximate methods can be used. for example, one may use id125 for id136,
and for the partition function sum over the structures remaining in the beam instead of
over the exponentially large y(x).
a hinge based approached was used by pei et al (2015) for arc-factored dependency
parsing, and the probabilistic approach by durrett and klein (durrett & klein, 2015) for a
crf constituency parser. the approximate beam-based partition function was e   ectively
used by zhou et al (2015) in a transition based parser.

reranking when searching over all possible structures is intractable, ine   cient or hard
to integrate into a model, reranking methods are often used. in the reranking framework
(charniak & johnson, 2005; collins & koo, 2005) a base model is used to produce a

23. one should keep in mind that the resulting objectives are no longer convex, and so lack the formal guar-
antees and bounds associated with id76 problems. similarly, the theory, learning bounds
and guarantees associated with the algorithms do not automatically transfer to the neural versions.

40

list of the k-best scoring structures. a more complex model is then trained to score the
candidates in the k-best list such that the best structure with respect to the gold one is
scored highest. as the search is now performed over k items rather than over an exponential
space, the complex model can condition on (extract features from) arbitrary aspects of the
scored structure. reranking methods are natural candidates for id170 using
neural-network models, as they allow the modeler to focus on the feature extraction and
network structure, while removing the need to integrate the neural network scoring into a
decoder. indeed, reranking methods are often used for experimenting with neural models
that are not straightforward to integrate into a decoder, such as convolutional, recurrent
and recursive networks, which will be discussed in later sections. works using the reranking
approach include (socher et al., 2013; auli et al., 2013; le & zuidema, 2014; zhu et al.,
2015a)

memm and hybrid approaches other formulations are, of course, also possible. for
example, an memm (mccallum, freitag, & pereira, 2000) can be trivially adapted to the
neural network world by replacing the id28 (   maximum id178   ) component
with an mlp.

hybrid approaches between neural networks and linear models are also explored.

in
particular, weiss et al (weiss et al., 2015) report strong results for transition-based depen-
dency parsing in a two-stage model. in the    rst stage, a static feed-forward neural network
(mlp2) is trained to perform well on each of the individual decisions of the structured
problem in isolation. in the second stage, the neural network model is held    xed, and the
di   erent layers (output as well as hidden layer vectors) for each input are then concatenated
and used as the input features of a linear structured id88 model (collins, 2002) that
is trained to perform beam-search for the best resulting structure. while it is not clear
that such training regime is more e   ective than training a single structured-prediction neu-
ral network, the use of two simpler, isolated models allowed the researchers to perform a
much more extensive hyper-parameter search (e.g. tuning layer sizes, id180,
learning rates and so on) for each model than is feasible with more complicated networks.

41

9. convolutional layers

sometimes we are interested in making predictions based on ordered sets of items (e.g.
the sequence of words in a sentence, the sequence of sentences in a document and so on).
consider for example predicting the sentiment (positive, negative or neutral) of a sentence.
some of the sentence words are very informative of the sentiment, other words are less
informative, and to a good approximation, an informative clue is informative regardless
of its position in the sentence. we would like to feed all of the sentence words into a
learner, and let the training process    gure out the important clues. one possible solution is
feeding a cbow representation into a fully connected network such as an mlp. however,
a downside of the cbow approach is that it ignores the ordering information completely,
assigning the sentences    it was not good, it was actually quite bad    and    it was not bad,
it was actually quite good    the exact same representation. while the global position of
the indicators    not good    and    not bad    does not matter for the classi   cation task, the
local ordering of the words (that the word    not    appears right before the word    bad   ) is
very important. a naive approach would suggest embedding word-pairs (bi-grams) rather
than words, and building a cbow over the embedded bigrams. while such architecture
could be e   ective, it will result in huge embedding matrices, will not scale for longer n-
grams, and will su   er from data sparsity problems as it does not share statistical strength
between di   erent id165s (the embedding of    quite good    and    very good    are completely
independent of one another, so if the learner saw only one of them during training, it
will not be able to deduce anything about the other based on its component words). the
convolution-and-pooling (also called convolutional neural networks, or id98s) architecture
is an elegant and robust solution to this modeling problem. a convolutional neural network
is designed to identify indicative local predictors in a large structure, and combine them
to produce a    xed size vector representation of the structure, capturing these local aspects
that are most informative for the prediction task at hand.

convolution-and-pooling architectures (lecun & bengio, 1995) evolved in the neural
networks vision community, where they showed great success as object detectors     recog-
nizing an object from a prede   ned category (   cat   ,    bicycles   ) regardless of its position in
the image (krizhevsky et al., 2012). when applied to images, the architecture is using 2-
dimensional (grid) convolutions. when applied to text, nlp we are mainly concerned with
1-d (sequence) convolutions. convolutional networks were introduced to the nlp commu-
nity in the pioneering work of collobert, weston and colleagues (2011) who used them for
semantic-role labeling, and later by kalchbrenner et al (2014) and kim (kim, 2014) who
used them for sentiment and question-type classi   cation.

9.1 basic convolution + pooling

the main idea behind a convolution and pooling architecture for language tasks is to apply
a non-linear (learned) function over each instantiation of a k-word sliding window over
the sentence. this function (also called       lter   ) transforms a window of k words into a d
dimensional vector that captures important properties of the words in the window (each
dimension is sometimes referred to in the literature as a    channel   ). then, a    pooling   
operation is used combine the vectors resulting from the di   erent windows into a single
d-dimensional vector, by taking the max or the average value observed in each of the d

42

channels over the di   erent windows. the intention is to focus on the most important
   features    in the sentence, regardless of their location. the d-dimensional vector is then
fed further into a network that is used for prediction. the gradients that are propagated
back from the network   s loss during the training process are used to tune the parameters
of the    lter function to highlight the aspects of the data that are important for the task
the network is trained for. intuitively, when the sliding window is run over a sequence, the
   lter function learns to identify informative k-grams.

more formally, consider a sequence of words x = x1, . . . , xn, each with their correspond-
ing demb dimensional id27 v(xi). a 1d convolution layer24 of width k works
by moving a sliding window of size k over the sentence, and applying the same       lter    to
each window in the sequence (v(xi); v(xi+1); . . . ; v(xi+k   1)). the    lter function is usually a
linear transformation followed by a non-linear activation function.

let the concatenated vector of the ith window be wi = v(xi); v(xi+1); . . . ; v(xi+k   1),
wi     rkdemb. depending on whether we pad the sentence with k     1 words to each side,
we may get either m = n     k + 1 (narrow convolution) or m = n + k + 1 windows (wide
convolution) (kalchbrenner et al., 2014). the result of the convolution layer is m vectors
p1, . . . , pm, pi     rdconv where:

pi = g(wiw + b)

.

g is a non-linear activation function that is applied element-wise, w     rk  demb  dconv and
b     rdconv are parameters of the network. each pi is a dconv dimensional vector, encoding
the information in wi. ideally, each dimension captures a di   erent kind of indicative infor-
mation. the m vectors are then combined using a max pooling layer, resulting in a single
dconv dimensional vector c.

cj = max
1<i   m

pi[j]

pi[j] denotes the jth component of pi. the e   ect of the max-pooling operation is to get the
most salient information across window positions. ideally, each dimension will    specialize   
in a particular sort of predictors, and max operation will pick on the most important
predictor of each type.

figure 4 provides an illustration of the process.
the resulting vector c is a representation of the sentence in which each dimension
re   ects the most salient information with respect to some prediction task. c is then fed
into a downstream network layers, perhaps in parallel to other vectors, culminating in an
output layer which is used for prediction. the training procedure of the network calculates
the loss with respect to the prediction task, and the error gradients are propagated all the
way back through the pooling and convolution layers, as well as the embedding layers. 25

24. 1d here refers to a convolution operating over 1-dimensional inputs such as sequences, as opposed to 2d

convolutions which are applied to images.

25. besides being useful for prediction, a by-product of the training procedure is a set of parameters w, b
and embeddings v() that can be used in a convolution and pooling architecture to encode arbitrary length
sentences into    xed-size vectors, such that sentences that share the same kind of predictive information
will be close to each other.

43

figure 4: 1d convolution+pooling over the sentence    the quick brown fox jumped over the
lazy dog   . this is a narrow convolution (no padding is added to the sentence)
with a window size of 3. each word is translated to a 2-dim embedding vector
(not shown). the embedding vectors are then concatenated, resulting in 6-dim
window representations. each of the seven windows is transfered through a 6   3
   lter (linear transformation followed by element-wise tanh), resulting in seven
3-dimensional    ltered representations. then, a max-pooling operation is applied,
taking the max over each dimension, resulting in a    nal 3-dimensional pooled
vector.

while max-pooling is the most common pooling operation in text applications, other
pooling operations are also possible, the second most common operation being average
pooling, taking the average value of each index instead of the max.

9.2 dynamic, hierarchical and k-max pooling

rather than performing a single pooling operation over the entire sequence, we may want
to retain some positional information based on our domain understanding of the prediction
problem at hand. to this end, we can split the vectors pi into (cid:96) distinct groups, apply
the pooling separately on each group, and then concatenate the (cid:96) resulting dconv vectors
c1, . . . , c(cid:96). the division of the pis into groups is performed based on domain knowledge. for
example, we may conjecture that words appearing early in the sentence are more indicative
than words appearing late. we can then split the sequence into (cid:96) equally sized regions,
applying a separate max-pooling to each region. for example, johnson and zhang (johnson
& zhang, 2014) found that when classifying documents into topics, it is useful to have 20
average-pooling regions, clearly separating the initial sentences (where the topic is usually
introduced) from later ones, while for a sentiment classi   cation task a single max-pooling
operation over the entire sentence was optimal (suggesting that one or two very strong
signals are enough to determine the sentiment, regardless of the position in the sentence).

44

thequickbrownquickbrownfoxbrownfoxjumpedfoxjumpedoverjumpedovertheoverthelazythelazydogmul+tanhmul+tanhmul+tanhmul+tanhmul+tanhmul+tanhmul+tanhw6  3thequickbrownfoxjumpedoverthelazydogmaxconvolutionpooling                  

                  
(cid:21)
(cid:20)9 6 3

1 2 3
9 6 5
2 3 1
7 8 1
3 4 1

similarly, in a id36 kind of task we may be given two words and asked to
determine the relation between them. we could argue that the words before the    rst word,
the words after the second word, and the words between them provide three di   erent kinds
of information (chen et al., 2015). we can thus split the pi vectors accordingly, pooling
separately the windows resulting from each group.

another variation is performing hierarchical pooling, in which we have a succession
of convolution and pooling layers, where each stage applies a convolution to a sequence,
pools every k neighboring vectors, performs a convolution on the resulting pooled sequence,
applies another convolution and so on. this architecture allows sensitivity to increasingly
larger structures.

finally, (kalchbrenner et al., 2014) introduced a k-max pooling operation, in which the
top k values in each dimension are retained instead of only the best one, while preserving
the order in which they appeared in the text. for example a, consider the following matrix:

a 1-max pooling over the column vectors will result in (cid:2)9 8 5(cid:3), while a 2-max pooling
(cid:2)9 6 3 7 8 5(cid:3)

whose rows will then be concatenated to

will result in the following matrix:

7 8 5

the k-max pooling operation makes it possible to pool the k most active indicators that
may be a number of positions apart; it preserves the order of the features, but is insensitive
to their speci   c positions. it can also discern more    nely the number of times the feature
is highly activated (kalchbrenner et al., 2014).

9.3 variations

rather than a single convolutional layer, several convolutional layers may be applied in
parallel. for example, we may have four di   erent convolutional layers, each with a di   erent
window size in the range 2   5, capturing id165 sequences of varying lengths. the result
of each convolutional layer will then be pooled, and the resulting vectors concatenated and
fed to further processing (kim, 2014).

the convolutional architecture need not be restricted into the linear ordering of a sen-
tence. for example, ma et al (2015) generalize the convolution operation to work over
syntactic dependency trees. there, each window is around a node in the syntactic tree,
and the pooling is performed over the di   erent nodes. similarly, liu et al (2015) apply a
convolutional architecture on top of dependency paths extracted from dependency trees. le
and zuidema (2015) propose to perform max pooling over vectors representing the di   erent
derivations leading to the same chart item in a chart parser.

45

10. recurrent neural networks     modeling sequences and stacks

when dealing with language data, it is very common to work with sequences, such as words
(sequences of letters), sentences (sequences of words) and documents. we saw how feed-
forward networks can accommodate arbitrary feature functions over sequences through the
use of vector concatenation and vector addition (cbow). in particular, the cbow rep-
resentations allows to encode arbitrary length sequences as    xed sized vectors. however,
the cbow representation is quite limited, and forces one to disregard the order of fea-
tures. the convolutional networks also allow encoding a sequence into a    xed size vector.
while representations derived from convolutional networks are an improvement above the
cbow representation as they o   er some sensitivity to word order, their order sensitivity is
restricted to mostly local patterns, and disregards the order of patterns that are far apart
in the sequence.

recurrent neural networks (id56s) (elman, 1990) allow representing arbitrarily sized
structured inputs in a    xed-size vector, while paying attention to the structured properties
of the input.

10.1 the id56 abstraction

we use xi:j to denote the sequence of vectors xi, . . . , xj. the id56 abstraction takes as
input an ordered list of input vectors x1, ..., xn together with an initial state vector s0,
and returns an ordered list of state vectors s1, ..., sn, as well as an ordered list of output
vectors y1, ..., yn. an output vector yi is a function of the corresponding state vector
si. the input vectors xi are presented to the id56 in a sequential fashion, and the state
vector si and output vector yi represent the state of the id56 after observing the inputs
x1:i. the output vector yi is then used for further prediction. for example, a model for
predicting the id155 of an event e given the sequence m1:i can be de   ned
as p(e = j|x1:i) = sof tmax(yiw + b)[j]. the id56 model provides a framework for
conditioning on the entire history x1, . . . , xi without resorting to the markov assumption
which is traditionally used for modeling sequences. indeed, id56-based language models
result in very good perplexity scores when compared to id165 based models.

mathematically, we have a recursively de   ned function r that takes as input a state
vector si and an input vector xi+1, and results in a new state vector si+1. an additional
function o is used to map a state vector si to an output vector yi. when constructing an
id56, much like when constructing a feed-forward network, one has to specify the dimension
of the inputs xi as well as the dimensions of the outputs yi. the dimensions of the states
si are a function of the output dimension.26

26. while id56 architectures in which the state dimension is independent of the output dimension are
possible, the current popular architectures, including the simple id56, the lstm and the gru do not
follow this    exibility.

46

rn n (s0, x1:n) =s1:n, y1:n

si = r(si   1, xi)
yi = o(si)

xi     rdin, yi     rdout, si     rf (dout)

the functions r and o are the same across the sequence positions, but the id56 keeps
track of the states of computation through the state vector that is kept and being passed
between invocations of r.

graphically, the id56 has been traditionally presented as in figure 5.

figure 5: graphical representation of an id56 (recursive).

this presentation follows the recursive de   nition, and is correct for arbitrary long sequences.
however, for a    nite sized input sequence (and all input sequences we deal with are    nite)
one can unroll the recursion, resulting in the structure in figure 6.

figure 6: graphical representation of an id56 (unrolled).

while not usually shown in the visualization, we include here the parameters    in order
to highlight the fact that the same parameters are shared across all time steps. di   erent

47

r,oxiyisisi   1  s0r,ox1y1r,ox2y2s1r,ox3y3s2  r,ox4y4s3r,ox5y5s4s5instantiations of r and o will result in di   erent network structures, and will exhibit di   erent
properties in terms of their running times and their ability to be trained e   ectively using
gradient-based methods. however, they all adhere to the same abstract interface. we will
provide details of concrete instantiations of r and o     the simple id56, the lstm and the
gru     in section 11. before that, let   s consider modeling with the id56 abstraction.

first, we note that the value of si is based on the entire input x1, ..., xi. for example,

by expanding the recursion for i = 4 we get:

s4 =r(s3, x4)
s3

(cid:122)

=r(

r(s2, x3), x4)

(cid:125)(cid:124)
(cid:123)
(cid:122)
(cid:125)(cid:124)
(cid:123)
(cid:125)(cid:124)
(cid:122)

s1

s2

(cid:123)

=r(r(

r(s1, x2), x3), x4)

=r(r(r(

r(s0, x1), x2), x3), x4)

thus, sn (as well as yn) could be thought of as encoding the entire input sequence.27 is
the encoding useful? this depends on our de   nition of usefulness. the job of the network
training is to set the parameters of r and o such that the state conveys useful information
for the task we are tying to solve.

10.2 id56 training

viewed as in figure 6 it is easy to see that an unrolled id56 is just a very deep neural
network (or rather, a very large computation graph with somewhat complex nodes), in
which the same parameters are shared across many parts of the computation. to train an
id56 network, then, all we need to do is to create the unrolled computation graph for a
given input sequence, add a loss node to the unrolled graph, and then use the backward
(id26) algorithm to compute the gradients with respect to that loss. this
procedure is referred to in the id56 literature as id26 through time, or bptt
(werbos, 1990).28 there are various ways in which the supervision signal can be applied.

acceptor one option is to base the supervision signal only on the    nal output vector,
yn. viewed this way, the id56 is an acceptor. we observe the    nal state, and then decide

27. note that, unless r is speci   cally designed against this, it is likely that the later elements of the input

sequence have stronger e   ect on sn than earlier ones.

28. variants of the bptt algorithm include unrolling the id56 only for a    xed number of input symbols at
each time:    rst unroll the id56 for inputs x1:k, resulting in s1:k. compute a loss, and backpropagate
the error through the network (k steps back). then, unroll the inputs xk+1:2k, this time using sk as the
initial state, and again backpropagate the error for k steps, and so on. this strategy is based on the
observations that for the simple-id56 variant, the gradients after k steps tend to vanish (for large enough
k), and so omitting them is negligible. this procedure allows training of arbitrarily long sequences. for
id56 variants such as the lstm or the gru that are designed speci   cally to mitigate the vanishing
gradients problem, this    xed size unrolling is less motivated, yet it is still being used, for example when
doing id38 over a book without breaking it into sentences.

48

on an outcome.29 for example, consider training an id56 to read the characters of a word
one by one and then use the    nal state to predict the part-of-speech of that word (this is
inspired by (ling et al., 2015b)), an id56 that reads in a sentence and, based on the    nal
state decides if it conveys positive or negative sentiment (this is inspired by (wang et al.,
2015b)) or an id56 that reads in a sequence of words and decides whether it is a valid
noun-phrase. the loss in such cases is de   ned in terms of a function of yn = o(sn), and
the error gradients will backpropagate through the rest of the sequence (see figure 7).30
the loss can take any familiar form     cross id178, hinge, margin, etc.

figure 7: acceptor id56 training graph.

encoder similar to the acceptor case, an encoder supervision uses only the    nal output
vector, yn. however, unlike the acceptor, where a prediction is made solely on the basis
of the    nal vector, here the    nal vector is treated as an encoding of the information in the
sequence, and is used as additional information together with other signals. for example, an
extractive document summarization system may    rst run over the document with an id56,
resulting in a vector yn summarizing the entire document. then, yn will be used together
with other features in order to select the sentences to be included in the summarization.

then be: l(   y1:n, y1:n) = (cid:80)n

transducer another option is to treat the id56 as a transducer, producing an output for
each input it reads in. modeled this way, we can compute a local loss signal llocal(   yi, yi)
for each of the outputs   yi based on a true label yi. the loss for unrolled sequence will
i=1 llocal(   yi, yi), or using another combination rather than a
sum such as an average or a weighted average (see figure 8). one example for such a
transducer is a sequence tagger, in which we take xi:n to be feature representations for the
n words of a sentence, and yi as an input for predicting the tag assignment of word i based
on words 1:i. a id35 super-tagger based on such an architecture provides state-of-the art
id35 super-tagging results (xu et al., 2015).

a very natural use-case of the transduction setup is for id38, in which the
sequence of words x1:i is used to predict a distribution over the i + 1th word. id56 based

29. the terminology is borrowed from finite-state acceptors. however, the id56 has a potentially in   nite
number of states, making it necessary to rely on a function other than a lookup table for mapping states
to decisions.

30. this kind of supervision signal may be hard to train for long sequences, especially so with the simple-
id56, because of the vanishing gradients problem. it is also a generally hard learning task, as we do not
tell the process on which parts of the input to focus.

49

r,ox1s0r,ox2s1r,ox3s2r,ox4s3r,ox5s4predict&calclossy5lossfigure 8: transducer id56 training graph.

language models are shown to provide much better perplexities than traditional language
models (mikolov et al., 2010; sundermeyer, schl  uter, & ney, 2012; mikolov, 2012).

using id56s as transducers allows us to relax the markov assumption that is tradition-
ally taken in language models and id48 taggers, and condition on the entire prediction
history. the power of the ability to condition on arbitrarily long histories is demonstrated
in generative character-level id56 models, in which a text is generated character by charac-
ter, each character conditioning on the previous ones (sutskever, martens, & hinton, 2011).
the generated texts show sensitivity to properties that are not captured by id165 language
models, including line lengths and nested parenthesis balancing. for a good demonstration
and analysis of the properties of id56-based id186, see (karpathy,
johnson, & li, 2015).

encoder - decoder finally, an important special case of the encoder scenario is the
encoder-decoder framework (cho, van merrienboer, bahdanau, & bengio, 2014a; sutskever
et al., 2014). the id56 is used to encode the sequence into a vector representation yn, and
this vector representation is then used as auxiliary input to another id56 that is used as
a decoder. for example, in a machine-translation setup the    rst id56 encodes the source
sentence into a vector representation yn, and then this state vector is fed into a separate
(decoder) id56 that is trained to predict (using a transducer-like id38 ob-
jective) the words of the target language sentence based on the previously predicted words
as well as yn. the supervision happens only for the decoder id56, but the gradients are
propagated all the way back to the encoder id56 (see figure 9).

such an approach was shown to be surprisingly e   ective for machine translation (sutskever

et al., 2014) using lstm id56s. in order for this technique to work, sutskever et al found it
e   ective to input the source sentence in reverse, such that xn corresponds to the    rst word
of the sentence. in this way, it is easier for the second id56 to establish the relation be-
tween the    rst word of the source sentence to the    rst word of the target sentence. another
use-case of the encoder-decoder framework is for sequence transduction. here, in order to
generate tags t1, . . . , tn, an encoder id56 is    rst used to encode the sentence x1:n into    xed
sized vector. this vector is then fed as the initial state vector of another (transducer) id56,
which is used together with x1:n to predict the label ti at each position i. this approach

50

r,ox1s0predict&calclossy1r,ox2s1predict&calclossy2r,ox3s2predict&calclossy3r,ox4s3predict&calclossy4r,ox5s4predict&calclossy5sumlossfigure 9: encoder-decoder id56 training graph.

was used in (filippova, alfonseca, colmenares, kaiser, & vinyals, 2015) to model sentence
compression by deletion.

10.3 multi-layer (stacked) id56s

id56s can be stacked in layers, forming a grid (hihi & bengio, 1996). consider k id56s,
rn n1, . . . , rn nk, where the jth id56 has states sj
1:n. the input for the
   rst id56 are x1:n, while the input of the jth id56 (j     2) are the outputs of the id56
below it, yj   1
1:n.
such layered architectures are often called deep id56s. a visual representation of a 3-layer
id56 is given in figure 10.

1:n . the output of the entire formation is the output of the last id56, yk

1:n and outputs yj

while it is not theoretically clear what is the additional power gained by the deeper
architecture, it was observed empirically that deep id56s work better than shallower ones
on some tasks. in particular, sutskever et al (2014) report that a 4-layers deep architec-
ture was crucial in achieving good machine-translation performance in an encoder-decoder
framework. irsoy and cardie (2014) also report improved results from moving from a one-
layer bi-id56 to an architecture with several layers. many other works report result using
layered id56 architectures, but do not explicitly compare to 1-layer id56s.

51

re,oex1se0re,oex2se1re,oex3se2re,oex4se3re,oex5se4se5rd,odx1sd0predict&calclossy1rd,odx2sd1predict&calclossy2rd,odx3sd2predict&calclossy3rd,odx4sd3predict&calclossy4rd,odx5sd4predict&calclossy5sumlossfigure 10: a 3-layer (   deep   ) id56 architecture.

10.4 bi-id56

a useful elaboration of an id56 is a bidirectional-id56 (bi-id56) (schuster & paliwal, 1997;
graves, 2008).31 consider the task of sequence tagging over a sentence x1, . . . , xn. an id56
allows us to compute a function of the ith word xi based on the past     the words x1:i up
to and including it. however, the following words xi:n may also be useful for prediction, as
is evident by the common sliding-window approach in which the focus word is categorized
based on a window of k words surrounding it. much like the id56 relaxes the markov
assumption and allows looking arbitrarily back into the past, the bi-id56 relaxes the    xed
window size assumption, allowing to look arbitrarily far at both the past and the future.

i and sb
i

for each input position i. the forward state sf

consider an input sequence x1:n. the bi-id56 works by maintaining two separate
states, sf
i is based on x1, x2, . . . , xi,
while the backward state sb
is based on xn, xn   1, . . . , xi. the forward and backward states
i
are generated by two di   erent id56s. the    rst id56 (rf , of ) is fed the input sequence
x1:n as is, while the second id56 (rb, ob) is fed the input sequence in reverse. the state
representation si is then composed of both the forward and backward states.

i ; yb

i ); ob(sb

i ] = [of (sf

the output at position i is based on the concatenation of the two output vectors
yi = [yf
i )], taking into account both the past and the future. the
vector yi can then be used directly for prediction, or fed as part of the input to a more
complex network. while the two id56s are run independently of each other, the error gra-
dients at position i will    ow both forward and backward through the two id56s. a visual
representation of the bi-id56 architecture is given in figure 11.

the use of bi-id56s for sequence tagging was introduced to the nlp community by

irsoy and cardie (2014).

10.5 id56s for representing stacks

some algorithms in language processing, including those for transition-based parsing (nivre,
2008), require performing feature extraction over a stack.
instead of being con   ned to

31. when used with a speci   c id56 architecture such as an lstm, the model is called bi-lstm.

52

r1,o1r2,o2y11s10r3,o3y21s20s30x1y1y31r1,o1r2,o2y12s11r3,o3y22s21s31x2y2y32r1,o1r2,o2y13s12r3,o3y23s22s32x3y3y33r1,o1r2,o2y14s13r3,o3y24s23s33x4y4y34r1,o1r2,o2y15s14r3,o3y25s24s34x5y5y35s15s25s35figure 11: bi-id56 over the sentence    the brown fox jumped .   .

looking at the k top-most elements of the stack, the id56 framework can be used to provide
a    xed-sized vector encoding of the entire stack.

the main intuition is that a stack is essentially a sequence, and so the stack state can be
represented by taking the stack elements and feeding them in order into an id56, resulting
in a    nal encoding of the entire stack. in order to do this computation e   ciently (without
performing an o(n) stack encoding operation each time the stack changes), the id56 state
is maintained together with the stack state.
if the stack was push-only, this would be
trivial: whenever a new element x is pushed into the stack, the corresponding vector x
will be used together with the id56 state si in order to obtain a new state si+1. dealing
with pop operation is more challenging, but can be solved by using the persistent-stack
data-structure (okasaki, 1999; goldberg, zhao, & huang, 2013). persistent, or immutable,
data-structures keep old versions of themselves intact when modi   ed. the persistent stack
construction represents a stack as a pointer to the head of a linked list. an empty stack is
the empty list. the push operation appends an element to the list, returning the new head.
the pop operation then returns the parent of the head, but keeping the original list intact.
from the point of view of someone who held a pointer to the previous head, the stack did
not change. a subsequent push operation will add a new child to the same node. applying
this procedure throughout the lifetime of the stack results in a tree, where the root is an
empty stack and each path from a node to the root represents an intermediary stack state.
figure 12 provides an example of such a tree. the same process can be applied in the
computation graph construction, creating an id56 with a tree structure instead of a chain
structure. backpropagating the error from a given node will then a   ect all the elements
that participated in the stack when the node was created, in order. figure 13 shows the
computation graph for the stack-id56 corresponding to the last state in figure 12. this
modeling approach was proposed independently by dyer et al and watanabe et al (dyer
et al., 2015; watanabe & sumita, 2015) for transition-based id33.

53

rf,ofxtheconcatyf1sf0rf,ofxbrownconcatyf2sf1rf,ofxfoxconcatyf3sf2rf,ofxjumpedconcatyf4sf3rf,ofx   concatyf5sf4sf5rb,obs0sb0yb1rb,obs1sb1yb2rb,obs2sb2yb3rb,obs3sb3yb4rb,obs4sb4yb5sb5ytheybrownyfoxyjumpedy   figure 12: an immutable stack construction for the sequence of operations push a; push b;

push c; pop; push d; pop; pop; push e; push f.

figure 13: the stack-id56 corresponding to the    nal state in figure 12.

10.6 a note on reading the literature

unfortunately, it is often the case that inferring the exact model form from reading its
description in a research paper can be quite challenging. many aspects of the models

54

   ahead(1)pusha   abhead(2)pushb   abchead(3)pushc   abheadc(4)pop   abcdhead(5)pushd   abheadcd(6)pop   aheadbcd(7)pop   abcdehead(8)pushe   abcdefhead(9)pushfsor,oyaxar,osaya:bxbr,osa:bya:cxcsa:cr,osa:bya,b,dxdsa,b,dr,osaya,exer,osa,eya,e,fxfsa,e,fare not yet standardized, and di   erent researchers use the same terms to refer to slightly
di   erent things. to list a few examples, the inputs to the id56 can be either one-hot vectors
(in which case the embedding matrix is internal to the id56) or embedded representations;
the input sequence can be padded with start-of-sequence and/or end-of-sequence symbols,
or not; while the output of an id56 is usually assumed to be a vector which is expected
to be fed to additional layers followed by a softmax for prediction (as is the case in the
presentation in this tutorial), some papers assume the softmax to be part of the id56 itself;
in multi-layer id56, the    state vector    can be either the output of the top-most layer, or a
concatenation of the outputs from all layers; when using the encoder-decoder framework,
conditioning on the output of the encoder can be interpreted in various di   erent ways; and
so on. on top of that, the lstm architecture described in the next section has many small
variants, which are all referred to under the common name lstm. some of these choices
are made explicit in the papers, other require careful reading, and others still are not even
mentioned, or are hidden behind ambiguous    gures or phrasing.

as a reader, be aware of these issues when reading and interpret model descriptions. as
a writer, be aware of these issues as well: either fully specify your model in mathematical
notation, or refer to a di   erent source in which the model is fully speci   ed, if such a source
is available. if using the default implementation from a software package without knowing
the details, be explicit of that fact and specify the software package you use. in any case,
don   t rely solely on    gures or natural language text when describing your model, as these
are often ambiguous.

55

11. concrete id56 architectures

we now turn to present three di   erent instantiations of the abstract rn n architecture
discussed in the previous section, providing concrete de   nitions of the functions r and o.
these are the simple id56 (sid56), the long short-term memory (lstm) and the gated
recurrent unit (gru).

11.1 simple id56

the simplest id56 formulation, known as an elman network or simple-id56 (s-id56), was
proposed by elman (1990) and explored for use in id38 by mikolov (2012).
the s-id56 takes the following form:

si =rsrn n (si   1, xi) = g(xiwx + si   1ws + b)
yi =osrn n (si) = si

si, yi     rds, xi     rdx, wx     rdx  ds, ws     rds  ds, b     rds

that is, the state at position i is a linear combination of the input at position i and
the previous state, passed through a non-linear activation (commonly tanh or relu). the
output at position i is the same as the hidden state in that position.32

in spite of its simplicity, the simple id56 provides strong results for sequence tagging
(xu et al., 2015) as well as id38. for comprehensive discussion on using
simple id56s for id38, see the phd thesis by mikolov (2012).

11.2 lstm

the s-id56 is hard to train e   ectively because of the vanishing gradients problem. error
signals (gradients) in later steps in the sequence diminish quickly in the back-propagation
process, and do not reach earlier input signals, making it hard for the s-id56 to capture
long-range dependencies. the long short-term memory (lstm) architecture (hochreiter
& schmidhuber, 1997) was designed to solve the vanishing gradients problem. the main
idea behind the lstm is to introduce as part of the state representation also    memory
cells    (a vector) that can preserve gradients across time. access to the memory cells is
controlled by gating components     smooth mathematical functions that simulate logical
gates. at each input state, a gate is used to decide how much of the new input should be
written to the memory cell, and how much of the current content of the memory cell should
be forgotten. concretely, a gate g     [0, 1]n is a vector of values in the range [0, 1] that is
multiplied component-wise with another vector v     rn, and the result is then added to
another vector. the values of g are designed to be close to either 0 or 1, i.e. by using a
sigmoid function. indices in v corresponding to near-one values in g are allowed to pass,
while those corresponding to near-zero values are blocked.

32. some authors treat the output at position i as a more complicated function of the state. in our presen-
tation, such further transformation of the output are not considered part of the id56, but as separate
computations that are applied to the id56s output. the distinction between the state and the output
are needed for the lstm architecture, in which not all of the state is observed outside of the id56.

56

mathematically, the lstm architecture is de   ned as:33

sj = rlst m (sj   1, xj) =[cj; hj]

cj =cj   1 (cid:12) f + g (cid:12) i
hj = tanh(cj) (cid:12) o
i =  (xjwxi + hj   1whi)
f =  (xjwxf + hj   1whf )
o =  (xjwxo + hj   1who)
g = tanh(xjwxg + hj   1whg)

yj = olst m (sj) =hj

sj     r2  dh, xi     rdx, cj, hj, i, f , o, g     rdh, wx        rdx  dh, wh        rdh  dh,

the symbol (cid:12) is used to denote component-wise product. the state at time j is com-
posed of two vectors, cj and hj, where cj is the memory component and hj is the output,
or state, component. there are three gates, i, f and o, controlling for input, f orget and
output. the gate values are computed based on linear combinations of the current input
xj and the previous state hj   1, passed through a sigmoid activation function. an update
candidate g is computed as a linear combination of xj and hj   1, passed through a tanh
activation function. the memory cj is then updated: the forget gate controls how much
of the previous memory to keep (cj   1 (cid:12) f ), and the input gate controls how much of the
proposed update to keep (g (cid:12) i). finally, the value of hj (which is also the output yj) is
determined based on the content of the memory cj, passed through a tanh non-linearity
and controlled by the output gate. the gating mechanisms allow for gradients related to
the memory part cj to stay high across very long time ranges.

for further discussion on the lstm architecture see the phd thesis by alex graves
(2008), as well as chris olah   s description.34 for an analysis of the behavior of an lstm
when used as a character-level language model, see (karpathy et al., 2015).

lstms are currently the most successful type of id56 architecture, and they are re-
sponsible for many state-of-the-art sequence modeling results. the main competitor of the
lstm-id56 is the gru, to be discussed next.

practical considerations when training id137, jozefowicz et al (2015) strongly
recommend to always initialize the bias term of the forget gate to be close to one. when
applying dropout to an id56 with an lstm, zaremba et al (2014) found out that it is

33. there are many variants on the lstm architecture presented here. for example, forget gates were not
part of the original proposal in (hochreiter & schmidhuber, 1997), but are shown to be an important
part of the architecture. other variants include peephole connections and gate-tying. for an overview
and comprehensive empirical comparison of various lstm architectures see (gre   , srivastava, koutn    k,
steunebrink, & schmidhuber, 2015).

34. http://colah.github.io/posts/2015-08-understanding-lstms/

57

crucial to apply dropout only on the non-recurrent connection, i.e. only to apply it between
layers and not between sequence positions.

11.3 gru

the lstm architecture is very e   ective, but also quite complicated. the complexity of the
system makes it hard to analyze, and also computationally expensive to work with. the
gated recurrent unit (gru) was recently introduced by cho et al (2014b) as an alternative
to the lstm. it was subsequently shown by chung et al (2014) to perform comparably to
the lstm on several (non textual) datasets.

like the lstm, the gru is also based on a gating mechanism, but with substantially

fewer gates and without a separate memory component.

sj = rgru (sj   1, xj) =(1     z) (cid:12) sj   1 + z (cid:12) h
z =  (xjwxz + hj   1whz)
r =  (xjwxr + hj   1whr)
h = tanh(xjwxh + (hj   1 (cid:12) r)whg)

yj = olst m (sj) =sj

sj     rdh, xi     rdx, z, r, h     rdh, wx        rdx  dh, wh        rdh  dh,

one gate (r) is used to control access to the previous state sj   1 and compute a proposed
update h. the updated state sj (which also serves as the output yj) is then determined based
on an interpolation of the previous state sj   1 and the proposal h, where the proportions of
the interpolation are controlled using the gate z.
the gru was shown to be e   ective in id38 and machine translation.
however, the jury between the gru, the lstm and possible alternative id56 architectures
is still out, and the subject is actively researched. for an empirical exploration of the gru
and the lstm architectures, see (jozefowicz et al., 2015).

11.4 other variants

the gated architectures of the lstm and the gru help in alleviating the vanishing gradi-
ents problem of the simple id56, and allow these id56s to capture dependencies that span
long time ranges. some researchers explore simpler architectures than the lstm and the
gru for achieving similar bene   ts.

mikolov et al (2014) observed that the id127 si   1ws coupled with the
nonlinearity g in the update rule r of the simple id56 causes the state vector si to undergo
large changes at each time step, prohibiting it from remembering information over long
time periods. they propose to split the state vector si into a slow changing component ci
(   context units   ) and a fast changing component hi.35 the slow changing component ci is

35. we depart from the notation in (mikolov et al., 2014) and reuse the symbols used in the lstm descrip-

tion.

58

updated according to a linear interpolation of the input and the previous component: ci =
(1       )xiwx1 +   ci   1, where        (0, 1). this update allows ci to accumulate the previous
inputs. the fast changing component hi is updated similarly to the simple id56 update
rule, but changed to take ci into account as well:36 hi =   (xiwx2 + hi   1wh + ciwc).
finally, the output yi is the concatenation of the slow and the fast changing parts of the
state: yi = [ci; hi]. mikolov et al demonstrate that this architecture provides competitive
perplexities to the much more complex lstm on id38 tasks.

the approach of mikolov et al can be interpreted as constraining the block of the matrix
ws in the s-id56 corresponding to ci to be a multiply of the identity matrix (see mikolov
et al (2014) for the details). le et al (le, jaitly, & hinton, 2015) propose an even simpler
approach: set the activation function of the s-id56 to a relu, and initialize the biases b
as zeroes and the matrix ws as the identify matrix. this causes an untrained id56 to copy
the previous state to the current state, add the e   ect of the current input xi and set the
negative values to zero. after setting this initial bias towards state copying, the training
procedure allows ws to change freely. le et al demonstrate that this simple modi   cation
makes the s-id56 comparable to an lstm with the same number of parameters on several
tasks, including id38.

36. the update rule diverges from the s-id56 update rule also by    xing the non-linearity to be a sigmoid
function, and by not using a bias term. however, these changes are not discussed as central to the
proposal.

59

12. modeling trees     id56s

the id56 is very useful for modeling sequences. in language processing, it is often natural
and desirable to work with tree structures. the trees can be syntactic trees, discourse trees,
or even trees representing the sentiment expressed by various parts of a sentence (socher
et al., 2013). we may want to predict values based on speci   c tree nodes, predict values
based on the root nodes, or assign a quality score to a complete tree or part of a tree. in
other cases, we may not care about the tree structure directly but rather reason about spans
in the sentence. in such cases, the tree is merely used as a backbone structure which help
guide the encoding process of the sequence into a    xed size vector.

the id56 (reid98) abstraction (pollack, 1990), popularized in nlp
by richard socher and colleagues (socher, manning, & ng, 2010; socher, lin, ng, & man-
ning, 2011; socher et al., 2013; socher, 2014) is a generalization of the id56 from sequences
to (binary) trees.37

much like the id56 encodes each sentence pre   x as a state vector, the reid98 encodes
each tree-node as a state vector in rd. we can then use these state vectors either to predict
values of the corresponding nodes, assign quality values to each node, or as a semantic
representation of the spans rooted at the nodes.

the main intuition behind the id56s is that each subtree is repre-
sented as a d dimensional vector, and the representation of a node p with children c1 and c2
is a function of the representation of the nodes: vec(p) = f (vec(c1), vec(c2)), where f is a
composition function taking two d-dimensional vectors and returning a single d-dimensional
vector. much like the id56 state si is used to encode the entire sequence x1 : i, the reid98
state associated with a tree node p encodes the entire subtree rooted at p. see figure 14
for an illustration.

12.1 formal de   nition

consider a binary parse tree t over an n-word sentence. as a reminder, an ordered,
unlabeled tree over a string x1, . . . , xn can be represented as a unique set of triplets (i, k, j),
s.t. i     k     j. each such triplet indicates that a node spanning words xi:j is parent of the
nodes spanning xi:k and xk+1:j. triplets of the form (i, i, i) correspond to terminal symbols
at the tree leaves (the words xi). moving from the unlabeled case to the labeled one, we can
represent a tree as a set of 6-tuples (a     b, c, i, k, j), whereas i, k and j indicate the spans
as before, and a, b and c are the node labels of of the nodes spanning xi:j, xi:k and xk+1:j
respectively. here, leaf nodes have the form (a     a, a, i, i, i), where a is a pre-terminal
symbol. we refer to such tuples as production rules. for an example, consider the syntactic
tree for the sentence    the boy saw her duck   .

37. while presented in terms of binary parse trees, the concepts easily transfer to general recursively-de   ned
data structures, with the major technical challenge is the de   nition of an e   ective form for r, the
combination function.

60

figure 14: illustration of a id56. the representations of v and np1
are combined to form the representation of vp. the representations of vp and
np2 are then combined to form the representation of s.

s

np

vp

det

noun

verb

np

the

boy

saw

det

noun

her

duck

its corresponding unlabeled and labeled representations are :

unlabeled

(1,1,1)
(2,2,2)
(3,3,3)
(4,4,4)
(5,5,5)
(4,4,5)
(3,3,5)
(1,1,2)
(1,2,5)

labeled

(det, det, det, 1, 1, 1)

corresponding span
x1:1 the
(noun, noun, noun, 2, 2, 2) x2:2 boy
(verb, verb, verb, 3, 3, 3)

(det, det, det, 4, 4, 4)

saw
her

(noun, noun, noun, 5, 5, 5) duck

(np, det, noun, 4, 4, 5)
(vp, verb, np, 3, 3, 5)
(np, det, noun, 1, 1, 2)

(s, np, vp, 1, 2, 5)

her duck
saw her duck
the boy
the boy saw her duck

the set of production rules above can be uniquely converted to a set tree nodes qa
i:j
(indicating a node with symbol a over the span xi:j) by simply ignoring the elements

61

v=np1=combinevp=np2=combines=(b, c, k) in each production rule. we are now in position to de   ne the recursive neural
network.

a id56 (reid98) is a function that takes as input a parse tree
over an n-word sentence x1, . . . , xn. each of the sentence   s words is represented as a d-
dimensional vector xi, and the tree is represented as a set t of production rules (a    
b, c, i, j, k). denote the nodes of t by qa
i:j. the reid98 returns as output a correspond-
i:j     rd represents the
ing set of inside state vectors sa
corresponding tree node qa
i:j, and encodes the entire structure rooted at that node. like
the sequence id56, the tree shaped reid98 is de   ned recursively using a function r, where
the inside vector of a given node is de   ned as a function of the inside vectors of its direct
children.38 formally:

i:j, where each inside state vector sa

recn n (x1, . . . , xn,t ) ={sa
sa
i:i =v(xi)
i:j =r(a, b, c, sb
sa

i:j     rd | qa

i:j     t }

i:k, sc

k+1:j)

i:k     t , qc
qb

k+1:j     t

the function r usually takes the form of a simple linear transformation, which may or

may not be followed by a non-linear activation function g:

r(a, b, c, sb

i:k, sc

k+1:j) = g([sb

i:k; sc

k+1:j]w)

this formulation of r ignores the tree labels, using the same matrix w     r2d  d for all

combinations. this may be a useful formulation in case the node labels do not exist (e.g.
when the tree does not represent a syntactic structure with clearly de   ned labels) or when
they are unreliable. however, if the labels are available, it is generally useful to include them
in the composition function. one approach would be to introduce label embeddings v(a)
mapping each non-terminal symbol to a dnt dimensional vector, and change r to include
the embedded symbols in the combination function:

r(a, b, c, sb

i:k, sc

k+1:j) = g([sb

i:k; sc

k+1:j; v(a); v(b)]w)

(here, w     r2d+2dnt  d). such approach is taken by (qian, tian, huang, liu, zhu, &

zhu, 2015). an alternative approach, due to (socher et al., 2013) is to untie the weights
according to the non-terminals, using a di   erent composition matrix for each b, c pair of
symbols:39

r(a, b, c, sb

i:k, sc

k+1:j) = g([sb

i:k; sc

k+1:j]wbc)

38. le and zuidema (2014) extend the reid98 de   nition such that each node has, in addition to its inside
state vector, also an outside state vector representing the entire structure around the subtree rooted
at that node. their formulation is based on the recursive computation of the classic inside-outside
algorithm, and can be thought of as the bi-id56 counterpart of the tree reid98. for details, see (le &
zuidema, 2014).

39. while not explored in the literature, a trivial extension would condition the transformation matrix also

on a.

62

this formulation is useful when the number of non-terminal symbols (or the number of
possible symbol combinations) is relatively small, as is usually the case with phrase-structure
parse trees. a similar model was also used by (hashimoto et al., 2013) to encode subtrees
in semantic-relation classi   cation task.

12.2 extensions and variations

as all of the de   nitions of r above su   er from the vanishing gradients problem of the
simple id56, several authors sought to replace it with functions inspired by the long short-
term memory (lstm) gated architecture, resulting in tree-shaped lstms (tai, socher, &
manning, 2015; zhu, sobhani, & guo, 2015b). the question of optimal tree representation
is still very much an open research question, and the vast space of possible combination
functions r is yet to be explored. other proposed variants on tree-structured id56s includes
a recursive matrix-vector model (socher, huval, manning, & ng, 2012) and recursive neural
tensor network (socher et al., 2013).
in the    rst variant, each word is represented as a
combination of a vector and a matrix, where the vector de   nes the word   s static semantic
content as before, while the matrix acts as a learned    operator    for the word, allowing
more subtle semantic compositions than the addition and weighted averaging implied by
the concatenation followed by linear transformation function. in the second variant, words
are associated with vectors as usual, but the composition function becomes more expressive
by basing it on tensor instead of matrix operations.

12.3 training id56s

the training procedure for a id56 follows the same recipe as training
other forms of networks: de   ne a loss, spell out the computation graph, compute gradients
using id2640, and train the parameters using sgd.

with regard to the id168, similar to the sequence id56 one can associate a loss
either with the root of the tree, with any given node, or with a set of nodes, in which case
the individual node   s losses are combined, usually by summation. the id168 is based
on the labeled training data which associates a label or other quantity with di   erent tree
nodes.

additionally, one can treat the reid98 as an encoder, whereas the inside-vector associ-
ated with a node is taken to be an encoding of the tree rooted at that node. the encoding
can potentially be sensitive to arbitrary properties of the structure. the vector is then
passed as input to another network.

for further discussion on id56s and their use in natural language

tasks, refer to the phd thesis of richard socher (2014).

40. before the introduction of the computation graph abstraction, the speci   c id26 procedure
for computing the gradients in a reid98 as de   ned above was referred to as the back-propagation trough
structure (bpts) algorithm (goller & k  uchler, 1996).

63

13. conclusions

neural networks are powerful learners, providing opportunities ranging from non-linear
classi   cation to non-markovian modeling of sequences and trees. we hope that this expo-
sition help nlp researchers to incorporate neural network models in their work and take
advantage of their power.

references

adel, h., vu, n. t., & schultz, t. (2013). combination of recurrent neural networks and
factored language models for code-switching id38. in proceedings
of the 51st annual meeting of the association for computational linguistics (vol-
ume 2: short papers), pp. 206   211, so   a, bulgaria. association for computational
linguistics.

ando, r., & zhang, t. (2005a). a high-performance semi-supervised learning method
for text chunking. in proceedings of the 43rd annual meeting of the association for
computational linguistics (acl   05), pp. 1   9, ann arbor, michigan. association for
computational linguistics.

ando, r. k., & zhang, t. (2005b). a framework for learning predictive structures from
multiple tasks and unlabeled data. the journal of machine learning research, 6,
1817   1853.

auli, m., galley, m., quirk, c., & zweig, g. (2013). joint language and translation mod-
eling with recurrent neural networks.
in proceedings of the 2013 conference on
empirical methods in natural language processing, pp. 1044   1054, seattle, washing-
ton, usa. association for computational linguistics.

auli, m., & gao, j. (2014). decoder integration and expected id7 training for recurrent
neural network language models. in proceedings of the 52nd annual meeting of the
association for computational linguistics (volume 2: short papers), pp. 136   142,
baltimore, maryland. association for computational linguistics.

ballesteros, m., dyer, c., & smith, n. a. (2015). improved transition-based parsing by
modeling characters instead of words with lstms. in proceedings of the 2015 con-
ference on empirical methods in natural language processing, pp. 349   359, lisbon,
portugal. association for computational linguistics.

bansal, m., gimpel, k., & livescu, k. (2014). tailoring continuous word representations
for id33. in proceedings of the 52nd annual meeting of the association
for computational linguistics (volume 2: short papers), pp. 809   815, baltimore,
maryland. association for computational linguistics.

baydin, a. g., pearlmutter, b. a., radul, a. a., & siskind, j. m. (2015). automatic

di   erentiation in machine learning: a survey. arxiv:1502.05767 [cs].

bengio, y. (2012). practical recommendations for gradient-based training of deep architec-

tures. arxiv:1206.5533 [cs].

bengio, y., ducharme, r., vincent, p., & janvin, c. (2003). a neural probabilistic lan-

guage model. j. mach. learn. res., 3, 1137   1155.

64

bengio, y., goodfellow, i. j., & courville, a. (2015). deep learning. book in preparation

for mit press.

bitvai, z., & cohn, t. (2015). non-linear text regression with a deep convolutional
neural network. in proceedings of the 53rd annual meeting of the association for
computational linguistics and the 7th international joint conference on natural lan-
guage processing (volume 2: short papers), pp. 180   185, beijing, china. association
for computational linguistics.

botha, j. a., & blunsom, p. (2014). compositional morphology for word representations
in proceedings of the 31st international conference on

and language modelling.
machine learning (icml), beijing, china. *award for best application paper*.

bottou, l. (2012). stochastic id119 tricks. in neural networks: tricks of the

trade, pp. 421   436. springer.

charniak, e., & johnson, m. (2005). coarse-to-fine n-best parsing and maxent discrim-
inative reranking. in proceedings of the 43rd annual meeting of the association for
computational linguistics (acl   05), pp. 173   180, ann arbor, michigan. association
for computational linguistics.

chen, d., & manning, c. (2014). a fast and accurate dependency parser using neural
networks. in proceedings of the 2014 conference on empirical methods in natural
language processing (emnlp), pp. 740   750, doha, qatar. association for compu-
tational linguistics.

chen, y., xu, l., liu, k., zeng, d., & zhao, j. (2015). event extraction via dynamic
multi-pooling convolutional neural networks.
in proceedings of the 53rd annual
meeting of the association for computational linguistics and the 7th international
joint conference on natural language processing (volume 1: long papers), pp. 167   
176, beijing, china. association for computational linguistics.

cho, k., van merrienboer, b., bahdanau, d., & bengio, y. (2014a). on the properties of
id4: encoder   decoder approaches. in proceedings of ssst-
8, eighth workshop on syntax, semantics and structure in statistical translation,
pp. 103   111, doha, qatar. association for computational linguistics.

cho, k., van merrienboer, b., gulcehre, c., bahdanau, d., bougares, f., schwenk, h., &
bengio, y. (2014b). learning phrase representations using id56 encoder   decoder for
id151. in proceedings of the 2014 conference on empirical
methods in natural language processing (emnlp), pp. 1724   1734, doha, qatar.
association for computational linguistics.

chrupala, g. (2014). normalizing tweets with edit scripts and recurrent neural embeddings.
in proceedings of the 52nd annual meeting of the association for computational lin-
guistics (volume 2: short papers), pp. 680   686, baltimore, maryland. association for
computational linguistics.

chung, j., gulcehre, c., cho, k., & bengio, y. (2014). empirical evaluation of gated

recurrent neural networks on sequence modeling. arxiv:1412.3555 [cs].

collins, m. (2002). discriminative training methods for id48: theory
in proceedings of the 2002 confer-

and experiments with id88 algorithms.

65

ence on empirical methods in natural language processing, pp. 1   8. association for
computational linguistics.

collins, m., & koo, t. (2005). discriminative reranking for natural language parsing.

computational linguistics, 31 (1), 25   70.

collobert, r., & weston, j. (2008). a uni   ed architecture for natural language processing:
deep neural networks with multitask learning. in proceedings of the 25th international
conference on machine learning, pp. 160   167. acm.

collobert, r., weston, j., bottou, l., karlen, m., kavukcuoglu, k., & kuksa, p. (2011).
natural language processing (almost) from scratch. the journal of machine learning
research, 12, 2493   2537.

crammer, k., & singer, y. (2002). on the algorithmic implementation of multiclass kernel-

based vector machines. the journal of machine learning research, 2, 265   292.

creutz, m., & lagus, k. (2007). unsupervised models for morpheme segmentation and

morphology learning. acm trans. speech lang. process., 4 (1), 3:1   3:34.

cybenko, g. (1989). approximation by superpositions of a sigmoidal function. mathematics

of control, signals and systems, 2 (4), 303   314.

dahl, g., sainath, t., & hinton, g. (2013). improving deep neural networks for lvcsr
using recti   ed linear units and dropout. in 2013 ieee international conference on
acoustics, speech and signal processing (icassp), pp. 8609   8613.

de gispert, a., iglesias, g., & byrne, b. (2015). fast and accurate preordering for smt
using neural networks. in proceedings of the 2015 conference of the north american
chapter of the association for computational linguistics: human language technolo-
gies, pp. 1012   1017, denver, colorado. association for computational linguistics.

dong, l., wei, f., tan, c., tang, d., zhou, m., & xu, k. (2014). adaptive recursive neural
network for target-dependent twitter sentiment classi   cation.
in proceedings of
the 52nd annual meeting of the association for computational linguistics (volume
2: short papers), pp. 49   54, baltimore, maryland. association for computational
linguistics.

dong, l., wei, f., zhou, m., & xu, k. (2015). id53 over freebase with
in proceedings of the 53rd annual
multi-column convolutional neural networks.
meeting of the association for computational linguistics and the 7th international
joint conference on natural language processing (volume 1: long papers), pp. 260   
269, beijing, china. association for computational linguistics.

dos santos, c., & gatti, m. (2014). deep convolutional neural networks for sentiment
analysis of short texts. in proceedings of coling 2014, the 25th international con-
ference on computational linguistics: technical papers, pp. 69   78, dublin, ireland.
dublin city university and association for computational linguistics.

dos santos, c., xiang, b., & zhou, b. (2015). classifying relations by ranking with
convolutional neural networks.
in proceedings of the 53rd annual meeting of the
association for computational linguistics and the 7th international joint confer-
ence on natural language processing (volume 1: long papers), pp. 626   634, beijing,
china. association for computational linguistics.

66

duchi, j., hazan, e., & singer, y. (2011). adaptive subgradient methods for online learning
and stochastic optimization. the journal of machine learning research, 12, 2121   
2159.

duh, k., neubig, g., sudoh, k., & tsukada, h. (2013). adaptation data selection us-
ing neural language models: experiments in machine translation. in proceedings
of the 51st annual meeting of the association for computational linguistics (vol-
ume 2: short papers), pp. 678   683, so   a, bulgaria. association for computational
linguistics.

durrett, g., & klein, d. (2015). neural crf parsing. in proceedings of the 53rd annual
meeting of the association for computational linguistics and the 7th international
joint conference on natural language processing (volume 1: long papers), pp. 302   
312, beijing, china. association for computational linguistics.

dyer, c., ballesteros, m., ling, w., matthews, a., & smith, n. a. (2015). transition-
based id33 with stack long short-term memory. in proceedings of
the 53rd annual meeting of the association for computational linguistics and the
7th international joint conference on natural language processing (volume 1: long
papers), pp. 334   343, beijing, china. association for computational linguistics.

elman, j. l. (1990). finding structure in time. cognitive science, 14 (2), 179   211.

faruqui, m., & dyer, c. (2014). improving vector space word representations using mul-
tilingual correlation. in proceedings of the 14th conference of the european chapter
of the association for computational linguistics, pp. 462   471, gothenburg, sweden.
association for computational linguistics.

filippova, k., alfonseca, e., colmenares, c. a., kaiser, l., & vinyals, o. (2015). sentence
compression by deletion with lstms.
in proceedings of the 2015 conference on
empirical methods in natural language processing, pp. 360   368, lisbon, portugal.
association for computational linguistics.

gal, y., & ghahramani, z. (2015). dropout as a bayesian approximation: representing

model uncertainty in deep learning. arxiv:1506.02142 [cs, stat].

gao, j., pantel, p., gamon, m., he, x., & deng, l. (2014). modeling interestingness with
deep neural networks. in proceedings of the 2014 conference on empirical methods
in natural language processing (emnlp), pp. 2   13, doha, qatar. association for
computational linguistics.

gim  enez, j., & m`arquez, l. (2004). id166tool: a general pos tagger generator based on

support vector machines. in proceedings of the 4th lrec, lisbon, portugal.

glorot, x., & bengio, y. (2010). understanding the di   culty of training deep feedforward
neural networks. in international conference on arti   cial intelligence and statistics,
pp. 249   256.

glorot, x., bordes, a., & bengio, y. (2011). deep sparse recti   er neural networks.

in

international conference on arti   cial intelligence and statistics, pp. 315   323.

goldberg, y., & elhadad, m. (2010). an e   cient algorithm for easy-first non-directional
id33. in human language technologies: the 2010 annual conference

67

of the north american chapter of the association for computational linguistics, pp.
742   750, los angeles, california. association for computational linguistics.

goldberg, y., & levy, o. (2014). id97 explained: deriving mikolov et al.   s negative-

sampling word-embedding method. arxiv:1402.3722 [cs, stat].

goldberg, y., & nivre, j. (2013). training deterministic parsers with non-deterministic
oracles. transactions of the association for computational linguistics, 1 (0), 403   
414.

goldberg, y., zhao, k., & huang, l. (2013). e   cient implementation of beam-search
incremental parsers. in proceedings of the 51st annual meeting of the association for
computational linguistics (volume 2: short papers), pp. 628   633, so   a, bulgaria.
association for computational linguistics.

goller, c., & k  uchler, a. (1996). learning task-dependent distributed representations
by id26 through structure. in in proc. of the iid98-96, pp. 347   352.
ieee.

graves, a. (2008). supervised sequence labelling with recurrent neural networks. ph.d.

thesis, technische universit  at m  unchen.

gre   , k., srivastava, r. k., koutn    k, j., steunebrink, b. r., & schmidhuber, j. (2015).

lstm: a search space odyssey. arxiv:1503.04069 [cs].

hal daum  e iii, langford, j., & marcu, d. (2009). search-based id170.

machine learning journal (mlj).

harris, z. (1954). distributional structure. word, 10 (23), 146   162.

hashimoto, k., miwa, m., tsuruoka, y., & chikayama, t. (2013). simple customization
of id56s for semantic relation classi   cation.
in proceedings
of the 2013 conference on empirical methods in natural language processing, pp.
1372   1376, seattle, washington, usa. association for computational linguistics.

he, k., zhang, x., ren, s., & sun, j. (2015). delving deep into recti   ers: surpassing

human-level performance on id163 classi   cation. arxiv:1502.01852 [cs].

henderson, m., thomson, b., & young, s. (2013). deep neural network approach for the
dialog state tracking challenge. in proceedings of the sigdial 2013 conference,
pp. 467   471, metz, france. association for computational linguistics.

hermann, k. m., & blunsom, p. (2013). the role of syntax in vector space models of
id152.
in proceedings of the 51st annual meeting of the asso-
ciation for computational linguistics (volume 1: long papers), pp. 894   904, so   a,
bulgaria. association for computational linguistics.

hermann, k. m., & blunsom, p. (2014). multilingual models for compositional distributed
semantics. in proceedings of the 52nd annual meeting of the association for com-
putational linguistics (volume 1: long papers), pp. 58   68, baltimore, maryland.
association for computational linguistics.

hihi, s. e., & bengio, y. (1996). hierarchical recurrent neural networks for long-term
dependencies. in touretzky, d. s., mozer, m. c., & hasselmo, m. e. (eds.), advances
in neural information processing systems 8, pp. 493   499. mit press.

68

hinton, g. e., srivastava, n., krizhevsky, a., sutskever, i., & salakhutdinov, r. r.
(2012). improving neural networks by preventing co-adaptation of feature detectors.
arxiv:1207.0580 [cs].

hochreiter, s., & schmidhuber, j. (1997). long short-term memory. neural computation,

9 (8), 1735   1780.

hornik, k., stinchcombe, m., & white, h. (1989). multilayer feedforward networks are

universal approximators. neural networks, 2 (5), 359   366.

irsoy, o., & cardie, c. (2014). opinion mining with deep recurrent neural networks.
in proceedings of the 2014 conference on empirical methods in natural language
processing (emnlp), pp. 720   728, doha, qatar. association for computational lin-
guistics.

iyyer, m., boyd-graber, j., claudino, l., socher, r., & daum  e iii, h. (2014a). a neural
network for factoid id53 over paragraphs. in proceedings of the 2014
conference on empirical methods in natural language processing (emnlp), pp.
633   644, doha, qatar. association for computational linguistics.

iyyer, m., enns, p., boyd-graber, j., & resnik, p. (2014b). political ideology detection
using id56s. in proceedings of the 52nd annual meeting of the
association for computational linguistics (volume 1: long papers), pp. 1113   1122,
baltimore, maryland. association for computational linguistics.

iyyer, m., manjunatha, v., boyd-graber, j., & daum  e iii, h. (2015). deep unordered
composition rivals syntactic methods for text classi   cation. in proceedings of the
53rd annual meeting of the association for computational linguistics and the 7th
international joint conference on natural language processing (volume 1: long pa-
pers), pp. 1681   1691, beijing, china. association for computational linguistics.

johnson, r., & zhang, t. (2014). e   ective use of word order for text categorization with

convolutional neural networks. arxiv:1412.1058 [cs, stat].

johnson, r., & zhang, t. (2015). e   ective use of word order for text categorization with
convolutional neural networks. in proceedings of the 2015 conference of the north
american chapter of the association for computational linguistics: human lan-
guage technologies, pp. 103   112, denver, colorado. association for computational
linguistics.

jozefowicz, r., zaremba, w., & sutskever, i. (2015). an empirical exploration of recur-
rent network architectures. in proceedings of the 32nd international conference on
machine learning (icml-15), pp. 2342   2350.

kalchbrenner, n., grefenstette, e., & blunsom, p. (2014). a convolutional neural network
for modelling sentences. in proceedings of the 52nd annual meeting of the associa-
tion for computational linguistics (volume 1: long papers), pp. 655   665, baltimore,
maryland. association for computational linguistics.

karpathy, a., johnson, j., & li, f.-f. (2015). visualizing and understanding recurrent

networks. arxiv:1506.02078 [cs].

69

kim, y. (2014). convolutional neural networks for sentence classi   cation. in proceed-
ings of the 2014 conference on empirical methods in natural language processing
(emnlp), pp. 1746   1751, doha, qatar. association for computational linguistics.

kingma, d., & ba, j.

(2014).

adam: a method for stochastic optimization.

arxiv:1412.6980 [cs].

krizhevsky, a., sutskever, i., & hinton, g. e. (2012). id163 classi   cation with deep
convolutional neural networks. in pereira, f., burges, c. j. c., bottou, l., & wein-
berger, k. q. (eds.), advances in neural information processing systems 25, pp.
1097   1105. curran associates, inc.

kudo, t., & matsumoto, y. (2003). fast methods for kernel-based text analysis.

in
proceedings of the 41st annual meeting on association for computational linguistics -
volume 1, acl    03, pp. 24   31, stroudsburg, pa, usa. association for computational
linguistics.

le, p., & zuidema, w. (2014). the inside-outside id56 model for
id33. in proceedings of the 2014 conference on empirical methods in
natural language processing (emnlp), pp. 729   739, doha, qatar. association for
computational linguistics.

le, p., & zuidema, w. (2015). the forest convolutional network: compositional distri-
butional semantics with a neural chart and without binarization.
in proceedings
of the 2015 conference on empirical methods in natural language processing, pp.
1155   1164, lisbon, portugal. association for computational linguistics.

le, q. v., jaitly, n., & hinton, g. e. (2015). a simple way to initialize recurrent networks

of recti   ed linear units. arxiv:1504.00941 [cs].

lecun, y., & bengio, y. (1995). convolutional networks for images, speech, and time-
series. in arbib, m. a. (ed.), the handbook of brain theory and neural networks.
mit press.

lecun, y., bottou, l., orr, g., & muller, k. (1998a). e   cient backprop. in orr, g., &

k, m. (eds.), neural networks: tricks of the trade. springer.

lecun, y., bottou, l., bengio, y., & ha   ner, p. (1998b). gradient based learning applied

to pattern recognition..

lecun, y., chopra, s., hadsell, r., ranzato, m., & huang, f. (2006). a tutorial on energy-

based learning. predicting structured data, 1, 0.

lecun, y., & huang, f. (2005). id168s for discriminative training of energybased

models.. aistats.

levy, o., & goldberg, y. (2014a). dependency-based id27s. in proceedings of
the 52nd annual meeting of the association for computational linguistics (volume
2: short papers), pp. 302   308, baltimore, maryland. association for computational
linguistics.

levy, o., & goldberg, y. (2014b). neural id27 as implicit matrix factoriza-
tion. in ghahramani, z., welling, m., cortes, c., lawrence, n. d., & weinberger,

70

k. q. (eds.), advances in neural information processing systems 27, pp. 2177   2185.
curran associates, inc.

levy, o., goldberg, y., & dagan, i. (2015).

improving distributional similarity with
lessons learned from id27s. transactions of the association for com-
putational linguistics, 3 (0), 211   225.

lewis, m., & steedman, m. (2014). improved id35 parsing with semi-supervised supertag-
ging. transactions of the association for computational linguistics, 2 (0), 327   338.

li, j., li, r., & hovy, e. (2014). recursive deep models for discourse parsing. in proceed-
ings of the 2014 conference on empirical methods in natural language processing
(emnlp), pp. 2061   2069, doha, qatar. association for computational linguistics.

ling, w., dyer, c., black, a. w., & trancoso, i. (2015a). two/too simple adaptations of
id97 for syntax problems. in proceedings of the 2015 conference of the north
american chapter of the association for computational linguistics: human lan-
guage technologies, pp. 1299   1304, denver, colorado. association for computational
linguistics.

ling, w., dyer, c., black, a. w., trancoso, i., fermandez, r., amir, s., marujo, l., &
luis, t. (2015b). finding function in form: compositional character models for
open vocabulary word representation. in proceedings of the 2015 conference on
empirical methods in natural language processing, pp. 1520   1530, lisbon, portugal.
association for computational linguistics.

liu, y., wei, f., li, s., ji, h., zhou, m., & wang, h. (2015). a dependency-based neural
network for relation classi   cation. in proceedings of the 53rd annual meeting of the
association for computational linguistics and the 7th international joint confer-
ence on natural language processing (volume 2: short papers), pp. 285   290, beijing,
china. association for computational linguistics.

ma, j., zhang, y., & zhu, j. (2014). tagging the web: building a robust web tagger
with neural network.
in proceedings of the 52nd annual meeting of the associa-
tion for computational linguistics (volume 1: long papers), pp. 144   154, baltimore,
maryland. association for computational linguistics.

ma, m., huang, l., zhou, b., & xiang, b. (2015). dependency-based convolutional neural
networks for sentence embedding. in proceedings of the 53rd annual meeting of the
association for computational linguistics and the 7th international joint confer-
ence on natural language processing (volume 2: short papers), pp. 174   179, beijing,
china. association for computational linguistics.

mccallum, a., freitag, d., & pereira, f. c. (2000). maximum id178 markov models for

information extraction and segmentation.. in icml, vol. 17, pp. 591   598.

mikolov, t., chen, k., corrado, g., & dean, j. (2013). e   cient estimation of word

representations in vector space. arxiv:1301.3781 [cs].

mikolov, t., joulin, a., chopra, s., mathieu, m., & ranzato, m. (2014). learning longer

memory in recurrent neural networks. arxiv:1412.7753 [cs].

71

mikolov, t., kara     at, m., burget, l., cernocky, j., & khudanpur, s. (2010). recurrent
neural network based language model.. in interspeech 2010, 11th annual con-
ference of the international speech communication association, makuhari, chiba,
japan, september 26-30, 2010, pp. 1045   1048.

mikolov, t., kombrink, s., luk  a  s burget,   cernocky, j. h., & khudanpur, s. (2011). ex-
tensions of recurrent neural network language model. in acoustics, speech and signal
processing (icassp), 2011 ieee international conference on, pp. 5528   5531. ieee.

mikolov, t., sutskever, i., chen, k., corrado, g. s., & dean, j. (2013). distributed rep-
resentations of words and phrases and their compositionality. in burges, c. j. c.,
bottou, l., welling, m., ghahramani, z., & weinberger, k. q. (eds.), advances in
neural information processing systems 26, pp. 3111   3119. curran associates, inc.

mikolov, t. (2012). statistical language models based on neural networks. ph.d. thesis, ph.

d. thesis, brno university of technology.

mnih, a., & kavukcuoglu, k. (2013). learning id27s e   ciently with noise-
contrastive estimation. in burges, c. j. c., bottou, l., welling, m., ghahramani, z.,
& weinberger, k. q. (eds.), advances in neural information processing systems 26,
pp. 2265   2273. curran associates, inc.

mrk  si  c, n.,   o s  eaghdha, d., thomson, b., gasic, m., su, p.-h., vandyke, d., wen, t.-h.,
& young, s. (2015). multi-domain dialog state tracking using recurrent neural
networks. in proceedings of the 53rd annual meeting of the association for compu-
tational linguistics and the 7th international joint conference on natural language
processing (volume 2: short papers), pp. 794   799, beijing, china. association for
computational linguistics.

neidinger, r. (2010).

introduction to automatic di   erentiation and matlab object-

oriented programming. siam review, 52 (3), 545   563.

nguyen, t. h., & grishman, r. (2015). id37 and id20 with
convolutional neural networks.
in proceedings of the 53rd annual meeting of the
association for computational linguistics and the 7th international joint confer-
ence on natural language processing (volume 2: short papers), pp. 365   371, beijing,
china. association for computational linguistics.

nivre, j. (2008). algorithms for deterministic incremental id33. compu-

tational linguistics, 34 (4), 513   553.

okasaki, c. (1999). purely functional data structures. cambridge university press, cam-

bridge, u.k.; new york.

pascanu, r., mikolov, t., & bengio, y. (2012). on the di   culty of training recurrent

neural networks. arxiv:1211.5063 [cs].

pei, w., ge, t., & chang, b. (2015). an e   ective neural network model for graph-based
id33. in proceedings of the 53rd annual meeting of the association
for computational linguistics and the 7th international joint conference on natural
language processing (volume 1: long papers), pp. 313   322, beijing, china. associa-
tion for computational linguistics.

72

pennington, j., socher, r., & manning, c. (2014). glove: global vectors for word rep-
resentation. in proceedings of the 2014 conference on empirical methods in natural
language processing (emnlp), pp. 1532   1543, doha, qatar. association for com-
putational linguistics.

pollack, j. b. (1990). recursive distributed representations. arti   cial intelligence, 46,

77   105.

polyak, b. t. (1964). some methods of speeding up the convergence of iteration methods.

ussr computational mathematics and mathematical physics, 4 (5), 1     17.

qian, q., tian, b., huang, m., liu, y., zhu, x., & zhu, x. (2015). learning tag embeddings
and tag-speci   c composition functions in id56. in proceedings
of the 53rd annual meeting of the association for computational linguistics and the
7th international joint conference on natural language processing (volume 1: long
papers), pp. 1365   1374, beijing, china. association for computational linguistics.

rong, x. (2014). id97 parameter learning explained. arxiv:1411.2738 [cs].

rumelhart, d. e., hinton, g. e., & williams, r. j. (1986). learning representations by

back-propagating errors. nature, 323 (6088), 533   536.

santos, c. d., & zadrozny, b. (2014). learning character-level representations for part-

of-speech tagging.. pp. 1818   1826.

schuster, m., & paliwal, k. k. (1997). id182.

ieee

transactions on signal processing, 45 (11), 2673   2681.

shawe-taylor, j., & cristianini, n. (2004). kernel methods for pattern analysis. cambridge

university press.

smith, n. a. (2011). linguistic structure prediction. synthesis lectures on human lan-

guage technologies. morgan and claypool.

socher, r. (2014). recursive deep learning for natural language processing and computer

vision. ph.d. thesis, stanford university.

socher, r., bauer, j., manning, c. d., & andrew y., n. (2013). parsing with compositional
vector grammars. in proceedings of the 51st annual meeting of the association for
computational linguistics (volume 1: long papers), pp. 455   465, so   a, bulgaria.
association for computational linguistics.

socher, r., huval, b., manning, c. d., & ng, a. y. (2012). semantic compositionality
through recursive matrix-vector spaces. in proceedings of the 2012 joint conference
on empirical methods in natural language processing and computational natural
language learning, pp. 1201   1211, jeju island, korea. association for computational
linguistics.

socher, r., lin, c. c.-y., ng, a. y., & manning, c. d. (2011). parsing natural scenes
and natural language with id56s. in getoor, l., & sche   er, t.
(eds.), proceedings of the 28th international conference on machine learning, icml
2011, bellevue, washington, usa, june 28 - july 2, 2011, pp. 129   136. omnipress.

73

socher, r., manning, c., & ng, a. (2010). learning continuous phrase representations
and syntactic parsing with id56s. in proceedings of the deep
learning and unsupervised id171 workshop of {nips} 2010, pp. 1   9.

socher, r., perelygin, a., wu, j., chuang, j., manning, c. d., ng, a., & potts, c. (2013).
recursive deep models for semantic compositionality over a sentiment treebank.
in proceedings of the 2013 conference on empirical methods in natural language
processing, pp. 1631   1642, seattle, washington, usa. association for computational
linguistics.

sordoni, a., galley, m., auli, m., brockett, c., ji, y., mitchell, m., nie, j.-y., gao, j.,
& dolan, b. (2015). a neural network approach to context-sensitive generation
of conversational responses.
in proceedings of the 2015 conference of the north
american chapter of the association for computational linguistics: human lan-
guage technologies, pp. 196   205, denver, colorado. association for computational
linguistics.

sundermeyer, m., alkhouli, t., wuebker, j., & ney, h. (2014). translation modeling
with id182. in proceedings of the 2014 conference
on empirical methods in natural language processing (emnlp), pp. 14   25, doha,
qatar. association for computational linguistics.

sundermeyer, m., schl  uter, r., & ney, h. (2012). lstm neural networks for language

modeling.. in interspeech.

sutskever, i., martens, j., dahl, g., & hinton, g. (2013). on the importance of initialization
and momentum in deep learning. in proceedings of the 30th international conference
on machine learning (icml-13), pp. 1139   1147.

sutskever, i., martens, j., & hinton, g. e. (2011). generating text with recurrent neural
networks. in proceedings of the 28th international conference on machine learning
(icml-11), pp. 1017   1024.

sutskever, i., vinyals, o., & le, q. v. v. (2014). sequence to sequence learning with
neural networks. in ghahramani, z., welling, m., cortes, c., lawrence, n. d., &
weinberger, k. q. (eds.), advances in neural information processing systems 27, pp.
3104   3112. curran associates, inc.

tai, k. s., socher, r., & manning, c. d. (2015). improved semantic representations from
tree-structured id137. in proceedings of the 53rd an-
nual meeting of the association for computational linguistics and the 7th interna-
tional joint conference on natural language processing (volume 1: long papers),
pp. 1556   1566, beijing, china. association for computational linguistics.

tamura, a., watanabe, t., & sumita, e. (2014). recurrent neural networks for word
alignment model.
in proceedings of the 52nd annual meeting of the association
for computational linguistics (volume 1: long papers), pp. 1470   1480, baltimore,
maryland. association for computational linguistics.

tieleman, t., & hinton, g. (2012). lecture 6.5   rmsprop: divide the gradient by a running
average of its recent magnitude. coursera: neural networks for machine learning.

74

van de cruys, t. (2014). a neural network approach to selectional preference acquisi-
tion. in proceedings of the 2014 conference on empirical methods in natural lan-
guage processing (emnlp), pp. 26   35, doha, qatar. association for computational
linguistics.

vaswani, a., zhao, y., fossum, v., & chiang, d. (2013). decoding with large-scale neu-
ral language models improves translation. in proceedings of the 2013 conference on
empirical methods in natural language processing, pp. 1387   1392, seattle, washing-
ton, usa. association for computational linguistics.

wager, s., wang, s., & liang, p. s. (2013). dropout training as adaptive id173.
in burges, c. j. c., bottou, l., welling, m., ghahramani, z., & weinberger, k. q.
(eds.), advances in neural information processing systems 26, pp. 351   359. curran
associates, inc.

wang, p., xu, j., xu, b., liu, c., zhang, h., wang, f., & hao, h. (2015a). semantic cluster-
ing and convolutional neural network for short text categorization. in proceedings
of the 53rd annual meeting of the association for computational linguistics and the
7th international joint conference on natural language processing (volume 2: short
papers), pp. 352   357, beijing, china. association for computational linguistics.

wang, x., liu, y., sun, c., wang, b., & wang, x. (2015b). predicting polarities of tweets
by composing id27s with long short-term memory. in proceedings of
the 53rd annual meeting of the association for computational linguistics and the
7th international joint conference on natural language processing (volume 1: long
papers), pp. 1343   1353, beijing, china. association for computational linguistics.

watanabe, t., & sumita, e. (2015). transition-based neural constituent parsing. in pro-
ceedings of the 53rd annual meeting of the association for computational linguistics
and the 7th international joint conference on natural language processing (volume
1: long papers), pp. 1169   1179, beijing, china. association for computational lin-
guistics.

weiss, d., alberti, c., collins, m., & petrov, s. (2015). structured training for neural
network transition-based parsing. in proceedings of the 53rd annual meeting of the
association for computational linguistics and the 7th international joint confer-
ence on natural language processing (volume 1: long papers), pp. 323   333, beijing,
china. association for computational linguistics.

werbos, p. j. (1990). id26 through time: what it does and how to do it..

proceedings of the ieee, 78 (10), 1550     1560.

weston, j., bordes, a., yakhnenko, o., & usunier, n. (2013). connecting language and
knowledge bases with embedding models for id36.
in proceedings
of the 2013 conference on empirical methods in natural language processing, pp.
1366   1371, seattle, washington, usa. association for computational linguistics.

xu, w., auli, m., & clark, s. (2015). id35 id55 with a recurrent neural network.
in proceedings of the 53rd annual meeting of the association for computational lin-
guistics and the 7th international joint conference on natural language processing
(volume 2: short papers), pp. 250   255, beijing, china. association for computational
linguistics.

75

yin, w., & sch  utze, h. (2015). convolutional neural network for paraphrase identi   cation.
in proceedings of the 2015 conference of the north american chapter of the asso-
ciation for computational linguistics: human language technologies, pp. 901   911,
denver, colorado. association for computational linguistics.

zaremba, w., sutskever, i., & vinyals, o. (2014). recurrent neural network id173.

arxiv:1409.2329 [cs].

zeiler, m. d. (2012). adadelta: an adaptive learning rate method. arxiv:1212.5701

[cs].

zeng, d., liu, k., lai, s., zhou, g., & zhao, j. (2014). relation classi   cation via convolu-
tional deep neural network. in proceedings of coling 2014, the 25th international
conference on computational linguistics: technical papers, pp. 2335   2344, dublin,
ireland. dublin city university and association for computational linguistics.

zhou, h., zhang, y., huang, s., & chen, j. (2015). a neural probabilistic structured-
prediction model for transition-based id33.
in proceedings of the
53rd annual meeting of the association for computational linguistics and the 7th
international joint conference on natural language processing (volume 1: long pa-
pers), pp. 1213   1222, beijing, china. association for computational linguistics.

zhu, c., qiu, x., chen, x., & huang, x. (2015a). a re-ranking model for dependency
parser with recursive convolutional neural network.
in proceedings of the 53rd
annual meeting of the association for computational linguistics and the 7th inter-
national joint conference on natural language processing (volume 1: long papers),
pp. 1159   1168, beijing, china. association for computational linguistics.

zhu, x., sobhani, p., & guo, h. (2015b). long short-term memory over tree structures.

arxiv:1503.04881 [cs].

76

