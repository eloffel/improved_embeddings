   (button) toggle navigation
   [1][nav_logo.svg?v=479cefe8d932fb14a67b93911b97d70f]
     * [2]jupyter
     * [3]faq
     * [4]view as code
     * [5]python 3 kernel
     * [6]view on github
     * [7]execute on binder
     * [8]download notebook

    1. [9]ipython
    2. [10]examples
    3. [11]ipython kernel

custom display logic[12]  

overview[13]  

   as described in the [14]rich output tutorial, the ipython display
   system can display rich representations of objects in the following
   formats:
     * javascript
     * html
     * png
     * jpeg
     * svg
     * latex
     * pdf

   this notebook shows how you can add custom display logic to your own
   classes, so that they can be displayed using these rich
   representations. there are two ways of accomplishing this:
    1. implementing special display methods such as _repr_html_ when you
       define your class.
    2. registering a display function for a particular existing class.

   this notebook describes and illustrates both approaches.

   import the ipython display functions.
   in [1]:
from ipython.display import (
    display, display_html, display_png, display_svg
)

   parts of this notebook need the matplotlib inline backend:
   in [2]:
import numpy as np
import matplotlib.pyplot as plt
plt.ion()

special display methods[15]  

   the main idea of the first approach is that you have to implement
   special display methods when you define your class, one for each
   representation you want to use. here is a list of the names of the
   special methods and the values they must return:
     * _repr_html_: return raw html as a string
     * _repr_json_: return a jsonable dict
     * _repr_jpeg_: return raw jpeg data
     * _repr_png_: return raw png data
     * _repr_svg_: return raw svg data as a string
     * _repr_latex_: return latex commands in a string surrounded by "$".
     * _repr_mimebundle_: return a full mimebundle containing the mapping
       from all mimetypes to data

   as an illustration, we build a class that holds data generated by
   sampling a gaussian distribution with given mean and standard
   deviation. here is the definition of the gaussian class, which has a
   custom png and latex representation.
   in [3]:
from ipython.core.pylabtools import print_figure
from ipython.display import image, svg, math

class gaussian(object):
    """a simple object holding data sampled from a gaussian distribution.
    """
    def __init__(self, mean=0.0, std=1, size=1000):
        self.data = np.random.normal(mean, std, size)
        self.mean = mean
        self.std = std
        self.size = size
        # for caching plots that may be expensive to compute
        self._png_data = none

    def _figure_data(self, format):
        fig, ax = plt.subplots()
        ax.hist(self.data, bins=50)
        ax.set_title(self._repr_latex_())
        ax.set_xlim(-10.0,10.0)
        data = print_figure(fig, format)
        # we must close the figure, otherwise ipython's display machinery
        # will pick it up and send it as output, resulting in a double display
        plt.close(fig)
        return data

    def _repr_png_(self):
        if self._png_data is none:
            self._png_data = self._figure_data('png')
        return self._png_data

    def _repr_latex_(self):
        return r'$\mathcal{n}(\mu=%.2g, \sigma=%.2g),\ n=%d$' % (self.mean,
                                                                 self.std, self.
size)

   create an instance of the gaussian distribution and return it to
   display the default representation:
   in [4]:
x = gaussian(2.0, 1.0)
x

   out[4]:
   $\mathcal{n}(\mu=2, \sigma=1),\ n=1000$

   you can also pass the object to the display function to display the
   default representation:
   in [5]:
display(x)

   $\mathcal{n}(\mu=2, \sigma=1),\ n=1000$

   use display_png to view the png representation:
   in [6]:
display_png(x)

   [a1aswqays9jdtdsjakbhr0knccwl6qggpas
   1addxpia8p8beb7ae9jkdqaaaaaasuvork5cyii= ]
   it is important to note a subtle different between display and
   display_png. the former computes all representations of the object, and
   lets the notebook ui decide which to display. the later only computes
   the png representation.

   create a new gaussian with different parameters:
   in [7]:
x2 = gaussian(0, 2, 2000)
x2

   out[7]:
   $\mathcal{n}(\mu=0, \sigma=2),\ n=2000$

   you can then compare the two gaussians by displaying their histograms:
   in [8]:
display_png(x)
display_png(x2)

   [a1aswqays9jdtdsjakbhr0knccwl6qggpas
   1addxpia8p8beb7ae9jkdqaaaaaasuvork5cyii= ]
   [8b+rbuym3h lnyaaaaasuvork5cyii= ]

   note that like print, you can call any of the display functions
   multiple times in a cell.

adding ipython display support to existing objects[16]  

   when you are directly writing your own classes, you can adapt them for
   display in ipython by following the above approach. but in practice,
   you often need to work with existing classes that you can't easily
   modify. we now illustrate how to add rich output capabilities to
   existing objects. we will use the numpy polynomials and change their
   default representation to be a formatted latex expression.

   first, consider how a numpy polynomial object renders by default:
   in [9]:
p = np.polynomial.polynomial([1,2,3], [-10, 10])
p

   out[9]:
polynomial([ 1.,  2.,  3.], [-10.,  10.], [-1,  1])

   next, define a function that pretty-prints a polynomial as a latex
   string:
   in [10]:
def poly_to_latex(p):
    terms = ['%.2g' % p.coef[0]]
    if len(p) > 1:
        term = 'x'
        c = p.coef[1]
        if c!=1:
            term = ('%.2g ' % c) + term
        terms.append(term)
    if len(p) > 2:
        for i in range(2, len(p)):
            term = 'x^%d' % i
            c = p.coef[i]
            if c!=1:
                term = ('%.2g ' % c) + term
            terms.append(term)
    px = '$p(x)=%s$' % '+'.join(terms)
    dom = r', $x \in [%.2g,\ %.2g]$' % tuple(p.domain)
    return px+dom

   this produces, on our polynomial p, the following:
   in [11]:
poly_to_latex(p)

   out[11]:
'$p(x)=1+2 x+3 x^2$, $x \\in [-10,\\ 10]$'

   you can render this string using the latex class:
   in [12]:
from ipython.display import latex
latex(poly_to_latex(p))

   out[12]:
   $p(x)=1+2 x+3 x^2$, $x \in [-10,\ 10]$

   however, you can configure ipython to do this automatically by
   registering the polynomial class and the poly_to_latex function with an
   ipython display formatter. let's look at the default formatters
   provided by ipython:
   in [13]:
ip = get_ipython()
for mime, formatter in ip.display_formatter.formatters.items():
    print('%24s : %s' % (mime, formatter.__class__.__name__))

              text/plain : plaintextformatter
               text/html : htmlformatter
           text/markdown : markdownformatter
           image/svg+xml : svgformatter
               image/png : pngformatter
         application/pdf : pdfformatter
              image/jpeg : jpegformatter
              text/latex : latexformatter
        application/json : jsonformatter
  application/javascript : javascriptformatter

   the formatters attribute is a dictionary keyed by mime types. to define
   a custom latex display function, you want a handle on the text/latex
   formatter:
   in [14]:
ip = get_ipython()
latex_f = ip.display_formatter.formatters['text/latex']

   the formatter object has a couple of methods for registering custom
   display functions for existing types.
   in [15]:
help(latex_f.for_type)

help on method for_type in module ipython.core.formatters:

for_type(typ, func=none) method of ipython.core.formatters.latexformatter instan
ce
    add a format function for a given type.

    parameters
    -----------
    typ : type or '__module__.__name__' string for a type
        the class of the object that will be formatted using `func`.
    func : callable
        a callable for computing the format data.
        `func` will be called with the object to be formatted,
        and will return the raw data in this formatter's format.
        subclasses may use a different call signature for the
        `func` argument.

        if `func` is none or not specified, there will be no change,
        only returning the current value.

    returns
    -------
    oldfunc : callable
        the currently registered callable.
        if you are registering a new formatter,
        this will be the previous value (to enable restoring later).


   in [16]:
help(latex_f.for_type_by_name)

help on method for_type_by_name in module ipython.core.formatters:

for_type_by_name(type_module, type_name, func=none) method of ipython.core.forma
tters.latexformatter instance
    add a format function for a type specified by the full dotted
    module and name of the type, rather than the type of the object.

    parameters
    ----------
    type_module : str
        the full dotted name of the module the type is defined in, like
        ``numpy``.
    type_name : str
        the name of the type (the class name), like ``dtype``
    func : callable
        a callable for computing the format data.
        `func` will be called with the object to be formatted,
        and will return the raw data in this formatter's format.
        subclasses may use a different call signature for the
        `func` argument.

        if `func` is none or unspecified, there will be no change,
        only returning the current value.

    returns
    -------
    oldfunc : callable
        the currently registered callable.
        if you are registering a new formatter,
        this will be the previous value (to enable restoring later).


   in this case, we will use for_type_by_name to register poly_to_latex as
   the display function for the polynomial type:
   in [17]:
latex_f.for_type_by_name('numpy.polynomial.polynomial',
                                 'polynomial', poly_to_latex)

   once the custom display function has been registered, all numpy
   polynomial instances will be represented by their latex form instead:
   in [18]:
p

   out[18]:
   $p(x)=1+2 x+3 x^2$, $x \in [-10,\ 10]$
   in [19]:
p2 = np.polynomial.polynomial([-20, 71, -15, 1])
p2

   out[19]:
   $p(x)=-20+71 x+-15 x^2+x^3$, $x \in [-1,\ 1]$

custom mimetypes with _repr_mimebundle_[17]  

   available on ipython 5.4+ and 6.1+.

   for objects needing full control over the repr protocol may decide to
   implement the _repr_mimebundle_(include, exclude) method. unlike the
   other _repr_*_ methods must return many representation of the object in
   a mapping object which keys are mimetypes and value are associated
   data. the _repr_mimebundle_() method, may also return a second mapping
   from mimetypes to metadata.

   example:
   in [20]:
class gaussian(object):
    """a simple object holding data sampled from a gaussian distribution.
    """
    def __init__(self, mean=0.0, std=1, size=1000):
        self.data = np.random.normal(mean, std, size)
        self.mean = mean
        self.std = std
        self.size = size
        # for caching plots that may be expensive to compute
        self._png_data = none

    def _figure_data(self, format):
        fig, ax = plt.subplots()
        ax.hist(self.data, bins=50)
        ax.set_xlim(-10.0,10.0)
        data = print_figure(fig, format)
        # we must close the figure, otherwise ipython's display machinery
        # will pick it up and send it as output, resulting in a double display
        plt.close(fig)
        return data

    def _compute_mathml(self):
        return """
        <math xmlns="http://www.w3.org/1998/math/mathml">
          <mrow class="mjx-texatom-ord">
            <mi class="mjx-tex-caligraphic" mathvariant="script">n</mi>
          </mrow>
          <mo stretchy="false">(</mo>
          <mi>&#x03bc;<!--    --></mi>
          <mo>=</mo>
          <mn>{mu}</mn>
          <mo>,</mo>
          <mi>&#x03c3;<!--    --></mi>
          <mo>=</mo>
          <mn>{sigma}</mn>
          <mo stretchy="false">)</mo>
          <mo>,</mo>
          <mtext>&#xa0;</mtext>
          <mi>n</mi>
          <mo>=</mo>
          <mn>{n}</mn>
        </math>
        """.format(n=self.size, mu=self.mean, sigma=self.std)

    def _repr_mimebundle_(self, include, exclude, **kwargs):
        """
        repr_mimebundle should accept include, exclude and **kwargs
        """
        if self._png_data is none:
            self._png_data = self._figure_data('png')
        math = r'$\mathcal{n}(\mu=%.2g, \sigma=%.2g),\ n=%d$' % (self.mean,
                                                                 self.std, self.
size)
        data = {'image/png':self._png_data,
                'text/latex':math,
                'application/mathml+xml': self._compute_mathml()
                }
        if include:
            data = {k:v for (k,v) in data.items() if k in include}
        if exclude:
            data = {k:v for (k,v) in data.items() if k not in exclude}
        return data

   in [21]:
# that is definitively wrong as it should show the png.
display(gaussian())

   $\mathcal{n}(\mu=0, \sigma=1),\ n=1000$

   in the above example, the 3 mimetypes are embedded in the notebook
   document this allowing custom extensions and converters to display the
   representation(s) of their choice.

   for example, converting this noetebook to epub may decide to use the
   mathml representation as most ebook reader cannot run mathjax (unlike
   browsers).

implementation guidelines[18]  

   the _repr_mimebundle_ methods is also given two keywords parameters :
   include and exclude. each can be a containers (e.g.:list, set ...) of
   mimetypes to return or none, this allows implementation to avoid
   computing potentially unnecessary and expensive mimetypes
   representations.

   when include is non-empty (empty list or none), _repr_mimebundle_ may
   decide to returns only the mimetypes in include. when exclude is
   non-empty, _repr_mimebundle_ may decide to not return any mimetype in
   exclude. if both include and exclude and overlap, mimetypes present in
   exclude may not be returned.

   if implementations decide to ignore the include and exclude logic and
   always returns a full mimebundles, the ipython kernel will take care of
   removing non-desired representations.

   the _repr_mimebundle_ method should accept arbitrary keyword arguments
   for future compatiility.
   in [22]:
display(gaussian(), include={'text/latex'}) # only show latex

   $\mathcal{n}(\mu=0, \sigma=1),\ n=1000$
   in [23]:
display(gaussian(), exclude={'image/png'}) # exclude png

   $\mathcal{n}(\mu=0, \sigma=1),\ n=1000$
   in [24]:
display(gaussian(), include={'text/plain', 'image/png'}, exclude={'image/png'})
# keep only plain/text

<__main__.gaussian at 0x11a8a0b38>

more complex display with _ipython_display_[19]  

   rich output special methods and functions can only display one object
   or mime type at a time. sometimes this is not enough if you want to
   display multiple objects or mime types at once. an example of this
   would be to use an html representation to put some html elements in the
   dom and then use a javascript representation to add events to those
   elements.

   ipython 2.0 recognizes another display method, _ipython_display_, which
   allows your objects to take complete control of displaying themselves.
   if this method is defined, ipython will call it, and make no effort to
   display the object using the above described _repr_*_ methods for
   custom display functions. it's a way for you to say "back off, ipython,
   i can display this myself." most importantly, your _ipython_display_
   method can make multiple calls to the top-level display functions to
   accomplish its goals.

   here is an object that uses display_html and display_javascript to make
   a plot using the [20]flot javascript plotting library:
   in [25]:
import json
import uuid
from ipython.display import display_javascript, display_html, display

class flotplot(object):
    def __init__(self, x, y):
        self.x = x
        self.y = y
        self.uuid = str(uuid.uu ())

    def _ipython_display_(self):
        json_data = json.dumps(list(zip(self.x, self.y)))
        display_html('<div id="{}" style="height: 300px; width:80%;"></div>'.for
mat(self.uuid),
            raw=true
        )
        display_javascript("""
        require(["//cdnjs.cloudflare.com/ajax/libs/flot/0.8.2/jquery.flot.min.js
"], function() {
          var line = json.parse("%s");
          console.log(line);
          $.plot("#%s", [line]);
        });
        """ % (json_data, self.uuid), raw=true)

   in [26]:
import numpy as np
x = np.linspace(0,10)
y = np.sin(x)
flotplot(x, np.sin(x))

   this website does not host notebooks, it only renders notebooks
   available on other websites.

   delivered by [21]fastly, rendered by [22]rackspace

   nbviewer github [23]repository.

   nbviewer version: [24]33c4683

   nbconvert version: [25]5.4.0

   rendered (fri, 05 apr 2019 18:19:52 utc)

references

   1. https://nbviewer.jupyter.org/
   2. http://jupyter.org/
   3. https://nbviewer.jupyter.org/faq
   4. https://nbviewer.jupyter.org/format/script/github/ipython/ipython/blob/master/examples/ipython kernel/custom display logic.ipynb
   5. https://nbviewer.jupyter.org/github/ipython/ipython/blob/master/examples/ipython kernel/custom display logic.ipynb
   6. https://github.com/ipython/ipython/blob/master/examples/ipython kernel/custom display logic.ipynb
   7. https://mybinder.org/v2/gh/ipython/ipython/master?filepath=examples/ipython kernel/custom display logic.ipynb
   8. https://raw.githubusercontent.com/ipython/ipython/master/examples/ipython kernel/custom display logic.ipynb
   9. https://nbviewer.jupyter.org/github/ipython/ipython/tree/master
  10. https://nbviewer.jupyter.org/github/ipython/ipython/tree/master/examples
  11. https://nbviewer.jupyter.org/github/ipython/ipython/tree/master/examples/ipython kernel
  12. https://nbviewer.jupyter.org/github/ipython/ipython/blob/master/examples/ipython kernel/custom display logic.ipynb#custom-display-logic
  13. https://nbviewer.jupyter.org/github/ipython/ipython/blob/master/examples/ipython kernel/custom display logic.ipynb#overview
  14. https://nbviewer.jupyter.org/github/ipython/ipython/blob/master/examples/ipython kernel/rich output.ipynb
  15. https://nbviewer.jupyter.org/github/ipython/ipython/blob/master/examples/ipython kernel/custom display logic.ipynb#special-display-methods
  16. https://nbviewer.jupyter.org/github/ipython/ipython/blob/master/examples/ipython kernel/custom display logic.ipynb#adding-ipython-display-support-to-existing-objects
  17. https://nbviewer.jupyter.org/github/ipython/ipython/blob/master/examples/ipython kernel/custom display logic.ipynb#custom-mimetypes-with-_repr_mimebundle_
  18. https://nbviewer.jupyter.org/github/ipython/ipython/blob/master/examples/ipython kernel/custom display logic.ipynb#implementation-guidelines
  19. https://nbviewer.jupyter.org/github/ipython/ipython/blob/master/examples/ipython kernel/custom display logic.ipynb#more-complex-display-with-_ipython_display_
  20. http://www.flotcharts.org/
  21. http://www.fastly.com/
  22. https://developer.rackspace.com/?nbviewer=awesome
  23. https://github.com/jupyter/nbviewer
  24. https://github.com/jupyter/nbviewer/commit/33c4683164d5ee4c92dbcd53afac7f13ef033c54
  25. https://github.com/jupyter/nbconvert/releases/tag/5.4.0
