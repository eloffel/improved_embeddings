   (button) toggle navigation
   [1][nav_logo.svg?v=479cefe8d932fb14a67b93911b97d70f]
     * [2]jupyter
     * [3]faq
     * [4]view as code
     * [5]python 2 kernel
     * [6]view on github
     * [7]execute on binder
     * [8]download notebook

    1. [9]scientific-python-lectures
    2. [10]lecture-4-matplotlib.ipynb

matplotlib - 2d and 3d plotting in python[11]  

   j.r. johansson (jrjohansson at gmail.com)

   the latest version of this [12]ipython notebook lecture is available at
   [13]http://github.com/jrjohansson/scientific-python-lectures.

   the other notebooks in this lecture series are indexed at
   [14]http://jrjohansson.github.io.
   in [1]:
# this line configures matplotlib to show figures embedded in the notebook,
# instead of opening a new window for each figure. more about that later.
# if you are using an old version of ipython, try using '%pylab inline' instead.
%matplotlib inline

introduction[15]  

   matplotlib is an excellent 2d and 3d graphics library for generating
   scientific figures. some of the many advantages of this library
   include:
     * easy to get started
     * support for $\latex$ formatted labels and texts
     * great control of every element in a figure, including figure size
       and dpi.
     * high-quality output in many formats, including png, pdf, svg, eps,
       and pgf.
     * gui for interactively exploring figures and support for headless
       generation of figure files (useful for batch jobs).

   one of the key features of matplotlib that i would like to emphasize,
   and that i think makes matplotlib highly suitable for generating
   figures for scientific publications is that all aspects of the figure
   can be controlled programmatically. this is important for
   reproducibility and convenient when one needs to regenerate the figure
   with updated data or change its appearance.

   more information at the matplotlib web page: [16]http://matplotlib.org/

   to get started using matplotlib in a python program, either include the
   symbols from the pylab module (the easy way):
   in [2]:
from pylab import *

   or import the matplotlib.pyplot module under the name plt (the tidy
   way):
   in [3]:
import matplotlib
import matplotlib.pyplot as plt

   in [4]:
import numpy as np

matlab-like api[17]  

   the easiest way to get started with plotting using matplotlib is often
   to use the matlab-like api provided by matplotlib.

   it is designed to be compatible with matlab's plotting functions, so it
   is easy to get started with if you are familiar with matlab.

   to use this api from matplotlib, we need to include the symbols in the
   pylab module:
   in [5]:
from pylab import *

example[18]  

   a simple figure with matlab-like plotting api:
   in [6]:
x = np.linspace(0, 5, 10)
y = x ** 2

   in [7]:
figure()
plot(x, y, 'r')
xlabel('x')
ylabel('y')
title('title')
show()

   [axxh+abiqfdbaaaaaelftksuqmcc ]

   most of the plotting related functions in matlab are covered by the
   pylab module. for example, subplot and color/symbol selection:
   in [8]:
subplot(1,2,1)
plot(x, y, 'r--')
subplot(1,2,2)
plot(y, x, 'g*-');

   [xxue5j
   vvp21i65oncruan4khjs04gkuwz7jwdfzgemepjxdne7bb6ggwmjedyhabfyx6ynrsiicui
   nruve
   eoqkuohiglbbfxfjecroiiijqgvdrcrbqkclicqifxqrkqshgi4ikid+hwifjhjzdk5aaaa
   aaelf tksuqmcc ]

   the good thing about the pylab matlab-style api is that it is easy to
   get started with if you are familiar with matlab, and it has a minumum
   of coding overhead for simple plots.

   however, i'd encourrage not using the matlab compatible api for
   anything but the simplest figures.

   instead, i recommend learning and using matplotlib's object-oriented
   plotting api. it is remarkably powerful. for advanced figures with
   subplots, insets and other components it is very nice to work with.

the matplotlib object-oriented api[19]  

   the main idea with object-oriented programming is to have objects that
   one can apply functions and actions on, and no object or program states
   should be global (such as the matlab-like api). the real advantage of
   this approach becomes apparent when more than one figure is created, or
   when a figure contains more than one subplot.

   to use the object-oriented api we start out very much like in the
   previous example, but instead of creating a new global figure instance
   we store a reference to the newly created figure instance in the fig
   variable, and from it we create a new axis instance axes using the
   add_axes method in the figure class instance fig:
   in [9]:
fig = plt.figure()

axes = fig.add_axes([0.1, 0.1, 0.8, 0.8]) # left, bottom, width, height (range 0
 to 1)

axes.plot(x, y, 'r')

axes.set_xlabel('x')
axes.set_ylabel('y')
axes.set_title('title');

   [agscaql+ca5fqyo5c
   qogige92rynpajuklp4j55kkmlk17wkkzhcrq4f3u0o3rkqfygpelfjkhtmxjtwehyukqsl
   3kcrj
   frkukqskdapjukughsspioncklsrqsfjqsigkcrv9p8b3lb90wkvrvwaaaaasuvork5cyii
   = ]

   although a little bit more code is involved, the advantage is that we
   now have full control of where the plot axes are placed, and we can
   easily add more than one axis to the figure:
   in [10]:
fig = plt.figure()

axes1 = fig.add_axes([0.1, 0.1, 0.8, 0.8]) # main axes
axes2 = fig.add_axes([0.2, 0.5, 0.4, 0.3]) # inset axes

# main figure
axes1.plot(x, y, 'r')
axes1.set_xlabel('x')
axes1.set_ylabel('y')
axes1.set_title('title')

# insert
axes2.plot(y, x, 'g')
axes2.set_xlabel('y')
axes2.set_ylabel('x')
axes2.set_title('insert title');

   [akobvwkxojyfhgvuotcxaum
   mdnwrnvqa6horx3u5ugixlpy7qaiwc4y0wc4za2dziyjabkmmbhw2nixo4l4hvouiiksk41
   riihi
   rlqoreqkvyouiikskxukerhjlqqfiijksovcrerypuihiik5+n9k32bw2qgjlqaaaabjru5
   erkjg gg== ]

   if we don't care about being explicit about where our plot axes are
   placed in the figure canvas, then we can use one of the many axis
   layout managers in matplotlib. my favorite is subplots, which can be
   used like this:
   in [11]:
fig, axes = plt.subplots()

axes.plot(x, y, 'r')
axes.set_xlabel('x')
axes.set_ylabel('y')
axes.set_title('title');

   [axxh+abiqfdbaaaaaelftksuqmcc ]
   in [12]:
fig, axes = plt.subplots(nrows=1, ncols=2)

for ax in axes:
    ax.plot(x, y, 'r')
    ax.set_xlabel('x')
    ax.set_ylabel('y')
    ax.set_title('title')

   [atisl5dby4t8aaaaaelftksuqmcc ]

   that was easy, but it isn't so pretty with overlapping figure axes and
   labels, right?

   we can deal with that by using the fig.tight_layout method, which
   automatically adjusts the positions of the axes on the figure canvas so
   that there is no overlapping content:
   in [13]:
fig, axes = plt.subplots(nrows=1, ncols=2)

for ax in axes:
    ax.plot(x, y, 'r')
    ax.set_xlabel('x')
    ax.set_ylabel('y')
    ax.set_title('title')

fig.tight_layout()

   [kglaaaaaelftksuqmcc ]

figure size, aspect ratio and dpi[20]  

   matplotlib allows the aspect ratio, dpi and figure size to be specified
   when the figure object is created, using the figsize and dpi keyword
   arguments. figsize is a tuple of the width and height of the figure in
   inches, and dpi is the dots-per-inch (pixel per inch). to create an
   800x400 pixel, 100 dots-per-inch figure, we can do:
   in [14]:
fig = plt.figure(figsize=(8,4), dpi=100)

<matplotlib.figure.figure at 0x8065320>

   the same arguments can also be passed to layout managers, such as the
   subplots function:
   in [15]:
fig, axes = plt.subplots(figsize=(12,3))

axes.plot(x, y, 'r')
axes.set_xlabel('x')
axes.set_ylabel('y')
axes.set_title('title');

   [avaugpckkdbqaaaaaelf tksuqmcc ]

saving figures[21]  

   to save a figure to a file we can use the savefig method in the figure
   class:
   in [16]:
fig.savefig("filename.png")

   here we can also optionally specify the dpi and choose between
   different output formats:
   in [17]:
fig.savefig("filename.png", dpi=200)

what formats are available and which ones should be used for best
quality?[22]  

   matplotlib can generate high-quality output in a number formats,
   including png, jpg, eps, svg, pgf and pdf. for scientific papers, i
   recommend using pdf whenever possible. (latex documents compiled with
   pdflatex can include pdfs using the includegraphics command). in some
   cases, pgf can also be good alternative.

legends, labels and titles[23]  

   now that we have covered the basics of how to create a figure canvas
   and add axes instances to the canvas, let's look at how decorate a
   figure with titles, axis labels, and legends.

   figure titles

   a title can be added to each axis instance in a figure. to set the
   title, use the set_title method in the axes instance:
   in [18]:
ax.set_title("title");

   axis labels

   similarly, with the methods set_xlabel and set_ylabel, we can set the
   labels of the x and y axes:
   in [19]:
ax.set_xlabel("x")
ax.set_ylabel("y");

   legends

   legends for curves in a figure can be added in two ways. one method is
   to use the legend method of the axis object and pass a list/tuple of
   legend texts for the previously defined curves:
   in [20]:
ax.legend(["curve1", "curve2", "curve3"]);

   the method described above follows the matlab api. it is somewhat prone
   to errors and unflexible if curves are added to or removed from the
   figure (resulting in a wrongly labelled curve).

   a better method is to use the label="label text" keyword argument when
   plots or other objects are added to the figure, and then using the
   legend method without arguments to add the legend to the figure:
   in [21]:
ax.plot(x, x**2, label="curve1")
ax.plot(x, x**3, label="curve2")
ax.legend();

   the advantage with this method is that if curves are added or removed
   from the figure, the legend is automatically updated accordingly.

   the legend function takes an optional keyword argument loc that can be
   used to specify where in the figure the legend is to be drawn. the
   allowed values of loc are numerical codes for the various places the
   legend can be drawn. see
   [24]http://matplotlib.org/users/legend_guide.html#legend-location for
   details. some of the most common loc values are:
   in [22]:
ax.legend(loc=0) # let matplotlib decide the optimal location
ax.legend(loc=1) # upper right corner
ax.legend(loc=2) # upper left corner
ax.legend(loc=3) # lower left corner
ax.legend(loc=4) # lower right corner
# .. many more options are available

   out[22]:
<matplotlib.legend.legend at 0x3dfc1d0>

   the following figure shows how to use the figure title, axis labels and
   legends described above:
   in [23]:
fig, ax = plt.subplots()

ax.plot(x, x**2, label="y = x**2")
ax.plot(x, x**3, label="y = x**3")
ax.legend(loc=2); # upper left corner
ax.set_xlabel('x')
ax.set_ylabel('y')
ax.set_title('title');

   [83b05z97scdknkhfqo
   ogcr8sdm+gdz7j7bzjkal8ws3d0zag5npnruyxarkqluxyaiiguomyiisafkdciiuoasg4i
   ifkde iciibsgxiihiauomiijsgbkdiigu8p8bsbxvkqettdcaaaaasuvork5cyii= ]

formatting text: latex, fontsize, font family[25]  

   the figure above is functional, but it does not (yet) satisfy the
   criteria for a figure used in a publication. first and foremost, we
   need to have latex formatted text, and second, we need to be able to
   adjust the font size to appear right in a publication.

   matplotlib has great support for latex. all we need to do is to use
   dollar signs encapsulate latex in any text (legend, title, label,
   etc.). for example, "$y=x^3$".

   but here we can run into a slightly subtle problem with latex code and
   python text strings. in latex, we frequently use the backslash in
   commands, for example \alpha to produce the symbol $\alpha$. but the
   backslash already has a meaning in python strings (the escape code
   character). to avoid python messing up our latex code, we need to use
   "raw" text strings. raw text strings are prepended with an 'r', like
   r"\alpha" or r'\alpha' instead of "\alpha" or '\alpha':
   in [24]:
fig, ax = plt.subplots()

ax.plot(x, x**2, label=r"$y = \alpha^2$")
ax.plot(x, x**3, label=r"$y = \alpha^3$")
ax.legend(loc=2) # upper left corner
ax.set_xlabel(r'$\alpha$', fontsize=18)
ax.set_ylabel(r'$y$', fontsize=18)
ax.set_title('title');

   [gcenfdjwvwpeiefbwiihirdvwjiehefbwiihir
   byeiierewseiihfrciiisequhciiehefh4iiretbisiievfwiihirbqciiiskf8padmz6pt
   uzyka aaaasuvork5cyii= ]

   we can also change the global font size and font family, which applies
   to all text elements in a figure (tick labels, axis labels and titles,
   legends, etc.):
   in [25]:
# update the matplotlib configuration parameters:
matplotlib.rcparams.update({'font.size': 18, 'font.family': 'serif'})

   in [26]:
fig, ax = plt.subplots()

ax.plot(x, x**2, label=r"$y = \alpha^2$")
ax.plot(x, x**3, label=r"$y = \alpha^3$")
ax.legend(loc=2) # upper left corner
ax.set_xlabel(r'$\alpha$')
ax.set_ylabel(r'$y$')
ax.set_title('title');

   [jtoh pqqnf1waaaaasuvork5cyii= ]

   a good choice of global fonts are the stix fonts:
   in [27]:
# update the matplotlib configuration parameters:
matplotlib.rcparams.update({'font.size': 18, 'font.family': 'stixgeneral', 'math
text.fontset': 'stix'})

   in [28]:
fig, ax = plt.subplots()

ax.plot(x, x**2, label=r"$y = \alpha^2$")
ax.plot(x, x**3, label=r"$y = \alpha^3$")
ax.legend(loc=2) # upper left corner
ax.set_xlabel(r'$\alpha$')
ax.set_ylabel(r'$y$')
ax.set_title('title');

   [qoqvltvl
   zdmxudhghzwbtfvnynx2v6awsf1eaopiexdkm6b4lid122cid35okyirakiyoxahcaxwfxaxaq
   a7mj9
   xhslnf1ljetezajqbvggxak8jbmo04dbvxwxi+uzuywwksyyy3zghr+mmcb4jiwkmcyyn7f
   qmcyy
   4zmwksyyy3zgqsuyy4zpwkgyy4zxgqsvy4wxpmohyowxxmcsviwxxvimhyoxxhif+x9awfu
   idx3b haaaaabjru5erkjggg== ]

   or, alternatively, we can request that matplotlib uses latex to render
   the text elements in the figure:
   in [29]:
matplotlib.rcparams.update({'font.size': 18, 'text.usetex': true})

   in [30]:
fig, ax = plt.subplots()

ax.plot(x, x**2, label=r"$y = \alpha^2$")
ax.plot(x, x**3, label=r"$y = \alpha^3$")
ax.legend(loc=2) # upper left corner
ax.set_xlabel(r'$\alpha$')
ax.set_ylabel(r'$y$')
ax.set_title('title');

   [au5iakyfnn4uaaaaaelftksuqmcc ]
   in [31]:
# restore
matplotlib.rcparams.update({'font.size': 12, 'font.family': 'sans', 'text.usetex
': false})

setting colors, linewidths, linetypes[26]  

colors[27]  

   with matplotlib, we can define the colors of lines and other graphical
   elements in a number of ways. first of all, we can use the matlab-like
   syntax where 'b' means blue, 'g' means green, etc. the matlab api for
   selecting line styles are also supported: where, for example, 'b.-'
   means a blue line with dots:
   in [32]:
# matlab style line color and style
ax.plot(x, x**2, 'b.-') # blue line with dots
ax.plot(x, x**3, 'g--') # green dashed line

   out[32]:
[<matplotlib.lines.line2d at 0x96df0b8>]

   we can also define colors by their names or rgb hex codes and
   optionally provide an alpha value using the color and alpha keyword
   arguments:
   in [33]:
fig, ax = plt.subplots()

ax.plot(x, x+1, color="red", alpha=0.5) # half-transparant red
ax.plot(x, x+2, color="#1155dd")        # rgb hex code for a bluish color
ax.plot(x, x+3, color="#15cc55")        # rgb hex code for a greenish color

   out[33]:
[<matplotlib.lines.line2d at 0x6fbc048>]

   [a2a0pdmtgu7e4o7bwv8h2e5tcpe0plxv
   hfgowdx8n2cotnd3n470curtruqsqmm6iehcagclicsebraisejoyiuijiqgtohiqmhgi4g
   khaa2 iehcagclicsebraisel8f0xrdutfv1staaaaaelftksuqmcc ]

line and marker styles[28]  

   to change the line width, we can use the linewidth or lw keyword
   argument. the line style can be selected using the linestyle or ls
   keyword arguments:
   in [34]:
fig, ax = plt.subplots(figsize=(12,6))

ax.plot(x, x+1, color="blue", linewidth=0.25)
ax.plot(x, x+2, color="blue", linewidth=0.50)
ax.plot(x, x+3, color="blue", linewidth=1.00)
ax.plot(x, x+4, color="blue", linewidth=2.00)

# possible linestype options    -   ,    --   ,    -.   ,    :   ,    steps   
ax.plot(x, x+5, color="red", lw=2, linestyle='-')
ax.plot(x, x+6, color="red", lw=2, ls='-.')
ax.plot(x, x+7, color="red", lw=2, ls=':')

# custom dash
line, = ax.plot(x, x+8, color="black", lw=1.50)
line.set_dashes([5, 10, 15, 10]) # format: line length, space length, ...

# possible marker symbols: marker = '+', 'o', '*', 's', ',', '.', '1', '2', '3',
 '4', ...
ax.plot(x, x+ 9, color="green", lw=2, ls='--', marker='+')
ax.plot(x, x+10, color="green", lw=2, ls='--', marker='o')
ax.plot(x, x+11, color="green", lw=2, ls='--', marker='s')
ax.plot(x, x+12, color="green", lw=2, ls='--', marker='1')

# marker size and color
ax.plot(x, x+13, color="purple", lw=1, ls='-', marker='o', markersize=2)
ax.plot(x, x+14, color="purple", lw=1, ls='-', marker='o', markersize=4)
ax.plot(x, x+15, color="purple", lw=1, ls='-', marker='o', markersize=8, markerf
acecolor="red")
ax.plot(x, x+16, color="purple", lw=1, ls='-', marker='s', markersize=8,
        markerfacecolor="yellow", markeredgewidth=2, markeredgecolor="blue");

   [rdhmrncid35ekisf45gjiyqqqkjc
   qhkmhbbcccejc2wyeeiiiyqkljrhqgghhbcssfcgid19eeejiwkizjoqqqgghcqtlmbbcid35
   ejcyu yuiiiyqqkrd8pwrfsajv3mn5aaaaaelftksuqmcc ]

control over axis appearance[29]  

   the appearance of the axes is an important aspect of a figure that we
   often need to modify to make a publication quality graphics. we need to
   be able to control where the ticks and labels are placed, modify the
   font size and possibly the labels used on the axes. in this section we
   will look at controling those properties in a matplotlib figure.

plot range[30]  

   the first thing we might want to configure is the ranges of the axes.
   we can do this using the set_ylim and set_xlim methods in the axis
   object, or axis('tight') for automatrically getting "tightly fitted"
   axes ranges:
   in [35]:
fig, axes = plt.subplots(1, 3, figsize=(12, 4))

axes[0].plot(x, x**2, x, x**3)
axes[0].set_title("default axes ranges")

axes[1].plot(x, x**2, x, x**3)
axes[1].axis('tight')
axes[1].set_title("tight axes")

axes[2].plot(x, x**2, x, x**3)
axes[2].set_ylim([0, 60])
axes[2].set_xlim([2, 5])
axes[2].set_title("custom axes range");

   [h+9aogsocet8aaaaaelftksuqmcc ]

logarithmic scale[31]  

   it is also possible to set a logarithmic scale for one or both axes.
   this functionality is in fact only one application of a more general
   transformation system in matplotlib. each of the axes' scales are set
   seperately using set_xscale and set_yscale methods which accept one
   parameter (with the value "log" in this case):
   in [36]:
fig, axes = plt.subplots(1, 2, figsize=(10,4))

axes[0].plot(x, x**2, x, np.exp(x))
axes[0].set_title("normal scale")

axes[1].plot(x, x**2, x, np.exp(x))
axes[1].set_yscale("log")
axes[1].set_title("logarithmic scale (y)");

   [wcqdc0s kfixqwaaaabjru5erkjggg== ]

placement of ticks and custom tick labels[32]  

   we can explicitly determine where we want the axis ticks with
   set_xticks and set_yticks, which both take a list of values for where
   on the axis the ticks are to be placed. we can also use the
   set_xticklabels and set_yticklabels methods to provide a list of custom
   text labels for each tick location:
   in [37]:
fig, ax = plt.subplots(figsize=(10, 4))

ax.plot(x, x**2, x, x**3, lw=2)

ax.set_xticks([1, 2, 3, 4, 5])
ax.set_xticklabels([r'$\alpha$', r'$\beta$', r'$\gamma$', r'$\delta$', r'$\epsil
on$'], fontsize=18)

yticks = [0, 50, 100, 150]
ax.set_yticks(yticks)
ax.set_yticklabels(["$%.1f$" % y for y in yticks], fontsize=18); # use latex for
matted labels

   out[37]:
[<matplotlib.text.text at 0x10a3ae610>,
 <matplotlib.text.text at 0x10a3aedd0>,
 <matplotlib.text.text at 0x10a3fe110>,
 <matplotlib.text.text at 0x10a3fe750>]

   [lmtuif5gaaaabjru5erkjggg== ]

   there are a number of more advanced methods for controlling major and
   minor tick placement in matplotlib figures, such as automatic placement
   according to different policies. see
   [33]http://matplotlib.org/api/ticker_api.html for details.

scientific notation[34]  

   with large numbers on axes, it is often better use scientific notation:
   in [38]:
fig, ax = plt.subplots(1, 1)

ax.plot(x, x**2, x, np.exp(x))
ax.set_title("scientific notation")

ax.set_yticks([0, 50, 100, 150])

from matplotlib import ticker
formatter = ticker.scalarformatter(usemathtext=true)
formatter.set_scientific(true)
formatter.set_powerlimits((-1,1))
ax.yaxis.set_major_formatter(formatter)

   [8p g9jksfvnxl8aaaaasuvork5cyii= ]

axis number and axis label spacing[35]  

   in [39]:
# distance between x and y axis and the numbers on the axes
matplotlib.rcparams['xtick.major.pad'] = 5
matplotlib.rcparams['ytick.major.pad'] = 5

fig, ax = plt.subplots(1, 1)

ax.plot(x, x**2, x, np.exp(x))
ax.set_yticks([0, 50, 100, 150])

ax.set_title("label and axis spacing")

# padding between axis label and axis numbers
ax.xaxis.labelpad = 5
ax.yaxis.labelpad = 5

ax.set_xlabel("x")
ax.set_ylabel("y");

   [angoje64g8fiaaaaaelftksuqmcc ]
   in [40]:
# restore defaults
matplotlib.rcparams['xtick.major.pad'] = 3
matplotlib.rcparams['ytick.major.pad'] = 3

axis position adjustments[36]  

   unfortunately, when saving figures the labels are sometimes clipped,
   and it can be necessary to adjust the positions of axes a little bit.
   this can be done using subplots_adjust:
   in [41]:
fig, ax = plt.subplots(1, 1)

ax.plot(x, x**2, x, np.exp(x))
ax.set_yticks([0, 50, 100, 150])

ax.set_title("title")
ax.set_xlabel("x")
ax.set_ylabel("y")

fig.subplots_adjust(left=0.15, right=.9, bottom=0.1, top=0.9);

   [ofcoaaaaasuvork5cyii= ]

axis grid[37]  

   with the grid method in the axis object, we can turn on and off grid
   lines. we can also customize the appearance of the grid lines using the
   same keyword arguments as the plot function:
   in [42]:
fig, axes = plt.subplots(1, 2, figsize=(10,3))

# default grid appearance
axes[0].plot(x, x**2, x, x**3, lw=2)
axes[0].grid(true)

# custom grid appearance
axes[1].plot(x, x**2, x, x**3, lw=2)
axes[1].grid(color='b', alpha=0.5, linestyle='dashed', linewidth=0.5)

   [lmkjhbbcid18tmhxgsgghhbdcdqsxekiiiytwewmshbbcccf8rboriyqqqggfkczkid35eem
   jh
   plesqgghhparaayeeeiiixxegishhbbccb+rxkoiiyqqwkf+p9mvfn3omvlhaaaaaelftks
   uqmcc ]

axis spines[38]  

   we can also change the properties of axis spines:
   in [43]:
fig, ax = plt.subplots(figsize=(6,2))

ax.spines['bottom'].set_color('blue')
ax.spines['top'].set_color('blue')

ax.spines['left'].set_color('red')
ax.spines['left'].set_linewidth(2)

# turn off axis spine to the right
ax.spines['right'].set_color("none")
ax.yaxis.tick_left() # only ticks on the left side

   [a3b1nuj19n2kaaaaaelftksuqmcc ]

twin axes[39]  

   sometimes it is useful to have dual x or y axes in a figure; for
   example, when plotting curves with different units together. matplotlib
   supports this with the twinx and twiny functions:
   in [44]:
fig, ax1 = plt.subplots()

ax1.plot(x, x**2, lw=2, color="blue")
ax1.set_ylabel(r"area $(m^2)$", fontsize=18, color="blue")
for label in ax1.get_yticklabels():
    label.set_color("blue")

ax2 = ax1.twinx()
ax2.plot(x, x**3, lw=2, color="red")
ax2.set_ylabel(r"volume $(m^3)$", fontsize=18, color="red")
for label in ax2.get_yticklabels():
    label.set_color("red")

   [cfb84xz91zoaaaaasuvork5cyii= ]

axes where x and y is zero[40]  

   in [45]:
fig, ax = plt.subplots()

ax.spines['right'].set_color('none')
ax.spines['top'].set_color('none')

ax.xaxis.set_ticks_position('bottom')
ax.spines['bottom'].set_position(('data',0)) # set position of x spine to x=0

ax.yaxis.set_ticks_position('left')
ax.spines['left'].set_position(('data',0))   # set position of y spine to y=0

xx = np.linspace(-0.75, 1., 100)
ax.plot(xx, xx**3);

   [cqfwaaaaasuvork5c yii= ]

other 2d plot styles[41]  

   in addition to the regular plot method, there are a number of other
   functions for generating different kind of plots. see the matplotlib
   plot gallery for a complete list of available plot types:
   [42]http://matplotlib.org/gallery.html. some of the more useful ones
   are show below:
   in [46]:
n = np.array([0,1,2,3,4,5])

   in [47]:
fig, axes = plt.subplots(1, 4, figsize=(12,3))

axes[0].scatter(xx, xx + 0.25*np.random.randn(len(xx)))
axes[0].set_title("scatter")

axes[1].step(n, n**2, lw=2)
axes[1].set_title("step")

axes[2].bar(n, n**2, align="center", width=0.5, alpha=0.5)
axes[2].set_title("bar")

axes[3].fill_between(x, x**2, x**3, color="green", alpha=0.5);
axes[3].set_title("fill_between");

   [2cy6ylwsrgjn5qu88eaq6udc5u17iz
   bq3uxakcjt05fya03ndmydh7nmmlwiewdfzw8f1wxfszslhlwbv7qnrfipb6hjejvvrch1e
   eiw0g
   91bhpeh6av3qyk+2mnojvfhd83+xdyc156rsnxbcid35eeaoyickzqgghhbbctcoamashhbb
   ccdea
   dzifeeiiiyqygabmqgghhbbcdeadzigeeeiiiqagabmqqgghhbad0ibzid35eeekiawjaliq
   qqggh xad+ax5xhvo2qhhdaaaaaelftksuqmcc ]
   in [48]:
# polar plot using add_axes and polar projection
fig = plt.figure()
ax = fig.add_axes([0.0, 0.0, .6, .6], polar=true)
t = np.linspace(0, 2 * np.pi, 100)
ax.plot(t, t, color='blue', lw=3);

   [bcaex+fmino91djheudu+aje
   kylotznkfjmikl+ukdirvb4ouwqiqnxroshevpmirjgjqpjfisituewlekumosoxjypmrju
   vshsz +h9pxg7jbznafqaaaabjru5erkjggg== ]
   in [49]:
# a histogram
n = np.random.randn(100000)
fig, axes = plt.subplots(1, 2, figsize=(12,4))

axes[0].hist(n)
axes[0].set_title("default histogram")
axes[0].set_xlim((min(n), max(n)))

axes[1].hist(n, cumulative=true, bins=50)
axes[1].set_title("cumulative detailed histogram")
axes[1].set_xlim((min(n), max(n)));

   [a87luhdi3ohlaaaaaelftksuqmcc ]

text annotation[43]  

   annotating text in matplotlib figures can be done using the text
   function. it supports latex formatting just like axis label texts and
   titles:
   in [50]:
fig, ax = plt.subplots()

ax.plot(xx, xx**2, xx, xx**3)

ax.text(0.15, 0.2, r"$y=x^2$", fontsize=20, color="blue")
ax.text(0.65, 0.1, r"$y=x^3$", fontsize=20, color="green");

   [lgaaaaaelftksuqmcc ]

figures with multiple subplots and insets[44]  

   axes can be added to a matplotlib figure canvas manually using
   fig.add_axes or using a sub-figure layout manager such as subplots,
   subplot2grid, or gridspec:

subplots[45]  

   in [51]:
fig, ax = plt.subplots(2, 3)
fig.tight_layout()

   [h+aji7xn+tl1aaa aabjru5erkjggg== ]

subplot2grid[46]  

   in [52]:
fig = plt.figure()
ax1 = plt.subplot2grid((3,3), (0,0), colspan=3)
ax2 = plt.subplot2grid((3,3), (1,0), colspan=2)
ax3 = plt.subplot2grid((3,3), (1,2), rowspan=2)
ax4 = plt.subplot2grid((3,3), (2,0))
ax5 = plt.subplot2grid((3,3), (2,1))
fig.tight_layout()

   [wdt vffdtsofpqaaaabjru5erkjggg== ]

gridspec[47]  

   in [53]:
import matplotlib.gridspec as gridspec

   in [54]:
fig = plt.figure()

gs = gridspec.gridspec(2, 3, height_ratios=[2,1], width_ratios=[1,2,1])
for g in gs:
    ax = fig.add_subplot(g)

fig.tight_layout()

   [+jfgh0pkqa37rskpg8zmzmah6mtizmzmq3fbmjozjlggmzlzelyq
   zmwscs5izmawbbckmzid86gusmzklwqxjzmys4ijkzmzj+h+wwg9fes2auaaaaabjru5erkj
   ggg== ]

add_axes[48]  

   manually adding axes with add_axes is useful for adding insets to
   figures:
   in [55]:
fig, ax = plt.subplots()

ax.plot(xx, xx**2, xx, xx**3)
fig.tight_layout()

# inset
inset_ax = fig.add_axes([0.2, 0.55, 0.35, 0.35]) # x, y, width, height

inset_ax.plot(xx, xx**2, xx, xx**3)
inset_ax.set_title('zoom near origin')

# set axis range
inset_ax.set_xlim(-.2, .2)
inset_ax.set_ylim(-.005, .01)

# set axis tick locations
inset_ax.set_yticks([0, 0.005, 0.01])
inset_ax.set_xticks([-0.1,0,.1]);

   [ztzmygucczmvkkxjdmzcwklkhmzhyffyqzm4ucc5kzmuxbbcnmzklggmrmzlh4f2qzxbcg
   9kcnaaaaaelftksuqmcc ]

colormap and contour figures[49]  

   colormaps and contour figures are useful for plotting functions of two
   variables. in most of these functions we will use a colormap to encode
   one dimension of the data. there are a number of predefined colormaps.
   it is relatively straightforward to define custom colormaps. for a list
   of pre-defined colormaps, see:
   [50]http://www.scipy.org/cookbook/matplotlib/show_colormaps
   in [56]:
alpha = 0.7
phi_ext = 2 * np.pi * 0.5

def flux_qubit_potential(phi_m, phi_p):
    return 2 + alpha - 2 * np.cos(phi_p) * np.cos(phi_m) - alpha * np.cos(phi_ex
t - 2*phi_p)

   in [57]:
phi_m = np.linspace(0, 2*np.pi, 100)
phi_p = np.linspace(0, 2*np.pi, 100)
x,y = np.meshgrid(phi_p, phi_m)
z = flux_qubit_potential(x, y).t

pcolor[51]  

   in [58]:
fig, ax = plt.subplots()

p = ax.pcolor(x/(2*np.pi), y/(2*np.pi), z, cmap=matplotlib.cm.rdbu, vmin=abs(z).
min(), vmax=abs(z).max())
cb = fig.colorbar(p, ax=ax)

   [75aaaaaelftksuqmcc ]

imshow[52]  

   in [59]:
fig, ax = plt.subplots()

im = ax.imshow(z, cmap=matplotlib.cm.rdbu, vmin=abs(z).min(), vmax=abs(z).max(),
 extent=[0, 1, 0, 1])
im.set_interpolation('bilinear')

cb = fig.colorbar(im, ax=ax)

   [ysfmpoyk6maaaaaasuvork5cyii= ]

contour[53]  

   in [60]:
fig, ax = plt.subplots()

cnt = ax.contour(z, cmap=matplotlib.cm.rdbu, vmin=abs(z).min(), vmax=abs(z).max(
), extent=[0, 1, 0, 1])

   [vfo57190p9oaaaaasuvork5cyii= ]

3d figures[54]  

   to use 3d graphics in matplotlib, we first need to create an instance
   of the axes3d class. 3d axes can be added to a matplotlib figure canvas
   in exactly the same way as 2d axes; or, more conveniently, by passing a
   projection='3d' keyword argument to the add_axes or add_subplot
   methods.
   in [61]:
from mpl_toolkits.mplot3d.axes3d import axes3d

surface plots[55]  

   in [62]:
fig = plt.figure(figsize=(14,6))

# `ax` is a 3d-aware axis instance because of the projection='3d' keyword argume
nt to add_subplot
ax = fig.add_subplot(1, 2, 1, projection='3d')

p = ax.plot_surface(x, y, z, rstride=4, cstride=4, linewidth=0)

# surface_plot with color grading and color bar
ax = fig.add_subplot(1, 2, 2, projection='3d')
p = ax.plot_surface(x, y, z, rstride=1, cstride=1, cmap=matplotlib.cm.coolwarm,
linewidth=0, antialiased=false)
cb = fig.colorbar(p, shrink=0.5)

   [4lnojubqgghhbbc7bst
   dbbcid35eegknqbgghbbccchetlexqaghhbbcij36f8yah2uy6psqaaaaaelftksuqmcc ]

wire-frame plot[56]  

   in [63]:
fig = plt.figure(figsize=(8,6))

ax = fig.add_subplot(1, 1, 1, projection='3d')

p = ax.plot_wireframe(x, y, z, rstride=4, cstride=4)

   [b2np0va4tuuuaaaaaelftksuqmcc ]

coutour plots with projections[57]  

   in [64]:
fig = plt.figure(figsize=(8,6))

ax = fig.add_subplot(1,1,1, projection='3d')

ax.plot_surface(x, y, z, rstride=4, cstride=4, alpha=0.25)
cset = ax.contour(x, y, z, zdir='z', offset=-np.pi, cmap=matplotlib.cm.coolwarm)
cset = ax.contour(x, y, z, zdir='x', offset=-np.pi, cmap=matplotlib.cm.coolwarm)
cset = ax.contour(x, y, z, zdir='y', offset=3*np.pi, cmap=matplotlib.cm.coolwarm
)

ax.set_xlim3d(-np.pi, 2*np.pi);
ax.set_ylim3d(0, 3*np.pi);
ax.set_zlim3d(-np.pi, 2*np.pi);

   [j9nrp08nrs1igaaaabjru5erkjggg== ]

change the view angle[58]  

   we can change the perspective of a 3d plot using the view_init method,
   which takes two arguments: elevation and azimuth angle (in degrees):
   in [65]:
fig = plt.figure(figsize=(12,6))

ax = fig.add_subplot(1,2,1, projection='3d')
ax.plot_surface(x, y, z, rstride=4, cstride=4, alpha=0.25)
ax.view_init(30, 45)

ax = fig.add_subplot(1,2,2, projection='3d')
ax.plot_surface(x, y, z, rstride=4, cstride=4, alpha=0.25)
ax.view_init(70, 30)

fig.tight_layout()

   [w9usalhw5xk0aaaaabjru5erkjggg== ]

animations[59]  

   matplotlib also includes a simple api for generating animations for
   sequences of figures. with the funcanimation function we can generate a
   movie file from sequences of figures. the function takes the following
   arguments: fig, a figure canvas, func, a function that we provide which
   updates the figure, init_func, a function we provide to setup the
   figure, frame, the number of frames to generate, and blit, which tells
   the animation function to only update parts of the frame which have
   changed (for smoother animations):
def init():
    # setup figure

def update(frame_counter):
    # update figure for new frame

anim = animation.funcanimation(fig, update, init_func=init, frames=200, blit=tru
e)

anim.save('animation.mp4', fps=30) # fps = frames per second


   to use the animation features in matplotlib we first need to import the
   module matplotlib.animation:
   in [66]:
from matplotlib import animation

   in [67]:
# solve the ode problem of the double compound pendulum again

from scipy.integrate import odeint
from numpy import cos, sin

g = 9.82; l = 0.5; m = 0.1

def dx(x, t):
    x1, x2, x3, x4 = x[0], x[1], x[2], x[3]

    dx1 = 6.0/(m*l**2) * (2 * x3 - 3 * cos(x1-x2) * x4)/(16 - 9 * cos(x1-x2)**2)
    dx2 = 6.0/(m*l**2) * (8 * x4 - 3 * cos(x1-x2) * x3)/(16 - 9 * cos(x1-x2)**2)
    dx3 = -0.5 * m * l**2 * ( dx1 * dx2 * sin(x1-x2) + 3 * (g/l) * sin(x1))
    dx4 = -0.5 * m * l**2 * (-dx1 * dx2 * sin(x1-x2) + (g/l) * sin(x2))
    return [dx1, dx2, dx3, dx4]

x0 = [np.pi/2, np.pi/2, 0, 0]  # initial state
t = np.linspace(0, 10, 250) # time coordinates
x = odeint(dx, x0, t)    # solve the ode problem

   generate an animation that shows the positions of the pendulums as a
   function of time:
   in [68]:
fig, ax = plt.subplots(figsize=(5,5))

ax.set_ylim([-1.5, 0.5])
ax.set_xlim([1, -1])

pendulum1, = ax.plot([], [], color="red", lw=2)
pendulum2, = ax.plot([], [], color="blue", lw=2)

def init():
    pendulum1.set_data([], [])
    pendulum2.set_data([], [])

def update(n):
    # n = frame counter
    # calculate the positions of the pendulums
    x1 = + l * sin(x[n, 0])
    y1 = - l * cos(x[n, 0])
    x2 = x1 + l * sin(x[n, 1])
    y2 = y1 - l * cos(x[n, 1])

    # update the line data
    pendulum1.set_data([0 ,x1], [0 ,y1])
    pendulum2.set_data([x1,x2], [y1,y2])

anim = animation.funcanimation(fig, update, init_func=init, frames=len(t), blit=
true)

# anim.save can be called in a few different ways, some which might or might not
 work
# on different platforms and with different versions of matplotlib and video enc
oders
#anim.save('animation.mp4', fps=20, extra_args=['-vcodec', 'libx264'], writer=an
imation.ffmpegwriter())
#anim.save('animation.mp4', fps=20, extra_args=['-vcodec', 'libx264'])
#anim.save('animation.mp4', fps=20, writer="ffmpeg", codec="libx264")
anim.save('animation.mp4', fps=20, writer="avconv", codec="libx264")

plt.close(fig)

   note: to generate the movie file we need to have either ffmpeg or
   avconv installed. install it on ubuntu using:
$ sudo apt-get install ffmpeg


   or (newer versions)
$ sudo apt-get install libav-tools


   on macosx, try:
$ sudo port install ffmpeg

   in [69]:
from ipython.display import html
video = open("animation.mp4", "rb").read()
video_encoded = video.encode("base64")
video_tag = '<video controls alt="test" src="data:video/x-m4v;base64,{0}">'.form
at(video_encoded)
html(video_tag)

   out[69]:

backends[60]  

   matplotlib has a number of "backends" which are responsible for
   rendering graphs. the different backends are able to generate graphics
   with different formats and display/event loops. there is a distinction
   between noninteractive backends (such as 'agg', 'svg', 'pdf', etc.)
   that are only used to generate image files (e.g. with the savefig
   function), and interactive backends (such as qt4agg, gtk, maxosx) that
   can display a gui window for interactively exploring figures.

   a list of available backends are:
   in [70]:
print(matplotlib.rcsetup.all_backends)

[u'gtk', u'gtkagg', u'gtkcairo', u'macosx', u'qt4agg', u'qt5agg', u'tkagg', u'wx
', u'wxagg', u'cocoaagg', u'gtk3cairo', u'gtk3agg', u'webagg', u'nbagg', u'agg',
 u'cairo', u'emf', u'gdk', u'pdf', u'pgf', u'ps', u'svg', u'template']

   the default backend, called agg, is based on a library for raster
   graphics which is great for generating raster formats like png.

   normally we don't need to bother with changing the default backend; but
   sometimes it can be useful to switch to, for example, pdf or gtkcairo
   (if you are using linux) to produce high-quality vector graphics
   instead of raster based graphics.

generating svg with the svg backend[61]  

   in [1]:
#
# restart the notebook: the matplotlib backend can only be selected before pylab
 is imported!
# (e.g. kernel > restart)
#
import matplotlib
matplotlib.use('svg')
import matplotlib.pylab as plt
import numpy
from ipython.display import image, svg

   in [2]:
#
# now we are using the svg backend to produce svg vector graphics
#
fig, ax = plt.subplots()
t = numpy.linspace(0, 10, 100)
ax.plot(t, numpy.cos(t)*numpy.sin(t))
plt.savefig("test.svg")

   in [3]:
#
# show the produced svg file.
#
svg(filename="test.svg")

   out[3]:

the ipython notebook inline backend[62]  

   when we use ipython notebook it is convenient to use a matplotlib
   backend that outputs the graphics embedded in the notebook file. to
   activate this backend, somewhere in the beginning on the notebook, we
   add:
%matplotlib inline


   it is also possible to activate inline matplotlib plotting with:
%pylab inline


   the difference is that %pylab inline imports a number of packages into
   the global address space (scipy, numpy), while %matplotlib inline only
   sets up inline plotting. in new notebooks created for ipython 1.0+, i
   would recommend using %matplotlib inline, since it is tidier and you
   have more control over which packages are imported and how. commonly,
   scipy and numpy are imported separately with:
import numpy as np
import scipy as sp
import matplotlib.pyplot as plt

   the inline backend has a number of configuration options that can be
   set by using the ipython magic command %config to update settings in
   inlinebackend. for example, we can switch to svg figures or higher
   resolution figures with either:
%config inlinebackend.figure_format='svg'


   or:
%config inlinebackend.figure_format='retina'


   for more information, type:
%config inlinebackend

   in [1]:
%matplotlib inline
%config inlinebackend.figure_format='svg'

import matplotlib.pylab as plt
import numpy

   in [2]:
#
# now we are using the svg vector graphics displaced inline in the notebook
#
fig, ax = plt.subplots()
t = numpy.linspace(0, 10, 100)
ax.plot(t, numpy.cos(t)*numpy.sin(t))
plt.savefig("test.svg")

interactive backend (this makes more sense in a python script file)[63]  

   in [1]:
#
# restart the notebook: the matplotlib backend can only be selected before pylab
 is imported!
# (e.g. kernel > restart)
#
import matplotlib
matplotlib.use('qt4agg') # or for example macosx
import matplotlib.pylab as plt
import numpy as np

   in [ ]:
# now, open an interactive plot window with the qt4agg backend
fig, ax = plt.subplots()
t = np.linspace(0, 10, 100)
ax.plot(t, np.cos(t) * np.sin(t))
plt.show()

   note that when we use an interactive backend, we must call plt.show()
   to make the figure appear on the screen.

further reading[64]  

     * [65]http://www.matplotlib.org - the project web page for
       matplotlib.
     * [66]https://github.com/matplotlib/matplotlib - the source code for
       matplotlib.
     * [67]http://matplotlib.org/gallery.html - a large gallery
       showcaseing various types of plots matplotlib can create. highly
       recommended!
     * [68]http://www.loria.fr/~rougier/teaching/matplotlib - a good
       matplotlib tutorial.
     * [69]http://scipy-lectures.github.io/matplotlib/matplotlib.html -
       another good matplotlib reference.

versions[70]  

   in [1]:
%reload_ext version_information
%version_information numpy, scipy, matplotlib

   out[1]:
    software                      version
   python     2.7.10 64bit [gcc 4.2.1 (apple inc. build 5577)]
   ipython    3.2.1
   os         darwin 14.1.0 x86_64 i386 64bit
   numpy      1.9.2
   scipy      0.16.0
   matplotlib 1.4.3
   sat aug 15 11:30:23 2015 jst

   this website does not host notebooks, it only renders notebooks
   available on other websites.

   delivered by [71]fastly, rendered by [72]rackspace

   nbviewer github [73]repository.

   nbviewer version: [74]33c4683

   nbconvert version: [75]5.4.0

   rendered (fri, 05 apr 2019 17:49:25 utc)

references

   1. https://nbviewer.jupyter.org/
   2. http://jupyter.org/
   3. https://nbviewer.jupyter.org/faq
   4. https://nbviewer.jupyter.org/format/script/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb
   5. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb
   6. https://github.com/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb
   7. https://mybinder.org/v2/gh/jrjohansson/scientific-python-lectures/master?filepath=lecture-4-matplotlib.ipynb
   8. https://raw.githubusercontent.com/jrjohansson/scientific-python-lectures/master/lecture-4-matplotlib.ipynb
   9. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/tree/master
  10. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/tree/master/lecture-4-matplotlib.ipynb
  11. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#matplotlib---2d-and-3d-plotting-in-python
  12. http://ipython.org/notebook.html
  13. http://github.com/jrjohansson/scientific-python-lectures
  14. http://jrjohansson.github.io/
  15. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#introduction
  16. http://matplotlib.org/
  17. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#matlab-like-api
  18. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#example
  19. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#the-matplotlib-object-oriented-api
  20. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#figure-size,-aspect-ratio-and-dpi
  21. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#saving-figures
  22. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#what-formats-are-available-and-which-ones-should-be-used-for-best-quality?
  23. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#legends,-labels-and-titles
  24. http://matplotlib.org/users/legend_guide.html#legend-location
  25. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#formatting-text:-latex,-fontsize,-font-family
  26. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#setting-colors,-linewidths,-linetypes
  27. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#colors
  28. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#line-and-marker-styles
  29. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#control-over-axis-appearance
  30. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#plot-range
  31. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#logarithmic-scale
  32. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#placement-of-ticks-and-custom-tick-labels
  33. http://matplotlib.org/api/ticker_api.html
  34. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#scientific-notation
  35. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#axis-number-and-axis-label-spacing
  36. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#axis-position-adjustments
  37. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#axis-grid
  38. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#axis-spines
  39. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#twin-axes
  40. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#axes-where-x-and-y-is-zero
  41. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#other-2d-plot-styles
  42. http://matplotlib.org/gallery.html
  43. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#text-annotation
  44. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#figures-with-multiple-subplots-and-insets
  45. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#subplots
  46. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#subplot2grid
  47. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#gridspec
  48. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#add_axes
  49. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#colormap-and-contour-figures
  50. http://www.scipy.org/cookbook/matplotlib/show_colormaps
  51. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#pcolor
  52. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#imshow
  53. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#contour
  54. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#3d-figures
  55. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#surface-plots
  56. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#wire-frame-plot
  57. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#coutour-plots-with-projections
  58. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#change-the-view-angle
  59. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#animations
  60. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#backends
  61. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#generating-svg-with-the-svg-backend
  62. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#the-ipython-notebook-inline-backend
  63. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#interactive-backend-(this-makes-more-sense-in-a-python-script-file)
  64. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#further-reading
  65. http://www.matplotlib.org/
  66. https://github.com/matplotlib/matplotlib
  67. http://matplotlib.org/gallery.html
  68. http://www.loria.fr/~rougier/teaching/matplotlib
  69. http://scipy-lectures.github.io/matplotlib/matplotlib.html
  70. https://nbviewer.jupyter.org/github/jrjohansson/scientific-python-lectures/blob/master/lecture-4-matplotlib.ipynb#versions
  71. http://www.fastly.com/
  72. https://developer.rackspace.com/?nbviewer=awesome
  73. https://github.com/jupyter/nbviewer
  74. https://github.com/jupyter/nbviewer/commit/33c4683164d5ee4c92dbcd53afac7f13ef033c54
  75. https://github.com/jupyter/nbconvert/releases/tag/5.4.0
