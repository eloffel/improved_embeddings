   #[1]publisher [2]medium [3]alternate

   [4]homepage
   [5]homepage
   [6]sign in[7]get started

   [8]towards data science
     * [9]data science
     * [10]machine learning
     * [11]programming
     * [12]visualization
     * [13]ai
     * [14]data journalism
     * [15]contribute
     __________________________________________________________________

keras tutorial: deep learning in python

   [16]go to the profile of karlijn willems
   [17]karlijn willems (button) blockedunblock (button) followfollowing
   may 5, 2017

   originally published at
   [18]https://www.datacamp.com/community/tutorials/deep-learning-python

   by now, you might already know machine learning, a branch in computer
   science that studies the design of algorithms that can learn. today,
   you   re going to focus on deep learning, a subfield of machine learning
   that is a set of algorithms that is inspired by the structure and
   function of the brain. these algorithms are usually called artificial
   neural networks (ann). deep learning is one of the hottest fields in
   data science with many case studies with marvelous results in robotics,
   image recognition and artificial intelligence (ai).

   some of the success stories that you might already know are
   self-driving cars, automatic game play (think of [19]alphago, which
   plays the board game go), handwriting generation,   

   one of the most powerful and easy-to-use python libraries for
   developing and evaluating deep learning models is keras; it wraps the
   efficient numerical computation libraries theano and tensorflow. the
   advantage of this is mainly that you can get started with neural
   networks in an easy and fun way.

   today   s keras tutorial for beginners will introduce you to the basics
   of python deep learning: step-by-step, the tutorial will show you how
   to use python and its libraries to explore your data, to build up
   multi-layer id88s for classification and regression tasks, to
   compile and fit the data to these models, to predict target values and
   to validate the models that you have built.

   would you like to take a course on keras and deep learning in python?
   consider taking datacamp   s [20]deep learning in python course!

   also, don   t miss our [21]keras cheat sheet, which shows you the six
   steps that you need to go through to build neural networks in python
   with code examples!

   before going deeper into keras and how you can use it to get started
   with deep learning in python, you should probably know a thing or two
   about neural networks. as you briefly read in the previous section,
   neural networks found their inspiration and biology, where the term
      neural network    can also be used for neurons. the human brain is then
   an example of such a neural network, which is composed of a number of
   neurons.

   and, as you all know, the brain is capable of performing quite complex
   computations and this is where the inspiration for artificial neural
   networks comes from. the network a whole is a powerful modeling tool.

   the most simple neural network is the    id88   , which, in its
   simplest form, consists of a single neuron. much like biological
   neurons, which have dendrites and axons, the single artificial neuron
   is a simple tree structure which has input nodes and a single output
   node, which is connected to each input node. here   s a visual comparison
   of the two:
   [0*gceutyiowo2pv5xg.png]

   as you can see from the picture, there are six components to artificial
   neurons. from left to right, these are:
    1. input nodes. as it so happens, each input node is associated with a
       numerical value, which can be any real number. remember that real
       numbers make up the full spectrum of numbers: they can be positive
       or negative, whole or decimal numbers.
    2. connections. similarly, each connection that departs from the input
       node has a weight associated with it and this can also be any real
       number.
    3. next, all the values of the input nodes and weights of the
       connections are brought together: they are used as inputs for a
       weighted sum: y = f(sum_{i=1}^{d} w_i*x_i)), or, stated
       differently, y = f(w_1*x_1 + w_2*x_2 +     w_d*x_d).
    4. this result will be the input for a transfer or activation
       function. in the simplest but trivial case, this transfer function
       would be an identity function, f(x)=x or, stated differently, y=x.
       in this case, \(x\) is the weighted sum of the input nodes and the
       connections. however, just like a biological neuron only fires when
       a certain treshold is exceeded, the artificial neuron will also
       only fire when the sum of the inputs exceeds a treshold, let   s say
       for example 0. this is something that you can   t find back in an
       identity function! the most intuitive way that one can think of is
       by devising a system like the following: f(x) = 0 if x<0; f(x) =
       0.5 if x=0; f(x) = 1 if x>0.
    5. of course, you can already imagine that the output is not going to
       be a smooth line: it will be a discontinuous function. because this
       can cause problems in the mathematical processing, acontinuous
       variant, the sigmoid function, is often used. an example of a
       sigmoid function that you might already know is the logistic
       function. using this function results in a much smoother result!
    6. as a result, you have the output node, which is associated with the
       function (such as the sigmoid function) of the weighted sum of the
       input nodes. note that the sigmoid function is a mathematical
       function that results in an    s    shaped curve; you   ll read more
       about this later.
    7. lastly, the id88 may be an additional parameter, called a
       bias, which you can actually consider as the weight associated with
       an additional input node that is permanently set to 1. the bias
       value is important because it allows you to shift the activation
       function to the left or right, which can make a determine the
       success of your learning.

   note that the logical consequence of this model is that id88s
   only work with numerical data. this implies that you should convert any
   nominal data into a numerical format.

   now that you know that id88s work with tresholds, the step to
   using them for classification purproses isn   t that far off: the
   id88 can agree that any output above a certain treshold indicates
   that an instance belongs to one class, while an output below the
   treshold might result in the input being a member of the other class.
   the straight line where the output equals the treshold is then the
   boundary between the two classes.
   [0*8fmbmwhzfngmcjxs.png]

   networks of id88s are multi-layer id88s, and this is what
   this tutorial will implement in python with the help of keras!
   multi-layer id88s are also known as    feed-forward neural
   networks   . as you sort of guessed it by now, these are more complex
   networks than the id88, as they consist of multiple neurons that
   are organized in layers. the number of layers is usually limited to two
   or three, but theoretically, there is no limit!

   the layers act very much like the biological neurons that you have read
   about above: the outputs of one layer serve as the inputs for the next
   layer.

   among the layers, you can distinguish an input layer, hidden layers and
   an output layer. multi-layer id88s are often fully connected.
   this means that there   s a connection from each id88 in a certain
   layer to each id88 in the next layer. even though the
   connectedness is no requirement, this is typically the case.

   note that while the id88 could only represent linear separations
   between classes, the multi-layer id88 overcomes that limitation
   and can also represent more complex decision boundaries.

   for this tutorial, you   ll use the wine quality data set that you can
   find in the wine quality data set from the uci machine learning
   repository. ideally, you perform deep learning on bigger data sets but
   for the purpose of this tutorial, you will make use of a smaller one.
   this is mainly because the goal is to get you started with the library
   and to familiarize yourself with how neural networks work.

   you might already know this data set, as it   s one of the most popular
   data sets to get started on learning how to work out machine learning
   problems. in this case, it will serve for you to get started with deep
   learning in python with keras.

   let   s get started now!

   however, before you start loading in the data, it might be a good idea
   to check how much you really know about wine (in relation with the
   dataset, of course). most of you will know that there are, in general,
   two very popular types of wine: red and white.

   (i   m sure that there are many others, but for simplicity and because of
   my limited knowledge of wines, i   ll keep it at this. i   m sorry if i   m
   disappointing the true connoisseurs among you :)).

   knowing this is already one thing but if you want to analyze this data,
   you will need to know just a little bit more.

   first, check out the data description folder to see which variables
   have been included. this is usually the first step to understanding
   your data. go to [22]this page to check out the description or keep on
   reading to get to know your data a little bit better.

   the data consists of two datasets that are related to red and white
   variants of the portuguese    vinho verde    wine. as stated in the
   description, you   ll only find physicochecmical and sensory variables
   included in this data set. the data description file just list the 12
   variables that are included in the data, but for those who, like me,
   aren   t really chemistry experts either, here   s a short description of
   each variable:
    1. fixed acidity: acids are major wine properties and contribute
       greatly to the wine   s taste. usually, the total acidity is divided
       into two groups: the volatile acids and the nonvolatile or fixed
       acids. among the fixed acids that you can find in wines are the
       following: tartaric, malic, citric, and succinic. this variable is
       expressed in g(tartaric acid)/dm   in the data sets.
    2. volatile acidity: the volatile acidity is basically the process of
       wine turning into vinegar. in the u.s, the legal limits of volatile
       acidity are 1.2 g/l for red table wine and 1.1 g/l for white table
       wine. in these data sets, the volatile acidity is expressed in
       g(acetic acid)/dm  .
    3. citric acid is one of the fixed acids that you   ll find in wines.
       it   s expressed in g/dm   in the two data sets.
    4. residual sugar typically refers to the sugar remaining after
       fermentation stops, or is stopped. it   s expressed in g/dm   in the
       red and white data.
    5. chlorides can be a major contributor to saltiness in wine. here,
       you   ll see that it   s expressed in g(sodium chloride)/dm  .
    6. free sulfur dioxide: the part of the sulphur dioxide that is added
       to a wine and that is lost into it is said to be bound, while the
       active part is said to be free. winemaker will always try to get
       the highest proportion of free sulphur to bind. this variables is
       expressed in mg/dm   in the data.
    7. total sulfur dioxide is the sum of the bound and the free sulfur
       dioxide (so2). here, it   s expressed in mg/dm  . there are legal
       limits for sulfur levels in wines: in the eu, red wines can only
       have 160mg/l, while white and rose wines can have about 210mg/l.
       sweet wines are allowed to have 400mg/l. for the us, the legal
       limits are set at 350mg/l and for australia, this is 250mg/l.
    8. density is generally used as a measure of the conversion of sugar
       to alcohol. here, it   s expressed in g/cm  .
    9. ph or the potential of hydrogen is a numeric scale to specify the
       acidity or basicity the wine. as you might know, solutions with a
       ph less than 7 are acidic, while solutions with a ph greater than 7
       are basic. with a ph of 7, pure water is neutral. most wines have a
       ph between 2.9 and 3.9 and are therefore acidic.
   10. sulphates are to wine as gluten is to food. you might already know
       sulphites from the headaches that they can cause. they are a
       regular part of the winemaking around the world and are considered
       necessary. in this case, they are expressed in g(potassium
       sulphate)/dm  .
   11. alcohol: wine is an alcoholic beverage and as you know, the
       percentage of alcohol can vary from wine to wine. it shouldn   t
       surprised that this variable is included in the data sets, where
       it   s expressed in % vol.
   12. quality: wine experts graded the wine quality between 0 (very bad)
       and 10 (very excellent). the eventual number is the median of at
       least three evaluations made by those same wine experts.

   this all, of course, is some very basic information that you might need
   to know to get started. if you   re a true wine connoisseur, you probably
   know all of this and more!

   now, tt   s time to get your data!

   this can be easily done with the python data manipulation library
   pandas. you follow the import convention and import the package under
   it   s alias, pd.

   next, you make use of the read_csv() function to read in the csv files
   in which the data is stored. additionally, use the sep argument to
   specify that the separator in this case is a semicolon and not a
   regular comma.

   you can try it out in [23]this datacamp light chunk.

   awesome! that wasn   t a piece of cake, wasn   t it?

   you have probably done this a million times by now, but it   s always an
   essential step to get started. now you   re completely set to start
   exploring, manipulating and modeling your data!

   with the data at hand, it   s easy for you to learn more about these
   wines! one of the first things that you   ll probably want to do is to
   start off with getting a quick view on both of your dataframes in
   [24]this exercise.

   now is the time to check whether your import was successful: double
   check whether the data contains all the variables that the data
   description file of the uci machine learning repository promised you.
   besides the number of variables, also check the quality of the import:
   are the data types correct? did all the rows come through? are there
   any null values that you should take into account when you   re cleaning
   up the data?

   you might also want to check out your data with more than just info() .
   you can do that in [25]this exercise.

   a brief recap of all these pandas functions: you see that head(),
   tail() and sample() are awesome because they provide you with a quick
   way of inspecting your data without any hassle.

   next, describe() offers some summary statistics about your data that
   can help you to assess your data quality. you see that some of the
   variables really have a lot of difference in their min and max values.
   this is something that you   ll deal with later, but at this point, it   s
   just very important to be aware of this.

   lastly, you have double checked the presence of null values in red with
   the help of isnull(). this is a function that always can come in handy
   when you   re still in doubt after having read the results of info().

   tip: also check out whether the wine data contains null values. you can
   do this by using the ipython shell of the datacamp light chunk which
   you see right above.

   now that you have already inspected your data to see if the import was
   successful and correct, it   s time to dig a little bit deeper.

   one way to do this is by looking at the distribution of some of the
   dataset   s variables and make scatter plots to see possible
   correlations. of course, you can take this all to a much higher level
   if you would use this data for your own project.

   one variable that you could find interesting at first sight is alcohol.
   it   s probably one of the first things that catches your attention when
   you   re inspecting a wine data set. you can visualize the distributions
   with any data visualization library, but in this case, the tutorial
   makes use of matplotlib to quickly plot the distributions. you can find
   the code [26]here.

   as you can see in the image below, you see that the alcohol levels
   between the red and white wine are mostly the same: they have around 9%
   of alcohol. of course, there are also a considerable amount of
   observations that have 10% or 11% of alcohol percentage.
   [0*ofal0csppx1vfckp.png]

   note that you can double check this if you use the histogram() function
   from the numpy package to compute the histogram of the white and red
   data. you can find the code [27]here.

   if you   re interested in matplotlib tutorials, make sure to check out
   datacamp   s [28]matplotlib tutorial for beginners and [29]viewing 3d
   volumetric data tutorial, which shows you how to make use of
   matplotlib   s event handler api.

   next, one thing that interests me is the relation between the sulphates
   and the quality of the wine. as you have read above, sulphates can
   cause people to have headaches and i   m wondering if this infuences the
   quality of the wine. what   s more, i often hear that women especially
   don   t want to drink wine exactly because it causes headaches. maybe
   this affects the ratings for the red wine?

   let   s take a look: you can find the code [30]here.

   as you can see in the image below, the red wine seems to contain more
   sulphates than the white wine, which has less sulphates above 1 g/dm  .
   for the white wine, there only seem to be a couple of exceptions that
   fall just above 1 g/\(dm  \), while this is definitely more for the red
   wines. this could maybe explain the general saying that red wine causes
   headaches, but what about the quality?

   you can clearly see that there is white wine with a relatively low
   amount of sulphates that gets a score of 9, but for the rest it   s
   difficult to interpret the data correctly at this point.

   of course, you need to take into account that the difference in
   observations could also affect the graphs and how you might interpret
   them.
   [0*6yrxr5vxsee1gsqh.png]

   apart from the sulphates, the acidity is one of the major and important
   wine characteristics that is necessary to achieve quality wines. great
   wines often balance out acidity, tannin, alcohol and sweetness. some
   more research taught me that in quantities of 0.2 to 0.4 g/l, volatile
   acidity doesn   t affect a wine   s quality. at higher levels, however,
   volatile acidity can give wine a sharp, vinegary tactile sensation.
   extreme volatile acidity signifies a seriously flawed wine.

   let   s put the data to the test and make a scatter plot that plots the
   alcohol versus the volatile acidity. the data points should be colored
   according to their rating or quality label. you can find the code and
   the exercise [31]here.

   note that the colors in this image are randomly chosen with the help of
   the numpy random module. you can always change this by passing a list
   to the redcolors or whitecolors variables. make sure that they are the
   same (except for 1 because the white wine data has one unique quality
   value more than the red wine data), though, otherwise your legends are
   not going to match!

   check out the full graph here:
   [0*b7upmjpvgtz2yf_w.png]

   in the image above, you see that the levels that you have read about
   above especially hold for the white wine: most wines with label 8 have
   volatile acidity levels of 0.5 or below, but whether or not it has an
   effect on the quality is too difficult to say, since all the data
   points are very densely packed towards one side of the graph.

   this is just a quick data exploration. if you would be interested in
   elaborating this step in your own projects, consider datacamp   s data
   exploration posts, such as [32]python exploratory data analysis and
   [33]python data profiling tutorials, which will guide you through the
   basics of eda.

   this maybe was a lot to digest, so it   s never too late for a small
   recap of what you have seen during your eda that could be important for
   the further course of this tutorial:
     * some of the variables of your data sets have values that are
       considerably far apart. you can and will deal with this in the next
       section of the tutorial.
     * you have an ideal scenario: there are no null values in the data
       sets.
     * most wines that were included in the data set have around 9% of
       alcohol.
     * red wine seems to contain more sulphates than the white wine, which
       has less sulphates above 1 g/dm  .
     * you saw that most wines had a volatile acidity of 0.5 and below. at
       the moment, there is no direct relation to the quality of the wine.

   up until now, you have looked at the white wine and red wine data
   separately. the two seem to differ somewhat when you look at some of
   the variables from close up, and in other cases, the two seem to be
   very similar. do you think that there could there be a way to classify
   entries based on their variables into white or red wine?

   there is only one way to find out: preprocess the data and model it in
   such a way so that you can see what happens!

   now that you have explored your data, it   s time to act upon the
   insights that you have gained! let   s preprocess the data so that you
   can start building your own neural network!

   to see the code, go to [34]the original tutorial.

   you set ignore_index to true in this case because you don   t want to
   keep the index labels of white when you   re appending the data to red:
   you want the labels to continue from where they left off in red, not
   duplicate index labels from joining both data sets together.

   now that you have the full data set, it   s a good idea to also do a
   quick data exploration; you already know some stuff from looking at the
   two data sets separately, and now it   s time to gather some more solid
   insights, perhaps.

   since it can be somewhat difficult to interpret graphs, it   s also a
   good idea to plot a correlation matrix. this will give insights more
   quickly about which variables correlate. you can find the code
   [35]here.

   as you would expect, there are some variables that correlate, such as
   density and residual sugar. also volatile acidity and type are more
   closely connected than you originally could have guessed by looking at
   the two data sets separately, and it was kind of to be expected that
   free sulfur dioxide and total sulfur dioxide were going to correlate.
   [0*pa_c2a_xfrlngy09.png]

   very interesting!

   imbalanced data typically refers to a problem with classification
   problems where the classes are not represented equally.most
   classification data sets do not have exactly equal number of instances
   in each class, but a small difference often does not matter. you thus
   need to make sure that all two classes of wine are present in the
   training model. what   s more, the amount of instances of all two wine
   types needs to be more or less equal so that you do not favour one or
   the other class in your predictions.

   in this case, there seems to be an imbalance, but you will go with this
   for the moment. afterwards, you can evaluate the model and if it
   underperforms, you can resort to undersampling or oversampling to cover
   up the difference in observations.

   for now, import the train_test_split from sklearn.model_selection and
   assign the data and the target labels to the variables x and y. you   ll
   see that you need to flatten the array of target labels in order to be
   totally ready to use the x and y variables as input for the
   train_test_split() function. off to work, get started in [36]this
   datacamp light chunk.

   you   re already well on your way to build your first neural network, but
   there is still one thing that you need to take care of! do you still
   know what you discovered when you were looking at the summaries of the
   white and red data sets?

   indeed, some of the values were kind of far apart. it might make sense
   to do some standardization here.

   standardization is a way to deal with these values that lie so far
   apart. the scikit-learn package offers you a great and quick way of
   getting your data standardized: import the standardscaler module from
   sklearn.preprocessing and you   re ready to scale your train and test
   data!
# import `standardscaler` from `sklearn.preprocessing`
from sklearn.preprocessing import standardscaler
# define the scaler
scaler = standardscaler().fit(x_train)
# scale the train set
x_train = scaler.transform(x_train)
# scale the test set
x_test = scaler.transform(x_test)

   now that you   re data is preprocessed, you can move on to the real work:
   building your own neural network to classify wines.

   before you start modelling, go back to your original question: can you
   predict whether a wine is red or white by looking at its chemical
   properties, such as volatile acidity or sulphates?

   since you only have two classes, namely white and red, you   re going to
   do a binary classification. as you can imagine,    binary    means 0 or 1,
   yes or no. since neural networks can only work with numerical data, you
   have already encoded red as 1 and white as 0.

   a type of network that performs well on such a problem is a multi-layer
   id88. as you have read in the beginning of this tutorial, this
   type of neural network is often fully connected. that means that you   re
   looking to build a fairly simple stack of fully-connected layers to
   solve this problem. as for the activation function that you will use,
   it   s best to use one of the most common ones here for the purpose of
   getting familiar with keras and neural networks, which is the relu
   activation function.

   now how do you start building your multi-layer id88? a quick way
   to get started is to use the keras sequential model: it   s a linear
   stack of layers. you can easily create the model by passing a list of
   layer instances to the constructor, which you set up by running model =
   sequential().

   next, it   s best to think back about the structure of the multi-layer
   id88 as you might have read about it in the beginning of this
   tutorial: you have an input layer, some hidden layers and an output
   layer. when you   re making your model, it   s therefore important to take
   into account that your first layer needs to make the input shape clear.
   the model needs to know what input shape to expect and that   s why
   you   ll always find the input_shape, input_dim, input_length, or
   batch_size arguments in the documentation of the layers and in
   practical examples of those layers.

   in this case, you will have to use a dense layer, which is a fully
   connected layer. dense layers implement the following operation: output
   = activation(dot(input, kernel) + bias). note that without the
   activation function, your dense layer would consist only of two linear
   operations: a dot product and an addition.

   in the first layer, the activation argument takes the value relu. next,
   you also see that the input_shape has been defined. this is the input
   of the operation that you have just seen: the model takes as input
   arrays of shape (12,), or (*, 12). lastly, you see that the first layer
   has 12 as a first value for the units argument of dense(), which is the
   dimensionality of the output space and which are actually 12 hidden
   units. this means that the model will output arrays of shape (*, 12):
   this is is the dimensionality of the output space. don   t worry if you
   don   t get this entirely just now, you   ll read more about it later on!

   the units actually represents the kernel of the above formula or the
   weights matrix, composed of all weights given to all input nodes,
   created by the layer. note that you don   t include any bias in the
   example below, as you haven   t included the use_bias argument and set it
   to true, which is also a possibility.

   the intermediate layer also uses the relu activation function. the
   output of this layer will be arrays of shape (*,8).

   you are ending the network with a dense layer of size 1. the final
   layer will also use a sigmoid activation function so that your output
   is actually a id203; this means that this will result in a score
   between 0 and 1, indicating how likely the sample is to have the target
      1   , or how likely the wine is to be red.

   you can find the code and exercise [37]here.

   all in all, you see that there are two key architecture decisions that
   you need to make to make your model: how many layers you   re going to
   use and how many    hidden units    you will chose for each layer.

   in this case, you picked 12 hidden units for the first layer of your
   model: as you read above, this is is the dimensionality of the output
   space. in other words, you   re setting the amount of freedom that you   re
   allowing the network to have when it   s learning representations. if you
   would allow more hidden units, your network will be able to learn more
   complex representations but it will also be a more expensive operations
   that can be prone to overfitting.

   remember that overfitting occurs when the model is too complex: it will
   describe random error or noise and not the underlying relationship that
   it needs to describe. in other words, the training data is modelled too
   well!

   note that when you don   t have that much training data available, you
   should prefer to use a a small network with very few hidden layers
   (typically only one, like in the example above).

   if you want to get some information on the model that you have just
   created, you can use the attributed output_shape or the summary()
   function, among others. some of the most basic ones are listed below.

   try running them to see what results you exactly get back and what they
   tell you about the model that you have just created. go to the exercise
   [38]here.

   next, it   s time to compile your model and fit the model to the data:
   once again, make use of compile() and fit() to get this done.
model.compile(loss='binary_crossid178', optimizer='adam', metrics=['accuracy']
)
model.fit(x_train, y_train,epochs=20, batch_size=1, verbose=1)

   in compiling, you configure the model with the adam optimizer and the
   binary_crossid178 id168. additionally, you can also monitor
   the accuracy during the training by passing ['accuracy'] to the metrics
   argument.

   the optimizer and the loss are two arguments that are required if you
   want to compile the model. some of the most popular optimization
   algorithms used are the stochastic id119 (sgd), adam and
   rmsprop. depending on whichever algorithm you choose, you   ll need to
   tune certain parameters, such as learning rate or momentum. the choice
   for a id168 depends on the task that you have at hand: for
   example, for a regression problem, you   ll usually use the mean squared
   error (mse). as you see in this example, you used binary_crossid178
   for the binary classification problem of determining whether a wine is
   red or white. lastly, with multi-class classification, you   ll make use
   of categorical_crossid178.

   after, you can train the model for 20 epochs or iterations over all the
   samples in x_train and y_train, in batches of 1 sample. you can also
   specify the verbose argument. by setting it to 1, you indicate that you
   want to see progress bar logging.

   in other words, you have to train the model for a specified number of
   epochs or exposures to the training dataset. an epoch is a single pass
   through the entire training set, followed by testing of the
   verification set. the batch size that you specify in the code above
   defines the number of samples that going to be propagated through the
   network. also, by doing this, you optimize the efficiency because you
   make sure that you don   t load too many input patterns into memory at
   the same time.

   let   s put your model to use! you can make predictions for the labels of
   the test set with it. just use predict() and pass the test set to it to
   predict the labels for the data. in this case, the result is stored in
   y_pred:
y_pred = model.predict(x_test)

   before you go and evaluate your model, you can already get a quick idea
   of the accuracy by checking how y_pred and y_test compare:
y_pred[:5]
array([[0], [1], [0], [0], [0]], dtype=int32)
y_test[:5]
array([0, 1, 0, 0, 0])

   you see that these values seem to add up, but what is all of this
   without some hard numbers?

   now that you have built your model and used it to make predictions on
   data that your model hadn   t seen yet, it   s time to evaluate it   s
   performance. you can visually compare the predictions with the actual
   test labels (y_test), or you can use all types of metrics to determine
   the actual performance. in this case, you   ll use evaluate() to do this.
   pass in the test data and test labels and if you want, put the verbose
   argument to 1. you   ll see more logs appearing when you do this.
score = model.evaluate(x_test, y_test,verbose=1)
print(score)
[0.025217213829228164, 0.99487179487179489]

   the score is a list that holds the combination of the loss and the
   accuracy. in this case, you see that both seem very great, but in this
   case it   s good to remember that your data was somewhat imbalanced: you
   had more white wine than red wine observations. the accuracy might just
   be reflecting the class distribution of your data because it   ll just
   predict white because those observations are abundantly present!

   before you start re-arranging the data and putting it together in a
   different way, it   s always a good idea to try out different evaluation
   metrics. for this, you can rely on scikit-learn (which you import as
   sklearn, just like before when you were making the train and test sets)
   for this.

   in this case, you will test out some basic classification evaluation
   techniques, such as:
     * the confusion matrix, which is a breakdown of predictions into a
       table showing correct predictions and the types of incorrect
       predictions made. ideally, you will only see numbers in the
       diagonal, which means that all your predictions were correct!
     * precision is a measure of a classifier   s exactness. the higher the
       precision, the more accurate the classifier.
     * recall is a measure of a classifier   s completeness. the higher the
       recall, the more cases the classifier covers.
     * the f1 score or f-score is a weighted average of precision and
       recall.
     * the kappa or cohen   s kappa is the classification accuracy
       normalized by the imbalance of the classes in the data.

# import the modules from `sklearn.metrics`
from sklearn.metrics import confusion_matrix, precision_score, recall_score, f1_
score, cohen_kappa_score
# confusion matrix
confusion_matrix(y_test, y_pred)
array([[1585, 3], [ 8, 549]])
# precision
precision_score(y_test, y_pred)
0.994565217391
# recall
recall_score(y_test, y_pred)
0.98563734290843807
# f1 score
f1_score(y_test,y_pred)
0.99008115419296661
# cohen's kappa
cohen_kappa_score(y_test, y_pred)
0.98662321692498967

   all these scores are very good! you have made a pretty accurate model
   despite the fact that you have considerably more rows that are of the
   white wine type.

   good job!

   you   ve successfully built your first model, but you can go even further
   with this one. why not try out the following things and see what their
   effect is? like you read above, the two key architectural decisions
   that you need to make involve the layers and the hidden nodes. these
   are great starting points:
     * you used 1 hidden layers. try to use 2 or 3 hidden layers;
     * use layers with more hidden units or less hidden units;
     * take the quality column as the target labels and the rest of the
       data (including the encoded type column!) as your data. you now
       have a multi-class classification problem!

   but why also not try out changing the activation function? instead of
   relu, try using the tanh activation function and see what the result
   is!
   [0*w4amuzdl0ee6im7c.png]

   your classification model performed perfectly for a first run!

   but there is so much more that you can do besides going a level higher
   and trying out more complex structures than the multi-layer id88.
   why not try to make a neural network to predict the wine quality?

   in this case, the tutorial assumes that quality is a continuous
   variable: the task is then not a binary classification task but an
   ordinal regression task. it   s a type of regression that is used for
   predicting an ordinal variable: the quality value exists on an
   arbitrary scale where the relative ordering between the different
   quality values is significant. in this scale, the quality scale 0-10
   for    very bad    to    very good    is such an example.

   note that you could also view this type of problem as a classification
   problem and consider the quality labels as fixed class labels.

   to see how you can also use neural networks for a regression problem,
   go to [39]the original tutorial.

   this tutorial was just a start in your deep learning journey with
   python and keras. there is still a lot to cover, so why not take
   datacamp   s [40]deep learning in python course? in the meantime, also
   make sure to check out the [41]keras documentation, if you haven   t done
   so already. you   ll find more examples and information on all functions,
   arguments, more layers, etc    it   ll undoubtedly be an indispensable
   resource when you   re learning how to work with neural networks in
   python!
     __________________________________________________________________

   originally published at [42]www.datacamp.com.

     * [43]machine learning
     * [44]neural networks
     * [45]data science
     * [46]artificial intelligence
     * [47]towards data science

   (button)
   (button)
   (button) 174 claps
   (button) (button) (button) 1 (button) (button)

     (button) blockedunblock (button) followfollowing
   [48]go to the profile of karlijn willems

[49]karlijn willems

   data science journalist [50]@datacamp

     (button) follow
   [51]towards data science

[52]towards data science

   sharing concepts, ideas, and codes.

     * (button)
       (button) 174
     * (button)
     *
     *

   [53]towards data science
   never miss a story from towards data science, when you sign up for
   medium. [54]learn more
   never miss a story from towards data science
   (button) get updatesget updates

references

   visible links
   1. https://plus.google.com/103654360130207659246
   2. https://towardsdatascience.com/osd.xml
   3. android-app://com.medium.reader/https/medium.com/p/2caf497f8ca1
   4. https://medium.com/
   5. https://medium.com/
   6. https://medium.com/m/signin?redirect=https://towardsdatascience.com/keras-tutorial-deep-learning-in-python-2caf497f8ca1&source=--------------------------nav_reg&operation=login
   7. https://medium.com/m/signin?redirect=https://towardsdatascience.com/keras-tutorial-deep-learning-in-python-2caf497f8ca1&source=--------------------------nav_reg&operation=register
   8. https://towardsdatascience.com/?source=logo-lo_tejcxeoscw2i---7f60cf5620c9
   9. https://towardsdatascience.com/data-science/home
  10. https://towardsdatascience.com/machine-learning/home
  11. https://towardsdatascience.com/programming/home
  12. https://towardsdatascience.com/data-visualization/home
  13. https://towardsdatascience.com/artificial-intelligence/home
  14. https://towardsdatascience.com/data-journalism/home
  15. https://towardsdatascience.com/contribute/home
  16. https://towardsdatascience.com/@kacawi?source=post_header_lockup
  17. https://towardsdatascience.com/@kacawi
  18. https://www.datacamp.com/community/tutorials/deep-learning-python
  19. https://deepmind.com/research/alphago/
  20. https://www.datacamp.com/courses/deep-learning-in-python
  21. https://www.datacamp.com/community/blog/keras-cheat-sheet
  22. http://archive.ics.uci.edu/ml/machine-learning-databases/wine-quality/winequality.names
  23. https://www.datacamp.com/community/tutorials/deep-learning-python
  24. https://www.datacamp.com/community/tutorials/deep-learning-python
  25. https://www.datacamp.com/community/tutorials/deep-learning-python
  26. https://www.datacamp.com/community/tutorials/deep-learning-python
  27. https://www.datacamp.com/community/tutorials/deep-learning-python
  28. https://www.datacamp.com/community/tutorials/matplotlib-tutorial-python
  29. https://www.datacamp.com/community/tutorials/matplotlib-3d-volumetric-data
  30. https://www.datacamp.com/community/tutorials/deep-learning-python
  31. https://www.datacamp.com/community/tutorials/deep-learning-python
  32. https://www.datacamp.com/community/tutorials/exploratory-data-analysis-python
  33. https://www.datacamp.com/community/tutorials/python-data-profiling
  34. https://www.datacamp.com/community/tutorials/deep-learning-python
  35. https://www.datacamp.com/community/tutorials/deep-learning-python
  36. https://www.datacamp.com/community/tutorials/deep-learning-python
  37. https://www.datacamp.com/community/tutorials/deep-learning-python
  38. https://www.datacamp.com/community/tutorials/deep-learning-python
  39. https://www.datacamp.com/community/tutorials/deep-learning-python
  40. https://www.datacamp.com/courses/deep-learning-in-python
  41. https://keras.io/
  42. https://www.datacamp.com/community/tutorials/deep-learning-python
  43. https://towardsdatascience.com/tagged/machine-learning?source=post
  44. https://towardsdatascience.com/tagged/neural-networks?source=post
  45. https://towardsdatascience.com/tagged/data-science?source=post
  46. https://towardsdatascience.com/tagged/artificial-intelligence?source=post
  47. https://towardsdatascience.com/tagged/towards-data-science?source=post
  48. https://towardsdatascience.com/@kacawi?source=footer_card
  49. https://towardsdatascience.com/@kacawi
  50. http://twitter.com/datacamp
  51. https://towardsdatascience.com/?source=footer_card
  52. https://towardsdatascience.com/?source=footer_card
  53. https://towardsdatascience.com/
  54. https://medium.com/@medium/personalize-your-medium-experience-with-users-publications-tags-26a41ab1ee0c#.hx4zuv3mg

   hidden links:
  56. https://medium.com/p/2caf497f8ca1/share/twitter
  57. https://medium.com/p/2caf497f8ca1/share/facebook
  58. https://medium.com/p/2caf497f8ca1/share/twitter
  59. https://medium.com/p/2caf497f8ca1/share/facebook
