project 0: unix/python/autograder tutorial

                  version 1.001. last updated: 08/26/2014.
     __________________________________________________________________

table of contents

     * [1]introduction
     * [2]unix basics
     * [3]python basics
     * [4]autograding
     * [5]q1: addition
     * [6]q2: buylotsoffruit
     * [7]q3: shopsmart
     __________________________________________________________________

introduction

   the projects for this class assume you use python 2.7.

   project 0 will cover the following:
     * a mini-unix tutorial (particularly important if you work on
       instructional machines),
     * a mini-python tutorial,
     * project grading: every project's release includes its autograder
       for you to run yourself.

   files to edit and submit: you will fill in portions of addition.py,
   buylotsoffruit.py, and shopsmart.py in [8]tutorial.zip during the
   assignment. you should submit these files with your code and comments.
   please do not change the other files in this distribution or submit any
   of our original files other than these files.

   evaluation: your code will be autograded for technical correctness.
   please do not change the names of any provided functions or classes
   within the code, or you will wreak havoc on the autograder. however,
   the correctness of your implementation -- not the autograder's
   judgements -- will be the final judge of your score. if necessary, we
   will review and grade assignments individually to ensure that you
   receive due credit for your work.

   academic dishonesty: we will be checking your code against other
   submissions in the class for logical redundancy. if you copy someone
   else's code and submit it with minor changes, we will know. these cheat
   detectors are quite hard to fool, so please don't try. we trust you all
   to submit your own work only; please don't let us down. if you do, we
   will pursue the strongest consequences available to us.

   getting help: you are not alone! if you find yourself stuck on
   something, contact the course staff for help. office hours, section,
   and the discussion forum are there for your support; please use them.
   if you can't make our office hours, let us know and we will schedule
   more. we want these projects to be rewarding and instructional, not
   frustrating and demoralizing. but, we don't know when or how to help
   unless you ask.

   discussion: please be careful not to post spoilers.
     __________________________________________________________________

unix basics

   here are basic commands to navigate unix and edit files.

file/directory manipulation

   when you open a terminal window, you're placed at a command prompt:

   [cs188-ta@nova ~]$

   the prompt shows your username, the host you are logged onto, and your
   current location in the directory structure (your path). the tilde
   character is shorthand for your home directory. note your prompt may
   look slightly different. to make a directory, use the mkdir command.
   use cd to change to that directory:

   [cs188-ta@nova ~]$ mkdir foo
   [cs188-ta@nova ~]$ cd foo
   [cs188-ta@nova ~/foo]$

   use ls to see a listing of the contents of a directory, and touch to
   create an empty file:

   [cs188-ta@nova ~/foo]$ ls
   [cs188-ta@nova ~/foo]$ touch hello_world
   [cs188-ta@nova ~/foo]$ ls
   hello_world
   [cs188-ta@nova ~/foo]$ cd ..
   [cs188-ta@nova ~]$

   download [9]python_basics.zip into your home directory (note: the zip
   file's name may be slightly different when you download it). use unzip
   to extract the contents of the zip file:
   [cs188-ta@nova ~]$ ls *.zip
   python_basics.zip
   [cs188-ta@nova ~]$ unzip python_basics.zip
   [cs188-ta@nova ~]$ cd python_basics
   [cs188-ta@nova ~/python_basics]$ ls
   foreach.py
   helloworld.py
   listcomp.py
   listcomp2.py
   quicksort.py
   shop.py
   shoptest.py

   some other useful unix commands:
     * cp copies a file or files
     * rm removes (deletes) a file
     * mv moves a file (i.e., cut/paste instead of copy/paste)
     * man displays documentation for a command
     * pwd prints your current path
     * xterm opens a new terminal window
     * firefox opens a web browser
     * press "ctrl-c" to kill a running process
     * append & to a command to run it in the background
     * fg brings a program running in the background to the foreground

the emacs text editor

   emacs is a customizable text editor which has some nice features
   specifically tailored for programmers. however, you can use any other
   text editor that you may prefer (such as vi, pico, or joe on unix; or
   notepad on windows; or textwrangler on os x; and [10]many more).

   to run emacs, type emacs at a command prompt:

   [cs188-ta@nova ~/python_basics]$ emacs helloworld.py &
   [1] 3262

   here we gave the argument helloworld.py which will either open that
   file for editing if it exists, or create it otherwise. emacs notices
   that this is a python source file (because of the .py ending) and
   enters python-mode, which is supposed to help you write code. when
   editing this file you may notice some of that text becomes
   automatically colored: this is syntax highlighting to help you
   distinguish items such as keywords, variables, strings, and comments.
   pressing enter, tab, or backspace may cause the cursor to jump to weird
   locations: this is because python is very picky about indentation, and
   emacs is predicting the proper tabbing that you should use.

   some basic emacs editing commands (c- means "while holding the
   ctrl-key"):
     * c-x c-s save the current file
     * c-x c-f open a file, or create a new file it if doesn't exist
     * c-k cut a line, add it to the clipboard
     * c-y paste the contents of the clipboard
     * c-_ undo
     * c-g abort a half-entered command

   you can also copy and paste using just the mouse. using the left
   button, select a region of text to copy. click the middle button to
   paste.

   there are two ways you can use emacs to develop python code. the most
   straightforward way is to use it just as a text editor: create and edit
   python files in emacs; then run python to test the code somewhere else,
   like in a terminal window. alternatively, you can run python inside
   emacs: see the options under "python" in the menubar, or type c-c ! to
   start a python interpreter in a split screen. (use c-x o to switch
   between the split screens, or just click if c-x doesn't work).

   if you want to spend some extra setup time becoming a power user, you
   can try an ide like [11]eclipse (download the eclipse classic package
   at the bottom). check out [12]pydev for python support in eclipse.
     __________________________________________________________________

python basics

required files

   you can download all of the files associated with the python
   mini-tutorial as a zip archive: [13]python_basics.zip. if you did the
   unix tutorial in the previous tab, you've already downloaded and
   unzipped this file.

table of contents

     * [14]invoking the interpreter
     * [15]operators
     * [16]strings
     * [17]dir and help
     * [18]built-in data structures

     * [19]lists
     * [20]tuples
     * [21]sets
     * [22]dictionaries

     [23]writing scripts

     [24]indentation

     [25]tabs vs spaces

     [26]writing functions

     [27]object basics
     * [28]defining classes
     * [29]using objects
     * [30]static vs instance variables

     [31]tips and tricks

     [32]troubleshooting

     [33]more references

   the programming assignments in this course will be written in
   [34]python, an interpreted, object-oriented language that shares some
   features with both java and scheme. this tutorial will walk through the
   primary syntactic constructions in python, using short examples.

   we encourage you to type all python shown in the tutorial onto your own
   machine. make sure it responds the same way.

   you may find the [35]troubleshooting section helpful if you run into
   problems. it contains a list of the frequent problems previous cs188
   students have encountered when following this tutorial.

    invoking the interpreter

   python can be run in one of two modes. it can either be used
   interactively, via an interpeter, or it can be called from the command
   line to execute a script. we will first use the python interpreter
   interactively.

   you invoke the interpreter by entering python at the unix command
   prompt.
   note: you may have to type python2.4, python2.5, python2.6 or
   python2.7, rather than python, depending on your machine.

   [cs188-ta@nova ~]$ python
   python 2.6.5 (r265:79063, jan 14 2011, 14:20:15)
   [gcc 4.4.1] on sunos5
   type "help", "copyright", "credits" or "license" for more information.
   >>>

    operators

   the python interpreter can be used to evaluate expressions, for example
   simple arithmetic expressions. if you enter such expressions at the
   prompt (>>>) they will be evaluated and the result will be returned on
   the next line.

   >>> 1 + 1
   2
   >>> 2 * 3
   6

   boolean operators also exist in python to manipulate the primitive true
   and false values.

   >>> 1==0
   false
   >>> not (1==0)
   true
   >>> (2==2) and (2==3)
   false
   >>> (2==2) or (2==3)
   true

    strings

   like java, python has a built in string type. the + operator is
   overloaded to do string concatenation on string values.

   >>> 'artificial' + "intelligence"
   'artificialintelligence'

   there are many built-in methods which allow you to manipulate strings.

   >>> 'artificial'.upper()
   'artificial'
   >>> 'help'.lower()
   'help'
   >>> len('help')
   4

   notice that we can use either single quotes ' ' or double quotes " " to
   surround string. this allows for easy nesting of strings.

   we can also store expressions into variables.

   >>> s = 'hello world'
   >>> print s
   hello world
   >>> s.upper()
   'hello world'
   >>> len(s.upper())
   11
   >>> num = 8.0
   >>> num += 2.5
   >>> print num
   10.5

   in python, you do not have declare variables before you assign to them.

    exercise: dir and help

   learn about the methods python provides for strings. to see what
   methods python provides for a datatype, use the dir and help commands:

   >>> s = 'abc'
   >>> dir(s)
   ['__add__', '__class__', '__contains__', '__delattr__', '__doc__',
   '__eq__', '__ge__', '__getattribute__', '__getitem__',
   '__getnewargs__', '__getslice__', '__gt__', '__hash__',
   '__init__','__le__', '__len__', '__lt__', '__mod__', '__mul__',
   '__ne__', '__new__', '__reduce__', '__reduce_ex__','__repr__',
   '__rmod__', '__rmul__', '__setattr__', '__str__', 'capitalize',
   'center', 'count', 'decode', 'encode', 'endswith', 'expandtabs',
   'find', 'index', 'isalnum', 'isalpha', 'isdigit', 'islower', 'isspace',
   'istitle', 'isupper', 'join', 'ljust', 'lower', 'lstrip', 'replace',
   'rfind','rindex', 'rjust', 'rsplit', 'rstrip', 'split', 'splitlines',
   'startswith', 'strip', 'swapcase', 'title', 'translate', 'upper',
   'zfill']
   >>> help(s.find)
help on built-in function find:

find(...)
    s.find(sub [,start [,end]]) -> int

    return the lowest index in s where substring sub is found,
    such that sub is contained within s[start,end].  optional
    arguments start and end are interpreted as in slice notation.

    return -1 on failure.


   >> s.find('b')
   1

   try out some of the string functions listed in dir (ignore those with
   underscores '_' around the method name).

    built-in data structures

   python comes equipped with some useful built-in data structures,
   broadly similar to java's collections package.

    lists

   lists store a sequence of mutable items:

   >>> fruits = ['apple','orange','pear','banana']
   >>> fruits[0]
   'apple'

   we can use the + operator to do list concatenation:

   >>> otherfruits = ['kiwi','strawberry']
   >>> fruits + otherfruits
   >>> ['apple', 'orange', 'pear', 'banana', 'kiwi', 'strawberry']

   python also allows negative-indexing from the back of the list. for
   instance, fruits[-1] will access the last element 'banana':

   >>> fruits[-2]
   'pear'
   >>> fruits.pop()
   'banana'
   >>> fruits
   ['apple', 'orange', 'pear']
   >>> fruits.append('grapefruit')
   >>> fruits
   ['apple', 'orange', 'pear', 'grapefruit']
   >>> fruits[-1] = 'pineapple'
   >>> fruits
   ['apple', 'orange', 'pear', 'pineapple']

   we can also index multiple adjacent elements using the slice operator.
   for instance, fruits[1:3], returns a list containing the elements at
   position 1 and 2. in general fruits[start:stop] will get the elements
   in start, start+1, ..., stop-1. we can also do fruits[start:] which
   returns all elements starting from the start index. also fruits[:end]
   will return all elements before the element at position end:

   >>> fruits[0:2]
   ['apple', 'orange']
   >>> fruits[:3]
   ['apple', 'orange', 'pear']
   >>> fruits[2:]
   ['pear', 'pineapple']
   >>> len(fruits)
   4

   the items stored in lists can be any python data type. so for instance
   we can have lists of lists:

   >>> lstoflsts = [['a','b','c'],[1,2,3],['one','two','three']]
   >>> lstoflsts[1][2]
   3
   >>> lstoflsts[0].pop()
   'c'
   >>> lstoflsts
   [['a', 'b'],[1, 2, 3],['one', 'two', 'three']]

    exercise: lists

   play with some of the list functions. you can find the methods you can
   call on an object via the dir and get information about them via the
   help command:

   >>> dir(list)
   ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__',
   '__delslice__', '__doc__', '__eq__', '__ge__', '__getattribute__',
   '__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__',
   '__imul__',
   '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__',
   '__ne__',
   '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__',
   '__rmul__', '__setattr__', '__setitem__', '__setslice__', '__str__',
   'append', 'count', 'extend', 'index', 'insert', 'pop', 'remove',
   'reverse',
   'sort']
>>> help(list.reverse)
help on built-in function reverse:

reverse(...)
    l.reverse() -- reverse *in place*

   >>> lst = ['a','b','c']
   >>> lst.reverse()
   >>> ['c','b','a']

   note: ignore functions with underscores "_" around the names; these are
   private helper methods. press 'q' to back out of a help screen.

    tuples

   a data structure similar to the list is the tuple, which is like a list
   except that it is immutable once it is created (i.e. you cannot change
   its content once created). note that tuples are surrounded with
   parentheses while lists have square brackets.

   >>> pair = (3,5)
   >>> pair[0]
   3
   >>> x,y = pair
   >>> x
   3
   >>> y
   5
   >>> pair[1] = 6
   typeerror: object does not support item assignment

   the attempt to modify an immutable structure raised an exception.
   exceptions indicate errors: index out of bounds errors, type errors,
   and so on will all report exceptions in this way.

    sets

   a set is another data structure that serves as an unordered list with
   no duplicate items. below, we show how to create a set, add things to
   the set, test if an item is in the set, and perform common set
   operations (difference, intersection, union):

   >>> shapes = ['circle','square','triangle','circle']
   >>> setofshapes = set(shapes)
   >>> setofshapes
   set(['circle','square','triangle'])
   >>> setofshapes.add('polygon')
   >>> setofshapes
   set(['circle','square','triangle','polygon'])
   >>> 'circle' in setofshapes
   true
   >>> 'rhombus' in setofshapes
   false
   >>> favoriteshapes = ['circle','triangle','hexagon']
   >>> setoffavoriteshapes = set(favoriteshapes)
   >>> setofshapes - setoffavoriteshapes
   set(['square','polyon'])
   >>> setofshapes & setoffavoriteshapes
   set(['circle','triangle'])
   >>> setofshapes | setoffavoriteshapes
   set(['circle','square','triangle','polygon','hexagon'])

   note that the objects in the set are unordered; you cannot assume that
   their traversal or print order will be the same across machines!

    dictionaries

   the last built-in data structure is the dictionary which stores a map
   from one type of object (the key) to another (the value). the key must
   be an immutable type (string, number, or tuple). the value can be any
   python data type.

   note: in the example below, the printed order of the keys returned by
   python could be different than shown below. the reason is that unlike
   lists which have a fixed ordering, a dictionary is simply a hash table
   for which there is no fixed ordering of the keys (like hashmaps in
   java). the order of the keys depends on how exactly the hashing
   algorithm maps keys to buckets, and will usually seem arbitrary. your
   code should not rely on key ordering, and you should not be surprised
   if even a small modification to how your code uses a dictionary results
   in a new key ordering.

   >>> studentids = {'knuth': 42.0, 'turing': 56.0, 'nash': 92.0 }
   >>> studentids['turing']
   56.0
   >>> studentids['nash'] = 'ninety-two'
   >>> studentids
   {'knuth': 42.0, 'turing': 56.0, 'nash': 'ninety-two'}
   >>> del studentids['knuth']
   >>> studentids
   {'turing': 56.0, 'nash': 'ninety-two'}
   >>> studentids['knuth'] = [42.0,'forty-two']
   >>> studentids
   {'knuth': [42.0, 'forty-two'], 'turing': 56.0, 'nash': 'ninety-two'}
   >>> studentids.keys()
   ['knuth', 'turing', 'nash']
   >>> studentids.values()
   [[42.0, 'forty-two'], 56.0, 'ninety-two']
   >>> studentids.items()
   [('knuth',[42.0, 'forty-two']), ('turing',56.0), ('nash','ninety-two')]
   >>> len(studentids)
   3

   as with nested lists, you can also create dictionaries of dictionaries.

    exercise: dictionaries

   use dir and help to learn about the functions you can call on
   dictionaries.

    writing scripts

   now that you've got a handle on using python interactively, let's write
   a simple python script that demonstrates python's for loop. open the
   file called foreach.py and update it with the following code:

# this is what a comment looks like
fruits = ['apples','oranges','pears','bananas']
for fruit in fruits:
    print fruit + ' for sale'

fruitprices = {'apples': 2.00, 'oranges': 1.50, 'pears': 1.75}
for fruit, price in fruitprices.items():
    if price < 2.00:
        print '%s cost %f a pound' % (fruit, price)
    else:
        print fruit + ' are too expensive!'

   at the command line, use the following command in the directory
   containing foreach.py:

   [cs188-ta@nova ~/tutorial]$ python foreach.py
   apples for sale
   oranges for sale
   pears for sale
   bananas for sale
   oranges cost 1.500000 a pound
   pears cost 1.750000 a pound
   apples are too expensive!

   remember that the print statements listing the costs may be in a
   different order on your screen than in this tutorial; that's due to the
   fact that we're looping over dictionary keys, which are unordered. to
   learn more about control structures (e.g., if and else) in python,
   check out the official [36]python tutorial section on this topic.

   if you like functional programming you might also like map and filter:

   >>> map(lambda x: x * x, [1,2,3])
   [1, 4, 9]
   >>> filter(lambda x: x > 3, [1,2,3,4,5,4,3,2,1])
   [4, 5, 4]

   you can [37]learn more about lambda if you're interested.

   the next snippet of code demonstrates python's list comprehension
   construction:

nums = [1,2,3,4,5,6]
plusonenums = [x+1 for x in nums]
oddnums = [x for x in nums if x % 2 == 1]
print oddnums
oddnumsplusone = [x+1 for x in nums if x % 2 ==1]
print oddnumsplusone

   this code is in a file called listcomp.py, which you can run:

   [cs188-ta@nova ~]$ python listcomp.py
   [1,3,5]
   [2,4,6]

    exercise: list comprehensions

   write a list comprehension which, from a list, generates a lowercased
   version of each string that has length greater than five. you can find
   the solution in listcomp2.py.

    beware of indendation!

   unlike many other languages, python uses the indentation in the source
   code for interpretation. so for instance, for the following script:

if 0 == 1:
    print 'we are in a world of arithmetic pain'
print 'thank you for playing'

   will output

   thank you for playing

   but if we had written the script as

if 0 == 1:
    print 'we are in a world of arithmetic pain'
    print 'thank you for playing'

   there would be no output. the moral of the story: be careful how you
   indent! it's best to use four spaces for indentation -- that's what the
   course code uses.

    tabs vs spaces

   because python uses indentation for code evaluation, it needs to keep
   track of the level of indentation across code blocks. this means that
   if your python file switches from using tabs as indentation to spaces
   as indentation, the python interpreter will not be able to resolve the
   ambiguity of the indentation level and throw an exception. even though
   the code can be lined up visually in your text editor, python "sees" a
   change in indentation and most likely will throw an exception (or
   rarely, produce unexpected behavior).

   this most commonly happens when opening up a python file that uses an
   indentation scheme that is opposite from what your text editor uses
   (aka, your text editor uses spaces and the file uses tabs). when you
   write new lines in a code block, there will be a mix of tabs and
   spaces, even though the whitespace is aligned. for a longer discussion
   on tabs vs spaces, see [38]this discussion on stackoverflow.

    writing functions

   as in java, in python you can define your own functions:

fruitprices = {'apples':2.00, 'oranges': 1.50, 'pears': 1.75}

def buyfruit(fruit, numpounds):
    if fruit not in fruitprices:
        print "sorry we don't have %s" % (fruit)
    else:
        cost = fruitprices[fruit] * numpounds
        print "that'll be %f please" % (cost)

# main function
if __name__ == '__main__':
    buyfruit('apples',2.4)
    buyfruit('coconuts',2)

   rather than having a main function as in java, the __name__ ==
   '__main__' check is used to delimit expressions which are executed when
   the file is called as a script from the command line. the code after
   the main check is thus the same sort of code you would put in a main
   function in java.

   save this script as fruit.py and run it:

   [cs188-ta@nova ~]$ python fruit.py
   that'll be 4.800000 please
   sorry we don't have coconuts

    advanced exercise

   write a quicksort function in python using list comprehensions. use the
   first element as the pivot. you can find the solution in quicksort.py.

    object basics

   although this isn't a class in object-oriented programming, you'll have
   to use some objects in the programming projects, and so it's worth
   covering the basics of objects in python. an object encapsulates data
   and provides functions for interacting with that data.

    defining classes

   here's an example of defining a class named fruitshop:

class fruitshop:

    def __init__(self, name, fruitprices):
        """
            name: name of the fruit shop

            fruitprices: dictionary with keys as fruit
            strings and prices for values e.g.
            {'apples':2.00, 'oranges': 1.50, 'pears': 1.75}
        """
        self.fruitprices = fruitprices
        self.name = name
        print 'welcome to the %s fruit shop' % (name)

    def getcostperpound(self, fruit):
        """
            fruit: fruit string
        returns cost of 'fruit', assuming 'fruit'
        is in our inventory or none otherwise
        """
        if fruit not in self.fruitprices:
            print "sorry we don't have %s" % (fruit)
            return none
        return self.fruitprices[fruit]

    def getpriceoforder(self, orderlist):
        """
            orderlist: list of (fruit, numpounds) tuples

        returns cost of orderlist. if any of the fruit are
        """
        totalcost = 0.0
        for fruit, numpounds in orderlist:
            costperpound = self.getcostperpound(fruit)
            if costperpound != none:
                totalcost += numpounds * costperpound
        return totalcost

    def getname(self):
        return self.name

   the fruitshop class has some data, the name of the shop and the prices
   per pound of some fruit, and it provides functions, or methods, on this
   data. what advantage is there to wrapping this data in a class?
    1. encapsulating the data prevents it from being altered or used
       inappropriately,
    2. the abstraction that objects provide make it easier to write
       general-purpose code.

    using objects

   so how do we make an object and use it? make sure you have the
   fruitshop implementation in shop.py. we then import the code from this
   file (making it accessible to other scripts) using import shop, since
   shop.py is the name of the file. then, we can create fruitshop objects
   as follows:

import shop

shopname = 'the berkeley bowl'
fruitprices = {'apples': 1.00, 'oranges': 1.50, 'pears': 1.75}
berkeleyshop = shop.fruitshop(shopname, fruitprices)
appleprice = berkeleyshop.getcostperpound('apples')
print appleprice
print('apples cost $%.2f at %s.' % (appleprice, shopname))

othername = 'the stanford mall'
otherfruitprices = {'kiwis':6.00, 'apples': 4.50, 'peaches': 8.75}
otherfruitshop = shop.fruitshop(othername, otherfruitprices)
otherprice = otherfruitshop.getcostperpound('apples')
print otherprice
print('apples cost $%.2f at %s.' % (otherprice, othername))
print("my, that's expensive!")

   this code is in shoptest.py; you can run it like this:

[cs188-ta@nova ~]$ python shoptest.py
welcome to the berkeley bowl fruit shop
1.0
apples cost $1.00 at the berkeley bowl.
welcome to the stanford mall fruit shop
4.5
apples cost $4.50 at the stanford mall.
my, that's expensive!

   so what just happended? the import shop statement told python to load
   all of the functions and classes in shop.py. the line berkeleyshop =
   shop.fruitshop(shopname, fruitprices) constructs an instance of the
   fruitshop class defined in shop.py, by calling the __init__ function in
   that class. note that we only passed two arguments in, while __init__
   seems to take three arguments: (self, name, fruitprices). the reason
   for this is that all methods in a class have self as the first
   argument. the self variable's value is automatically set to the object
   itself; when calling a method, you only supply the remaining arguments.
   the self variable contains all the data (name and fruitprices) for the
   current specific instance (similar to this in java). the print
   statements use the substitution operator (described in the [39]python
   docs if you're curious).

    static vs instance variables

   the following example illustrates how to use static and instance
   variables in python.

   create the person_class.py containing the following code:

class person:
    population = 0
    def __init__(self, myage):
        self.age = myage
        person.population += 1
    def get_population(self):
        return person.population
    def get_age(self):
        return self.age

   we first compile the script:

   [cs188-ta@nova ~]$ python person_class.py

   now use the class as follows:

   >>> import person_class
   >>> p1 = person_class.person(12)
   >>> p1.get_population()
   1
   >>> p2 = person_class.person(63)
   >>> p1.get_population()
   2
   >>> p2.get_population()
   2
   >>> p1.get_age()
   12
   >>> p2.get_age()
   63

   in the code above, age is an instance variable and population is a
   static variable. population is shared by all instances of the person
   class whereas each instance has its own age variable.

    more python tips and tricks

   this tutorial has briefly touched on some major aspects of python that
   will be relevant to the course. here are some more useful tidbits:
     * use range to generate a sequence of integers, useful for generating
       traditional indexed for loops:
for index in range(3):
    print lst[index]

     * after importing a file, if you edit a source file, the changes will
       not be immediately propagated in the interpreter. for this, use the
       reload command:
       >>> reload(shop)

    troubleshooting

   these are some problems (and their solutions) that new python learners
   commonly encounter.
     * problem:
       importerror: no module named py
       solution:
       when using import, do not include the ".py" from the filename.
       for example, you should say: import shop
       not: import shop.py
     * problem:
       nameerror: name 'my variable' is not defined
       even after importing you may see this.
       solution:
       to access a member of a module, you have to type module name.member
       name, where module name is the name of the .py file, and member
       name is the name of the variable (or function) you are trying to
       access.
     * problem:
       typeerror: 'dict' object is not callable
       solution:
       dictionary looks up are done using square brackets: [ and ]. not
       parenthesis: ( and ).
     * problem:
       valueerror: too many values to unpack
       solution:
       make sure the number of variables you are assigning in a for loop
       matches the number of elements in each item of the list. similarly
       for working with tuples.
       for example, if pair is a tuple of two elements (e.g. pair
       =('apple', 2.0)) then the following code would cause the "too many
       values to unpack error":
       (a,b,c) = pair
       here is a problematic scenario involving a for loop:
pairlist = [('apples', 2.00), ('oranges', 1.50), ('pears', 1.75)]
for fruit, price, color in pairlist:
    print '%s fruit costs %f and is the color %s' % (fruit, price, color)

     * problem:
       attributeerror: 'list' object has no attribute 'length' (or
       something similar)
       solution:
       finding length of lists is done using len(name of list).
     * problem:
       changes to a file are not taking effect.
       solution:
         1. make sure you are saving all your files after any changes.
         2. if you are editing a file in a window different from the one
            you are using to execute python, make sure you
            reload(your_module) to guarantee your changes are being
            reflected. reload works similarly to import.

    more references

     * the place to go for more python information: [40]www.python.org
     * a good reference book: [41]learning python (from the ucb campus,
       you can read the whole book online)
     __________________________________________________________________

autograding

   to get you familiarized with the autograder, we will ask you to code,
   test, and submit solutions for three questions.

   you can download all of the files associated the autograder tutorial as
   a zip archive: [42]tutorial.zip (note this is different from the zip
   file used in the unix and python mini-tutorials, python_basics.zip).
   unzip this file and examine its contents:
[cs188-ta@nova ~]$ unzip tutorial.zip
[cs188-ta@nova ~]$ cd tutorial
[cs188-ta@nova ~/tutorial]$ ls
addition.py
autograder.py
buylotsoffruit.py
grading.py
projectparams.py
shop.py
shopsmart.py
testclasses.py
testparser.py
test_cases
tutorialtestclasses.py

   this contains a number of files you'll edit or run:
     * addition.py: source file for question 1
     * buylotsoffruit.py: source file for question 2
     * shop.py: source file for question 3
     * shopsmart.py: source file for question 3
     * autograder.py: autograding script (see below)

   and others you can ignore:
     * test_cases: directory contains the test cases for each question
     * grading.py: autograder code
     * testclasses.py: autograder code
     * tutorialtestclasses.py: test classes for this particular project
     * projectparams.py: project parameters

   the command python autograder.py grades your solution to all three
   problems. if we run it before editing any files we get a page or two of
   output:
[cs188-ta@nova ~/tutorial]$ python autograder.py
starting on 1-21 at 23:39:51

question q1
===========
*** fail: test_cases/q1/addition1.test
***     add(a,b) must return the sum of a and b
***     student result: "0"
***     correct result: "2"
*** fail: test_cases/q1/addition2.test
***     add(a,b) must return the sum of a and b
***     student result: "0"
***     correct result: "5"
*** fail: test_cases/q1/addition3.test
***     add(a,b) must return the sum of a and b
***     student result: "0"
***     correct result: "7.9"
*** tests failed.

### question q1: 0/1 ###


question q2
===========
*** fail: test_cases/q2/food_price1.test
***     buylotsoffruit must compute the correct cost of the order
***     student result: "0.0"
***     correct result: "12.25"
*** fail: test_cases/q2/food_price2.test
***     buylotsoffruit must compute the correct cost of the order
***     student result: "0.0"
***     correct result: "14.75"
*** fail: test_cases/q2/food_price3.test
***     buylotsoffruit must compute the correct cost of the order
***     student result: "0.0"
***     correct result: "6.4375"
*** tests failed.

### question q2: 0/1 ###


question q3
===========
welcome to shop1 fruit shop
welcome to shop2 fruit shop
*** fail: test_cases/q3/select_shop1.test
***     shopsmart(order, shops) must select the cheapest shop
***     student result: "none"
***     correct result: "<fruitshop: shop1>"
welcome to shop1 fruit shop
welcome to shop2 fruit shop
*** fail: test_cases/q3/select_shop2.test
***     shopsmart(order, shops) must select the cheapest shop
***     student result: "none"
***     correct result: "<fruitshop: shop2>"
welcome to shop1 fruit shop
welcome to shop2 fruit shop
welcome to shop3 fruit shop
*** fail: test_cases/q3/select_shop3.test
***     shopsmart(order, shops) must select the cheapest shop
***     student result: "none"
***     correct result: "<fruitshop: shop3>"
*** tests failed.

### question q3: 0/1 ###


finished at 23:39:51

provisional grades
==================
question q1: 0/1
question q2: 0/1
question q3: 0/1
------------------
total: 0/3

your grades are not yet registered.  to register your grades, make sure
to follow your instructor's guidelines to receive credit on your project.

   for each of the three questions, this shows the results of that
   question's tests, the questions grade, and a final summary at the end.
   because you haven't yet solved the questions, all the tests fail. as
   you solve each question you may find some tests pass while other fail.
   when all tests pass for a question, you get full marks.

   looking at the results for question 1, you can see that it has failed
   three tests with the error message "add(a,b) must return the sum of a
   and b". the answer your code gives is always 0, but the correct answer
   is different. we'll fix that in the next tab.
     __________________________________________________________________

question 1: addition

   open addition.py and look at the definition of add:
    def add(a, b):
        "return the sum of a and b"
        "*** your code here ***"
        return 0

   the tests called this with a and b set to different values, but the
   code always returned zero. modify this definition to read:
    def add(a, b):
        "return the sum of a and b"
        print "passed a=%s and b=%s, returning a+b=%s" % (a,b,a+b)
        return a+b

   now rerun the autograder (omitting the results for questions 2 and 3):
[cs188-ta@nova ~/tutorial]$ python autograder.py -q q1
starting on 1-21 at 23:52:05

question q1
===========
passed a=1 and b=1, returning a+b=2
*** pass: test_cases/q1/addition1.test
***     add(a,b) returns the sum of a and b
passed a=2 and b=3, returning a+b=5
*** pass: test_cases/q1/addition2.test
***     add(a,b) returns the sum of a and b
passed a=10 and b=-2.1, returning a+b=7.9
*** pass: test_cases/q1/addition3.test
***     add(a,b) returns the sum of a and b

### question q1: 1/1 ###

finished at 23:41:01

provisional grades
==================
question q1: 1/1
question q2: 0/1
question q3: 0/1
------------------
total: 1/3


   you now pass all tests, getting full marks for question 1. notice the
   new lines "passed a=..." which appear before "*** pass: ...". these are
   produced by the print statement in add. you can use print statements
   like that to output information useful for debugging. you can also run
   the autograder with the option --mute to temporarily hide such lines,
   as follows:
[cs188-ta@nova ~/tutorial]$ python autograder.py -q q1 --mute
starting on 1-22 at 14:15:33

question q1
===========
*** pass: test_cases/q1/addition1.test
***     add(a,b) returns the sum of a and b
*** pass: test_cases/q1/addition2.test
***     add(a,b) returns the sum of a and b
*** pass: test_cases/q1/addition3.test
***     add(a,b) returns the sum of a and b

### question q1: 1/1 ###

     __________________________________________________________________

question 2: buylotsoffruit function

   add a buylotsoffruit(orderlist) function to buylotsoffruit.py which
   takes a list of (fruit,pound) tuples and returns the cost of your list.
   if there is some fruit in the list which doesn't appear in fruitprices
   it should print an error message and return none. please do not change
   the fruitprices variable.

   run python autograder.py until question 2 passes all tests and you get
   full marks. each test will confirm that buylotsoffruit(orderlist)
   returns the correct answer given various possible inputs. for example,
   test_cases/q2/food_price1.test tests whether:
   cost of [('apples', 2.0), ('pears', 3.0), ('limes', 4.0)] is 12.25
     __________________________________________________________________

question 3: shopsmart function

   fill in the function shopsmart(orders,shops) in shopsmart.py, which
   takes an orderlist (like the kind passed in to
   fruitshop.getpriceoforder) and a list of fruitshop and returns the
   fruitshop where your order costs the least amount in total. don't
   change the file name or variable names, please. note that we will
   provide the shop.py implementation as a "support" file, so you don't
   need to submit yours.

   run python autograder.py until question 3 passes all tests and you get
   full marks. each test will confirm that shopsmart(orders,shops) returns
   the correct answer given various possible inputs. for example, with the
   following variable definitions:
orders1 = [('apples',1.0), ('oranges',3.0)]
orders2 = [('apples',3.0)]
dir1 = {'apples': 2.0, 'oranges':1.0}
shop1 =  shop.fruitshop('shop1',dir1)
dir2 = {'apples': 1.0, 'oranges': 5.0}
shop2 = shop.fruitshop('shop2',dir2)
shops = [shop1, shop2]

   test_cases/q3/select_shop1.test tests whether:

   shopsmart.shopsmart(orders1, shops) == shop1

   and test_cases/q3/select_shop2.test tests whether:

   shopsmart.shopsmart(orders2, shops) == shop2
     __________________________________________________________________

  submission

   you're not done yet! follow your instructor's guidelines to receive
   credit on your project!

references

   1. http://ai.berkeley.edu/tutorial.html#introduction
   2. http://ai.berkeley.edu/tutorial.html#unixbasics
   3. http://ai.berkeley.edu/tutorial.html#pythonbasics
   4. http://ai.berkeley.edu/tutorial.html#autograding
   5. http://ai.berkeley.edu/tutorial.html#q1
   6. http://ai.berkeley.edu/tutorial.html#q2
   7. http://ai.berkeley.edu/tutorial.html#q3
   8. http://ai.berkeley.edu/projects/release/tutorial/v1/001/tutorial.zip
   9. http://ai.berkeley.edu/projects/release/tutorial/v1/001/python_basics.zip
  10. http://en.wikipedia.org/wiki/python_ide#python
  11. http://www.eclipse.org/downloads/
  12. http://pydev.org/manual_101_root.html
  13. http://ai.berkeley.edu/projects/release/tutorial/v1/001/python_basics.zip
  14. http://ai.berkeley.edu/tutorial.html#invoking the interpreter
  15. http://ai.berkeley.edu/tutorial.html#operators
  16. http://ai.berkeley.edu/tutorial.html#strings
  17. http://ai.berkeley.edu/tutorial.html#dir and help
  18. http://ai.berkeley.edu/tutorial.html#built-in data structures
  19. http://ai.berkeley.edu/tutorial.html#lists
  20. http://ai.berkeley.edu/tutorial.html#tuples
  21. http://ai.berkeley.edu/tutorial.html#sets
  22. http://ai.berkeley.edu/tutorial.html#dictionaries
  23. http://ai.berkeley.edu/tutorial.html#writing scripts
  24. http://ai.berkeley.edu/tutorial.html#indentation
  25. http://ai.berkeley.edu/tutorial.html#tabsspaces
  26. http://ai.berkeley.edu/tutorial.html#writing functions
  27. http://ai.berkeley.edu/tutorial.html#object basics
  28. http://ai.berkeley.edu/tutorial.html#defining classes
  29. http://ai.berkeley.edu/tutorial.html#using objects
  30. http://ai.berkeley.edu/tutorial.html#static vs instance variables
  31. http://ai.berkeley.edu/tutorial.html#tips and tricks
  32. http://ai.berkeley.edu/tutorial.html#troubleshooting
  33. http://ai.berkeley.edu/tutorial.html#more references
  34. http://www.python.org/about/
  35. http://ai.berkeley.edu/tutorial.html#troubleshooting
  36. http://docs.python.org/tut/
  37. http://www.secnetix.de/olli/python/lambda_functions.hawk
  38. http://stackoverflow.com/questions/119562/tabs-versus-spaces-in-python-programming
  39. https://docs.python.org/2/library/stdtypes.html#string-formatting
  40. http://www.python.org/
  41. http://oreilly.com/catalog/9780596513986/
  42. http://ai.berkeley.edu/projects/release/tutorial/v1/001/tutorial.zip
