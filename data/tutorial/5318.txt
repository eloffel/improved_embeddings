day 1

esslli 2016 
bolzano, italy

        

logical foundations of databases

diego figueira

gabriele puppis

cnrs     labri

about the speakers   

gabriele puppis 
phd from udine (italy) 
post-docs in oxford 
works in labri, bordeaux 
cnrs researcher

diego figueira 
phd from ens cachan (france), 
post-docs in warsaw, edinburgh 
works in labri, bordeaux 
cnrs researcher

2

first and foremost   

interrupt!

3

organization

id208

schedule:

relational algebra

databases

id85

e f   g a m e s

locality

c

i

g

o

l

0-1 law

complexity

conjunctive queries

acyclicity

4

databases

dbms  =

a collection of data,  
structured in some way

+

a way of defining, querying,  
updating the data inside

mediate between 

humans, processes 
  & 
data

*

* [abitebou, hull, vianu    foundations of databases   ]

5

databases

dbms  =

a collection of data,  
structured in some way

+

a way of defining, querying,  
updating the data inside

mediate between 

humans, processes 
  & 
data

*

data model 
       how the data is logically organised 
        mathematical abstraction for representing data 
       independent from physical organisation

dbms also implement: transactions, concurrency, access control, resiliency   

* [abitebou, hull, vianu    foundations of databases   ]

5

id208, historical outlook

1970   72: e.f. codd (ibm san jose research lab) introduces the 
"relational data model" and two query languages: "relational algebra" 
and "relational calculus" 
1974   75: ibm researchers start implementing  
        "system r":    rst relational database management system (rdbms). 
        sequel: a query langauge based on relational algebra 
1983: ibm "db2" is released, based on system r.  
            and uc berkley released ingres rdbms 
! according to gartner, inc., june 
1979: oracle corporation is founded 
1981: codd receives turing award 
now: multi-billion industry

relational database industry today

   worldwide relational database 
management systems (rdbms) 
total software revenue totaled 
$15.2 billion in 2006, a 14.2 
percent increase from 2005 
revenue of $13.3 billion.   

2006 
revenue 

company

microsoft

oracle 

3.204b

7.168b

2.654b

2007:

ibm 

2006 
market 
share 
47.1%

21.1%

17.4%

" in 2007, the total rdbms 

software revenue increased to 
$17.1 billion (figures released in 
july 2008).

teradata

sybase

494.2m

486.7m

other

total

1.2b

15.2b

3.2%

3.2%

7.8%

100%

6

id208

relational data model = data logically organised into relations (   tables   ).

what   s a relation? 

    a (finite) subset of the cartesian product of sets 
    a    table    with rows and columns

7

id208

relational data model = data logically organised into relations (   tables   ).

what   s a relation? 

    a (finite) subset of the cartesian product of sets 
    a    table    with rows and columns

like:

{ (1,a,2), (2,b,6), (2,a,1) }     n    {a,b}    n

7

id208

relational data model = data logically organised into relations (   tables   ).

what   s a relation? 

    a (finite) subset of the cartesian product of sets 
    a    table    with rows and columns

like:

{ (1,a,2), (2,b,6), (2,a,1) }     n    {a,b}    n

a    tuple    (a    3-tuple   )

7

id208

relational data model = data logically organised into relations (   tables   ).

what   s a relation? 

    a (finite) subset of the cartesian product of sets 
    a    table    with rows and columns

like:

{ (1,a,2), (2,b,6), (2,a,1) }     n    {a,b}    n

a    tuple    (a    3-tuple   )

()            0-tuple

7

id208

relational data model = data logically organised into relations (   tables   ).

what   s a relation? 

    a (finite) subset of the cartesian product of sets 
    a    table    with rows and columns

like:

{ (1,a,2), (2,b,6), (2,a,1) }     n    {a,b}    n

a    tuple    (a    3-tuple   )

()            0-tuple

like:                       

1 a  2
2 b 6
2 a 1

7

id208

relational data model = data logically organised into relations (   tables   ).

what   s a relation? 

    a (finite) subset of the cartesian product of sets 
    a    table    with rows and columns

db =

a schema: names of tables and attributes

an instance: data conforming to the schema

7

id208

relational data model = data logically organised into relations (   tables   ).

what   s a relation? 

    a (finite) subset of the cartesian product of sets 
    a    table    with rows and columns

db =

a schema: names of tables and attributes

films (title:string, director:string, actor:string) 
schedule (theatre:string, title:string)

an instance: data conforming to the schema

7

id208

relational data model = data logically organised into relations (   tables   ).

what   s a relation? 

    a (finite) subset of the cartesian product of sets 
    a    table    with rows and columns

db =

a schema: names of tables and attributes

films (title:string, director:string, actor:string) 
schedule (theatre:string, title:string)

an instance: data conforming to the schema

films

title
8 1/2
shining

actor

director
fellini mastroianni
kubrick nicholson

dr. strangelove kubrick
ozon

8 femmes

sellers
ardant

title

schedule
theatre
utopia dr. strangelove
utopia
ugc dr. strangelove
ugc

8 femmes

8 1/2

7

id208

relational data model = data logically organised into relations (   tables   ).

 we assume all elements come from  
     a fixed set of constants or data values u.

8

id208: queries

what is a query q ? 

a mapping that

takes a database instance d  
returns a relation q(d)     ur of fixed arity r

9

id208: queries

computable!

what is a query q ? 

a mapping that

takes a database instance d  
returns a relation q(d)     ur of fixed arity r

9

id208: queries

computable!

what is a query q ? 

a mapping that

takes a database instance d  
returns a relation q(d)     ur of fixed arity r

generic! 

(order independent)

9

id208: queries

computable!

what is a query q ? 

a mapping that

takes a database instance d  
returns a relation q(d)     ur of fixed arity r

generic! 

(order independent)

boolean query: r=0 

either    yes    { () } or    no    { }

9

id208: queries

what is a query q ? 

a mapping that

takes a database instance d  
returns a relation q(d)     ur of fixed arity r

what do we care about queries?

expressive power

evaluation

static analysis

9

the fundamental questions:

how to query the relational data model? 

how efficient/expressive is it?

10

the fundamental questions:

how to query the relational data model? 

how efficient/expressive is it?

expressiveness

efficiency

10

query languages

query language

syntax 

+

semantics 

expressions for querying the db, 

governed by syntactic rules 

interpretation of symbols  
in terms of some structure 

   select x from y    

   y :-    x (x     y)   

retrieves all strings  
in column x of table y 

returns the maximum element 

of the set.

11

relational algebra (ra)

[codd, 1970]

syntax:

e := r,s,    | e     e | e \ e | e  e  |   m(e) |     (e)

where m        

              {=,   }       

12

relational algebra (ra)

[codd, 1970]

syntax:

e := r,s,    | e     e | e \ e | e  e  |   m(e) |     (e)

where m        

              {=,   }       

    r1     r2 : set union 

    r1    r2 : cartesian product 

    r1 \ r2 : set difference

12

relational algebra (ra)

[codd, 1970]

syntax:

e := r,s,    | e     e | e \ e | e  e  |   m(e) |     (e)

where m        

              {=,   }       

    r1     r2 : set union 

    r1    r2 : cartesian product 

    r1 \ r2 : set difference
      {i1=j1,   ,in=jn}(r)    {(x1,    , xm)     r | (xi1=xj1)               (xin=xjn)} :  selection

12

relational algebra (ra)

[codd, 1970]

syntax:

e := r,s,    | e     e | e \ e | e  e  |   m(e) |     (e)

where m        

              {=,   }       

    r1     r2 : set union 

    r1    r2 : cartesian product 

    r1 \ r2 : set difference
      {i1=j1,   ,in=jn}(r)    {(x1,    , xm)     r | (xi1=xj1)               (xin=xjn)} :  selection

   

   

   

   

12

relational algebra (ra)

[codd, 1970]

syntax:

e := r,s,    | e     e | e \ e | e  e  |   m(e) |     (e)

where m        

              {=,   }       

    r1     r2 : set union 

    r1    r2 : cartesian product 

  {1=3,1   2}( {(1,2,1), (2,2,2)} ) = {(1,2,1)}
a procedural query language 

    r1 \ r2 : set difference
      {i1=j1,   ,in=jn}(r)    {(x1,    , xm)     r | (xi1=xj1)               (xin=xjn)} :  selection

   

   

   

   

12

relational algebra (ra)

[codd, 1970]

syntax:

e := r,s,    | e     e | e \ e | e  e  |   m(e) |     (e)

where m        

              {=,   }       

    r1     r2 : set union 

    r1    r2 : cartesian product 

  {1=3,1   2}( {(1,2,1), (2,2,2)} ) = {(1,2,1)}
a procedural query language 

   

    r1 \ r2 : set difference
      {i1=j1,   ,in=jn}(r)    {(x1,    , xm)     r | (xi1=xj1)               (xin=xjn)} :  selection
      {i1,   ,in}(r)     {(xi1,   ,xin) | (x1,    , xm)     r} :  projection

   

   

   

12

relational algebra (ra)

[codd, 1970]

syntax:

e := r,s,    | e     e | e \ e | e  e  |   m(e) |     (e)

where m        

              {=,   }       

    r1     r2 : set union 

    r1    r2 : cartesian product 

  {1=3,1   2}( {(1,2,1), (2,2,2)} ) = {(1,2,1)}
a procedural query language 
  {1,3}( {(1,2,1),(2,2,2)} ) = {(1,1), (2,2)}

   

    r1 \ r2 : set difference
      {i1=j1,   ,in=jn}(r)    {(x1,    , xm)     r | (xi1=xj1)               (xin=xjn)} :  selection
      {i1,   ,in}(r)     {(xi1,   ,xin) | (x1,    , xm)     r} :  projection

   

   

   

12

relational algebra (ra)

[codd, 1970]

    r1     r2 : set union 

    r1    r2 : cartesian product 

   

    r1 \ r2 : set difference
   
      {i1=j1,   ,in=jn}(r)    {(x1,    , xm)     r | (xi1=xj1)               (xin=xjn)} :  selection
      {i1,   ,in}(r)     {(xi1,   ,xin) | (x1,    , xm)     r} :  projection

   

   

question 1: what is the ra expression for  
                    { (v1,v2) | there are w1   w2 so that (v1,w1)     r1 and (v2,w2)     r2 } ?

question 2:    2(  1=3(  2 (  1=3(r1    r2))    r2))= ?

r1

r2

a
b
c
b
a

3
2
4
3
2

a
b
b
a
b

4
1
2
1
3

13

relational algebra (ra)

[codd, 1970]

    r1     r2 : set union 

    r1    r2 : cartesian product 

   

    r1 \ r2 : set difference
   
      {i1=j1,   ,in=jn}(r)    {(x1,    , xm)     r | (xi1=xj1)               (xin=xjn)} :  selection
      {i1,   ,in}(r)     {(xi1,   ,xin) | (x1,    , xm)     r} :  projection

   

   

question 1: what is the ra expression for  
                    { (v1,v2) | there are w1   w2 so that (v1,w1)     r1 and (v2,w2)     r2 } ?

answer:   {1,3}(  1   3(r1    r2))

a
b
c
c

b
a
a
b

question 2:    2(  1=3(  2 (  1=3(r1    r2))    r2))= ?

r1

r2

a
b
c
b
a

3
2
4
3
2

a
b
b
a
b

4
1
2
1
3

13

relational algebra (ra)

[codd, 1970]

    r1     r2 : set union 

    r1    r2 : cartesian product 

   

    r1 \ r2 : set difference
   
      {i1=j1,   ,in=jn}(r)    {(x1,    , xm)     r | (xi1=xj1)               (xin=xjn)} :  selection
      {i1,   ,in}(r)     {(xi1,   ,xin) | (x1,    , xm)     r} :  projection

   

   

question 1: what is the ra expression for  
                    { (v1,v2) | there are w1   w2 so that (v1,w1)     r1 and (v2,w2)     r2 } ?

answer:   {1,3}(  1   3(r1    r2))

a
b
c
c

b
a
a
b

question 2:    2(  1=3(  2 (  1=3(r1    r2))    r2))= ?
answer (only one element): 

b

r1

r2

a
b
c
b
a

3
2
4
3
2

a
b
b
a
b

4
1
2
1
3

13

ra = basic sql

no domain-specific features, 

aggregation, etc

select   x   
from   r1,   ,rn   
where   z

        x (   z( r1              rn ) )

      or             union

      not   in   (   )       difference

14

ra = basic sql

no domain-specific features, 

aggregation, etc

select   x   
from   r1,   ,rn   
where   z

        x (   z( r1              rn ) )

      or             union

      not   in   (   )       difference

  2 (  1   3(r1    r2))     

r1

r2

a
b
c
b
a

3
2
4
3
2

a
b
b
a
b

4
1
2
1
3

14

ra = basic sql

no domain-specific features, 

aggregation, etc

select   x   
from   r1,   ,rn   
where   z

        x (   z( r1              rn ) )

      or             union

      not   in   (   )       difference

  2 (  1   3(r1    r2))     

select   r1.2   as   foo   
from   r1,   r2   
where   r1.1         r2.1

r1

r2

a
b
c
b
a

3
2
4
3
2

a
b
b
a
b

4
1
2
1
3

14

ra = basic sql

no domain-specific features, 

aggregation, etc

select   x   
from   r1,   ,rn   
where   z

        x (   z( r1              rn ) )

      or             union

      not   in   (   )       difference

  2 (  1   3(r1    r2))     

select   r1.2   as   foo   
from   r1,   r2   
where   r1.1         r2.1

   

  2(  1=3(         r2))    

r1

r2

a
b
c
b
a

3
2
4
3
2

a
b
b
a
b

4
1
2
1
3

14

ra = basic sql

no domain-specific features, 

aggregation, etc

select   x   
from   r1,   ,rn   
where   z

        x (   z( r1              rn ) )

      or             union

      not   in   (   )       difference

  2 (  1   3(r1    r2))     

select   r1.2   as   foo   
from   r1,   r2   
where   r1.1         r2.1

   

   

  2(  1=3(         r2))    

r1

r2

a
b
c
b
a

3
2
4
3
2

a
b
b
a
b

4
1
2
1
3

14

ra = basic sql

no domain-specific features, 

aggregation, etc

select   x   
from   r1,   ,rn   
where   z

        x (   z( r1              rn ) )

      or             union

      not   in   (   )       difference

  2 (  1   3(r1    r2))     

select   r1.2   as   foo   
from   r1,   r2   
where   r1.1         r2.1

   

   

  2(  1=3(         r2))    

select   foo   
from      ,   r2   
where   foo   =   r2.2

r1

r2

a
b
c
b
a

3
2
4
3
2

a
b
b
a
b

4
1
2
1
3

14

denotational languages

procedural

algebra       how to obtain the result 

logics         what is the property of the result

declarative

15

denotational languages

{

relational algebra 
operations on tables

procedural

algebra       how to obtain the result 

logics         what is the property of the result

declarative

15

denotational languages

{

relational algebra 
operations on tables

procedural

algebra       how to obtain the result 

logics         what is the property of the result

{

first order logic  
properties on mathematical structures

declarative

15

denotational languages

{

relational algebra 
operations on tables

procedural

algebra       how to obtain the result 

logics         what is the property of the result

{

first order logic  
properties on mathematical structures

declarative

15

fo = id85

16

relational structures

a structure is:

a = (d, r1,    , rn, f1,     fn)

d is a non-empty set, the domain 
ri is an m-ary relation for some m  (ie,  ri     dm ) 
fi is an n-ary function for some n    (ie,  fi : dn     d )

17

relational structures

a structure is:

a = (d, r1,    , rn, f1,     fn)

d is a non-empty set, the domain 
ri is an m-ary relation for some m  (ie,  ri     dm ) 
fi is an n-ary function for some n    (ie,  fi : dn     d )

a graph g = (v,e) 
    v: nodes 
    e     v 2: edges (binary relation) 
    (no functions)

a group, like (   ,+) 
       : natural numbers 
    (no relations) 
    +:    2         addition (binary function) 

17

id85

18

id85

fo

variables x, y, z,     
quantifiers:    ,    
boolean connectives:   ,    ,    

a language to talk about structures 
variables range over the domain 
atomic formulas: r(x1,    , xm), x=y

18

id85

fo

variables x, y, z,     
quantifiers:    ,    
boolean connectives:   ,    ,    

a graph g = (v,e) 
      v: nodes 
      e     v 2: edges (binary relation) 
      (no functions)

a language to talk about structures 
variables range over the domain 
atomic formulas: r(x1,    , xm), x=y

language to talk about graphs 
variables range over nodes 
atomic formulas: e(x,y), x = y

18

id85

fo

variables x, y, z,     
quantifiers:    ,    
boolean connectives:   ,    ,    

a graph g = (v,e) 
      v: nodes 
      e     v 2: edges (binary relation) 
      (no functions)

a language to talk about structures 
variables range over the domain 
atomic formulas: r(x1,    , xm), x=y

language to talk about graphs 
variables range over nodes 
atomic formulas: e(x,y), x = y

formulas: atomic formulas + connectives + quantifiers

18

   the node x has at least two neighbours    
               y    z (  (y=z)     e(x,y)     e(x,z))

19

   the node x has at least two neighbours    
  (x) =
               y    z (  (y=z)     e(x,y)     e(x,z))

x is free = not quantified 
(a property of a node in the graph)

free

19

   the node x has at least two neighbours    
  (x) =
               y    z (  (y=z)     e(x,y)     e(x,z))

x is free = not quantified 
(a property of a node in the graph)

free

   each node has at least two neighbours    
           x    y    z (  (y=z)     e(x,y)     e(x,z))

19

   the node x has at least two neighbours    
  (x) =
               y    z (  (y=z)     e(x,y)     e(x,z))

x is free = not quantified 
(a property of a node in the graph)

free

   each node has at least two neighbours    
   =
           x    y    z (  (y=z)     e(x,y)     e(x,z))

the formula is a sentence  
= no free variables 
(a property of the graph)

19

   the node x has at least two neighbours    
  (x) =
               y    z (  (y=z)     e(x,y)     e(x,z))

x is free = not quantified 
(a property of a node in the graph)

free

   each node has at least two neighbours    
   =
           x    y    z (  (y=z)     e(x,y)     e(x,z))

the formula is a sentence  
= no free variables 
(a property of the graph)

question:       how to express in fo 
                               every two adjacent nodes have a common neighbour    ? 

                       does it have free variables? is it a sentence?

19

   the node x has at least two neighbours    
  (x) =
               y    z (  (y=z)     e(x,y)     e(x,z))

x is free = not quantified 
(a property of a node in the graph)

free

   each node has at least two neighbours    
   =
           x    y    z (  (y=z)     e(x,y)     e(x,z))

the formula is a sentence  
= no free variables 
(a property of the graph)

question:       how to express in fo 
                               every two adjacent nodes have a common neighbour    ? 

                       does it have free variables? is it a sentence?

answer:        x   y (  e(x,y)        z ( (e(x,z)     e(z,x))     (e(y,z)     e(z,y)) ) )

19

binding

to evaluate a formula    we need a graph g=(v,e) and a binding    
                                      that maps free variables of    to nodes of g.

g         (x1,   ,xn)

   : {x1,   ,xn}     v assigns nodes to free variables

20

binding

to evaluate a formula    we need a graph g=(v,e) and a binding    
                                      that maps free variables of    to nodes of g.

   g,   satisfy      

      is satis   able   

g         (x1,   ,xn)

   : {x1,   ,xn}     v assigns nodes to free variables

20

binding

to evaluate a formula    we need a graph g=(v,e) and a binding    
                                      that maps free variables of    to nodes of g.

   g,   satisfy      

      is satis   able   

g         (x1,   ,xn)

   : {x1,   ,xn}     v assigns nodes to free variables

   the node x has at least two neighbours    
    (x) =    y    z (  (y=z)     e(x,y)     e(x,z))

g             if      = {x   v}

v'

v

v''

g

20

binding

to evaluate a formula    we need a graph g=(v,e) and a binding    
                                      that maps free variables of    to nodes of g.

   g,   satisfy      

      is satis   able   

g         (x1,   ,xn)

   : {x1,   ,xn}     v assigns nodes to free variables

   the node x has at least two neighbours    
    (x) =    y    z (  (y=z)     e(x,y)     e(x,z))

g             if      = {x   v}

   every node has at least two neighbours    
     =    x    y    z (  (y=z)     e(x,y)     e(x,z))

g          

v'

v

v''

g

20

id85

formal semantics of fo

g          x          i        for some v     v and   ' =        {x     v}  we have g      '    

g          x          i        for every v     v and   ' =        {x     v}  we have g      '    

g                    i        g          and g          

g                     i        it is not true that g          

g       x=y        i          (x)=  (y) 

g       e(x,y)    i        (  (x),  (y))     e

21

formulas as queries

  (x1,    , xn) evaluated on g=(v,e) yields all the bindings that satisfy   :

  (g) = { (   (x1),   ,  (xn) )  |  g         ,    : {x1,   ,xn}     v }

22

formulas as queries

  (x1,    , xn) evaluated on g=(v,e) yields all the bindings that satisfy   :

  (g) = { (   (x1),   ,  (xn) )  |  g         ,    : {x1,   ,xn}     v }

   the node x has at least two neighbours    
    (x) =    y    z (  (y=z)     e(x,y)     e(x,z))

   

   return all nodes with 
  at least two neighbours   

22

formulas as queries

  (x1,    , xn) evaluated on g=(v,e) yields all the bindings that satisfy   :

  (g) = { (   (x1),   ,  (xn) )  |  g         ,    : {x1,   ,xn}     v }

   the node x has at least two neighbours    
    (x) =    y    z (  (y=z)     e(x,y)     e(x,z))
  (g) = {v, v', v''} 
  (g') = {v, v'}

   

   return all nodes with 
  at least two neighbours   

v

v'

v

v'

v''

g

v''

g'

22

formulas as queries

  (x1,    , xn) evaluated on g=(v,e) yields all the bindings that satisfy   :

  (g) = { (   (x1),   ,  (xn) )  |  g         ,    : {x1,   ,xn}     v }

   the node x has at least two neighbours    
    (x) =    y    z (  (y=z)     e(x,y)     e(x,z))
  (g) = {v, v', v''} 
  (g') = {v, v'}

   

   return all nodes with 
  at least two neighbours   

   every node has two neighbours    
     =    x    y    z (  (y=z)     e(x,y)     e(x,z))
    (g) = {()}      set with one element: the 0-tuple
    (g') = {}        empty set

v

v'

v

v'

v''

g

v''

g'

22

question:      which bindings    verify g          for 
                                     (x,y) =    z (e(x,z)     e(z,y)) 
                        

                                    and                                                   ?

g =

v

v'

v''

23

question:      which bindings    verify g          for 
                                     (x,y) =    z (e(x,z)     e(z,y)) 
                        

                                    and                                                   ?

g =

v

v'

answer:           = { x     v, y     v    }, 

                           = { x     v, y     v }, 

                           = { x     v', y     v    }, 
                            and all the rest

v''

  (g) = {v,v', v''}    {v,v', v''}

23

formulas as queries

fo can serve as a declarative query language on id208 : 
we express the properties of the answer

  tables = relations 

queries = formulas 

rows = tuples

24

formulas as queries

fo can serve as a declarative query language on id208 : 
we express the properties of the answer

  tables = relations 

queries = formulas 

rows = tuples

particular to databases: 
       use of constants 
       no functions 
       finite structure 
       quantification over  
      active domain

24

formulas as queries

fo can serve as a declarative query language on id208 : 
we express the properties of the answer

  tables = relations 

queries = formulas 

rows = tuples

   finite  is different from     

particular to databases: 
       use of constants 
       no functions 
       finite structure 
       quantification over  
      active domain

24

formulas as queries

fo can serve as a declarative query language on id208 : 
we express the properties of the answer

  tables = relations 

queries = formulas 

rows = tuples

particular to databases: 
       use of constants 
       no functions 
       finite structure 
       quantification over  
      active domain

   finite  is different from     

there are formulas    that are satis   able 
only on in   nite structures. 

like which?

24

formulas as queries

fo can serve as a declarative query language on id208 : 
we express the properties of the answer

  tables = relations 

queries = formulas 

rows = tuples

particular to databases: 
       use of constants 
       no functions 
       finite structure 
       quantification over  
      active domain

   finite  is different from     

there are formulas    that are satis   able 
only on in   nite structures. 

like which?

      =     r(x,y) is an in   nite linear order    

24

formulas as queries

fo can serve as a declarative query language on id208 : 
we express the properties of the answer

  tables = relations 

queries = formulas 

rows = tuples

particular to databases: 
       use of constants 
       no functions 
       finite structure 
       quantification over  
      active domain

   finite  is different from     

there are formulas    that are satis   able 
only on in   nite structures. 

like which?

      =     r(x,y) is an in   nite linear order    

finite model theory

24

formulas as queries

fo can serve as a declarative query language on id208 : 
we express the properties of the answer

   tables  =  relations 
    rows  =  tuples 
queries  =  formulas

[e.f. codd 1972]

25

formulas as queries

fo can serve as a declarative query language on id208 : 
we express the properties of the answer

   tables  =  relations 
    rows  =  tuples 
queries  =  formulas

ra  =* fo
how  = what

[e.f. codd 1972]

25

formulas as queries

fo can serve as a declarative query language on id208 : 
we express the properties of the answer

   tables  =  relations 
    rows  =  tuples 
queries  =  formulas

ra  =* fo
how  = what

ra and fo logic have roughly* the same expressive power!
[e.f. codd 1972]

*fo without functions, with equality, on finite domains,    

25

formulas as queries

ra     fo

    r1    r2                    r1(x1,    , xn)     r2(xn+1,    , xm) 

    r1     r2                    r1(x1,    , xn)     r2(x1,    , xn) 

      {i1=j1,   ,in=jn}(r)         r(x1,    , xm)     (xi1=xj1)               (xin=xjn) 

      {i1,   ,in}(r)                  ({x1,   ,xm} \ {xi1,   ,xin}). r(x1,    , xm) 

    r1 \ r2                    r1(x1,    , xn)       r2(x1,    , xn) 

       

26

formulas as queries

fo     ra

 does not hold in general! 

27

formulas as queries

fo     ra

 does not hold in general! 

   the complement of r   

     ra
     fo :    r(x)

27

formulas as queries

fo     ra/

   the complement of r   

     ra
     fo :    r(x)

27

formulas as queries

fo     ra/

   the complement of r   

     ra
     fo :    r(x)

               we restrict variables to range over active domain 

27

formulas as queries

fo     ra/

   the complement of r   

     ra
     fo :    r(x)

               we restrict variables to range over active domain 

elements in the relations

foact  

=  

fo restricted 
to active domain

27

formulas as queries

fo     ra/

   the complement of r   

     ra
     fo :    r(x)

               we restrict variables to range over active domain 

elements in the relations

foact  

=  

fo restricted 
to active domain

  1(x)   =    y e(y,x) 
  1(g) = {v2}  

  2(x,y) =   e(x,y) 
  2(g)   = {(v1,v1),(v3,v1),(v2,v3)}

g =

v2

v3

v1

v4

27

id85 restricted to active domain

formal semantics of foact

g          x        i        for some v     act(g) and   ' =        {x     v}  we have g      '    

g          x        i        for every v     act(g) and   ' =        {x     v}  we have g      '    

g                  i        g          and g          

g                   i        it is not true that g          

g       x=y        i          (x)=  (y) 

g       e(x,y)    i        (  (x),  (y))     e

act(g) = {v | for some v': (v,v')     e or (v',v)     e}

28

id85 restricted to active domain

foact     ra

29

id85 restricted to active domain

foact     ra

assume: 

1.    has variables x1,   ,xn,  
2.    in normal form: (   * (     )*)*  +  quanti   er-free   (x1,   ,xn)

   x1    x2      x3    x4 . ( e(x1,x3)       e(x4,x2) )     (x1=x3)

29

id85 restricted to active domain

foact     ra

assume: 

1.    has variables x1,   ,xn,  
2.    in normal form: (   * (     )*)*  +  quanti   er-free   (x1,   ,xn)

   x1    x2      x3    x4 . ( e(x1,x3)       e(x4,x2) )     (x1=x3)
adom = ra expression for active domain =      1(e)       2(e)    
    (r(xi1,   ,xin))        r 

     (    xi   (xi1,   ,xin) )          {i1,   ,in}\{i}(       ) 

    (xi = xj)           {i=j}( adom                adom ) 

    (  1(xi1,   ,xin)       2(xi1,   ,xin))          1          2    

    (    (xi1,   ,xin))        adom                adom  \       

n
o
i
t
a
l
s
n
a
r
t

29

id85 restricted to active domain

foact     ra

assume: 

1.    has variables x1,   ,xn,  
2.    in normal form: (   * (     )*)*  +  quanti   er-free   (x1,   ,xn)

   x1    x2      x3    x4 . ( e(x1,x3)       e(x4,x2) )     (x1=x3)
adom = ra expression for active domain =      1(e)       2(e)    
    (r(xi1,   ,xin))        r 

     (    xi   (xi1,   ,xin) )          {i1,   ,in}\{i}(       ) 

    (xi = xj)           {i=j}( adom                adom ) 

    (  1(xi1,   ,xin)       2(xi1,   ,xin))          1          2    

    (    (xi1,   ,xin))        adom                adom  \       

a   b = (a   b) \ a \ b

29

n
o
i
t
a
l
s
n
a
r
t

corollary

foact is equivalent to ra

30

question 1: how is   2(  1=3(  2(  1=3(r1    r2))    r2)) expressed in fo? 
remember: r1,r2 are binary

question 2: how is    y,z . (r1(x,y)     r1(y,z)      x   z ) expressed in ra? 
remember: the signature is the same as before (r1,r2 binary)

    r1     r2 
    r1    r2 
    r1 \ r2 
      {i1=j1,   ,in=jn}(r)    {(x1,    , xm)     r | (xi1=xj1)               (xin=xjn)} 
      {i1,   ,in}(r)     {(xi1,   ,xin) | (x1,    , xm)     r}

   

   

   

   

31

question 1: how is   2(  1=3(  2(  1=3(r1    r2))    r2)) expressed in fo? 
remember: r1,r2 are binary
answer:    x2 . (    x1,x4 . (r1(x1,x2)     r2(x1,x4))     r2(x2,x5) )

question 2: how is    y,z . (r1(x,y)     r1(y,z)      x   z ) expressed in ra? 
remember: the signature is the same as before (r1,r2 binary)

    r1     r2 
    r1    r2 
    r1 \ r2 
      {i1=j1,   ,in=jn}(r)    {(x1,    , xm)     r | (xi1=xj1)               (xin=xjn)} 
      {i1,   ,in}(r)     {(xi1,   ,xin) | (x1,    , xm)     r}

   

   

   

   

31

question 1: how is   2(  1=3(  2(  1=3(r1    r2))    r2)) expressed in fo? 
remember: r1,r2 are binary
answer:    x2 . (    x1,x4 . (r1(x1,x2)     r2(x1,x4))     r2(x2,x5) )

question 2: how is    y,z . (r1(x,y)     r1(y,z)      x   z ) expressed in ra? 
remember: the signature is the same as before (r1,r2 binary)

    r1     r2 
    r1    r2 
    r1 \ r2 
      {i1=j1,   ,in=jn}(r)    {(x1,    , xm)     r | (xi1=xj1)               (xin=xjn)} 
      {i1,   ,in}(r)     {(xi1,   ,xin) | (x1,    , xm)     r}

   

   

   

   

answer:    1(  {2=3,1   4}(r1    r1))

31

fo ra sql

=

=

logic

algebra

programming 

language

32

over 

active domain

on finite 
domains

very basic

fo ra sql

=

=

logic

algebra

programming 

language

32

algorithmic problems for query languages

evaluation problem:  given a query q, a database instance db, 
                                  and a tuple t, is t     q(db) ?

    how hard is it to retrieve data?

33

algorithmic problems for query languages

evaluation problem:  given a query q, a database instance db, 
                                  and a tuple t, is t     q(db) ?

    how hard is it to retrieve data?

emptiness problem:  given a query q, is there a database instance db 
                                  so that q(db)         ?

    does q make sense? is it a contradiction? (query optimization)

33

algorithmic problems for query languages

evaluation problem:  given a query q, a database instance db, 
                                  and a tuple t, is t     q(db) ?

    how hard is it to retrieve data?

emptiness problem:  given a query q, is there a database instance db 
                                  so that q(db)         ?

    does q make sense? is it a contradiction? (query optimization)

equivalence problem:  given queries q1, q2, is 
                                                   q1(db) = q2(db) 
                                    for all database instances db?

    can we safely replace a query with another? (query optimization)

33

complexity theory

  what can be mechanized?        decidable/undecidable 
how hard is it to mechanise?      complexity classes

34

complexity theory

domino

h   s 10th pcp

  what can be mechanized?        decidable/undecidable 
how hard is it to mechanise?      complexity classes

k

.

 

.

 

.

34

complexity theory

domino

h   s 10th pcp

  what can be mechanized?        decidable/undecidable 
how hard is it to mechanise?      complexity classes

usage of resources:       time 
                                   memory

k

.

 

.

 

.

34

complexity theory

domino

h   s 10th pcp

  what can be mechanized?        decidable/undecidable 
how hard is it to mechanise?      complexity classes

usage of resources:       time 
                                   memory

algorithm alg is time-bounded  
by a function f : n     n if 
alg(input) uses less than f (|input|) units of time.

k

.

 

.

 

.

34

complexity theory

domino

h   s 10th pcp

  what can be mechanized?        decidable/undecidable 
how hard is it to mechanise?      complexity classes

usage of resources:       time 
                                   memory

k

.

 

.

 

.

algorithm alg is time-bounded  
by a function f : n     n if 
alg(input) uses less than f (|input|) units of time.

e
m

i
t

input size

f

alg

34

complexity theory

domino

h   s 10th pcp

  what can be mechanized?        decidable/undecidable 
how hard is it to mechanise?      complexity classes

usage of resources:       time 
                                   memory

space

algorithm alg is time-bounded  
by a function f : n     n if 
space.
alg(input) uses less than f (|input|) units of time.

e
m

i
t

input size

k

.

 

.

 

.

f

alg

34

complexity theory

domino

h   s 10th pcp

  what can be mechanized?        decidable/undecidable 
how hard is it to mechanise?      complexity classes

usage of resources:       time 
                                   memory

space

algorithm alg is time-bounded  
by a function f : n     n if 
space.
alg(input) uses less than f (|input|) units of time.

e
m

i
t

input size

logspace     ptime     pspace     exptime             

k

.

 

.

 

.

f

alg

34

complexity theory

domino

h   s 10th pcp

  what can be mechanized?        decidable/undecidable 
how hard is it to mechanise?      complexity classes

usage of resources:       time 
                                   memory

k

.

 

.

 

.

space

algorithm alg is time-bounded  
by a function f : n     n if 
space.
alg(input) uses less than f (|input|) units of time.

f

alg

e
m

i
t

input size

time-bounded by a polynomial

logspace     ptime     pspace     exptime             

space-bounded by log(n)

space-bounded by a polynomial

34

algorithmic problems for fo

evaluation problem:      given a fo formula   (x1,    , xn),  
                                              a graph g, and a binding   , does g          ?

satis   ability problem:   given a fo formula   , is there a graph g  
                                               and binding   , such that g         ?

equivalence problem:    given fo formulae   ,  , is  
                                                         g           i      g          
                                               for all graphs g and bindings   ?

35

algorithmic problems for fo

evaluation problem:      given a fo formula   (x1,    , xn),  
                                              a graph g, and a binding   , does g          ?

decidable     foundations of the database industry

satis   ability problem:   given a fo formula   , is there a graph g  
                                               and binding   , such that g         ?

equivalence problem:    given fo formulae   ,  , is  
                                                         g           i      g          
                                               for all graphs g and bindings   ?

35

algorithmic problems for fo

evaluation problem:      given a fo formula   (x1,    , xn),  
                                              a graph g, and a binding   , does g          ?

decidable     foundations of the database industry

satis   ability problem:   given a fo formula   , is there a graph g  
                                               and binding   , such that g         ?

     undecidable     both for     and    finite

equivalence problem:    given fo formulae   ,  , is  
                                                         g           i      g          
                                               for all graphs g and bindings   ?

35

algorithmic problems for fo

evaluation problem:      given a fo formula   (x1,    , xn),  
                                              a graph g, and a binding   , does g          ?

decidable     foundations of the database industry

satis   ability problem:   given a fo formula   , is there a graph g  
                                               and binding   , such that g         ?

     undecidable     both for     and    finite

equivalence problem:    given fo formulae   ,  , is  
                                                         g           i      g          
                                               for all graphs g and bindings   ?

     undecidable     by reduction to the satisfiability problem

35

algorithmic problems for fo

satis   ability problem:   given a fo formula   , is there a graph g  
                                               and binding   , such that g         ?

     undecidable     both for     and    finite

[trakhtenbrot    50]

36

algorithmic problems for fo

satis   ability problem:   given a fo formula   , is there a graph g  
                                               and binding   , such that g         ?

     undecidable     both for     and    finite

[trakhtenbrot    50]

proof: by reduction from the domino (aka tiling) problem.

36

algorithmic problems for fo

satis   ability problem:   given a fo formula   , is there a graph g  
                                               and binding   , such that g         ?

     undecidable     both for     and    finite

[trakhtenbrot    50]

proof: by reduction from the domino (aka tiling) problem.

reduction from p to p':   algorithm that solves p using a o(1) procedure  
                                                                                   p'(x)     
                                                 that returns the truth value of p'(x).

36

the (undecidable) domino problem

 domino 

input:  4-sided dominos:

the (undecidable) domino problem

 domino 

input:  4-sided dominos:

output:  is it possible to form a white-bordered rectangle? (of any size)

.
 
.
 
.

. . .

. . .

. . .

.
 
.
 
.

the (undecidable) domino problem

 domino 

input:  4-sided dominos:

output:  is it possible to form a white-bordered rectangle? (of any size)

.
 
.
 
.

. . .

. . .

. . .

.
 
.
 
.

rules:  sides must match,   
            you can   t rotate the dominos,  but you can    clone    them.

the (undecidable) domino problem

 domino  -  why is it undecidable? 

it can easily encode halting computations of turing machines:

. . .

q q

l

l

r r

0

0
0

0
0

0
0

l 1
l 1

1
1

s 0
s 0

0

l 1
l 1

1
1

q 0
q 0

0
0

r 0
r 0

0
0

q

q

l

l

r

r

q 0

0
0

r 0
r 0

0
0

0
0

0
0

0
0

0

0
0

0
0

0
0

0
0

0
0

0
0

the (undecidable) domino problem

 domino  -  why is it undecidable? 

it can easily encode halting computations of turing machines:

i

i

i

i

i

i

(head is elsewhere,   
 symbol is not modified)

. . .

q q

l

l

r r

0

0
0

0
0

0
0

l 1
l 1

1
1

s 0
s 0

0

l 1
l 1

1
1

q 0
q 0

0
0

r 0
r 0

0
0

q

q

l

l

r

r

q 0

0
0

r 0
r 0

0
0

0
0

0
0

0
0

0

0
0

0
0

0
0

0
0

0
0

0
0

the (undecidable) domino problem

 domino  -  why is it undecidable? 

it can easily encode halting computations of turing machines:

i

i

1

q 0

r

i

i

r

r 2

2

i

i

(head is elsewhere,   
 symbol is not modified)
(head is here, symbol is   
 rewritten, head moves right)

. . .

q q

l

l

r r

0

0
0

0
0

0
0

l 1
l 1

1
1

s 0
s 0

0

l 1
l 1

1
1

q 0
q 0

0
0

r 0
r 0

0
0

q

q

l

l

r

r

q 0

0
0

r 0
r 0

0
0

0
0

0
0

0
0

0

0
0

0
0

0
0

0
0

0
0

0
0

the (undecidable) domino problem

 domino  -  why is it undecidable? 

it can easily encode halting computations of turing machines:

i

i

1

q 0

l 2

2

r

l

i

i

r

l

r 2

2

1

q 0

i

i

(head is elsewhere,   
 symbol is not modified)
(head is here, symbol is   
 rewritten, head moves right)
(head is here, symbol is   
 rewritten, head moves left)

. . .

q q

l

l

r r

0

0
0

0
0

0
0

l 1
l 1

1
1

s 0
s 0

0

l 1
l 1

1
1

q 0
q 0

0
0

r 0
r 0

0
0

q

q

l

l

r

r

q 0

0
0

r 0
r 0

0
0

0
0

0
0

0
0

0

0
0

0
0

0
0

0
0

0
0

0
0

the (undecidable) domino problem

 domino  -  why is it undecidable? 

it can easily encode halting computations of turing machines:

i

i

1

q 0

l 2

2

s 0

r

l

i

i

r 2

2

1

q 0

0

r

l

i

i

0

(head is elsewhere,   
 symbol is not modified)
(head is here, symbol is   
 rewritten, head moves right)
(head is here, symbol is   
 rewritten, head moves left)

(initial configuration)

. . .

q q

l

l

r r

0

0
0

0
0

0
0

l 1
l 1

1
1

s 0
s 0

0

l 1
l 1

1
1

q 0
q 0

0
0

r 0
r 0

0
0

q

q

l

l

r

r

q 0

0
0

r 0
r 0

0
0

0
0

0
0

0
0

0

0
0

0
0

0
0

0
0

0
0

0
0

the (undecidable) domino problem

 domino  -  why is it undecidable? 

it can easily encode halting computations of turing machines:

(head is elsewhere,   
 symbol is not modified)
(head is here, symbol is   
 rewritten, head moves right)
(head is here, symbol is   
 rewritten, head moves left)

(initial configuration)

(halting configuration)

i

i

0

0

i

i

r 2

2

1

q 0

0

r

l

0

i

i

1

q 0

l 2

2

s 0

r

l

h 0

. . .

. . .

q q

l

l

r r

0

0
0

0
0

0
0

l 1
l 1

1
1

s 0
s 0

0

l 1
l 1

1
1

q 0
q 0

0
0

r 0
r 0

0
0

q

q

l

l

r

r

q 0

0
0

r 0
r 0

0
0

0
0

0
0

0
0

0

0
0

0
0

0
0

0
0

0
0

0
0

domino     sat-fo  (domino has a solution i       satis   able)

1. there is a grid: h( , ) and v( , ) are relations representing bijections such that   

domino     sat-fo  (domino has a solution i       satis   able)

1. there is a grid: h( , ) and v( , ) are relations representing bijections such that   

   

v

h

domino     sat-fo  (domino has a solution i       satis   able)

1. there is a grid: h( , ) and v( , ) are relations representing bijections such that   

   

v

   

v

h

h

domino     sat-fo  (domino has a solution i       satis   able)

1. there is a grid: h( , ) and v( , ) are relations representing bijections such that   

v

.
 
.
 
.

v

v

v

h

h

h

h

v

.
 
.
 
.

v

v

v

h

h

h

h

v

.
 
.
 
.

v

v

v

h

h

. . .

. . .

h

h

. . .

h

h

. . .

h

h

. . .

v

v

v

v

domino     sat-fo  (domino has a solution i       satis   able)

1. there is a grid: h( , ) and v( , ) are relations representing bijections such that   

v

.
 
.
 
.

v

v

v

h

h

h

h

v

.
 
.
 
.

v

v

v

h

h

h

h

v

.
 
.
 
.

v

v

v

h

h

. . .

. . .

h

h

. . .

h

h

. . .

h

h

. . .

v

v

v

v

2. assign one domino to each node: 
    a unary relation   

d ( x )

    for each domino

   
   
   
domino     sat-fo  (domino has a solution i       satis   able)

1. there is a grid: h( , ) and v( , ) are relations representing bijections such that   

v

.
 
.
 
.

v

v

v

h

h

h

h

v

.
 
.
 
.

v

v

v

h

h

h

h

v

.
 
.
 
.

v

v

v

h

h

. . .

. . .

h

h

. . .

h

h

. . .

h

h

. . .

v

v

v

v

2. assign one domino to each node: 
    a unary relation   

d ( x )

    for each domino

3. match the sides                x,y 
    if h(x,y), then da(x)     db(y)  
    for some dominos a,b that    match      
    horizontally         (idem vertically)

   
   
   
domino     sat-fo  (domino has a solution i       satis   able)

1. there is a grid: h( , ) and v( , ) are relations representing bijections such that   

v

.
 
.
 
.

v

v

v

h

h

h

h

v

.
 
.
 
.

v

v

v

h

h

h

h

v

.
 
.
 
.

v

v

v

h

h

. . .

. . .

h

h

. . .

h

h

. . .

h

h

. . .

v

v

v

v

4. borders are white.

2. assign one domino to each node: 
    a unary relation   

d ( x )

    for each domino

3. match the sides                x,y 
    if h(x,y), then da(x)     db(y)  
    for some dominos a,b that    match      
    horizontally         (idem vertically)

   
   
   
algorithmic problems for fo

evaluation problem:      given a fo formula   (x1,    , xn),  
                                              a graph g, and a binding   , does g          ?

decidable     foundations of the database industry

satis   ability problem:   given a fo formula   , is there a graph g  
                                               and binding   , such that g         ?

     undecidable     both for     and    finite

equivalence problem:    given fo formulae   ,  , is  
                                                        g           i      g          
                                               for all graphs g and bindings   ?

     undecidable     by reduction to the satisfiability problem

40

algorithmic problems for fo

equivalence problem:    given fo formulae   ,  , is  
                                                        g           i      g          
                                               for all graphs g and bindings   ?

     undecidable     by reduction from the satisfiability problem

41

algorithmic problems for fo

   is satis   able  i        is not equivalent to    
satis   ability problem undecidable       equivalence problem undecidable

equivalence problem:    given fo formulae   ,  , is  
                                                        g           i      g          
                                               for all graphs g and bindings   ?

     undecidable     by reduction from the satisfiability problem

41

algorithmic problems for fo

   is satis   able  i        is not equivalent to    
satis   ability problem undecidable       equivalence problem undecidable
actually, there are reductions in both senses: 
  (x1,   ,xn) and   (y1,   ,ym) are  equivalent  i     
        n=m 
         (x1=y1)                (xn=yn)       (x1,   ,xn)         (y1,   ,yn) is unsatis   able 
         (x1=y1)                (xn=yn)       (x1,   ,xn)         (y1,   ,yn) is unsatis   able

equivalence problem:    given fo formulae   ,  , is  
                                                        g           i      g          
                                               for all graphs g and bindings   ?

     undecidable     by reduction from the satisfiability problem

41

algorithmic problems for fo

evaluation problem:      given a fo formula   (x1,    , xn),  
                                      a graph g, and a binding   , does g          ?
decidable     foundations of the database industry

satis   ability problem:   given a fo formula   , is there a graph g  
                                      and binding   , such that g         ?

     undecidable     both for     and    finite

equivalence problem:    given fo formulae   ,  , is  
                                                        g           i      g          
                                               for all graphs g and bindings   ?

     undecidable     by reduction to the satisfiability problem

42

evaluation problem for fo

input:

  (x1,   ,xn) 
g = (v,e) 
   = {x1,   ,xn}     v

output:

g          ?

43

evaluation problem for fo

input:

  (x1,   ,xn) 
g = (v,e) 
   = {x1,   ,xn}     v

encoding of g = (v, e)

output:

g          ?

    each node is coded with a bit string of size log(|v|), 
    edge set is encoded by its tuples, e.g. (100,101), (010, 010),    

cost of coding: ||g|| = |e|  2  log(|v|)     |v| (mod a polynomial)

43

evaluation problem for fo

input:

  (x1,   ,xn) 
g = (v,e) 
   = {x1,   ,xn}     v

encoding of g = (v, e)

output:

g          ?

    each node is coded with a bit string of size log(|v|), 
    edge set is encoded by its tuples, e.g. (100,101), (010, 010),    

cost of coding: ||g|| = |e|  2  log(|v|)     |v| (mod a polynomial)

encoding of    = {x1,   ,xn}     v

    each node is coded with a bit string of size log(|v|),

cost of coding: ||  || = n  log(|v|)

43

evaluation problem for fo

input:

  (x1,   ,xn) 
g = (v,e) 
   = {x1,   ,xn}     v

output:

g          ?

44

evaluation problem for fo

input:

  (x1,   ,xn) 
g = (v,e) 
   = {x1,   ,xn}     v

   

   

   

   

if   (x1,   ,xn) = e(xi,xj):   
answer yes  i     (  (xi),  (xj))     e   
if   (x1,   ,xn) =   (x1,   ,xn)       '(x1,   ,xn):   
answer yes  i     g          and g         '    
if   (x1,   ,xn) =     (x1,   ,xn):   
answer no  i     g             
if   (x1,   ,xn) =    y .   (x1,   ,xn,y):   
answer yes  i     for some v     v and   '=        {y   v}   
                         we have g      '   .

output:

g          ?

44

evaluation problem for fo

input:

  (x1,   ,xn) 
g = (v,e) 
   = {x1,   ,xn}     v

   

   

   

   

if   (x1,   ,xn) = e(xi,xj):   
answer yes  i     (  (xi),  (xj))     e   
if   (x1,   ,xn) =   (x1,   ,xn)       '(x1,   ,xn):   
answer yes  i     g          and g         '    
if   (x1,   ,xn) =     (x1,   ,xn):   
answer no  i     g             
if   (x1,   ,xn) =    y .   (x1,   ,xn,y):   
answer yes  i     for some v     v and   '=        {y   v}   
                         we have g      '   .

question:   
how much space   
does it take?

output:

g          ?

44

evaluation problem for fo

input:

  (x1,   ,xn) 
g = (v,e) 
   = {x1,   ,xn}     v

   

   

   

   

if   (x1,   ,xn) = e(xi,xj):   
answer yes  i     (  (xi),  (xj))     e   
if   (x1,   ,xn) =   (x1,   ,xn)       '(x1,   ,xn):   
answer yes  i     g          and g         '    
if   (x1,   ,xn) =     (x1,   ,xn):   
answer no  i     g             
if   (x1,   ,xn) =    y .   (x1,   ,xn,y):   
answer yes  i     for some v     v and   '=        {y   v}   
                         we have g      '   .

question:   
how much space   
does it take?

output:

g          ?

use 4 pointers       logspace

44

output:

g          ?

use 4 pointers       logspace

     max( space(g         )), space(g         ')) )

evaluation problem for fo

input:

  (x1,   ,xn) 
g = (v,e) 
   = {x1,   ,xn}     v

   

   

   

   

if   (x1,   ,xn) = e(xi,xj):   
answer yes  i     (  (xi),  (xj))     e   
if   (x1,   ,xn) =   (x1,   ,xn)       '(x1,   ,xn):   
answer yes  i     g          and g         '    
if   (x1,   ,xn) =     (x1,   ,xn):   
answer no  i     g             
if   (x1,   ,xn) =    y .   (x1,   ,xn,y):   
answer yes  i     for some v     v and   '=        {y   v}   
                         we have g      '   .

question:   
how much space   
does it take?

44

evaluation problem for fo

input:

  (x1,   ,xn) 
g = (v,e) 
   = {x1,   ,xn}     v

   

   

   

   

if   (x1,   ,xn) = e(xi,xj):   
answer yes  i     (  (xi),  (xj))     e   
if   (x1,   ,xn) =   (x1,   ,xn)       '(x1,   ,xn):   
answer yes  i     g          and g         '    
if   (x1,   ,xn) =     (x1,   ,xn):   
answer no  i     g             
if   (x1,   ,xn) =    y .   (x1,   ,xn,y):   
answer yes  i     for some v     v and   '=        {y   v}   
                         we have g      '   .

question:   
how much space   
does it take?

output:

g          ?

use 4 pointers       logspace

     max( space(g         )), space(g         ')) )

     space(g         ))

44

evaluation problem for fo

input:

  (x1,   ,xn) 
g = (v,e) 
   = {x1,   ,xn}     v

   

   

   

   

if   (x1,   ,xn) = e(xi,xj):   
answer yes  i     (  (xi),  (xj))     e   
if   (x1,   ,xn) =   (x1,   ,xn)       '(x1,   ,xn):   
answer yes  i     g          and g         '    
if   (x1,   ,xn) =     (x1,   ,xn):   
answer no  i     g             
if   (x1,   ,xn) =    y .   (x1,   ,xn,y):   
answer yes  i     for some v     v and   '=        {y   v}   
                         we have g      '   .

question:   
how much space   
does it take?

output:

g          ?

use 4 pointers       logspace

     max( space(g         )), space(g         ')) )

     space(g         ))

     2  log(|g|) + space(g      '    )

44

evaluation problem for fo

input:

  (x1,   ,xn) 
g = (v,e) 
   = {x1,   ,xn}     v

   

   

   

   

if   (x1,   ,xn) = e(xi,xj):   
answer yes  i     (  (xi),  (xj))     e   
if   (x1,   ,xn) =   (x1,   ,xn)       '(x1,   ,xn):   
answer yes  i     g          and g         '    
if   (x1,   ,xn) =     (x1,   ,xn):   
answer no  i     g             
if   (x1,   ,xn) =    y .   (x1,   ,xn,y):   
answer yes  i     for some v     v and   '=        {y   v}   
                         we have g      '   .

output:

g          ?

use 4 pointers       logspace

     max( space(g         )), space(g         ')) )

     space(g         ))

     2  log(|g|) + space(g      '    )

question:   
how much space   
does it take?

2  log(|g|) +        + 2  log(|g|) + k  log(|  |+|g|) space

    |  | times

44

evaluation problem for fo

in pspace

input:

  (x1,   ,xn) 
g = (v,e) 
   = {x1,   ,xn}     v

   

   

   

   

if   (x1,   ,xn) = e(xi,xj):   
answer yes  i     (  (xi),  (xj))     e   
if   (x1,   ,xn) =   (x1,   ,xn)       '(x1,   ,xn):   
answer yes  i     g          and g         '    
if   (x1,   ,xn) =     (x1,   ,xn):   
answer no  i     g             
if   (x1,   ,xn) =    y .   (x1,   ,xn,y):   
answer yes  i     for some v     v and   '=        {y   v}   
                         we have g      '   .

output:

g          ?

use 4 pointers       logspace

     max( space(g         )), space(g         ')) )

     space(g         ))

     2  log(|g|) + space(g      '    )

question:   
how much space   
does it take?

2  log(|g|) +        + 2  log(|g|) + k  log(|  |+|g|) space

    |  | times

44

combined, query, and data complexities 

[vardi, 1982]

problem: usual scenario in database

a database of size 106

a query of size 100

input:

45

combined, query, and data complexities 

[vardi, 1982]

problem: usual scenario in database

a database of size 106

a query of size 100

input:

query +

45

combined, query, and data complexities 

[vardi, 1982]

problem: usual scenario in database

a database of size 106

a query of size 100

input:

query +

database

45

combined, query, and data complexities 

[vardi, 1982]

problem: usual scenario in database

a database of size 106

a query of size 100

input:

query +

database

but we don   t distinguish this in the analysis:

time(2|query| + |data|)

=

time(|query| + 2|data|)

45

combined, query, and data complexities 

[vardi, 1982]

query and data play very di   erent roles.

separation of concerns:    how the resources grow with respect to 

                                                     the size of the data 

                                                     the query size

46

combined, query, and data complexities 

combined complexity: input size is |query| + |data|

query complexity (|data| fixed): input size is |query|

data complexity (|query| fixed): input size is |data|

47

combined, query, and data complexities 

combined complexity: input size is |query| + |data|

query complexity (|data| fixed): input size is |query|

data complexity (|query| fixed): input size is |data|

o(2|query| + |data|) is 

o(|query| + 2|data|) is 

exponential in combined complexity 
exponential in query complexity 
linear in data complexity

exponential in combined complexity 
linear in query complexity 
exponential in data complexity

47

question

what is the data, query and combined complexity 
for the evaluation problem for fo?

remember:

data complexity, input size: |data|
query complexity, input size: |query|
combined complexity, input size: |data| + |query|

|  |    2    log(|g|) + k  log(|  |+|g|) space

48

question

what is the data, query and combined complexity 
for the evaluation problem for fo?

remember:

data complexity, input size: |data|
query complexity, input size: |query|
combined complexity, input size: |data| + |query|

|  |    2    log(|g|) + k  log(|  |+|g|) space

query

data

o(log(|data|)  |query|) space pspace combined and query complexity

logspace data complexity

48

evaluation pb for fo is pspace-complete 

(combined  
 complexity)

 pspace-complete problem: qbf 

qbf = a boolean formula with quantification over the truth values (t,f)

(satisfaction of  quantified boolean formulas)

49

evaluation pb for fo is pspace-complete 

(combined  
 complexity)

 pspace-complete problem: qbf 

qbf = a boolean formula with quantification over the truth values (t,f)

(satisfaction of  quantified boolean formulas)

   p    q . (p       q)    where p,q range over {t,f}

49

evaluation pb for fo is pspace-complete 

(combined  
 complexity)

 pspace-complete problem: qbf 

qbf = a boolean formula with quantification over the truth values (t,f)

(satisfaction of  quantified boolean formulas)

   p    q . (p       q)    where p,q range over {t,f}

theorem: evaluation for fo is pspace-complete (combined c.)

49

evaluation pb for fo is pspace-complete 

(combined  
 complexity)

 pspace-complete problem: qbf 

qbf = a boolean formula with quantification over the truth values (t,f)

(satisfaction of  quantified boolean formulas)

   p    q . (p       q)    where p,q range over {t,f}

theorem: evaluation for fo is pspace-complete (combined c.)

polynomial reduction qbf     fo :

1. given        qbf,   
               let   '(x) be the replacement    
               of each    p    with    p=x    in   .

2. note:    x   ' holds in a 2-element 

graph  i        is qbf-satis   able

3. test if  g          '  for g=({v,v'},{})

49

evaluation pb for fo is pspace-complete 

(combined  
 complexity)

 pspace-complete problem: qbf 

qbf = a boolean formula with quantification over the truth values (t,f)

(satisfaction of  quantified boolean formulas)

   p    q . (p       q)    where p,q range over {t,f}

theorem: evaluation for fo is pspace-complete (combined c.)

polynomial reduction qbf     fo :
  '(x)=   p    q . ( (p=x)       (q=x) )

1. given        qbf,   
               let   '(x) be the replacement    
               of each    p    with    p=x    in   .

2. note:    x   ' holds in a 2-element 

graph  i        is qbf-satis   able

3. test if  g          '  for g=({v,v'},{})

49

evaluation pb for fo is pspace-complete 

(combined  
 complexity)

 pspace-complete problem: qbf 

qbf = a boolean formula with quantification over the truth values (t,f)

(satisfaction of  quantified boolean formulas)

   p    q . (p       q)    where p,q range over {t,f}

theorem: evaluation for fo is pspace-complete (combined c.)

polynomial reduction qbf     fo :
  '(x)=   p    q . ( (p=x)       (q=x) )

1. given        qbf,   
               let   '(x) be the replacement    
               of each    p    with    p=x    in   .

   x    p    q . ( (p=x)       (q=x) )

2. note:    x   ' holds in a 2-element 

graph  i        is qbf-satis   able

3. test if  g          '  for g=({v,v'},{})

49

recap

equivalence-ra

equivalence-sql

equivalence-fo

sat-fo

eval-fo 
(combined)

domino

qbf

undecidable

pspace

eval-fo 
(data)

logspace

50

bibliography

abiteboul, hull, vianu,    foundations of databases   , addison-wesley, 1995. 

(freely available at http://webdam.inria.fr/alice/)

chapters 1, 2, 3

51

