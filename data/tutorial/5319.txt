day 2

esslli 2016 
bolzano, italy

        

logical foundations of databases

diego figueira

gabriele puppis

cnrs     labri

recap

   relational model (tables) 

   relational algebra (union, product, di   erence, selection, projection) 

   sql (select     from     where    ) 

   ra     basic sql 

   id85 (syntax, semantics) 

   expressiveness: fo =* ra

formulas as queries

fo can serve as a declarative query language on id208 : 
we express the properties of the answer

   tables  =  relations 
    rows  =  tuples 
queries  =  formulas

[e.f. codd 1972]

3

formulas as queries

fo can serve as a declarative query language on id208 : 
we express the properties of the answer

   tables  =  relations 
    rows  =  tuples 
queries  =  formulas

ra  =* fo
how  = what

[e.f. codd 1972]

3

formulas as queries

fo can serve as a declarative query language on id208 : 
we express the properties of the answer

   tables  =  relations 
    rows  =  tuples 
queries  =  formulas

ra  =* fo
how  = what

ra and fo logic have roughly* the same expressive power!
[e.f. codd 1972]

*fo without functions, with equality, on finite domains,    

3

formulas as queries

ra     fo

    r1    r2                    r1(x1,    , xn)     r2(xn+1,    , xm) 

    r1     r2                    r1(x1,    , xn)     r2(x1,    , xn) 

      {i1=j1,   ,in=jn}(r)         r(x1,    , xm)     (xi1=xj1)               (xin=xjn) 

      {i1,   ,in}(r)                  ({x1,   ,xm} \ {xi1,   ,xin}). r(x1,    , xm) 

    r1 \ r2                    r1(x1,    , xn)       r2(x1,    , xn) 

       

4

formulas as queries

fo     ra

 does not hold in general! 

5

formulas as queries

fo     ra

 does not hold in general! 

   the complement of r   

     ra
     fo :    r(x)

5

formulas as queries

fo     ra/

   the complement of r   

     ra
     fo :    r(x)

5

formulas as queries

fo     ra/

   the complement of r   

     ra
     fo :    r(x)

               we restrict variables to range over active domain 

5

formulas as queries

fo     ra/

   the complement of r   

     ra
     fo :    r(x)

               we restrict variables to range over active domain 

elements in the relations

foact  

=  

fo restricted 
to active domain

5

formulas as queries

fo     ra/

   the complement of r   

     ra
     fo :    r(x)

               we restrict variables to range over active domain 

elements in the relations

foact  

=  

fo restricted 
to active domain

  1(x)   =    y e(y,x) 
  1(g) = {v2}  

  2(x,y) =   e(x,y) 
  2(g)   = {(v1,v1),(v3,v1),(v2,v3)}

g =

v2

v3

v1

v4

5

id85 restricted to active domain

formal semantics of foact

g          x        i        for some v     act(g) and   ' =        {x     v}  we have g      '    

g          x        i        for every v     act(g) and   ' =        {x     v}  we have g      '    

g                  i        g          and g          

g                   i        it is not true that g          

g       x=y        i          (x)=  (y) 

g       e(x,y)    i        (  (x),  (y))     e

act(g) = {v | for some v': (v,v')     e or (v',v)     e}

6

id85 restricted to active domain

foact     ra

7

id85 restricted to active domain

foact     ra

assume: 

1.    in normal form: (   * (     )*)*  +  quanti   er-free   (x1,   ,xn)  
2.    has n variables

   x1    x2      x3    x4 . ( e(x1,x3)       e(x4,x2) )     (x1=x3)

7

id85 restricted to active domain

foact     ra

assume: 

1.    in normal form: (   * (     )*)*  +  quanti   er-free   (x1,   ,xn)  
2.    has n variables

   x1    x2      x3    x4 . ( e(x1,x3)       e(x4,x2) )     (x1=x3)
adom = ra expression for active domain =      1(e)       2(e)    
    (r(xi1,   ,xit))        r 

    (xi = xj)           {i=j}( adom                adom ) 

    (  1       2)          1          2    

    (    )        adom                adom  \        

     (    xi   (xi1,   ,xit) )          {i1,   ,it}\{i}(       )

n
o
i
t
a
l
s
n
a
r
t

7

id85 restricted to active domain

foact     ra

assume: 

1.    in normal form: (   * (     )*)*  +  quanti   er-free   (x1,   ,xn)  
2.    has n variables

  {1,   ,n}(  {i1=n+1,   ,it=n+t} (adomn    r)) 

   x1    x2      x3    x4 . ( e(x1,x3)       e(x4,x2) )     (x1=x3)
adom = ra expression for active domain =      1(e)       2(e)    
    (r(xi1,   ,xit))        r 

    (xi = xj)           {i=j}( adom                adom ) 

    (  1       2)          1          2    

    (    )        adom                adom  \        

     (    xi   (xi1,   ,xit) )          {i1,   ,it}\{i}(       )

n
o
i
t
a
l
s
n
a
r
t

7

id85 restricted to active domain

foact     ra

assume: 

1.    in normal form: (   * (     )*)*  +  quanti   er-free   (x1,   ,xn)  
2.    has n variables

   x1    x2      x3    x4 . ( e(x1,x3)       e(x4,x2) )     (x1=x3)
adom = ra expression for active domain =      1(e)       2(e)    
    (r(xi1,   ,xit))        r 

adomn

    (xi = xj)           {i=j}( adom                adom ) 

    (  1       2)          1          2    

    (    )        adom                adom  \        

     (    xi   (xi1,   ,xit) )          {i1,   ,it}\{i}(       )

n
o
i
t
a
l
s
n
a
r
t

7

id85 restricted to active domain

foact     ra

assume: 

1.    in normal form: (   * (     )*)*  +  quanti   er-free   (x1,   ,xn)  
2.    has n variables

   x1    x2      x3    x4 . ( e(x1,x3)       e(x4,x2) )     (x1=x3)
adom = ra expression for active domain =      1(e)       2(e)    
    (r(xi1,   ,xit))        r 

    (xi = xj)           {i=j}( adom                adom ) 

a   b = ((a   b) \ (a \ b)) 
                      \ (b \ a)

    (  1       2)          1          2    

    (    )        adom                adom  \        

     (    xi   (xi1,   ,xit) )          {i1,   ,it}\{i}(       )

7

n
o
i
t
a
l
s
n
a
r
t

id85 restricted to active domain

foact     ra

assume: 

1.    in normal form: (   * (     )*)*  +  quanti   er-free   (x1,   ,xn)  
2.    has n variables

   x1    x2      x3    x4 . ( e(x1,x3)       e(x4,x2) )     (x1=x3)
adom = ra expression for active domain =      1(e)       2(e)    
    (r(xi1,   ,xit))        r 

    (xi = xj)           {i=j}( adom                adom ) 

adomt if t is the arity of      

    (  1       2)          1          2    

    (    )        adom                adom  \        

     (    xi   (xi1,   ,xit) )          {i1,   ,it}\{i}(       )

n
o
i
t
a
l
s
n
a
r
t

7

corollary

foact is equivalent to ra

8

question 1: how is   2(  1=3(r1    r2) expressed in fo? 
remember: r1,r2 are binary

question 2: how is    y,z . (r1(x,y)     r1(y,z)      x   z ) expressed in ra? 
remember: the signature is the same as before (r1,r2 binary)

    r1     r2 
    r1    r2 
    r1 \ r2 
      {i1=j1,   ,in=jn}(r)    {(x1,    , xm)     r | (xi1=xj1)               (xin=xjn)} 
      {i1,   ,in}(r)     {(xi1,   ,xin) | (x1,    , xm)     r}

   

   

   

   

9

question 1: how is   2(  1=3(r1    r2) expressed in fo? 
remember: r1,r2 are binary
answer:    x1,x3,x4 (r1(x1,x2)     r2(x3,x4)     x1 = x3)

question 2: how is    y,z . (r1(x,y)     r1(y,z)      x   z ) expressed in ra? 
remember: the signature is the same as before (r1,r2 binary)

    r1     r2 
    r1    r2 
    r1 \ r2 
      {i1=j1,   ,in=jn}(r)    {(x1,    , xm)     r | (xi1=xj1)               (xin=xjn)} 
      {i1,   ,in}(r)     {(xi1,   ,xin) | (x1,    , xm)     r}

   

   

   

   

9

question 1: how is   2(  1=3(r1    r2) expressed in fo? 
remember: r1,r2 are binary
answer:    x1,x3,x4 (r1(x1,x2)     r2(x3,x4)     x1 = x3)

question 2: how is    y,z . (r1(x,y)     r1(y,z)      x   z ) expressed in ra? 
remember: the signature is the same as before (r1,r2 binary)

    r1     r2 
    r1    r2 
    r1 \ r2 
      {i1=j1,   ,in=jn}(r)    {(x1,    , xm)     r | (xi1=xj1)               (xin=xjn)} 
      {i1,   ,in}(r)     {(xi1,   ,xin) | (x1,    , xm)     r}

   

   

   

   

answer:    1(  {2=3,1   4}(r1    r1))

9

fo ra sql

=

=

logic

algebra

programming 

language

10

over 

active domain

on finite 
domains

very basic

fo ra sql

=

=

logic

algebra

programming 

language

10

algorithmic problems for query languages

evaluation problem:  given a query q, a database instance db, 
                                  and a tuple t, is t     q(db) ?

    how hard is it to retrieve data?

11

algorithmic problems for query languages

evaluation problem:  given a query q, a database instance db, 
                                  and a tuple t, is t     q(db) ?

    how hard is it to retrieve data?

emptiness problem:  given a query q, is there a database instance db 
                                  so that q(db)         ?

    does q make sense? is it a contradiction? (query optimization)

11

algorithmic problems for query languages

evaluation problem:  given a query q, a database instance db, 
                                  and a tuple t, is t     q(db) ?

    how hard is it to retrieve data?

emptiness problem:  given a query q, is there a database instance db 
                                  so that q(db)         ?

    does q make sense? is it a contradiction? (query optimization)

equivalence problem:  given queries q1, q2, is 
                                                   q1(db) = q2(db) 
                                    for all database instances db?

    can we safely replace a query with another? (query optimization)

11

complexity theory

  what can be mechanized?        decidable/undecidable 
how hard is it to mechanise?      complexity classes

12

complexity theory

domino

h   s 10th pcp

  what can be mechanized?        decidable/undecidable 
how hard is it to mechanise?      complexity classes

k

.

 

.

 

.

12

complexity theory

domino

h   s 10th pcp

  what can be mechanized?        decidable/undecidable 
how hard is it to mechanise?      complexity classes

usage of resources:       time 
                                   memory

k

.

 

.

 

.

12

complexity theory

domino

h   s 10th pcp

  what can be mechanized?        decidable/undecidable 
how hard is it to mechanise?      complexity classes

usage of resources:       time 
                                   memory

algorithm alg is time-bounded  
by a function f : n     n if 
alg(input) uses less than f (|input|) units of time.

k

.

 

.

 

.

12

complexity theory

domino

h   s 10th pcp

  what can be mechanized?        decidable/undecidable 
how hard is it to mechanise?      complexity classes

usage of resources:       time 
                                   memory

k

.

 

.

 

.

algorithm alg is time-bounded  
by a function f : n     n if 
alg(input) uses less than f (|input|) units of time.

e
m

i
t

input size

f

alg

12

complexity theory

domino

h   s 10th pcp

  what can be mechanized?        decidable/undecidable 
how hard is it to mechanise?      complexity classes

usage of resources:       time 
                                   memory

space

algorithm alg is time-bounded  
by a function f : n     n if 
space.
alg(input) uses less than f (|input|) units of time.

e
m

i
t

input size

k

.

 

.

 

.

f

alg

12

complexity theory

domino

h   s 10th pcp

  what can be mechanized?        decidable/undecidable 
how hard is it to mechanise?      complexity classes

usage of resources:       time 
                                   memory

space

algorithm alg is time-bounded  
by a function f : n     n if 
space.
alg(input) uses less than f (|input|) units of time.

e
m

i
t

input size

logspace     ptime     pspace     exptime             

k

.

 

.

 

.

f

alg

12

complexity theory

domino

h   s 10th pcp

  what can be mechanized?        decidable/undecidable 
how hard is it to mechanise?      complexity classes

usage of resources:       time 
                                   memory

k

.

 

.

 

.

space

algorithm alg is time-bounded  
by a function f : n     n if 
space.
alg(input) uses less than f (|input|) units of time.

f

alg

e
m

i
t

input size

time-bounded by a polynomial

logspace     ptime     pspace     exptime             

space-bounded by log(n)

space-bounded by a polynomial

12

algorithmic problems for fo

evaluation problem:      given a fo formula   (x1,    , xn),  
                                              a graph g, and a binding   , does g          ?

satis   ability problem:   given a fo formula   , is there a graph g  
                                               and binding   , such that g         ?

equivalence problem:    given fo formulae   ,  , is  
                                                         g           i      g          
                                               for all graphs g and bindings   ?

13

algorithmic problems for fo

evaluation problem:      given a fo formula   (x1,    , xn),  
                                              a graph g, and a binding   , does g          ?

decidable     foundations of the database industry

satis   ability problem:   given a fo formula   , is there a graph g  
                                               and binding   , such that g         ?

equivalence problem:    given fo formulae   ,  , is  
                                                         g           i      g          
                                               for all graphs g and bindings   ?

13

algorithmic problems for fo

evaluation problem:      given a fo formula   (x1,    , xn),  
                                              a graph g, and a binding   , does g          ?

decidable     foundations of the database industry

satis   ability problem:   given a fo formula   , is there a graph g  
                                               and binding   , such that g         ?

     undecidable     both for     and    finite

equivalence problem:    given fo formulae   ,  , is  
                                                         g           i      g          
                                               for all graphs g and bindings   ?

13

algorithmic problems for fo

evaluation problem:      given a fo formula   (x1,    , xn),  
                                              a graph g, and a binding   , does g          ?

decidable     foundations of the database industry

satis   ability problem:   given a fo formula   , is there a graph g  
                                               and binding   , such that g         ?

     undecidable     both for     and    finite

equivalence problem:    given fo formulae   ,  , is  
                                                         g           i      g          
                                               for all graphs g and bindings   ?

     undecidable     by reduction to the satisfiability problem

13

algorithmic problems for fo

satis   ability problem:   given a fo formula   , is there a graph g  
                                               and binding   , such that g         ?

     undecidable     both for     and    finite

[trakhtenbrot    50]

14

algorithmic problems for fo

satis   ability problem:   given a fo formula   , is there a graph g  
                                               and binding   , such that g         ?

     undecidable     both for     and    finite

[trakhtenbrot    50]

proof: by reduction from the domino (aka tiling) problem.

14

algorithmic problems for fo

satis   ability problem:   given a fo formula   , is there a graph g  
                                               and binding   , such that g         ?

     undecidable     both for     and    finite

[trakhtenbrot    50]

proof: by reduction from the domino (aka tiling) problem.

reduction from p to p':   algorithm that solves p using a o(1) procedure  
                                                                                   p'(x)     
                                                 that returns the truth value of p'(x).

14

the (undecidable) domino problem

 domino 

input:  4-sided dominos:

the (undecidable) domino problem

 domino 

input:  4-sided dominos:

output:  is it possible to form a white-bordered rectangle? (of any size)

.
 
.
 
.

. . .

. . .

. . .

.
 
.
 
.

the (undecidable) domino problem

 domino 

input:  4-sided dominos:

output:  is it possible to form a white-bordered rectangle? (of any size)

.
 
.
 
.

. . .

. . .

. . .

.
 
.
 
.

rules:  sides must match,   
            you can   t rotate the dominos,  but you can    clone    them.

the (undecidable) domino problem

 domino  -  why is it undecidable? 

it can easily encode halting computations of turing machines:

. . .

q q

l

l

r r

0

0
0

0
0

0
0

l 1
l 1

1
1

s 0
s 0

0

l 1
l 1

1
1

q 0
q 0

0
0

r 0
r 0

0
0

q

q

l

l

r

r

q 0

0
0

r 0
r 0

0
0

0
0

0
0

0
0

0

0
0

0
0

0
0

0
0

0
0

0
0

the (undecidable) domino problem

 domino  -  why is it undecidable? 

it can easily encode halting computations of turing machines:

i

i

i

i

i

i

(head is elsewhere,   
 symbol is not modified)

. . .

q q

l

l

r r

0

0
0

0
0

0
0

l 1
l 1

1
1

s 0
s 0

0

l 1
l 1

1
1

q 0
q 0

0
0

r 0
r 0

0
0

q

q

l

l

r

r

q 0

0
0

r 0
r 0

0
0

0
0

0
0

0
0

0

0
0

0
0

0
0

0
0

0
0

0
0

the (undecidable) domino problem

 domino  -  why is it undecidable? 

it can easily encode halting computations of turing machines:

i

i

1

q 0

r

i

i

r

r 2

2

i

i

(head is elsewhere,   
 symbol is not modified)
(head is here, symbol is   
 rewritten, head moves right)

. . .

q q

l

l

r r

0

0
0

0
0

0
0

l 1
l 1

1
1

s 0
s 0

0

l 1
l 1

1
1

q 0
q 0

0
0

r 0
r 0

0
0

q

q

l

l

r

r

q 0

0
0

r 0
r 0

0
0

0
0

0
0

0
0

0

0
0

0
0

0
0

0
0

0
0

0
0

the (undecidable) domino problem

 domino  -  why is it undecidable? 

it can easily encode halting computations of turing machines:

i

i

1

q 0

l 2

2

r

l

i

i

r

l

r 2

2

1

q 0

i

i

(head is elsewhere,   
 symbol is not modified)
(head is here, symbol is   
 rewritten, head moves right)
(head is here, symbol is   
 rewritten, head moves left)

. . .

q q

l

l

r r

0

0
0

0
0

0
0

l 1
l 1

1
1

s 0
s 0

0

l 1
l 1

1
1

q 0
q 0

0
0

r 0
r 0

0
0

q

q

l

l

r

r

q 0

0
0

r 0
r 0

0
0

0
0

0
0

0
0

0

0
0

0
0

0
0

0
0

0
0

0
0

the (undecidable) domino problem

 domino  -  why is it undecidable? 

it can easily encode halting computations of turing machines:

i

i

1

q 0

l 2

2

s 0

r

l

i

i

r 2

2

1

q 0

0

r

l

i

i

0

(head is elsewhere,   
 symbol is not modified)
(head is here, symbol is   
 rewritten, head moves right)
(head is here, symbol is   
 rewritten, head moves left)

(initial configuration)

. . .

q q

l

l

r r

0

0
0

0
0

0
0

l 1
l 1

1
1

s 0
s 0

0

l 1
l 1

1
1

q 0
q 0

0
0

r 0
r 0

0
0

q

q

l

l

r

r

q 0

0
0

r 0
r 0

0
0

0
0

0
0

0
0

0

0
0

0
0

0
0

0
0

0
0

0
0

the (undecidable) domino problem

 domino  -  why is it undecidable? 

it can easily encode halting computations of turing machines:

(head is elsewhere,   
 symbol is not modified)
(head is here, symbol is   
 rewritten, head moves right)
(head is here, symbol is   
 rewritten, head moves left)

(initial configuration)

(halting configuration)

i

i

0

0

i

i

r 2

2

1

q 0

0

r

l

0

i

i

1

q 0

l 2

2

s 0

r

l

h 0

. . .

. . .

q q

l

l

r r

0

0
0

0
0

0
0

l 1
l 1

1
1

s 0
s 0

0

l 1
l 1

1
1

q 0
q 0

0
0

r 0
r 0

0
0

q

q

l

l

r

r

q 0

0
0

r 0
r 0

0
0

0
0

0
0

0
0

0

0
0

0
0

0
0

0
0

0
0

0
0

domino     sat-fo  (domino has a solution i       satis   able)

1. there is a grid: h( , ) and v( , ) are relations representing bijections such that   

domino     sat-fo  (domino has a solution i       satis   able)

1. there is a grid: h( , ) and v( , ) are relations representing bijections such that   

   

v

h

domino     sat-fo  (domino has a solution i       satis   able)

1. there is a grid: h( , ) and v( , ) are relations representing bijections such that   

   

v

   

v

h

h

domino     sat-fo  (domino has a solution i       satis   able)

1. there is a grid: h( , ) and v( , ) are relations representing bijections such that   

v

.
 
.
 
.

v

v

v

h

h

h

h

v

.
 
.
 
.

v

v

v

h

h

h

h

v

.
 
.
 
.

v

v

v

h

h

. . .

. . .

h

h

. . .

h

h

. . .

h

h

. . .

v

v

v

v

domino     sat-fo  (domino has a solution i       satis   able)

1. there is a grid: h( , ) and v( , ) are relations representing bijections such that   

v

.
 
.
 
.

v

v

v

h

h

h

h

v

.
 
.
 
.

v

v

v

h

h

h

h

v

.
 
.
 
.

v

v

v

h

h

. . .

. . .

h

h

. . .

h

h

. . .

h

h

. . .

v

v

v

v

2. assign one domino to each node: 
    a unary relation   

d ( x )

    for each domino

   
   
   
domino     sat-fo  (domino has a solution i       satis   able)

1. there is a grid: h( , ) and v( , ) are relations representing bijections such that   

v

.
 
.
 
.

v

v

v

h

h

h

h

v

.
 
.
 
.

v

v

v

h

h

h

h

v

.
 
.
 
.

v

v

v

h

h

. . .

. . .

h

h

. . .

h

h

. . .

h

h

. . .

v

v

v

v

2. assign one domino to each node: 
    a unary relation   

d ( x )

    for each domino

3. match the sides                x,y 
    if h(x,y), then da(x)     db(y)  
    for some dominos a,b that    match      
    horizontally         (idem vertically)

   
   
   
domino     sat-fo  (domino has a solution i       satis   able)

1. there is a grid: h( , ) and v( , ) are relations representing bijections such that   

v

.
 
.
 
.

v

v

v

h

h

h

h

v

.
 
.
 
.

v

v

v

h

h

h

h

v

.
 
.
 
.

v

v

v

h

h

. . .

. . .

h

h

. . .

h

h

. . .

h

h

. . .

v

v

v

v

4. borders are white.

2. assign one domino to each node: 
    a unary relation   

d ( x )

    for each domino

3. match the sides                x,y 
    if h(x,y), then da(x)     db(y)  
    for some dominos a,b that    match      
    horizontally         (idem vertically)

   
   
   
algorithmic problems for fo

evaluation problem:      given a fo formula   (x1,    , xn),  
                                              a graph g, and a binding   , does g          ?

decidable     foundations of the database industry

satis   ability problem:   given a fo formula   , is there a graph g  
                                               and binding   , such that g         ?

     undecidable     both for     and    finite

equivalence problem:    given fo formulae   ,  , is  
                                                        g           i      g          
                                               for all graphs g and bindings   ?

     undecidable     by reduction to the satisfiability problem

18

algorithmic problems for fo

equivalence problem:    given fo formulae   ,  , is  
                                                        g           i      g          
                                               for all graphs g and bindings   ?

     undecidable     by reduction from the satisfiability problem

19

algorithmic problems for fo

   is satis   able  i        is not equivalent to    
satis   ability problem undecidable       equivalence problem undecidable

equivalence problem:    given fo formulae   ,  , is  
                                                        g           i      g          
                                               for all graphs g and bindings   ?

     undecidable     by reduction from the satisfiability problem

19

algorithmic problems for fo

   is satis   able  i        is not equivalent to    
satis   ability problem undecidable       equivalence problem undecidable
actually, there are reductions in both senses: 
  (x1,   ,xn) and   (y1,   ,ym) are  equivalent  i     
        n=m 
         (x1=y1)                (xn=yn)       (x1,   ,xn)         (y1,   ,yn) is unsatis   able 
         (x1=y1)                (xn=yn)       (x1,   ,xn)         (y1,   ,yn) is unsatis   able

equivalence problem:    given fo formulae   ,  , is  
                                                        g           i      g          
                                               for all graphs g and bindings   ?

     undecidable     by reduction from the satisfiability problem

19

algorithmic problems for fo

evaluation problem:      given a fo formula   (x1,    , xn),  
                                      a graph g, and a binding   , does g          ?
decidable     foundations of the database industry

satis   ability problem:   given a fo formula   , is there a graph g  
                                      and binding   , such that g         ?

     undecidable     both for     and    finite

equivalence problem:    given fo formulae   ,  , is  
                                                        g           i      g          
                                               for all graphs g and bindings   ?

     undecidable     by reduction to the satisfiability problem

20

evaluation problem for fo

input:

  (x1,   ,xn) 
g = (v,e) 
   = {x1,   ,xn}     v

output:

g          ?

21

evaluation problem for fo

input:

  (x1,   ,xn) 
g = (v,e) 
   = {x1,   ,xn}     v

encoding of g = (v, e)

output:

g          ?

    each node is coded with a bit string of size log(|v|), 
    edge set is encoded by its tuples, e.g. (100,101), (010, 010),    

cost of coding: ||g|| = |e|  2  log(|v|)     |v| (mod a polynomial)

21

evaluation problem for fo

input:

  (x1,   ,xn) 
g = (v,e) 
   = {x1,   ,xn}     v

encoding of g = (v, e)

output:

g          ?

    each node is coded with a bit string of size log(|v|), 
    edge set is encoded by its tuples, e.g. (100,101), (010, 010),    

cost of coding: ||g|| = |e|  2  log(|v|)     |v| (mod a polynomial)

encoding of    = {x1,   ,xn}     v

    each node is coded with a bit string of size log(|v|),

cost of coding: ||  || = n  log(|v|)

21

evaluation problem for fo

input:

  (x1,   ,xn) 
g = (v,e) 
   = {x1,   ,xn}     v

output:

g          ?

22

evaluation problem for fo

input:

  (x1,   ,xn) 
g = (v,e) 
   = {x1,   ,xn}     v

   

   

   

   

if   (x1,   ,xn) = e(xi,xj):   
answer yes  i     (  (xi),  (xj))     e   
if   (x1,   ,xn) =   (x1,   ,xn)       '(x1,   ,xn):   
answer yes  i     g          and g         '    
if   (x1,   ,xn) =     (x1,   ,xn):   
answer no  i     g             
if   (x1,   ,xn) =    y .   (x1,   ,xn,y):   
answer yes  i     for some v     v and   '=        {y   v}   
                         we have g      '   .

output:

g          ?

22

evaluation problem for fo

input:

  (x1,   ,xn) 
g = (v,e) 
   = {x1,   ,xn}     v

   

   

   

   

if   (x1,   ,xn) = e(xi,xj):   
answer yes  i     (  (xi),  (xj))     e   
if   (x1,   ,xn) =   (x1,   ,xn)       '(x1,   ,xn):   
answer yes  i     g          and g         '    
if   (x1,   ,xn) =     (x1,   ,xn):   
answer no  i     g             
if   (x1,   ,xn) =    y .   (x1,   ,xn,y):   
answer yes  i     for some v     v and   '=        {y   v}   
                         we have g      '   .

question:   
how much space   
does it take?

output:

g          ?

22

evaluation problem for fo

input:

  (x1,   ,xn) 
g = (v,e) 
   = {x1,   ,xn}     v

   

   

   

   

if   (x1,   ,xn) = e(xi,xj):   
answer yes  i     (  (xi),  (xj))     e   
if   (x1,   ,xn) =   (x1,   ,xn)       '(x1,   ,xn):   
answer yes  i     g          and g         '    
if   (x1,   ,xn) =     (x1,   ,xn):   
answer no  i     g             
if   (x1,   ,xn) =    y .   (x1,   ,xn,y):   
answer yes  i     for some v     v and   '=        {y   v}   
                         we have g      '   .

question:   
how much space   
does it take?

output:

g          ?

use 4 pointers       logspace

22

output:

g          ?

use 4 pointers       logspace

     max( space(g         )), space(g         ')) )

evaluation problem for fo

input:

  (x1,   ,xn) 
g = (v,e) 
   = {x1,   ,xn}     v

   

   

   

   

if   (x1,   ,xn) = e(xi,xj):   
answer yes  i     (  (xi),  (xj))     e   
if   (x1,   ,xn) =   (x1,   ,xn)       '(x1,   ,xn):   
answer yes  i     g          and g         '    
if   (x1,   ,xn) =     (x1,   ,xn):   
answer no  i     g             
if   (x1,   ,xn) =    y .   (x1,   ,xn,y):   
answer yes  i     for some v     v and   '=        {y   v}   
                         we have g      '   .

question:   
how much space   
does it take?

22

evaluation problem for fo

input:

  (x1,   ,xn) 
g = (v,e) 
   = {x1,   ,xn}     v

   

   

   

   

if   (x1,   ,xn) = e(xi,xj):   
answer yes  i     (  (xi),  (xj))     e   
if   (x1,   ,xn) =   (x1,   ,xn)       '(x1,   ,xn):   
answer yes  i     g          and g         '    
if   (x1,   ,xn) =     (x1,   ,xn):   
answer no  i     g             
if   (x1,   ,xn) =    y .   (x1,   ,xn,y):   
answer yes  i     for some v     v and   '=        {y   v}   
                         we have g      '   .

question:   
how much space   
does it take?

output:

g          ?

use 4 pointers       logspace

     max( space(g         )), space(g         ')) )

     space(g         ))

22

evaluation problem for fo

input:

  (x1,   ,xn) 
g = (v,e) 
   = {x1,   ,xn}     v

   

   

   

   

if   (x1,   ,xn) = e(xi,xj):   
answer yes  i     (  (xi),  (xj))     e   
if   (x1,   ,xn) =   (x1,   ,xn)       '(x1,   ,xn):   
answer yes  i     g          and g         '    
if   (x1,   ,xn) =     (x1,   ,xn):   
answer no  i     g             
if   (x1,   ,xn) =    y .   (x1,   ,xn,y):   
answer yes  i     for some v     v and   '=        {y   v}   
                         we have g      '   .

question:   
how much space   
does it take?

output:

g          ?

use 4 pointers       logspace

     max( space(g         )), space(g         ')) )

     space(g         ))

     2  log(|g|) + space(g      '    )

22

evaluation problem for fo

input:

  (x1,   ,xn) 
g = (v,e) 
   = {x1,   ,xn}     v

   

   

   

   

if   (x1,   ,xn) = e(xi,xj):   
answer yes  i     (  (xi),  (xj))     e   
if   (x1,   ,xn) =   (x1,   ,xn)       '(x1,   ,xn):   
answer yes  i     g          and g         '    
if   (x1,   ,xn) =     (x1,   ,xn):   
answer no  i     g             
if   (x1,   ,xn) =    y .   (x1,   ,xn,y):   
answer yes  i     for some v     v and   '=        {y   v}   
                         we have g      '   .

output:

g          ?

use 4 pointers       logspace

     max( space(g         )), space(g         ')) )

     space(g         ))

     2  log(|g|) + space(g      '    )

question:   
how much space   
does it take?

2  log(|g|) +        + 2  log(|g|) + k  log(|  |+|g|) space

    |  | times

22

evaluation problem for fo

in pspace

input:

  (x1,   ,xn) 
g = (v,e) 
   = {x1,   ,xn}     v

   

   

   

   

if   (x1,   ,xn) = e(xi,xj):   
answer yes  i     (  (xi),  (xj))     e   
if   (x1,   ,xn) =   (x1,   ,xn)       '(x1,   ,xn):   
answer yes  i     g          and g         '    
if   (x1,   ,xn) =     (x1,   ,xn):   
answer no  i     g             
if   (x1,   ,xn) =    y .   (x1,   ,xn,y):   
answer yes  i     for some v     v and   '=        {y   v}   
                         we have g      '   .

output:

g          ?

use 4 pointers       logspace

     max( space(g         )), space(g         ')) )

     space(g         ))

     2  log(|g|) + space(g      '    )

question:   
how much space   
does it take?

2  log(|g|) +        + 2  log(|g|) + k  log(|  |+|g|) space

    |  | times

22

evaluation pb for fo is pspace-complete 

 pspace-complete problem: qbf 

qbf = a boolean formula with quantification over the truth values (t,f)

(satisfaction of  quantified boolean formulas)

23

evaluation pb for fo is pspace-complete 

 pspace-complete problem: qbf 

qbf = a boolean formula with quantification over the truth values (t,f)

(satisfaction of  quantified boolean formulas)

   p    q . (p       q)    where p,q range over {t,f}

23

evaluation pb for fo is pspace-complete 

 pspace-complete problem: qbf 

qbf = a boolean formula with quantification over the truth values (t,f)

(satisfaction of  quantified boolean formulas)

   p    q . (p       q)    where p,q range over {t,f}

theorem: evaluation for fo is pspace-complete (combined c.)

23

evaluation pb for fo is pspace-complete 

 pspace-complete problem: qbf 

qbf = a boolean formula with quantification over the truth values (t,f)

(satisfaction of  quantified boolean formulas)

   p    q . (p       q)    where p,q range over {t,f}

theorem: evaluation for fo is pspace-complete (combined c.)

polynomial reduction qbf     fo :

1. given        qbf,   
               let   '(x) be the replacement    
               of each    p    with    p=x    in   .

2. note:    x   ' holds in a 2-element 

graph  i        is qbf-satis   able

3. test if  g          '  for g=({v,v'},{})

23

evaluation pb for fo is pspace-complete 

 pspace-complete problem: qbf 

qbf = a boolean formula with quantification over the truth values (t,f)

(satisfaction of  quantified boolean formulas)

   p    q . (p       q)    where p,q range over {t,f}

theorem: evaluation for fo is pspace-complete (combined c.)

polynomial reduction qbf     fo :
  '(x)=   p    q . ( (p=x)       (q=x) )

1. given        qbf,   
               let   '(x) be the replacement    
               of each    p    with    p=x    in   .

2. note:    x   ' holds in a 2-element 

graph  i        is qbf-satis   able

3. test if  g          '  for g=({v,v'},{})

23

evaluation pb for fo is pspace-complete 

 pspace-complete problem: qbf 

qbf = a boolean formula with quantification over the truth values (t,f)

(satisfaction of  quantified boolean formulas)

   p    q . (p       q)    where p,q range over {t,f}

theorem: evaluation for fo is pspace-complete (combined c.)

polynomial reduction qbf     fo :
  '(x)=   p    q . ( (p=x)       (q=x) )

1. given        qbf,   
               let   '(x) be the replacement    
               of each    p    with    p=x    in   .

   x    p    q . ( (p=x)       (q=x) )

2. note:    x   ' holds in a 2-element 

graph  i        is qbf-satis   able

3. test if  g          '  for g=({v,v'},{})

23

combined, query, and data complexities 

[vardi, 1982]

problem: usual scenario in database

a database of size 106

a query of size 100

input:

24

combined, query, and data complexities 

[vardi, 1982]

problem: usual scenario in database

a database of size 106

a query of size 100

input:

query +

24

combined, query, and data complexities 

[vardi, 1982]

problem: usual scenario in database

a database of size 106

a query of size 100

input:

query +

database

24

combined, query, and data complexities 

[vardi, 1982]

problem: usual scenario in database

a database of size 106

a query of size 100

input:

query +

database

but we don   t distinguish this in the analysis:

time(2|query| + |data|)

=

time(|query| + 2|data|)

24

combined, query, and data complexities 

[vardi, 1982]

query and data play very di   erent roles.

separation of concerns:    how the resources grow with respect to 

                                                     the size of the data 

                                                     the query size

25

combined, query, and data complexities 

combined complexity: input size is |query| + |data|

query complexity (|data| fixed): input size is |query|

data complexity (|query| fixed): input size is |data|

26

combined, query, and data complexities 

combined complexity: input size is |query| + |data|

query complexity (|data| fixed): input size is |query|

data complexity (|query| fixed): input size is |data|

o(2|query| + |data|) is 

o(|query| + 2|data|) is 

exponential in combined complexity 
exponential in query complexity 
linear in data complexity

exponential in combined complexity 
linear in query complexity 
exponential in data complexity

26

question

what is the data, query and combined complexity 
for the evaluation problem for fo?

remember:

data complexity, input size: |data|
query complexity, input size: |query|
combined complexity, input size: |data| + |query|

|  |    2    log(|g|) + k  log(|  |+|g|) space

27

question

what is the data, query and combined complexity 
for the evaluation problem for fo?

remember:

data complexity, input size: |data|
query complexity, input size: |query|
combined complexity, input size: |data| + |query|

|  |    2    log(|g|) + k  log(|  |+|g|) space

query

data

o(log(|data|)  |query|) space pspace combined and query complexity

logspace data complexity

27

recap

equivalence-ra

equivalence-sql

equivalence-fo

sat-fo

eval-fo 
(combined)

domino

qbf

undecidable

pspace

eval-fo 
(data)

logspace

28

trading expressiveness for e   ciency

expressiveness

efficiency

alternation of quanti   ers signi   cantly a   ects complexity 
(recall that evaluation of qbf is pspace-complete:     x    y    z    w       ). 

what happens if we disallow     and    ? 

29

   
the class np

logspace           ptime                  pspace           exptime

   

30

the class np

logspace           ptime                  pspace           exptime
np  =  problems whose solutions can be witnessed by a  certificate   
              to be guessed and checked in polynomial time  (e.g. a colouring)

    np    

30

the class np

logspace           ptime                  pspace           exptime
np  =  problems whose solutions can be witnessed by a  certificate   
              to be guessed and checked in polynomial time  (e.g. a colouring)

    np    

 examples: 

    3-colorability:   given a graph g, can we assign a colour from {r,g,b} to each node   
                                              so that adjacent nodes have always di   erent colours ?   
    sat: given a propositional formula, e.g. (p       q     r)     (  p     s )     (  s       p),   
           can we assign a truth value to each variable so that the formula becomes true ?   
    money-change: given an amount of money a and a set of coins {b1,    , bn},   
                                            can we    nd a subset s     {b1,    , bn} such that     s = a ?

30

the class np

logspace           ptime                  pspace           exptime
np  =  problems whose solutions can be witnessed by a  certificate   
              to be guessed and checked in polynomial time  (e.g. a colouring)

    np    

31

the class np

logspace           ptime                  pspace           exptime
np  =  problems whose solutions can be witnessed by a  certificate   
              to be guessed and checked in polynomial time  (e.g. a colouring)

    np    

initial con   guration

final   

con   guration

31

the class np

logspace           ptime                  pspace           exptime
np  =  problems whose solutions can be witnessed by a  certificate   
              to be guessed and checked in polynomial time  (e.g. a colouring)

    np    

initial con   guration

final   

con   guration

final   

con   guration

final   

con   guration

31

the class np

logspace           ptime                  pspace           exptime
np  =  problems whose solutions can be witnessed by a  certificate   
              to be guessed and checked in polynomial time  (e.g. a colouring)

    np    

initial con   guration

non-deterministic transitions

final   

con   guration

final   

con   guration

final   

con   guration

31

the class np

logspace           ptime                  pspace           exptime
np  =  problems whose solutions can be witnessed by a  certificate   
              to be guessed and checked in polynomial time  (e.g. a colouring)

    np    

initial con   guration

non-deterministic transitions
many paths,  each has length   
bounded by a polynomial

final   

con   guration

final   

con   guration

final   

con   guration

31

the class np

logspace           ptime                  pspace           exptime
np  =  problems whose solutions can be witnessed by a  certificate   
              to be guessed and checked in polynomial time  (e.g. a colouring)

    np    

initial con   guration

non-deterministic transitions
many paths,  each has length   
bounded by a polynomial

a solution exists if there is  
at least a successful path.

final   

con   guration

final   

con   guration

final   

con   guration

31

question

consider:

positive fo  =  fo without    ,  

e.g.      =     x     y     z .  (e(x, y)     e(y, z))     ( y=z     e(x, z))

what is the complexity of evaluating positive fo on graphs ?

32

question

consider:

positive fo  =  fo without    ,  

e.g.      =     x     y     z .  (e(x, y)     e(y, z))     ( y=z     e(x, z))

what is the complexity of evaluating positive fo on graphs ?

solution

this is in np:    given    and g=(v, e) 
                              it su   ces to guess a binding    : { x, y, z,     }     v    
                              and then verify that the formula holds.

32

conjunctive queries

def.

cq  =  fo without    ,  ,   

eg:          (x, y) =      z . (parent(x, z)     parent(z, y))

usual notation:    grandparent(x,y)  :     parent(x,z), parent(z,y)   

33

conjunctive queries

def.

cq  =  fo without    ,  ,   

normal form:           x1,    , xn .   (x1,    , xn)    

quanti   er-free and no equalities!

eg:          (x, y) =      z . (parent(x, z)     parent(z, y))

usual notation:    grandparent(x,y)  :     parent(x,z), parent(z,y)   

33

conjunctive queries

def.

cq  =  fo without    ,  ,   

normal form:           x1,    , xn .   (x1,    , xn)    

quanti   er-free and no equalities!

eg:          (x, y) =      z . (parent(x, z)     parent(z, y))

usual notation:    grandparent(x,y)  :     parent(x,z), parent(z,y)   

it corresponds to positive  
   select-from-where    sql queries
select   ...   
from   ...   
where   z

no negation or disjunction

it corresponds to      -  -      ra queries

  x(  z(r1            rn))

no negation

33

bibliography

abiteboul, hull, vianu,    foundations of databases   , addison-wesley, 1995. 

(freely available at http://webdam.inria.fr/alice/)

chapters 1, 2, 3

34

