community

   news
   beta
   tutorials
   cheat sheets
   open courses
   podcast - dataframed
   chat
   new

datacamp

   official blog
   tech thoughts
   (button)
   search
   [1](button)
   log in
   (button)
   create account
   (button)
   share an article
   (button)
   back to tutorials
   tutorials
   [2]0
   61
   61
   andrew brooks
   september 12th, 2017
   python
   +2

graph optimization with networkx in python

   this networkx tutorial will show you how to do graph optimization in
   python by solving the chinese postman problem in python.

   [giant-state-park-1_eygeqt.png]

   with this tutorial, you'll tackle an established problem in graph
   theory called the chinese postman problem. there are some components of
   the algorithm that while conceptually simple, turn out to be
   computationally rigorous. however, for this tutorial, only some prior
   knowledge of python is required: no rigorous math, computer science or
   id207 background is needed.

   this tutorial will first go over the basic building blocks of graphs
   (nodes, edges, paths, etc) and solve the problem on a real graph (trail
   network of a state park) using the [3]networkx library in python.
   you'll focus on the core concepts and implementation. for the
   interested reader, further reading on the guts of the optimization are
   provided.

     * [4]motivating graph optimization
          + the problem
          + personal motivation
     * [5]introducing graphs
          + introducing networkx
          + installing packages
     * [6]load data
     * [7]create graph
     * [8]inspect graph
     * [9]visualize graph
     * [10]solving the cpp
          + overview of cpp algorithm
          + assumptions and simplifications
          + cpp step 1: find nodes of odd degree
          + cpp step 2: find min distance pairs
          + cpp step 3: compute eulerian circuit
          + compute cpp solution
          + visualize cpp solution
     * [11]next steps
     * [12]references

motivating graph optimization

the problem

   you've probably heard of the [13]travelling salesman problem which
   amounts to finding the shortest route (say, roads) that connects a set
   of nodes (say, cities). although lesser known, the [14]chinese postman
   problem (cpp), also referred to as the route inspection or arc routing
   problem, is quite similar. the objective of the cpp is to find the
   shortest path that covers all the links (roads) on a graph at least
   once. if this is possible without doubling back on the same road twice,
   great; that's the ideal scenario and the problem is quite simple.
   however, if some roads must be traversed more than once, you need some
   math to find the shortest route that hits every road at least once with
   the lowest total mileage.

personal motivation

   (the following is a personal note: cheesy, cheeky and 100% not
   necessary for learning graph optimization in python)

   i had a real-life application for solving this problem: attaining the
   rank of giantmaster marathoner.

   what is a giantmaster? a [15]giantmaster is one (canine or human) who
   has hiked every trail of sleeping giant state park in hamden ct
   (neighbor to my hometown of wallingford)... in their lifetime. a
   giantmaster marathoner is one who has hiked all these trails in a
   single day.

   thanks to the fastidious record keeping of the sleeping giant park
   association, the full roster of giantmasters and their level of
   giantmastering can be found [16]here. i have to admit this motivated me
   quite a bit to kick-start this side-project and get out there to run
   the trails. while i myself achieved giantmaster status in the winter of
   2006 when i was a budding young volunteer of the sleeping giant trail
   crew (which i was pleased to see recorded in the [17]sg archive), new
   challenges have since arisen. while the 12-month and 4-season
   giantmaster categories are impressive and enticing, they'd also require
   more travel from my current home (dc) to my formative home (ct) than i
   could reasonably manage... and they're not as interesting for graph
   optimization, so giantmaster marathon it is!

   for another reference, the sleeping giant trail map is provided below:

   iframe:
   [18]https://s3.amazonaws.com/assets.datacamp.com/blog_assets/network+op
   timization/sleepgiant.pdf

introducing graphs

   the nice thing about graphs is that the concepts and terminology are
   generally intuitive. nonetheless, here's some of the basic lingo:

   graphs are structures that map relations between objects. the objects
   are referred to as nodes and the connections between them as edges in
   this tutorial. note that edges and nodes are commonly referred to by
   several names that generally mean exactly the same thing:
node == vertex == point
edge == arc == link

   the starting graph is undirected. that is, your edges have no
   orientation: they are bi-directional. for example: a<--->b == b<--->a.
   by contrast, the graph you might create to specify the shortest path to
   hike every trail could be a directed graph, where the order and
   direction of edges matters. for example: a--->b != b--->a.

   the graph is also an edge-weighted graph where the distance (in miles)
   between each pair of adjacent nodes represents the weight of an edge.
   this is handled as an edge attribute named "distance".

   degree refers to the number of edges incident to (touching) a node.
   nodes are referred to as odd-degree nodes when this number is odd and
   even-degree when even.

   the solution to this cpp problem will be a eulerian tour: a graph where
   a cycle that passes through every edge exactly once can be made from a
   starting node back to itself (without backtracking). an euler tour is
   also known by several names:
eulerian tour == eulerian circuit == eulerian cycle

   a matching is a subset of edges in which no node occurs more than once.
   a minimum weight matching finds the matching with the lowest possible
   summed edge weight.

networkx: graph manipulation and analysis

   networkx is the most popular python package for manipulating and
   analyzing graphs. several packages offer the same basic level of graph
   manipulation, notably igraph which also has bindings for r and c++.
   however, i found that networkx had the strongest graph algorithms that
   i needed to solve the cpp.

installing packages

   if you've done any sort of data analysis in python or have the anaconda
   distribution, my guess is you probably have pandas and matplotlib.
   however, you might not have networkx. these should be the only
   dependencies outside the python standard library that you'll need to
   run through this tutorial. they are easy to install with pip:
pip install pandas
pip install networkx
pip install matplotlib

   these should be all the packages you'll need for now. imageio and numpy
   are imported at the very end to create the gif animation of the cpp
   solution. the animation is embedded within this post, so these packages
   are optional.
import itertools
import copy
import networkx as nx
import pandas as pd
import matplotlib.pyplot as plt

load data

edge list

   the edge list is a simple data structure that you'll use to create the
   graph. each row represents a single edge of the graph with some edge
   attributes.
     * node1 & node2: names of the nodes connected.
     * trail: edge attribute indicating the abbreviated name of the trail
       for each edge. for example: rs = red square
     * distance: edge attribute indicating trail length in miles.
     * color: trail color used for plotting.
     * estimate: edge attribute indicating whether the edge distance is
       estimated from eyeballing the trailmap (1=yes, 0=no) as some
       distances are not provided. this is solely for reference; it is not
       used for analysis.

# grab edge list data hosted on gist
edgelist = pd.read_csv('https://gist.githubusercontent.com/brooksandrew/e570c38b
cc72a8d102422f2af836513b/raw/89c76b2563dbc0e88384719a35cba0dfc04cd522/edgelist_s
leeping_giant.csv')

# preview edgelist
edgelist.head(10)

        node1        node2     trail distance color estimate
   0 rs_end_north v_rs         rs    0.30     red   0
   1 v_rs         b_rs         rs    0.21     red   0
   2 b_rs         g_rs         rs    0.11     red   0
   3 g_rs         w_rs         rs    0.18     red   0
   4 w_rs         o_rs         rs    0.21     red   0
   5 o_rs         y_rs         rs    0.12     red   0
   6 y_rs         rs_end_south rs    0.39     red   0
   7 rc_end_north v_rc         rc    0.70     red   0
   8 v_rc         b_rc         rc    0.04     red   0
   9 b_rc         g_rc         rc    0.15     red   0

node list

   node lists are usually optional in networkx and other graph libraries
   when edge lists are provided because the node names are provided in the
   edge list's first two columns. however, in this case, there are some
   node attributes that we'd like to add: x, y coordinates of the nodes
   (trail intersections) so that you can plot your graph with the same
   layout as the trail map.

   i spent an afternoon annotating these manually by tracing over the
   image with [19]gimp:
     * id: name of the node corresponding to node1 and node2 in the edge
       list.
     * x: horizontal position/coordinate of the node relative to the
       topleft.
     * y vertical position/coordinate of the node relative to the topleft.

note on generating the node & edge lists

   creating the node names also took some manual effort. each node
   represents an intersection of two or more trails. where possible, the
   node is named by trail1_trail2 where trail1 precedes trail2 in
   alphabetical order.

   things got a little more difficult when the same trails intersected
   each other more than once. for example, the orange and white trail. in
   these cases, i appended a _2 or _3 to the node name. for example, you
   have two distinct node names for the two distinct intersections of
   orange and white: o_w and o_w_2.

   this took a lot of trial and error and comparing the plots generated
   with x,y coordinates to the real trail map.
# grab node list data hosted on gist
nodelist = pd.read_csv('https://gist.githubusercontent.com/brooksandrew/f989e10a
f17fb4c85b11409fea47895b/raw/a3a8da0fa5b094f1ca9d82e1642b384889ae16e8/nodelist_s
leeping_giant.csv')

# preview nodelist
nodelist.head(5)

         id      x    y
   0 b_bv       1486 732
   1 b_bw       716  1357
   2 b_end_east 3164 1111
   3 b_end_west 141  1938
   4 b_g        1725 771

create graph

   now you use the edge list and the node list to create a graph object in
   networkx.
# create empty graph
g = nx.graph()

   loop through the rows of the edge list and add each edge and its
   corresponding attributes to graph g.
# add edges and edge attributes
for i, elrow in edgelist.iterrows():
    g.add_edge(elrow[0], elrow[1], attr_dict=elrow[2:].to_dict())

   to illustrate what's happening here, let's print the values from the
   last row in the edge list that got added to graph g:
# edge list example
print(elrow[0]) # node1
print(elrow[1]) # node2
print(elrow[2:].to_dict()) # edge attribute dict

o_gy2
y_gy2
{'color': 'yellowgreen', 'estimate': 0, 'trail': 'gy2', 'distance': 0.12}

   similarly, you loop through the rows in the node list and add these
   node attributes.
# add node attributes
for i, nlrow in nodelist.iterrows():
    g.node[nlrow['id']] = nlrow[1:].to_dict()

   here's an example from the last row of the node list:
# node list example
print(nlrow)

id    y_rt
x      977
y     1666
name: 76, dtype: object

inspect graph

edges

   your graph edges are represented by a list of tuples of length 3. the
   first two elements are the node names linked by the edge. the third is
   the dictionary of edge attributes.
# preview first 5 edges
g.edges(data=true)[0:5]

[('rs_end_south',
  'y_rs',
  {'color': 'red', 'distance': 0.39, 'estimate': 0, 'trail': 'rs'}),
 ('w_gy2',
  'park_east',
  {'color': 'gray', 'distance': 0.12, 'estimate': 0, 'trail': 'w'}),
 ('w_gy2',
  'g_gy2',
  {'color': 'yellowgreen', 'distance': 0.05, 'estimate': 0, 'trail': 'gy2'}),
 ('w_gy2',
  'b_w',
  {'color': 'gray', 'distance': 0.42, 'estimate': 0, 'trail': 'w'}),
 ('w_gy2',
  'b_gy2',
  {'color': 'yellowgreen', 'distance': 0.03, 'estimate': 1, 'trail': 'gy2'})]

nodes

   similarly, your nodes are represented by a list of tuples of length 2.
   the first element is the node id, followed by the dictionary of node
   attributes.
# preview first 10 nodes
g.nodes(data=true)[0:10]

[('rs_end_south', {'x': 1865, 'y': 1598}),
 ('w_gy2', {'x': 2000, 'y': 954}),
 ('rd_end_south_dupe', {'x': 273, 'y': 1869}),
 ('w_gy1', {'x': 1184, 'y': 1445}),
 ('g_rt', {'x': 908, 'y': 1378}),
 ('v_rd', {'x': 258, 'y': 1684}),
 ('g_rs', {'x': 1676, 'y': 775}),
 ('rc_end_north', {'x': 867, 'y': 618}),
 ('v_end_east', {'x': 2131, 'y': 921}),
 ('rh_end_south', {'x': 721, 'y': 1925})]

summary stats

   print out some summary statistics before visualizing the graph.
print('# of edges: {}'.format(g.number_of_edges()))
print('# of nodes: {}'.format(g.number_of_nodes()))

# of edges: 123
# of nodes: 77

visualize

manipulate colors and layout

   positions: first you need to manipulate the node positions from the
   graph into a dictionary. this will allow you to recreate the graph
   using the same layout as the actual trail map. y is negated to
   transform the y-axis origin from the topleft to the bottoid113ft.
# define node positions data structure (dict) for plotting
node_positions = {node[0]: (node[1]['x'], -node[1]['y']) for node in g.nodes(dat
a=true)}

# preview of node_positions with a bit of hack (there is no head/slice method fo
r dictionaries).
dict(list(node_positions.items())[0:5])

{'b_rd': (268, -1744),
 'g_rt': (908, -1378),
 'o_gy1': (1130, -1297),
 'rh_end_tt_2': (550, -1608),
 'rs_end_south': (1865, -1598)}

   colors: now you manipulate the edge colors from the graph into a simple
   list so that you can visualize the trails by their color.
# define data structure (list) of edge colors for plotting
edge_colors = [e[2]['color'] for e in g.edges(data=true)]

# preview first 10
edge_colors[0:10]

['red',
 'gray',
 'yellowgreen',
 'gray',
 'yellowgreen',
 'blue',
 'black',
 'yellowgreen',
 'gray',
 'gray']

plot

   now you can make a nice plot that lines up nicely with the sleeping
   giant trail map:
plt.figure(figsize=(8, 6))
nx.draw(g, pos=node_positions, edge_color=edge_colors, node_size=10, node_color=
'black')
plt.title('graph representation of sleeping giant trail map', size=15)
plt.show()

   graph optimization in python

   this graph representation obviously doesn't capture all the trails'
   bends and squiggles, however not to worry: these are accurately
   captured in the edge distance attribute which is used for computation.
   the visual does capture distance between nodes (trail intersections) as
   the crow flies, which appears to be a decent approximation.

overview of cpp algorithm

   ok, so now that you've defined some terms and created the graph, how do
   you find the shortest path through it?

   solving the chinese postman problem is quite simple conceptually:
    1. find all nodes with odd degree (very easy).
       (find all trail intersections where the number of trails touching
       that intersection is an odd number)
    2. add edges to the graph such that all nodes of odd degree are made
       even. these added edges must be duplicates from the original graph
       (we'll assume no bushwhacking for this problem). the set of edges
       added should sum to the minimum distance possible (hard...np-hard
       to be precise).
       (in simpler terms, minimize the amount of double backing on a route
       that hits every trail)
    3. given a starting point, find the eulerian tour over the augmented
       dataset (moderately easy).
       (once we know which trails we'll be double backing on, actually
       calculate the route from beginning to end)

assumptions and simplifications

   while a shorter and more precise path could be generated by relaxing
   the assumptions below, this would add complexity beyond the scope of
   this tutorial which focuses on the cpp.

   assumption 1: required trails only

   as you can see from the trail map above, there are roads along the
   borders of the park that could be used to connect trails, particularly
   the red trails. there are also some trails (horseshoe and unmarked
   blazes) which are not required per the [20]giantmaster log, but could
   be helpful to prevent lengthy double backing. the inclusion of optional
   trails is actually an established variant of the cpp called the
   [21]rural postman problem. we ignore optional trails in this tutorial
   and focus on required trails only.

   assumption 2: uphill == downhill

   the cpp assumes that the cost of walking a trail is equivalent to its
   distance, regardless of which direction it is walked. however, some of
   these trails are rather hilly and will require more energy to walk up
   than down. some metric that combines both distance and elevation change
   over a directed graph could be incorporated into an extension of the
   cpp called the [22]windy postman problem.

   assumption 3: no parallel edges (trails)

   while possible, the inclusion of parallel edges (multiple trails
   connecting the same two nodes) adds complexity to computation. luckily
   this only occurs twice here (blue <=> red diamond and blue <=> tower
   trail). this is addressed by a bit of a hack to the edge list:
   duplicate nodes are included with a _dupe suffix to capture every trail
   while maintaining uniqueness in the edges. the cpp implementation in
   the [23]postman_problems package i wrote robustly handles parallel
   edges in a more elegant way if you'd like to solve the cpp on your own
   graph with many parallel edges.

cpp step 1: find nodes of odd degree

   this is a pretty straightforward counting computation. you see that 36
   of the 76 nodes have odd degree. these are mostly the dead-end trails
   (degree 1) and intersections of 3 trails. there are a handful of degree
   5 nodes.
# calculate list of nodes with odd degree
nodes_odd_degree = [v for v, d in g.degree_iter() if d % 2 == 1]

# preview
nodes_odd_degree[0:5]

['rs_end_south', 'rc_end_north', 'v_end_east', 'rh_end_south', 'b_end_east']

# counts
print('number of nodes of odd degree: {}'.format(len(nodes_odd_degree)))
print('number of total nodes: {}'.format(len(g.nodes())))

number of nodes of odd degree: 36
number of total nodes: 77

cpp step 2: find min distance pairs

   this is really the meat of the problem. you'll break it down into 5
   parts:
    1. compute all possible pairs of odd degree nodes.
    2. compute the shortest path between each node pair calculated in 1.
    3. create a [24]complete graph connecting every node pair in 1. with
       shortest path distance attributes calculated in 2.
    4. compute a [25]minimum weight matching of the graph calculated in 3.
       (this boils down to determining how to pair the odd nodes such that
       the sum of the distance between the pairs is as small as possible).
    5. augment the original graph with the shortest paths between the node
       pairs calculated in 4.

step 2.1: compute node pairs

   you use the itertools combination function to compute all possible
   pairs of the odd degree nodes. your graph is undirected, so we don't
   care about order: for example, (a,b) == (b,a).
# compute all pairs of odd nodes. in a list of tuples
odd_node_pairs = list(itertools.combinations(nodes_odd_degree, 2))

# preview pairs of odd degree nodes
odd_node_pairs[0:10]

[('rs_end_south', 'rc_end_north'),
 ('rs_end_south', 'v_end_east'),
 ('rs_end_south', 'rh_end_south'),
 ('rs_end_south', 'b_end_east'),
 ('rs_end_south', 'b_bv'),
 ('rs_end_south', 'rt_end_south'),
 ('rs_end_south', 'o_rt'),
 ('rs_end_south', 'y_rt'),
 ('rs_end_south', 'g_gy2'),
 ('rs_end_south', 'b_tt_3')]

# counts
print('number of pairs: {}'.format(len(odd_node_pairs)))

number of pairs: 630

   let's confirm that this number of pairs is correct with a the
   combinatoric below. luckily, you only have 630 pairs to worry about.
   your computation time to solve this cpp example is trivial (a couple
   seconds).

   however, if you had 3,600 odd node pairs instead, you'd have ~6.5
   million pairs to optimize. that's a ~10,000x increase in output given a
   100x increase in input size.
   \begin{equation*} \#\;of\;pairs = n\;choose\;r = {n \choose r} =
   \frac{n!}{r!(n-r)!} = \frac{36!}{2! (36-2)!} = 630 \end{equation*}

step 2.2: compute shortest paths between node pairs

   this is the first step that involves some real computation. luckily
   networkx has a convenient implementation of [26]dijkstra's algorithm to
   compute the shortest path between two nodes. you apply this function to
   every pair (all 630) calculated above in odd_node_pairs.
def get_shortest_paths_distances(graph, pairs, edge_weight_name):
    """compute shortest distance between each pair of nodes in a graph.  return
a dictionary keyed on node pairs (tuples)."""
    distances = {}
    for pair in pairs:
        distances[pair] = nx.dijkstra_path_length(graph, pair[0], pair[1], weigh
t=edge_weight_name)
    return distances

# compute shortest paths.  return a dictionary with node pairs keys and a single
 value equal to shortest path distance.
odd_node_pairs_shortest_paths = get_shortest_paths_distances(g, odd_node_pairs,
'distance')

# preview with a bit of hack (there is no head/slice method for dictionaries).
dict(list(odd_node_pairs_shortest_paths.items())[0:10])

{('b_bv', 'y_gy1'): 1.22,
 ('b_bw', 'rc_end_south'): 1.35,
 ('b_end_east', 'b_bw'): 3.0400000000000005,
 ('b_end_east', 'rd_end_north'): 3.83,
 ('g_gy1', 'nature_end_west'): 0.9900000000000001,
 ('o_rt', 'y_gy1'): 0.53,
 ('rc_end_north', 'rd_end_south'): 2.21,
 ('rc_end_north', 'rs_end_north'): 1.79,
 ('rs_end_north', 'o_tt'): 2.0999999999999996,
 ('w_bw', 'rd_end_north'): 1.02}

step 2.3: create complete graph

   a [27]complete graph is simply a graph where every node is connected to
   every other node by a unique edge.

   here's a basic example from wikipedia of a 7 node complete graph with
   21 (7 choose 2) edges:

   networkx tutorial python

   the graph you create below has 36 nodes and 630 edges with their
   corresponding edge weight (distance).

   create_complete_graph is defined to calculate it. the flip_weights
   parameter is used to transform the distance to the weight attribute
   where smaller numbers reflect large distances and high numbers reflect
   short distances. this sounds a little counter intuitive, but is
   necessary for step 2.4 where you calculate the minimum weight matching
   on the complete graph.

   ideally you'd calculate the minimum weight matching directly, but
   networkx only implements a max_weight_matching function which
   maximizes, rather than minimizes edge weight. we hack this a bit by
   negating (multiplying by -1) the distance attribute to get weight. this
   ensures that order and scale by distance are preserved, but reversed.
def create_complete_graph(pair_weights, flip_weights=true):
    """
    create a completely connected graph using a list of vertex pairs and the sho
rtest path distances between them
    parameters:
        pair_weights: list[tuple] from the output of get_shortest_paths_distance
s
        flip_weights: boolean. should we negate the edge attribute in pair_weigh
ts?
    """
    g = nx.graph()
    for k, v in pair_weights.items():
        wt_i = - v if flip_weights else v
        g.add_edge(k[0], k[1], attr_dict={'distance': v, 'weight': wt_i})
    return g

# generate the complete graph
g_odd_complete = create_complete_graph(odd_node_pairs_shortest_paths, flip_weigh
ts=true)

# counts
print('number of nodes: {}'.format(len(g_odd_complete.nodes())))
print('number of edges: {}'.format(len(g_odd_complete.edges())))

number of nodes: 36
number of edges: 630

   for a visual prop, the fully connected graph of odd degree node pairs
   is plotted below. note that you preserve the x, y coordinates of each
   node, but the edges do not necessarily represent actual trails. for
   example, two nodes could be connected by a single edge in this graph,
   but the shortest path between them could be 5 hops through even degree
   nodes (not shown here).
# plot the complete graph of odd-degree nodes
plt.figure(figsize=(8, 6))
pos_random = nx.random_layout(g_odd_complete)
nx.draw_networkx_nodes(g_odd_complete, node_positions, node_size=20, node_color=
"red")
nx.draw_networkx_edges(g_odd_complete, node_positions, alpha=0.1)
plt.axis('off')
plt.title('complete graph of odd-degree nodes')
plt.show()

   png

step 2.4: compute minimum weight matching

   this is the most complex step in the cpp. you need to find the odd
   degree node pairs whose combined sum (of distance between them) is as
   small as possible. so for your problem, this boils down to selecting
   the optimal 18 edges (36 odd degree nodes / 2) from the hairball of a
   graph generated in 2.3.

   both the implementation and intuition of this optimization are beyond
   the scope of this tutorial... like [28]800+ lines of code and a body of
   academic literature beyond this scope.

   however, a quick aside for the interested reader:

   a huge thanks to joris van rantwijk for writing the orginal
   implementation on [29]his blog way back in 2008. i stumbled into the
   problem a similar way with the same intention as joris. from joris's
   2008 post:

     since i did not find any perl implementations of maximum weighted
     matching, i lightly decided to write some code myself. it turned out
     that i had underestimated the problem, but by the time i realized my
     mistake, i was so obsessed with the problem that i refused to give
     up.

   however, i did give up. luckily joris did not.

   this maximum weight matching has since been folded into and maintained
   within the networkx package. another big thanks to the [30]10+
   contributors on github who have maintained this hefty codebase.

   this is a hard and intensive computation. the first breakthrough in
   1965 proved that the maximum matching problem could be solved in
   polynomial time. it was published by jack edmonds with perhaps one of
   the most beautiful academic paper titles ever: "paths, trees, and
   flowers" [[31]1]. a body of literature has since built upon this work,
   improving the optimization procedure. the code implemented in the
   networkx function [32]max_weight_matching is based on galil, zvi (1986)
   [[33]2] which employs an o(n^3) time algorithm.
# compute min weight matching.
# note: max_weight_matching uses the 'weight' attribute by default as the attrib
ute to maximize.
odd_matching_dupes = nx.algorithms.max_weight_matching(g_odd_complete, true)

print('number of edges in matching: {}'.format(len(odd_matching_dupes)))

number of edges in matching: 36

   the matching output (odd_matching_dupes) is a dictionary. although
   there are 36 edges in this matching, you only want 18. each edge-pair
   occurs twice (once with node 1 as the key and a second time with node 2
   as the key of the dictionary).
# preview of matching with dupes
odd_matching_dupes

{'b_bv': 'v_bv',
 'b_bw': 'rh_end_tt_1',
 'b_end_east': 'g_gy2',
 'b_end_west': 'rd_end_south',
 'b_tt_3': 'rt_end_north',
 'b_v': 'v_end_west',
 'g_gy1': 'rc_end_north',
 'g_gy2': 'b_end_east',
 'g_w': 'w_bw',
 'nature_end_west': 'o_y_tt_end_west',
 'o_rt': 'o_w_1',
 'o_tt': 'rh_end_tt_2',
 'o_w_1': 'o_rt',
 'o_y_tt_end_west': 'nature_end_west',
 'rc_end_north': 'g_gy1',
 'rc_end_south': 'y_gy1',
 'rd_end_north': 'rh_end_north',
 'rd_end_south': 'b_end_west',
 'rh_end_north': 'rd_end_north',
 'rh_end_south': 'y_rh',
 'rh_end_tt_1': 'b_bw',
 'rh_end_tt_2': 'o_tt',
 'rh_end_tt_3': 'rh_end_tt_4',
 'rh_end_tt_4': 'rh_end_tt_3',
 'rs_end_north': 'v_end_east',
 'rs_end_south': 'y_gy2',
 'rt_end_north': 'b_tt_3',
 'rt_end_south': 'y_rt',
 'v_bv': 'b_bv',
 'v_end_east': 'rs_end_north',
 'v_end_west': 'b_v',
 'w_bw': 'g_w',
 'y_gy1': 'rc_end_south',
 'y_gy2': 'rs_end_south',
 'y_rh': 'rh_end_south',
 'y_rt': 'rt_end_south'}

   you convert this dictionary to a list of tuples since you have an
   undirected graph and order does not matter. removing duplicates yields
   the unique 18 edge-pairs that cumulatively sum to the least possible
   distance.
# convert matching to list of deduped tuples
odd_matching = list(pd.unique([tuple(sorted([k, v])) for k, v in odd_matching_du
pes.items()]))

# counts
print('number of edges in matching (deduped): {}'.format(len(odd_matching)))

number of edges in matching (deduped): 18

# preview of deduped matching
odd_matching

[('rs_end_south', 'y_gy2'),
 ('b_end_west', 'rd_end_south'),
 ('b_bv', 'v_bv'),
 ('rh_end_tt_3', 'rh_end_tt_4'),
 ('b_bw', 'rh_end_tt_1'),
 ('o_tt', 'rh_end_tt_2'),
 ('g_w', 'w_bw'),
 ('b_end_east', 'g_gy2'),
 ('nature_end_west', 'o_y_tt_end_west'),
 ('g_gy1', 'rc_end_north'),
 ('o_rt', 'o_w_1'),
 ('rs_end_north', 'v_end_east'),
 ('rc_end_south', 'y_gy1'),
 ('rh_end_south', 'y_rh'),
 ('rt_end_south', 'y_rt'),
 ('b_tt_3', 'rt_end_north'),
 ('rd_end_north', 'rh_end_north'),
 ('b_v', 'v_end_west')]

   let's visualize these pairs on the complete graph plotted earlier in
   step 2.3. as before, while the node positions reflect the true graph
   (trail map) here, the edge distances shown (blue lines) are as the crow
   flies. the actual shortest route from one node to another could involve
   multiple edges that twist and turn with considerably longer distance.
plt.figure(figsize=(8, 6))

# plot the complete graph of odd-degree nodes
nx.draw(g_odd_complete, pos=node_positions, node_size=20, alpha=0.05)

# create a new graph to overlay on g_odd_complete with just the edges from the m
in weight matching
g_odd_complete_min_edges = nx.graph(odd_matching)
nx.draw(g_odd_complete_min_edges, pos=node_positions, node_size=20, edge_color='
blue', node_color='red')

plt.title('min weight matching on complete graph')
plt.show()

   png

   to illustrate how this fits in with the original graph, you plot the
   same min weight pairs (blue lines), but over the trail map (faded)
   instead of the complete graph. again, note that the blue lines are the
   bushwhacking route (as the crow flies edges, not actual trails). you
   still have a little bit of work to do to find the edges that comprise
   the shortest route between each pair in step 3.
plt.figure(figsize=(8, 6))

# plot the original trail map graph
nx.draw(g, pos=node_positions, node_size=20, alpha=0.1, node_color='black')

# plot graph to overlay with just the edges from the min weight matching
nx.draw(g_odd_complete_min_edges, pos=node_positions, node_size=20, alpha=1, nod
e_color='red', edge_color='blue')

plt.title('min weight matching on orginal graph')
plt.show()

   png

step 2.5: augment the original graph

   now you augment the original graph with the edges from the matching
   calculated in 2.4. a simple function to do this is defined below which
   also notes that these new edges came from the augmented graph. you'll
   need to know this in 3. when you actually create the eulerian circuit
   through the graph.
def add_augmenting_path_to_graph(graph, min_weight_pairs):
    """
    add the min weight matching edges to the original graph
    parameters:
        graph: networkx graph (original graph from trailmap)
        min_weight_pairs: list[tuples] of node pairs from min weight matching
    returns:
        augmented networkx graph
    """

    # we need to make the augmented graph a multigraph so we can add parallel ed
ges
    graph_aug = nx.multigraph(graph.copy())
    for pair in min_weight_pairs:
        graph_aug.add_edge(pair[0],
                           pair[1],
                           attr_dict={'distance': nx.dijkstra_path_length(graph,
 pair[0], pair[1]),
                                      'trail': 'augmented'}
                          )
    return graph_aug

   let's confirm that your augmented graph adds the expected number (18)
   of edges:
# create augmented graph: add the min weight matching edges to g
g_aug = add_augmenting_path_to_graph(g, odd_matching)

# counts
print('number of edges in original graph: {}'.format(len(g.edges())))
print('number of edges in augmented graph: {}'.format(len(g_aug.edges())))

number of edges in original graph: 123
number of edges in augmented graph: 141

   let's also confirm that every node now has even degree:
pd.value_counts(g_aug.degree())

4    54
2    18
6     5
dtype: int64

cpp step 3: compute eulerian circuit

   now that you have a graph with even degree the hard optimization work
   is over. as euler famously postulated in 1736 with the [34]seven
   bridges of k  nigsberg problem, there exists a path which visits each
   edge exactly once if all nodes have even degree. carl hierholzer
   fomally proved this result later in the 1870s.

   there are many eulerian circuits with the same distance that can be
   constructed. you can get 90% of the way there with the networkx
   eulerian_circuit function. however there are some limitations.

   limitations you will fix:
    1. the augmented graph could (and likely will) contain edges that
       didn't exist on the original graph. to get the circuit (without
       bushwhacking), you must break down these augmented edges into the
       shortest path through the edges that actually exist.
    2. eulerian_circuit only returns the order in which we hit each node.
       it does not return the attributes of the edges needed to complete
       the circuit. this is necessary because you need to keep track of
       which edges have been walked already when multiple edges exist
       between two nodes.

   limitations you won't fix:
    3. to save your legs some work, you could relax the assumption of the
       eulerian circuit that one start and finish at the same node. an
       [35]eulerian path (the general case of the eulerian circuit), can
       also be found if there are exactly two nodes of odd degree. this
       would save you a little bit of double backing...presuming you could
       get a ride back from the other end of the park. however, at the
       time of this writing, networkx does not provide a euler path
       algorithm. the [36]eulerian_circuit code isn't too bad and could be
       adopted for this case, but you'll keep it simple here.

naive circuit

   nonetheless, let's start with the simple yet incomplete solution:
naive_euler_circuit = list(nx.eulerian_circuit(g_aug, source='b_end_east'))

   as expected, the length of the naive eulerian circuit is equal to the
   number of the edges in the augmented graph.
print('length of eulerian circuit: {}'.format(len(naive_euler_circuit)))

length of eulerian circuit: 141

   the output is just a list of tuples which represent node pairs. note
   that the first node of each pair is the same as the second node from
   the preceding pair.
# preview naive euler circuit
naive_euler_circuit[0:10]

[('b_end_east', 'g_gy2'),
 ('g_gy2', 'b_g'),
 ('b_g', 'b_w'),
 ('b_w', 'b_gy2'),
 ('b_gy2', 'w_gy2'),
 ('w_gy2', 'b_w'),
 ('b_w', 'w_rs'),
 ('w_rs', 'g_rs'),
 ('g_rs', 'b_g'),
 ('b_g', 'b_rs')]

correct circuit

   now let's define a function that utilizes the original graph to tell
   you which trails to use to get from node a to node b. although verbose
   in code, this logic is actually quite simple. you simply transform the
   naive circuit which included edges that did not exist in the original
   graph to a eulerian circuit using only edges that exist in the original
   graph.

   you loop through each edge in the naive eulerian circuit
   (naive_euler_circuit). wherever you encounter an edge that does not
   exist in the original graph, you replace it with the sequence of edges
   comprising the shortest path between its nodes using the original
   graph.
def create_eulerian_circuit(graph_augmented, graph_original, starting_node=none)
:
    """create the eulerian path using only edges from the original graph."""
    euler_circuit = []
    naive_circuit = list(nx.eulerian_circuit(graph_augmented, source=starting_no
de))

    for edge in naive_circuit:
        edge_data = graph_augmented.get_edge_data(edge[0], edge[1])

        if edge_data[0]['trail'] != 'augmented':
            # if `edge` exists in original graph, grab the edge attributes and a
dd to eulerian circuit.
            edge_att = graph_original[edge[0]][edge[1]]
            euler_circuit.append((edge[0], edge[1], edge_att))
        else:
            aug_path = nx.shortest_path(graph_original, edge[0], edge[1], weight
='distance')
            aug_path_pairs = list(zip(aug_path[:-1], aug_path[1:]))

            print('filling in edges for augmented edge: {}'.format(edge))
            print('augmenting path: {}'.format(' => '.join(aug_path)))
            print('augmenting path pairs: {}\n'.format(aug_path_pairs))

            # if `edge` does not exist in original graph, find the shortest path
 between its nodes and
            #  add the edge attributes for each link in the shortest path.
            for edge_aug in aug_path_pairs:
                edge_aug_att = graph_original[edge_aug[0]][edge_aug[1]]
                euler_circuit.append((edge_aug[0], edge_aug[1], edge_aug_att))

    return euler_circuit

   you hack limitation 3 a bit by starting the eulerian circuit at the far
   east end of the park on the blue trail (node "b_end_east"). when
   actually running this thing, you could simply skip the last direction
   which doubles back on it.

   verbose print statements are added to convey what happens when you
   replace nonexistent edges from the augmented graph with the shortest
   path using edges that actually exist.
# create the eulerian circuit
euler_circuit = create_eulerian_circuit(g_aug, g, 'b_end_east')

filling in edges for augmented edge: ('b_end_east', 'g_gy2')
augmenting path: b_end_east => b_y => b_o => b_gy2 => w_gy2 => g_gy2
augmenting path pairs: [('b_end_east', 'b_y'), ('b_y', 'b_o'), ('b_o', 'b_gy2'),
 ('b_gy2', 'w_gy2'), ('w_gy2', 'g_gy2')]

filling in edges for augmented edge: ('b_bw', 'rh_end_tt_1')
augmenting path: b_bw => b_tt_1 => rh_end_tt_1
augmenting path pairs: [('b_bw', 'b_tt_1'), ('b_tt_1', 'rh_end_tt_1')]

filling in edges for augmented edge: ('b_tt_3', 'rt_end_north')
augmenting path: b_tt_3 => b_tt_2 => tt_rt => v_rt => rt_end_north
augmenting path pairs: [('b_tt_3', 'b_tt_2'), ('b_tt_2', 'tt_rt'), ('tt_rt', 'v_
rt'), ('v_rt', 'rt_end_north')]

filling in edges for augmented edge: ('rc_end_north', 'g_gy1')
augmenting path: rc_end_north => v_rc => b_rc => g_rc => g_gy1
augmenting path pairs: [('rc_end_north', 'v_rc'), ('v_rc', 'b_rc'), ('b_rc', 'g_
rc'), ('g_rc', 'g_gy1')]

filling in edges for augmented edge: ('y_gy1', 'rc_end_south')
augmenting path: y_gy1 => y_rc => rc_end_south
augmenting path pairs: [('y_gy1', 'y_rc'), ('y_rc', 'rc_end_south')]

filling in edges for augmented edge: ('b_end_west', 'rd_end_south')
augmenting path: b_end_west => b_v => rd_end_south
augmenting path pairs: [('b_end_west', 'b_v'), ('b_v', 'rd_end_south')]

filling in edges for augmented edge: ('rh_end_north', 'rd_end_north')
augmenting path: rh_end_north => v_rh => v_rd => rd_end_north
augmenting path pairs: [('rh_end_north', 'v_rh'), ('v_rh', 'v_rd'), ('v_rd', 'rd
_end_north')]

filling in edges for augmented edge: ('v_end_east', 'rs_end_north')
augmenting path: v_end_east => v_rs => rs_end_north
augmenting path pairs: [('v_end_east', 'v_rs'), ('v_rs', 'rs_end_north')]

filling in edges for augmented edge: ('y_gy2', 'rs_end_south')
augmenting path: y_gy2 => y_rs => rs_end_south
augmenting path pairs: [('y_gy2', 'y_rs'), ('y_rs', 'rs_end_south')]

   you see that the length of the eulerian circuit is longer than the
   naive circuit, which makes sense.
print('length of eulerian circuit: {}'.format(len(euler_circuit)))

length of eulerian circuit: 158

cpp solution

text

   here's a printout of the solution in text:
# preview first 20 directions of cpp solution
for i, edge in enumerate(euler_circuit[0:20]):
    print(i, edge)

0 ('b_end_east', 'b_y', {'color': 'blue', 'estimate': 0, 'trail': 'b', 'distance
': 1.32})
1 ('b_y', 'b_o', {'color': 'blue', 'estimate': 0, 'trail': 'b', 'distance': 0.08
})
2 ('b_o', 'b_gy2', {'color': 'blue', 'estimate': 1, 'trail': 'b', 'distance': 0.
05})
3 ('b_gy2', 'w_gy2', {'color': 'yellowgreen', 'estimate': 1, 'trail': 'gy2', 'di
stance': 0.03})
4 ('w_gy2', 'g_gy2', {'color': 'yellowgreen', 'estimate': 0, 'trail': 'gy2', 'di
stance': 0.05})
5 ('g_gy2', 'b_g', {'color': 'green', 'estimate': 0, 'trail': 'g', 'distance': 0
.45})
6 ('b_g', 'b_w', {'color': 'blue', 'estimate': 0, 'trail': 'b', 'distance': 0.16
})
7 ('b_w', 'b_gy2', {'color': 'blue', 'estimate': 0, 'trail': 'b', 'distance': 0.
41})
8 ('b_gy2', 'w_gy2', {'color': 'yellowgreen', 'estimate': 1, 'trail': 'gy2', 'di
stance': 0.03})
9 ('w_gy2', 'b_w', {'color': 'gray', 'estimate': 0, 'trail': 'w', 'distance': 0.
42})
10 ('b_w', 'w_rs', {'color': 'gray', 'estimate': 1, 'trail': 'w', 'distance': 0.
06})
11 ('w_rs', 'g_rs', {'color': 'red', 'estimate': 0, 'trail': 'rs', 'distance': 0
.18})
12 ('g_rs', 'b_g', {'color': 'green', 'estimate': 1, 'trail': 'g', 'distance': 0
.05})
13 ('b_g', 'b_rs', {'color': 'blue', 'estimate': 0, 'trail': 'b', 'distance': 0.
07})
14 ('b_rs', 'g_rs', {'color': 'red', 'estimate': 0, 'trail': 'rs', 'distance': 0
.11})
15 ('g_rs', 'g_rc', {'color': 'green', 'estimate': 0, 'trail': 'g', 'distance':
0.45})
16 ('g_rc', 'g_gy1', {'color': 'green', 'estimate': 0, 'trail': 'g', 'distance':
 0.37})
17 ('g_gy1', 'g_rt', {'color': 'green', 'estimate': 0, 'trail': 'g', 'distance':
 0.26})
18 ('g_rt', 'g_w', {'color': 'green', 'estimate': 0, 'trail': 'g', 'distance': 0
.31})
19 ('g_w', 'o_w_1', {'color': 'gray', 'estimate': 0, 'trail': 'w', 'distance': 0
.18})

   you can tell pretty quickly that the algorithm is not very loyal to any
   particular trail, jumping from one to the next pretty quickly. an
   extension of this approach could get fancy and build in some notion of
   trail loyalty into the objective function to make actually running this
   route more manageable.

stats

   let's peak into your solution to see how reasonable it looks.
   (not important to dwell on this verbose code, just the printed output)
# computing some stats
total_mileage_of_circuit = sum([edge[2]['distance'] for edge in euler_circuit])
total_mileage_on_orig_trail_map = sum(nx.get_edge_attributes(g, 'distance').valu
es())
_vcn = pd.value_counts(pd.value_counts([(e[0]) for e in euler_circuit]), sort=fa
lse)
node_visits = pd.dataframe({'n_visits': _vcn.index, 'n_nodes': _vcn.values})
_vce = pd.value_counts(pd.value_counts([sorted(e)[0] + sorted(e)[1] for e in nx.
multidigraph(euler_circuit).edges()]))
edge_visits = pd.dataframe({'n_visits': _vce.index, 'n_edges': _vce.values})

# printing stats
print('mileage of circuit: {0:.2f}'.format(total_mileage_of_circuit))
print('mileage on original trail map: {0:.2f}'.format(total_mileage_on_orig_trai
l_map))
print('mileage retracing edges: {0:.2f}'.format(total_mileage_of_circuit-total_m
ileage_on_orig_trail_map))
print('percent of mileage retraced: {0:.2f}%\n'.format((1-total_mileage_of_circu
it/total_mileage_on_orig_trail_map)*-100))

print('number of edges in circuit: {}'.format(len(euler_circuit)))
print('number of edges in original graph: {}'.format(len(g.edges())))
print('number of nodes in original graph: {}\n'.format(len(g.nodes())))

print('number of edges traversed more than once: {}\n'.format(len(euler_circuit)
-len(g.edges())))

print('number of times visiting each node:')
print(node_visits.to_string(index=false))

print('\nnumber of times visiting each edge:')
print(edge_visits.to_string(index=false))

mileage of circuit: 33.59
mileage on original trail map: 25.76
mileage retracing edges: 7.83
percent of mileage retraced: 30.40%

number of edges in circuit: 158
number of edges in original graph: 123
number of nodes in original graph: 77

number of edges traversed more than once: 35

number of times visiting each node:
n_nodes  n_visits
     18         1
     38         2
     20         3
      1         4

number of times visiting each edge:
n_edges  n_visits
     88         1
     35         2

visualize cpp solution

   while networkx also provides functionality to visualize graphs, they
   are [37]notably humble in this department:

     networkx provides basic functionality for visualizing graphs, but
     its main goal is to enable graph analysis rather than perform graph
     visualization. in the future, graph visualization functionality may
     be removed from networkx or only available as an add-on package.

     proper graph visualization is hard, and we highly recommend that
     people visualize their graphs with tools dedicated to that task.
     notable examples of dedicated and fully-featured graph visualization
     tools are cytoscape, gephi, graphviz and, for latex typesetting,
     pgf/tikz.

   that said, the built-in networkx drawing functionality with matplotlib
   is powerful enough for eyeballing and visually exploring basic graphs,
   so you stick with networkx draw for this tutorial.

   i used [38]graphviz and the [39]dot graph description language to
   visualize the solution in my python package [40]postman_problems.
   although it took some legwork to convert the networkx graph structure
   to a dot graph, it does unlock enhanced quality and control over
   visualizations.

create cpp graph

   your first step is to convert the list of edges to walk in the euler
   circuit into an edge list with plot-friendly attributes.

   create_cpp_edgelist creates an edge list with some additional
   attributes that you'll use for plotting:
     * sequence: records a sequence of when we walk each edge.
     * visits: is simply the number of times we walk a particular edge.

def create_cpp_edgelist(euler_circuit):
    """
    create the edgelist without parallel edge for the visualization
    combine duplicate edges and keep track of their sequence and # of walks
    parameters:
        euler_circuit: list[tuple] from create_eulerian_circuit
    """
    cpp_edgelist = {}

    for i, e in enumerate(euler_circuit):
        edge = frozenset([e[0], e[1]])

        if edge in cpp_edgelist:
            cpp_edgelist[edge][2]['sequence'] += ', ' + str(i)
            cpp_edgelist[edge][2]['visits'] += 1

        else:
            cpp_edgelist[edge] = e
            cpp_edgelist[edge][2]['sequence'] = str(i)
            cpp_edgelist[edge][2]['visits'] = 1

    return list(cpp_edgelist.values())

   let's create the cpp edge list:
cpp_edgelist = create_cpp_edgelist(euler_circuit)

   as expected, your edge list has the same number of edges as the
   original graph.
print('number of edges in cpp edge list: {}'.format(len(cpp_edgelist)))

number of edges in cpp edge list: 123

   the cpp edge list looks similar to euler_circuit, just with a few
   additional attributes.
# preview cpp plot-friendly edge list
cpp_edgelist[0:3]

[('rh_end_tt_4',
  'nature_end_west',
  {'color': 'black',
   'distance': 0.2,
   'estimate': 0,
   'sequence': '73',
   'trail': 'tt',
   'visits': 1}),
 ('rd_end_south',
  'b_rd',
  {'color': 'red',
   'distance': 0.13,
   'estimate': 0,
   'sequence': '95',
   'trail': 'rd',
   'visits': 1}),
 ('w_gy1',
  'w_rc',
  {'color': 'gray',
   'distance': 0.33,
   'estimate': 0,
   'sequence': '151',
   'trail': 'w',
   'visits': 1})]

   now let's make the graph:
# create cpp solution graph
g_cpp = nx.graph(cpp_edgelist)

visualization 1: retracing steps

   here you illustrate which edges are walked once (gray) and more than
   once (blue). this is the "correct" version of the visualization created
   in 2.4 which showed the naive (as the crow flies) connections between
   the odd node pairs (red). that is corrected here by tracing the
   shortest path through edges that actually exist for each pair of odd
   degree nodes.

   if the optimization is any good, these blue lines should represent the
   least distance possible. specifically, the minimum distance needed to
   generate a [41]matching of the odd degree nodes.
plt.figure(figsize=(14, 10))

visit_colors = {1:'lightgray', 2:'blue'}
edge_colors = [visit_colors[e[2]['visits']] for e in g_cpp.edges(data=true)]
node_colors = ['red'  if node in nodes_odd_degree else 'lightgray' for node in g
_cpp.nodes()]

nx.draw_networkx(g_cpp, pos=node_positions, node_size=20, node_color=node_colors
, edge_color=edge_colors, with_labels=false)
plt.axis('off')
plt.show()

   png

visualization 2: cpp solution sequence

   here you plot the original graph (trail map) annotated with the
   sequence numbers in which we walk the trails per the cpp solution.
   multiple numbers indicate trails we must double back on.

   you start on the blue trail in the bottom right (0th and the 157th
   direction).
plt.figure(figsize=(14, 10))

edge_colors = [e[2]['color'] for e in g_cpp.edges(data=true)]
nx.draw_networkx(g_cpp, pos=node_positions, node_size=10, node_color='black', ed
ge_color=edge_colors, with_labels=false, alpha=0.5)

bbox = {'ec':[1,1,1,0], 'fc':[1,1,1,0]}  # hack to label edges over line (rather
 than breaking up line)
edge_labels = nx.get_edge_attributes(g_cpp, 'sequence')
nx.draw_networkx_edge_labels(g_cpp, pos=node_positions, edge_labels=edge_labels,
 bbox=bbox, font_size=6)

plt.axis('off')
plt.show()

   png

visualization 3: movie

   the movie below that traces the euler circuit from beginning to end is
   embedded below. edges are colored black the first time they are walked
   and red the second time.

   note that this gif doesn't do give full visual justice to edges which
   overlap another or are too small to visualize properly. a more robust
   visualization library such as graphviz could address this by plotting
   splines instead of straight lines between nodes.

   the code that creates it is presented below as a reference.

   alt text

   first a png image is produced for each direction (edge walked) from the
   cpp solution.
visit_colors = {1:'black', 2:'red'}
edge_cnter = {}
g_i_edge_colors = []
for i, e in enumerate(euler_circuit, start=1):

    edge = frozenset([e[0], e[1]])
    if edge in edge_cnter:
        edge_cnter[edge] += 1
    else:
        edge_cnter[edge] = 1

    # full graph (faded in background)
    nx.draw_networkx(g_cpp, pos=node_positions, node_size=6, node_color='gray',
with_labels=false, alpha=0.07)

    # edges walked as of iteration i
    euler_circuit_i = copy.deepcopy(euler_circuit[0:i])
    for i in range(len(euler_circuit_i)):
        edge_i = frozenset([euler_circuit_i[i][0], euler_circuit_i[i][1]])
        euler_circuit_i[i][2]['visits_i'] = edge_cnter[edge_i]
    g_i = nx.graph(euler_circuit_i)
    g_i_edge_colors = [visit_colors[e[2]['visits_i']] for e in g_i.edges(data=tr
ue)]

    nx.draw_networkx_nodes(g_i, pos=node_positions, node_size=6, alpha=0.6, node
_color='lightgray', with_labels=false, linewidths=0.1)
    nx.draw_networkx_edges(g_i, pos=node_positions, edge_color=g_i_edge_colors,
alpha=0.8)

    plt.axis('off')
    plt.savefig('fig/png/img{}.png'.format(i), dpi=120, bbox_inches='tight')
    plt.close()

   then the the png images are stitched together to make the nice little
   gif above.

   first the pngs are sorted in the order from 0 to 157. then they are
   stitched together using imageio at 3 frames per second to create the
   gif.
import glob
import numpy as np
import imageio
import os

def make_circuit_video(image_path, movie_filename, fps=5):
    # sorting filenames in order
    filenames = glob.glob(image_path + 'img*.png')
    filenames_sort_indices = np.argsort([int(os.path.basename(filename).split('.
')[0][3:]) for filename in filenames])
    filenames = [filenames[i] for i in filenames_sort_indices]

    # make movie
    with imageio.get_writer(movie_filename, mode='i', fps=fps) as writer:
        for filename in filenames:
            image = imageio.imread(filename)
            writer.append_data(image)

make_circuit_video('fig/png/', 'fig/gif/cpp_route_animation.gif', fps=3)

next steps

   congrats, you have finished this tutorial solving the chinese postman
   problem in python. you have covered a lot of ground in this tutorial
   (33.6 miles of trails to be exact). for a deeper dive into network
   fundamentals, you might be interested in datacamp's [42]network
   analysis in python course which provides a more thorough treatment of
   the core concepts.

   don't hesitate to check out the [43]networkx documentation for more on
   how to create, manipulate and traverse these complex networks. the docs
   are comprehensive with a good number of [44]examples and a series of
   [45]tutorials.

   if you're interested in solving the cpp on your own graph, i've
   packaged the functionality within this tutorial into the
   [46]postman_problems python package on github. you can also piece
   together the code blocks from this tutorial with a different edge and
   node list, but the postman_problems package will probably get you there
   more quickly and cleanly.

   one day i plan to implement the extensions of the cpp (rural and windy
   postman problem) here as well. i also have grand ambitions of writing
   about these extensions and experiences testing the routes out on the
   trails on my blog [47]here. another application i plan to explore and
   write about is incorporating lat/long coordinates to develop (or use) a
   mechanism to send turn-by-turn directions to my garmin watch.

   and of course one last next step: getting outside and trail running the
   route!

   if you would like to learn more about the networkx library, take
   datacamp's [48]network analysis in python (part 1) course.

references

   [49]1: edmonds, jack (1965). "paths, trees, and flowers". canad. j.
   math. 17: 449   467.
   [50]2: galil, z. (1986). "efficient algorithms for finding maximum
   matching in graphs". acm computing surveys. vol. 18, no. 1: 23-38.
   61
   61
   [51]0
   (button)
   post a comment

   [52]subscribe to rss
   [53]about[54]terms[55]privacy

   want to leave a comment?

references

   visible links
   1. https://www.datacamp.com/users/sign_in
   2. https://www.datacamp.com/community/tutorials/networkx-python-graph-tutorial#comments
   3. https://networkx.github.io/
   4. https://www.datacamp.com/community/tutorials/networkx-python-graph-tutorial#motivation
   5. https://www.datacamp.com/community/tutorials/networkx-python-graph-tutorial#graphs
   6. https://www.datacamp.com/community/tutorials/networkx-python-graph-tutorial#data
   7. https://www.datacamp.com/community/tutorials/networkx-python-graph-tutorial#creategraph
   8. https://www.datacamp.com/community/tutorials/networkx-python-graph-tutorial#inspectgraph
   9. https://www.datacamp.com/community/tutorials/networkx-python-graph-tutorial#visualizegraph
  10. https://www.datacamp.com/community/tutorials/networkx-python-graph-tutorial#solution
  11. https://www.datacamp.com/community/tutorials/networkx-python-graph-tutorial#next
  12. https://www.datacamp.com/community/tutorials/networkx-python-graph-tutorial#references
  13. https://en.wikipedia.org/wiki/travelling_salesman_problem
  14. https://en.wikipedia.org/wiki/route_inspection_problem
  15. http://www.sgpa.org/hikes/masters.html
  16. http://brooksandrew.github.io/simpleblog/
  17. http://www.sgpa.org/gnews/archive/84.pdf
  18. https://s3.amazonaws.com/assets.datacamp.com/blog_assets/network+optimization/sleepgiant.pdf
  19. https://www.gimp.org/
  20. http://www.sgpa.org/hikes/masterlog.pdf
  21. https://en.wikipedia.org/wiki/route_inspection_problem#variants
  22. https://en.wikipedia.org/wiki/route_inspection_problem#windy_postman_problem
  23. https://github.com/brooksandrew/postman_problems
  24. https://en.wikipedia.org/wiki/complete_graph
  25. https://en.wikipedia.org/wiki/matching_(graph_theory)
  26. https://en.wikipedia.org/wiki/dijkstra's_algorithm
  27. https://en.wikipedia.org/wiki/complete_graph
  28. https://networkx.github.io/documentation/networkx-1.10/_modules/networkx/algorithms/matching.html#max_weight_matching
  29. http://jorisvr.nl/article/maximum-matching
  30. https://github.com/networkx/networkx/blob/master/networkx/algorithms/matching.py
  31. https://cms.math.ca/openaccess/cjm/v17/cjm1965v17.0449-0467.pdf
  32. http://networkx.readthedocs.io/en/networkx-1.10/reference/generated/networkx.algorithms.matching.max_weight_matching.html?highlight=max_weight_matching]
  33. https://pdfs.semanticscholar.org/6fc3/371dc5d40b638a6b4acb548c8420fa67aac1.pdf
  34. https://en.wikipedia.org/wiki/seven_bridges_of_k  nigsberg
  35. https://en.wikipedia.org/wiki/eulerian_path
  36. https://networkx.github.io/documentation/networkx-1.10/_modules/networkx/algorithms/euler.html#eulerian_circuit
  37. https://networkx.github.io/documentation/networkx-1.10/reference/drawing.html
  38. http://www.graphviz.org/
  39. https://en.wikipedia.org/wiki/dot_(graph_description_language)
  40. https://github.com/brooksandrew/postman_problems
  41. https://en.wikipedia.org/wiki/matching_(graph_theory)
  42. https://www.datacamp.com/courses/network-analysis-in-python-part-1
  43. http://networkx.readthedocs.io/en/stable/overview.html
  44. http://networkx.readthedocs.io/en/stable/examples/index.html
  45. http://networkx.readthedocs.io/en/stable/tutorial/index.html
  46. https://github.com/brooksandrew/postman_problems
  47. http://brooksandrew.github.io/simpleblog/
  48. https://www.datacamp.com/courses/network-analysis-in-python-part-1
  49. https://cms.math.ca/openaccess/cjm/v17/cjm1965v17.0449-0467.pdf
  50. https://pdfs.semanticscholar.org/6fc3/371dc5d40b638a6b4acb548c8420fa67aac1.pdf
  51. https://www.datacamp.com/community/tutorials/networkx-python-graph-tutorial#comments
  52. https://www.datacamp.com/community/rss.xml
  53. https://www.datacamp.com/about
  54. https://www.datacamp.com/terms-of-use
  55. https://www.datacamp.com/privacy-policy

   hidden links:
  57. https://www.datacamp.com/
  58. https://www.datacamp.com/community
  59. https://www.datacamp.com/community/tutorials
  60. https://www.datacamp.com/community/data-science-cheatsheets
  61. https://www.datacamp.com/community/open-courses
  62. https://www.datacamp.com/community/podcast
  63. https://www.datacamp.com/community/chat
  64. https://www.datacamp.com/community/blog
  65. https://www.datacamp.com/community/tech
  66. https://www.facebook.com/sharer.php?u=https://www.datacamp.com/community/tutorials/networkx-python-graph-tutorial
  67. https://twitter.com/intent/tweet?url=https://www.datacamp.com/community/tutorials/networkx-python-graph-tutorial
  68. https://www.linkedin.com/cws/share?url=https://www.datacamp.com/community/tutorials/networkx-python-graph-tutorial
  69. https://www.datacamp.com/profile/andrewbrooksct
  70. https://www.facebook.com/sharer.php?u=https://www.datacamp.com/community/tutorials/networkx-python-graph-tutorial
  71. https://twitter.com/intent/tweet?url=https://www.datacamp.com/community/tutorials/networkx-python-graph-tutorial
  72. https://www.linkedin.com/cws/share?url=https://www.datacamp.com/community/tutorials/networkx-python-graph-tutorial
  73. https://www.facebook.com/pages/datacamp/726282547396228
  74. https://twitter.com/datacamp
  75. https://www.linkedin.com/company/datamind-org
  76. https://www.youtube.com/channel/uc79gv3myp6zkiswyemeik9a
