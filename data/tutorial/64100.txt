   #[1]github [2]recent commits to python3_with_pleasure:master

   [3]skip to content

   (button)

     * why github?
       [4]features    
          + [5]code review
          + [6]project management
          + [7]integrations
          + [8]actions
          + [9]team management
          + [10]social coding
          + [11]documentation
          + [12]code hosting
          + [13]customer stories    
          + [14]security    
     * [15]enterprise
     * explore
          + [16]explore github    

learn & contribute
          + [17]topics
          + [18]collections
          + [19]trending
          + [20]learning lab
          + [21]open source guides

connect with others
          + [22]events
          + [23]community forum
          + [24]github education
     * [25]marketplace
     * pricing
       [26]plans    
          + [27]compare plans
          + [28]contact sales
          + [29]nonprofit    
          + [30]education    

   ____________________
     * in this repository all github    
       jump to    

     * no suggested jump to results

     * in this repository all github    
       jump to    
     * in this repository all github    
       jump to    

   [31]sign in [32]sign up

     * [33]watch [34]98
     * [35]star [36]3,554
     * [37]fork [38]198

[39]arogozhnikov/[40]python3_with_pleasure

   [41]code [42]issues 2 [43]pull requests 0 [44]projects 0 [45]insights
   (button) dismiss

join github today

   github is home to over 31 million developers working together to host
   and review code, manage projects, and build software together.
   [46]sign up
   a short guide on features of python 3 with examples (updated for python
   3.7)
     * [47]138 commits
     * [48]2 branches
     * [49]0 releases
     * [50]fetching contributors

   branch: master (button) new pull request
   [51]find file
   clone or download

clone with https

   use git or checkout with svn using the web url.
   https://github.com/a
   [52]download zip

downloading...

   want to be notified of new releases in
   arogozhnikov/python3_with_pleasure?
   [53]sign in [54]sign up

launching github desktop...

   if nothing happens, [55]download github desktop and try again.

   (button) go back

launching github desktop...

   if nothing happens, [56]download github desktop and try again.

   (button) go back

launching xcode...

   if nothing happens, [57]download xcode and try again.

   (button) go back

launching visual studio...

   if nothing happens, [58]download the github extension for visual studio
   and try again.

   (button) go back
   [59]@arogozhnikov
   [60]arogozhnikov [61]add remark, [62]fix [63]#34
   latest commit [64]8cb8c37 nov 8, 2018
   [65]permalink
 type       name                   latest commit message             commit time
      failed to load latest commit information.
      [66]images       [67]added screenshot of variable annotations jan 27, 2018
      [68]readme.md    [69]add remark, [70]fix [71]#34              nov 9, 2018
      [72]readme_cn.md

readme.md

migrating to python 3 with pleasure

a short guide on features of python 3 for data scientists

   python became a mainstream language for machine learning and other
   scientific fields that heavily operate with data; it boasts various
   deep learning frameworks and well-established set of tools for data
   processing and visualization.

   however, python ecosystem co-exists in python 2 and python 3, and
   python 2 is still used among data scientists. by the end of 2019 the
   scientific stack will [73]stop supporting python2. as for numpy, after
   2018 any new feature releases will only support [74]python3. update
   (sep 2018): same story now with pandas, matplotlib, ipython, jupyter
   notebook and jupyter lab.

   to make the transition less frustrating, i've collected a bunch of
   python 3 features that you may find useful.

   [75][68747470733a2f2f75706c6f6164732e746f7074616c2e696f2f626c6f672f696d
   6167652f39323231362f746f7074616c2d626c6f672d696d6167652d313435373631383
   635393437322d6265326633383066653361616434313333333432376563643561316563
   3563352e6a7067]

   image from [76]dario bertini post (toptal)

better paths handling with pathlib

   pathlib is a default module in python3, that helps you to avoid tons of
   os.path.joins:
from pathlib import path

dataset = 'wiki_images'
datasets_root = path('/path/to/datasets/')

train_path = datasets_root / dataset / 'train'
test_path = datasets_root / dataset / 'test'

for image_path in train_path.iterdir():
    with image_path.open() as f: # note, open is a method of path object
        # do something with an image

   previously it was always tempting to use string concatenation (concise,
   but obviously bad), now with pathlib the code is safe, concise, and
   readable.

   also pathlib.path has a bunch of methods and properties, that every
   python novice previously had to google:
p.exists()
p.is_dir()
p.parts
p.with_name('sibling.png') # only change the name, but keep the folder
p.with_suffix('.jpg') # only change the extension, but keep the folder and the n
ame
p.chmod(mode)
p.rmdir()

   pathlib should save you lots of time, please see [77]docs and
   [78]reference for more.

type hinting is now part of the language

   example of type hinting in pycharm:
   [79][pycharm-type-hinting.png]

   python is not just a language for small scripts anymore, data pipelines
   these days include numerous steps each involving different frameworks
   (and sometimes very different logic).

   type hinting was introduced to help with growing complexity of
   programs, so machines could help with code verification. previously
   different modules used custom ways to point [80]types in docstrings
   (hint: pycharm can convert old docstrings to fresh type hinting).

   as a simple example, the following code may work with different types
   of data (that's what we like about python data stack).
def repeat_each_entry(data):
    """ each entry in the data is doubled
    <blah blah nobody reads the documentation till the end>
    """
    index = numpy.repeat(numpy.arange(len(data)), 2)
    return data[index]

   this code e.g. works for numpy.array (incl. multidimensional ones),
   astropy.table and astropy.column, bcolz, cupy, mxnet.ndarray and
   others.

   this code will work for pandas.series, but in the wrong way:
repeat_each_entry(pandas.series(data=[0, 1, 2], index=[3, 4, 5])) # returns seri
es with nones inside

   this was two lines of code. imagine how unpredictable behavior of a
   complex system, because just one function may misbehave. stating
   explicitly which types a method expects is very helpful in large
   systems, this will warn you if a function was passed unexpected
   arguments.
def repeat_each_entry(data: union[numpy.ndarray, bcolz.carray]):

   if you have a significant codebase, hinting tools like [81]mypy are
   likely to become part of your continuous integration pipeline. a
   webinar [82]"putting type hints to work" by daniel pyrathon is good for
   a brief introduction.

   sidenote: unfortunately, hinting is not yet powerful enough to provide
   fine-grained typing for ndarrays/tensors, but [83]maybe we'll have it
   once, and this will be a great feature for ds.

type hinting     type checking in runtime

   by default, function annotations do not influence how your code is
   working, but merely help you to point code intentions.

   however, you can enforce type checking in runtime with tools like ...
   [84]enforce, this can help you in debugging (there are many cases when
   type hinting is not working).
@enforce.runtime_validation
def foo(text: str) -> none:
    print(text)

foo('hi') # ok
foo(5)    # fails


@enforce.runtime_validation
def any2(x: list[bool]) -> bool:
    return any(x)

any ([false, false, true, false]) # true
any2([false, false, true, false]) # true

any (['false']) # true
any2(['false']) # fails

any ([false, none, "", 0]) # false
any2([false, none, "", 0]) # fails

[del: other usages of function annotations :del]

   update: starting from python 3.7 this behavior was [85]depreciated, and
   function annotations should be used for type hinting only. python 4
   will not support other usages of annotations.

   as mentioned before, annotations do not influence code execution, but
   rather provide some meta-information, and you can use it as you wish.

   for instance, measurement units are a common pain in scientific areas,
   astropy package [86]provides a simple decorator to control units of
   input quantities and convert output to required units
# python 3
from astropy import units as u
@u.quantity_input()
def frequency(speed: u.meter / u.s, wavelength: u.nm) -> u.terahertz:
    return speed / wavelength

frequency(speed=300_000 * u.km / u.s, wavelength=555 * u.nm)
# output: 540.5405405405404 thz, frequency of green visible light

   if you're processing tabular scientific data in python (not necessarily
   astronomical), you should give astropy a shot.

   you can also define your application-specific decorators to perform
   control / conversion of inputs and output in the same manner.

id127 with @

   let's implement one of the simplest ml models     a id75
   with l2 id173 (a.k.a. ridge regression):
# l2-regularized id75: || ax - y ||^2 + alpha * ||x||^2 -> min

# python 2
x = np.linalg.inv(np.dot(a.t, a) + alpha * np.eye(a.shape[1])).dot(a.t.dot(y))
# python 3
x = np.linalg.inv(a.t @ a + alpha * np.eye(a.shape[1])) @ (a.t @ y)

   the code with @ becomes more readable and more translatable between
   deep learning frameworks: same code x @ w + b[none, :] for a single
   layer of id88 works in numpy, cupy, pytorch, tensorflow (and
   other frameworks that operate with tensors).

globbing with **

   recursive folder globbing is not easy in python 2, even though the
   [87]glob2 custom module exists that overcomes this. a recursive flag is
   supported since python 3.5:
import glob

# python 2
found_images = (
    glob.glob('/path/*.jpg')
  + glob.glob('/path/*/*.jpg')
  + glob.glob('/path/*/*/*.jpg')
  + glob.glob('/path/*/*/*/*.jpg')
  + glob.glob('/path/*/*/*/*/*.jpg'))

# python 3
found_images = glob.glob('/path/**/*.jpg', recursive=true)

   a better option is to use pathlib in python3 (minus one import!):
# python 3
found_images = pathlib.path('/path/').glob('**/*.jpg')

   note: there are [88]minor differences between glob.glob, path.glob and
   bash globbing.

print is a function now

   yes, code now has these annoying parentheses, but there are some
   advantages:
     * simple syntax for using file descriptor:
print >>sys.stderr, "critical error"      # python 2
print("critical error", file=sys.stderr)  # python 3
     * printing tab-aligned tables without str.join:
# python 3
print(*array, sep='\t')
print(batch, epoch, loss, accuracy, time, sep='\t')
     * hacky suppressing / redirection of printing output:
# python 3
_print = print # store the original print function
def print(*args, **kargs):
    pass  # do something useful, e.g. store output to some file
       in jupyter it is desirable to log each output to a separate file
       (to track what's happening after you got disconnected), so you can
       override print now.
       below you can see a context manager that temporarily overrides
       behavior of print:
@contextlib.contextmanager
def replace_print():
    import builtins
    _print = print # saving old print function
    # or use some other function here
    builtins.print = lambda *args, **kwargs: _print('new printing', *args, **kwa
rgs)
    yield
    builtins.print = _print

with replace_print():
    <code here will invoke other print function>
       it is not a recommended approach, but a small dirty hack that is
       now possible.
     * print can participate in list comprehensions and other language
       constructs
# python 3
result = process(x) if is_valid(x) else print('invalid item: ', x)

underscores in numeric literal (thousands separator)

   [89]pep-515 introduced underscores in numeric literals. in python3,
   underscores can be used to group digits visually in integral,
   floating-point, and complex number literals.
# grouping decimal numbers by thousands
one_million = 1_000_000

# grouping hexadecimal addresses by words
addr = 0xcafe_f00d

# grouping bits into nibbles in a binary literal
flags = 0b_0011_1111_0100_1110

# same, for string conversions
flags = int('0b_1111_0000', 2)

f-strings for simple and reliable formatting

   the default formatting system provides a flexibility that is not
   required in data experiments. the resulting code is either too verbose
   or too fragile towards any changes.

   quite typically data scientists outputs some logging information
   iteratively in a fixed format. it is common to have a code like:
# python 2
print '{batch:3} {epoch:3} / {total_epochs:3}  accuracy: {acc_mean:0.4f}  {acc_st
d:0.4f} time: {avg_time:3.2f}'.format(
    batch=batch, epoch=epoch, total_epochs=total_epochs,
    acc_mean=numpy.mean(accuracies), acc_std=numpy.std(accuracies),
    avg_time=time / len(data_batch)
)

# python 2 (too error-prone during fast modifications, please avoid):
print '{:3} {:3} / {:3}  accuracy: {:0.4f}  {:0.4f} time: {:3.2f}'.format(
    batch, epoch, total_epochs, numpy.mean(accuracies), numpy.std(accuracies),
    time / len(data_batch)
)

   sample output:
120  12 / 300  accuracy: 0.8180  0.4649 time: 56.60

   f-strings aka formatted string literals were introduced in python 3.6:
# python 3.6+
print(f'{batch:3} {epoch:3} / {total_epochs:3}  accuracy: {numpy.mean(accuracies
):0.4f}  {numpy.std(accuracies):0.4f} time: {time / len(data_batch):3.2f}')

explicit difference between 'true division' and 'floor division'

   for data science this is definitely a handy change
data = pandas.read_csv('timing.csv')
velocity = data['distance'] / data['time']

   results in python 2 depend on whether 'time' and 'distance' (e.g.
   measured in meters and seconds) are stored as integers. in python 3,
   the result is correct in both cases, because the result of division is
   float.

   another case is floor division, which is now an explicit operation:
n_gifts = money // gift_price  # correct for int and float arguments

   in a nutshell:
>>> from operator import truediv, floordiv
>>> truediv.__doc__, floordiv.__doc__
('truediv(a, b) -- same as a / b.', 'floordiv(a, b) -- same as a // b.')
>>> (3 / 2), (3 // 2), (3.0 // 2.0)
(1.5, 1, 1.0)

   note, that this applies both to built-in types and to custom types
   provided by data packages (e.g. numpy or pandas).

strict ordering

# all these comparisons are illegal in python 3
3 < '3'
2 < none
(3, 4) < (3, none)
(4, 5) < [4, 5]

# false in both python 2 and python 3
(4, 5) == [4, 5]

     * prevents from occasional sorting of instances of different types
sorted([2, '1', 3])  # invalid for python 3, in python 2 returns [2, 3, '1']
     * helps to spot some problems that arise when processing raw data

   sidenote: proper check for none is (in both python versions)
if a is not none:
  pass

if a: # wrong check for none
  pass

unicode for nlp

s = '      '
print(len(s))
print(s[:2])

   output:
     * python 2: 6\n      
     * python 3: 2\n      .

x = u'    '
x += 'co' # ok
x += '    ' # fail

   python 2 fails, python 3 works as expected (because i've used russian
   letters in strings).

   in python 3 strs are unicode strings, and it is more convenient for nlp
   processing of non-english texts.

   there are other funny things, for instance:
'a' < type < u'a'  # python 2: true
'a' < u'a'         # python 2: false

from collections import counter
counter('m  belst  ck')

     * python 2: counter({'\xc3': 2, 'b': 1, 'e': 1, 'c': 1, 'k': 1, 'm':
       1, 'l': 1, 's': 1, 't': 1, '\xb6': 1, '\xbc': 1})
     * python 3: counter({'m': 1, '  ': 1, 'b': 1, 'e': 1, 'l': 1, 's': 1,
       't': 1, '  ': 1, 'c': 1, 'k': 1})

   you can handle all of this in python 2 properly, but python 3 is more
   friendly.

preserving order of dictionaries and **kwargs

   in cpython 3.6+ dicts behave like ordereddict by default (and [90]this
   is guaranteed in python 3.7+). this preserves order during dict
   comprehensions (and other operations, e.g. during json
   serialization/deserialization)
import json
x = {str(i):i for i in range(5)}
json.loads(json.dumps(x))
# python 2
{u'1': 1, u'0': 0, u'3': 3, u'2': 2, u'4': 4}
# python 3
{'0': 0, '1': 1, '2': 2, '3': 3, '4': 4}

   same applies to **kwargs (in python 3.6+), they're kept in the same
   order as they appear in parameters. order is crucial when it comes to
   data pipelines, previously we had to write it in a cumbersome manner:
from torch import nn

# python 2
model = nn.sequential(ordereddict([
          ('conv1', nn.conv2d(1,20,5)),
          ('relu1', nn.relu()),
          ('conv2', nn.conv2d(20,64,5)),
          ('relu2', nn.relu())
        ]))

# python 3.6+, how it *can* be done, not supported right now in pytorch
model = nn.sequential(
    conv1=nn.conv2d(1,20,5),
    relu1=nn.relu(),
    conv2=nn.conv2d(20,64,5),
    relu2=nn.relu())
)

   did you notice? uniqueness of names is also checked automatically.

iterable unpacking

# handy when amount of additional stored info may vary between experiments, but
the same code can be used in all cases
model_paramteres, optimizer_parameters, *other_params = load(checkpoint_name)

# picking two last values from a sequence
*prev, next_to_last, last = values_history

# this also works with any iterables, so if you have a function that yields e.g.
 qualities,
# below is a simple way to take only last two values from a list
*prev, next_to_last, last = iter_train(args)

default pickle engine provides better compression for arrays

   pickling is a mechanism to pass data between threads / processes, in
   particular used inside multiprocessing package.
# python 2
import cpickle as pickle
import numpy
print len(pickle.dumps(numpy.random.normal(size=[1000, 1000])))
# result: 23691675

# python 3
import pickle
import numpy
len(pickle.dumps(numpy.random.normal(size=[1000, 1000])))
# result: 8000162

   three times less space. and it is much faster. actually similar
   compression (but not speed) is achievable with protocol=2 parameter,
   but developers typically ignore this option (or simply are not aware of
   it).

   note: pickle is [91]not safe (and not quite transferrable), so never
   unpickle data received from an untrusted or unauthenticated source.

safer comprehensions

labels = <initial_value>
predictions = [model.predict(data) for data, labels in dataset]

# labels are overwritten in python 2
# labels are not affected by comprehension in python 3

super, simply super()

   python 2 super(...) was a frequent source of mistakes in code.
# python 2
class mysubclass(mysuperclass):
    def __init__(self, name, **options):
        super(mysubclass, self).__init__(name='subclass', **options)

# python 3
class mysubclass(mysuperclass):
    def __init__(self, name, **options):
        super().__init__(name='subclass', **options)

   more on super and method resolution order on [92]stackoverflow.

better ide suggestions with variable annotations

   the most enjoyable thing about programming in languages like java, c#
   and alike is that ide can make very good suggestions, because type of
   each identifier is known before executing a program.

   in python this is hard to achieve, but annotations will help you
     * write your expectations in a clear form
     * and get good suggestions from ide

   [93][variable_annotations.png]
   this is an example of pycharm suggestions with variable annotations.
   this works even in situations when functions you use are not annotated
   (e.g. due to backward compatibility).

multiple unpacking

   here is how you merge two dicts now:
x = dict(a=1, b=2)
y = dict(b=3, d=4)
# python 3.5+
z = {**x, **y}
# z = {'a': 1, 'b': 3, 'd': 4}, note that value for `b` is taken from the latter
 dict.

   see [94]this thread at stackoverflow for a comparison with python 2.

   the same approach also works for lists, tuples, and sets (a, b, c are
   any iterables):
[*a, *b, *c] # list, concatenating
(*a, *b, *c) # tuple, concatenating
{*a, *b, *c} # set, union

   functions also [95]support multiple unpacking for *args and **kwargs:
# python 3.5+
do_something(**{**default_settings, **custom_settings})

# also possible, this code also checks there is no intersection between keys of
dictionaries
do_something(**first_args, **second_args)

future-proof apis with keyword-only arguments

   let's consider this snippet
model = sklearn.id166.svc(2, 'poly', 2, 4, 0.5)

   obviously, an author of this code didn't get the python style of coding
   yet (most probably, just jumped from cpp or rust). unfortunately, this
   is not just question of taste, because changing the order of arguments
   (adding/deleting) in svc will break this code. in particular, sklearn
   does some reordering/renaming from time to time of numerous algorithm
   parameters to provide consistent api. each such refactoring may drive
   to broken code.

   in python 3, library authors may demand explicitly named parameters by
   using *:
class svc(basesvc):
    def __init__(self, *, c=1.0, kernel='rbf', degree=3, gamma='auto', coef0=0.0
, ... )

     * users have to specify names of parameters sklearn.id166.svc(c=2,
       kernel='poly', degree=2, gamma=4, coef0=0.5) now
     * this mechanism provides a great combination of reliability and
       flexibility of apis

data classes

   python 3.7 introduces data classes, a good replacement for namedtuple
   in most cases.
@dataclass
class person:
    name: str
    age: int

@dataclass
class coder(person):
    preferred_language: str = 'python 3'

   dataclass decorator takes the job of implementing routine methods for
   you (initialization, representation, comparison, and hashing when
   applicable). let's name some features:
     * data classes can be both mutable and immutable
     * default values for fields are supported
     * inheritance
     * data classes are still old good classes: you can define new methods
       and override existing
     * post-init processing (e.g. to verify consistency)

   geir arne hjelle gives a good overview of dataclasses [96]in his post.

customizing access to module attributes

   in python you can control attribute access and hinting with __getattr__
   and __dir__ for any object. since python 3.7 you can do it for modules
   too.

   a natural example is implementing a random submodule of tensor
   libraries, which is typically a shortcut to skip initialization and
   passing of randomstate objects. here's implementation for numpy:
# nprandom.py
import numpy
__random_state = numpy.random.randomstate()

def __getattr__(name):
    return getattr(__random_state, name)

def __dir__():
    return dir(__random_state)

def seed(seed):
    __random_state = numpy.random.randomstate(seed=seed)

   one can also mix this way functionalities of different
   objects/submodules. compare with tricks in [97]pytorch and [98]cupy.

   additionally, now one can
     * use it for [99]lazy loading of submodules. for example, import
       tensorflow takes ~150mb of ram is imports all submodules (and
       dependencies).
     * use this for [100]deprecations in api
     * introduce runtime routing between submodules

built-in breakpoint()

   just write breakpoint() in the code to invoke debugger.
# python 3.7+, not all ides support this at the moment
foo()
breakpoint()
bar()

   for remote debugging you may want to try [101]combining breakpoint()
   with web-pdb

minor: constants in math module

# python 3
math.inf # infinite float
math.nan # not a number

max_quality = -math.inf  # no more magic initial values!

for model in trained_models:
    max_quality = max(max_quality, compute_quality(model, data))

minor: single integer type

   python 2 provides two basic integer types, which are int (64-bit signed
   integer) and long for long arithmetics (quite confusing after c++).

   python 3 has a single type int, which incorporates long arithmetics.

   here is how you check that value is integer:
isinstance(x, numbers.integral) # python 2, the canonical way
isinstance(x, (long, int))      # python 2
isinstance(x, int)              # python 3, easier to remember

   update: first check also works for other integral types, such as
   numpy.int32, numpy.int64, but others don't. so they're not equivalent.

other stuff

     * enums are theoretically useful, but
          + string-typing is already widely adopted in the python data
            stack
          + enums don't seem to interplay with numpy and categorical from
            pandas
     * coroutines also sound very promising for data pipelining (see
       [102]slides by david beazley), but i don't see their adoption in
       the wild.
     * python 3 has [103]stable abi
     * python 3 supports unicode identifies (so    =      /   t is ok), but
       you'd [104]better use good old ascii names
     * some libraries e.g. [105]jupyterhub (jupyter in cloud), django and
       fresh ipython only support python 3, so features that sound useless
       for you are useful for libraries you'll probably want to use once.

problems for code migration specific for data science (and how to resolve
those)

     * support for nested arguments [106]was dropped
map(lambda x, (y, z): x, z, dict.items())
       however, it is still perfectly working with different
       comprehensions:
{x:z for x, (y, z) in d.items()}
       in general, comprehensions are also better 'translatable' between
       python 2 and 3.
     * map(), .keys(), .values(), .items(), etc. return iterators, not
       lists. main problems with iterators are:
          + no trivial slicing
          + can't be iterated twice
       almost all of the problems are resolved by converting result to
       list.
     * see [107]python faq: how do i port to python 3? when in trouble

main problems for teaching machine learning and data science with python

   course authors should spend time in the first lectures to explain what
   is an iterator, why it can't be sliced / concatenated / multiplied /
   iterated twice like a string (and how to deal with it).

   i think most course authors would be happy to avoid these details, but
   now it is hardly possible.

conclusion

   python 2 and python 3 have co-existed for almost 10 years, but we
   should move to python 3.

   research and production code should become a bit shorter, more
   readable, and significantly safer after moving to python 3-only
   codebase.

   right now most libraries support both python versions. and i can't wait
   for the bright moment when packages drop support for python 2 and enjoy
   new language features.

   following migrations are promised to be smoother: [108]"we will never
   do this kind of backwards-incompatible change again"

links

     * [109]key differences between python 2.7 and python 3.x
     * [110]python faq: how do i port to python 3?
     * [111]10 awesome features of python that you can't use because you
       refuse to upgrade to python 3
     * [112]trust me, python 3.3 is better than 2.7 (video)
     * [113]python 3 for scientists

license

   this text was published by [114]alex rogozhnikov and [115]contributors
   under [116]cc by-sa 3.0 license (excluding images).

     *    2019 github, inc.
     * [117]terms
     * [118]privacy
     * [119]security
     * [120]status
     * [121]help

     * [122]contact github
     * [123]pricing
     * [124]api
     * [125]training
     * [126]blog
     * [127]about

   (button) you can   t perform that action at this time.

   you signed in with another tab or window. [128]reload to refresh your
   session. you signed out in another tab or window. [129]reload to
   refresh your session.

   (button)

references

   visible links
   1. https://github.com/opensearch.xml
   2. https://github.com/arogozhnikov/python3_with_pleasure/commits/master.atom
   3. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#start-of-content
   4. https://github.com/features
   5. https://github.com/features/code-review/
   6. https://github.com/features/project-management/
   7. https://github.com/features/integrations
   8. https://github.com/features/actions
   9. https://github.com/features#team-management
  10. https://github.com/features#social-coding
  11. https://github.com/features#documentation
  12. https://github.com/features#code-hosting
  13. https://github.com/customer-stories
  14. https://github.com/security
  15. https://github.com/enterprise
  16. https://github.com/explore
  17. https://github.com/topics
  18. https://github.com/collections
  19. https://github.com/trending
  20. https://lab.github.com/
  21. https://opensource.guide/
  22. https://github.com/events
  23. https://github.community/
  24. https://education.github.com/
  25. https://github.com/marketplace
  26. https://github.com/pricing
  27. https://github.com/pricing#feature-comparison
  28. https://enterprise.github.com/contact?utm_campaign=read_more&utm_medium=blog&utm_source=mybridge
  29. https://github.com/nonprofit
  30. https://education.github.com/
  31. https://github.com/login?return_to=/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more
  32. https://github.com/join
  33. https://github.com/login?return_to=/arogozhnikov/python3_with_pleasure
  34. https://github.com/arogozhnikov/python3_with_pleasure/watchers
  35. https://github.com/login?return_to=/arogozhnikov/python3_with_pleasure
  36. https://github.com/arogozhnikov/python3_with_pleasure/stargazers
  37. https://github.com/login?return_to=/arogozhnikov/python3_with_pleasure
  38. https://github.com/arogozhnikov/python3_with_pleasure/network/members
  39. https://github.com/arogozhnikov
  40. https://github.com/arogozhnikov/python3_with_pleasure
  41. https://github.com/arogozhnikov/python3_with_pleasure
  42. https://github.com/arogozhnikov/python3_with_pleasure/issues
  43. https://github.com/arogozhnikov/python3_with_pleasure/pulls
  44. https://github.com/arogozhnikov/python3_with_pleasure/projects
  45. https://github.com/arogozhnikov/python3_with_pleasure/pulse
  46. https://github.com/join?source=prompt-code
  47. https://github.com/arogozhnikov/python3_with_pleasure/commits/master
  48. https://github.com/arogozhnikov/python3_with_pleasure/branches
  49. https://github.com/arogozhnikov/python3_with_pleasure/releases
  50. https://github.com/arogozhnikov/python3_with_pleasure/graphs/contributors
  51. https://github.com/arogozhnikov/python3_with_pleasure/find/master
  52. https://github.com/arogozhnikov/python3_with_pleasure/archive/master.zip
  53. https://github.com/login?return_to=https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more
  54. https://github.com/join?return_to=/arogozhnikov/python3_with_pleasure
  55. https://desktop.github.com/
  56. https://desktop.github.com/
  57. https://developer.apple.com/xcode/
  58. https://visualstudio.github.com/
  59. https://github.com/arogozhnikov
  60. https://github.com/arogozhnikov/python3_with_pleasure/commits?author=arogozhnikov
  61. https://github.com/arogozhnikov/python3_with_pleasure/commit/8cb8c37ae3e52c191cbbb80db3d27e4776a387a4
  62. https://github.com/arogozhnikov/python3_with_pleasure/commit/8cb8c37ae3e52c191cbbb80db3d27e4776a387a4
  63. https://github.com/arogozhnikov/python3_with_pleasure/issues/34
  64. https://github.com/arogozhnikov/python3_with_pleasure/commit/8cb8c37ae3e52c191cbbb80db3d27e4776a387a4
  65. https://github.com/arogozhnikov/python3_with_pleasure/tree/8cb8c37ae3e52c191cbbb80db3d27e4776a387a4
  66. https://github.com/arogozhnikov/python3_with_pleasure/tree/master/images
  67. https://github.com/arogozhnikov/python3_with_pleasure/commit/3232a0526289a4da31e91f7ff0dd1e3a53a674ff
  68. https://github.com/arogozhnikov/python3_with_pleasure/blob/master/readme.md
  69. https://github.com/arogozhnikov/python3_with_pleasure/commit/8cb8c37ae3e52c191cbbb80db3d27e4776a387a4
  70. https://github.com/arogozhnikov/python3_with_pleasure/commit/8cb8c37ae3e52c191cbbb80db3d27e4776a387a4
  71. https://github.com/arogozhnikov/python3_with_pleasure/issues/34
  72. https://github.com/arogozhnikov/python3_with_pleasure/blob/master/readme_cn.md
  73. http://www.python3statement.org/
  74. https://github.com/numpy/numpy/blob/master/doc/neps/dropping-python2.7-proposal.rst
  75. https://camo.githubusercontent.com/9936046c7d691a3f6d74c2873e483332b7a0b20e/68747470733a2f2f75706c6f6164732e746f7074616c2e696f2f626c6f672f696d6167652f39323231362f746f7074616c2d626c6f672d696d6167652d313435373631383635393437322d62653266333830666533616164343133333334323765636435613165633563352e6a7067
  76. https://www.toptal.com/python/python-3-is-it-worth-the-switch
  77. https://docs.python.org/3/library/pathlib.html
  78. https://pymotw.com/3/pathlib/
  79. https://github.com/arogozhnikov/python3_with_pleasure/blob/master/images/pycharm-type-hinting.png
  80. https://www.jetbrains.com/help/pycharm/type-hinting-in-pycharm.html#legacy
  81. http://mypy.readthedocs.io/
  82. https://www.youtube.com/watch?v=jqbcffie11g
  83. https://github.com/numpy/numpy/issues/7370
  84. https://github.com/russbaz/enforce
  85. https://www.python.org/dev/peps/pep-0563/#non-typing-usage-of-annotations
  86. http://docs.astropy.org/en/stable/units/quantity.html#functions-that-accept-quantities
  87. https://github.com/miracle2k/python-glob2
  88. https://github.com/arogozhnikov/python3_with_pleasure/issues/16
  89. https://www.python.org/dev/peps/pep-0515/
  90. https://stackoverflow.com/questions/39980323/are-dictionaries-ordered-in-python-3-6
  91. https://docs.python.org/3/library/pickle.html
  92. https://stackoverflow.com/questions/576169/understanding-python-super-with-init-methods
  93. https://github.com/arogozhnikov/python3_with_pleasure/blob/master/images/variable_annotations.png
  94. https://stackoverflow.com/questions/38987/how-to-merge-two-dictionaries-in-a-single-expression
  95. https://docs.python.org/3/whatsnew/3.5.html#whatsnew-pep-448
  96. https://realpython.com/python-data-classes/
  97. https://github.com/pytorch/pytorch/blob/3ce17bf8f6a2c4239085191ea60d6ee51cd620a5/torch/__init__.py#l253-l256
  98. https://github.com/cupy/cupy/blob/94592ecac8152d5f4a56a129325cc91d184480ad/cupy/random/distributions.py
  99. https://snarky.ca/lazy-importing-in-python-3-7/
 100. https://www.python.org/dev/peps/pep-0562/
 101. https://hackernoon.com/python-3-7s-new-builtin-breakpoint-a-quick-tour-4f1aebc444c
 102. http://www.dabeaz.com/coroutines/coroutines.pdf
 103. https://www.python.org/dev/peps/pep-0384/
 104. https://stackoverflow.com/a/29855176/498892
 105. https://github.com/jupyterhub/jupyterhub
 106. https://www.python.org/dev/peps/pep-3113/
 107. https://eev.ee/blog/2016/07/31/python-faq-how-do-i-port-to-python-3/
 108. https://snarky.ca/why-python-3-exists/
 109. http://sebastianraschka.com/articles/2014_python_2_3_key_diff.html
 110. https://eev.ee/blog/2016/07/31/python-faq-how-do-i-port-to-python-3/
 111. http://www.asmeurer.com/python3-presentation/slides.html
 112. http://pyvideo.org/pycon-us-2013/python-33-trust-me-its-better-than-27.html
 113. http://python-3-for-scientists.readthedocs.io/en/latest/
 114. https://arogozhnikov.github.io/about/
 115. https://github.com/arogozhnikov/python3_with_pleasure/graphs/contributors
 116. https://creativecommons.org/licenses/by-sa/3.0/
 117. https://github.com/site/terms
 118. https://github.com/site/privacy
 119. https://github.com/security
 120. https://githubstatus.com/
 121. https://help.github.com/
 122. https://github.com/contact
 123. https://github.com/pricing
 124. https://developer.github.com/
 125. https://training.github.com/
 126. https://github.blog/
 127. https://github.com/about
 128. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more
 129. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more

   hidden links:
 131. https://github.com/
 132. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more
 133. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more
 134. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more
 135. https://help.github.com/articles/which-remote-url-should-i-use
 136. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#migrating-to-python-3-with-pleasure
 137. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#a-short-guide-on-features-of-python-3-for-data-scientists
 138. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#better-paths-handling-with-pathlib
 139. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#type-hinting-is-now-part-of-the-language
 140. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#type-hinting--type-checking-in-runtime
 141. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#other-usages-of-function-annotations
 142. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#matrix-multiplication-with-
 143. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#globbing-with-
 144. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#print-is-a-function-now
 145. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#underscores-in-numeric-literal-thousands-separator
 146. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#f-strings-for-simple-and-reliable-formatting
 147. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#explicit-difference-between-true-division-and-floor-division
 148. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#strict-ordering
 149. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#unicode-for-nlp
 150. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#preserving-order-of-dictionaries-and-kwargs
 151. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#iterable-unpacking
 152. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#default-pickle-engine-provides-better-compression-for-arrays
 153. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#safer-comprehensions
 154. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#super-simply-super
 155. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#better-ide-suggestions-with-variable-annotations
 156. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#multiple-unpacking
 157. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#future-proof-apis-with-keyword-only-arguments
 158. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#data-classes
 159. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#customizing-access-to-module-attributes
 160. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#built-in-breakpoint
 161. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#minor-constants-in-math-module
 162. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#minor-single-integer-type
 163. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#other-stuff
 164. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#problems-for-code-migration-specific-for-data-science-and-how-to-resolve-those
 165. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#main-problems-for-teaching-machine-learning-and-data-science-with-python
 166. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#conclusion
 167. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#links
 168. https://github.com/arogozhnikov/python3_with_pleasure?utm_source=mybridge&utm_medium=blog&utm_campaign=read_more#license
 169. https://github.com/
