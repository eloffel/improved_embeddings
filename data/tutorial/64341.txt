8
1
0
2

 

n
a
j
 
7
1

 
 
]

.

o
h
h
t
a
m

[
 
 

1
v
4
9
8
5
0

.

1
0
8
1
:
v
i
x
r
a

deep learning: an introduction for applied

mathematicians

catherine f. higham   

desmond j. higham   

january 19, 2018

abstract

multilayered arti   cial neural networks are becoming a pervasive tool
in a host of application    elds. at the heart of this deep learning revolution
are familiar concepts from applied and computational mathematics; no-
tably, in calculus, approximation theory, optimization and id202.
this article provides a very brief introduction to the basic ideas that un-
derlie deep learning from an applied mathematics perspective. our target
audience includes postgraduate and    nal year undergraduate students in
mathematics who are keen to learn about the area. the article may also
be useful for instructors in mathematics who wish to enliven their classes
with references to the application of deep learning techniques. we focus
on three fundamental questions: what is a deep neural network? how is a
network trained? what is the stochastic gradient method? we illustrate
the ideas with a short matlab code that sets up and trains a network.
we also show the use of state-of-the art software on a large scale image
classi   cation problem. we    nish with references to the current literature.

1 motivation

most of us have come across the phrase deep learning.
it relates to a set of
tools that have become extremely popular in a vast range of application    elds,
from image recognition, id103 and natural language processing to
targeted advertising and drug discovery. the    eld has grown to the extent
where sophisticated software packages are available in the public domain, many
produced by high-pro   le technology companies. chip manufacturers are also
customizing their graphics processing units (gpus) for kernels at the heart of
deep learning.

   school

of

computing

science,

uk
this author was supported by the epsrc uk

university

glasgow,

of

(catherine.higham@glasgow.ac.uk).
quantum technology programme under grant ep/m01326x/1.

   department

of strathclyde, uk
(d.j.higham@strath.ac.uk). this author was supported by the epsrc/rcuk digi-
tal economy programme under grant ep/m00158x/1.

and statistics, university

of mathematics

1

whether or not its current level of attention is fully justi   ed, deep learning is
clearly a topic of interest to employers, and therefore to our students. although
there are many useful resources available, we feel that there is a niche for a
brief treatment aimed at mathematical scientists. for a mathematics student,
gaining some familiarity with deep learning can enhance employment prospects.
for mathematics educators, slipping    applications to deep learning    into the
syllabus of a class on calculus, approximation theory, optimization, linear al-
gebra, or scienti   c computing is a great way to attract students and maintain
their interest in core topics. the area is also ripe for independent project study.
there is no novel material in this article, and many topics are glossed over
or omitted. our aim is to present some key ideas as clearly as possible while
avoiding non-essential detail. the treatment is aimed at readers with a back-
ground in mathematics who have completed a course in id202 and are
familiar with partial di   erentiation. some experience of scienti   c computing is
also desirable.

to keep the material concrete, we list and walk through a short matlab
code that illustrates the main algorithmic steps in setting up, training and
applying an arti   cial neural network. we also demonstrate the high-level use of
state-of-the-art software on a larger scale problem.

section 2 introduces some key ideas by creating and training an arti   cial
neural network using a simple example. section 3 sets up some useful notation
and de   nes a general network. training a network, which involves the solution
of an optimization problem, is the main computational challenge in this    eld.
in section 4 we describe the stochastic gradient method, a variation of a tra-
ditional optimization technique that is designed to cope with very large scale
sets of training data. section 5 explains how the partial derivatives needed for
the stochastic gradient method can be computed e   ciently using back propa-
gation. first-principles matlab code that illustrates these ideas is provided
in section 6. a larger scale problem is treated in section 7. here we make
use of existing software. rather than repeatedly acknowledge work throughout
the text, we have chosen to place the bulk of our citations in section 8, where
pointers to the large and growing literature are given. in that section we also
raise issues that were not mentioned elsewhere, and highlight some current hot
topics.

2 example of an arti   cial neural network

this article takes a data    tting view of arti   cial neural networks. to be concrete,
consider the set of points shown in figure 1. this shows labeled data   some
points are in category a, indicated by circles, and the rest are in category b,
indicated by crosses. for example, the data may show oil drilling sites on a
map, where category a denotes a successful outcome. can we use this data
to categorize a newly proposed drilling site? our job is to construct a trans-
formation that takes any point in r2 and returns either a circle or a square.
of course, there are many reasonable ways to construct such a transformation.

2

figure 1:
crosses denote points in category b.

labeled data points in r2. circles denote points in category a.

the arti   cial neural network approach uses repeated application of a simple,
nonlinear function.

we will base our network on the sigmoid function

1

  (x) =

1 + e   x ,

(1)
which is illustrated in the upper half of figure 2 over the interval    10     x     10.
we may regard   (x) as a smoothed version of a step function, which itself mimics
the behavior of a neuron in the brain      ring (giving output equal to one) if the
input is large enough, and remaining inactive (giving output equal to zero)
otherwise. the sigmoid also has the convenient property that its derivative
takes the simple form

  (cid:48)(x) =   (x) (1       (x)) ,

(2)

which is straightforward to verify.

the steepness and location of the transition in the sigmoid function may
be altered by scaling and shifting the argument or, in the language of neural
networks, by weighting and biasing the input. the lower plot in figure 2 shows
   (3(x     5)). the factor 3 has sharpened the changeover and the shift    5 has
altered its location. to keep our notation managable, we need to interpret the
sigmoid function in a vectorized sense. for z     rm,    : rm     rm is de   ned by
applying the sigmoid function in the obvious componentwise manner, so that

(  (z))i =   (zi).

with this notation, we can set up layers of neurons. in each layer, every neuron
outputs a single real number, which is passed to every neuron in the next layer.
at the next layer, each neuron forms its own weighted combination of these
values, adds its own bias, and applies the sigmoid function. introducing some
mathematics, if the real numbers produced by the neurons in one layer are

3

figure 2: upper: sigmoid function (1). lower: sigmoid with shifted and scaled
input.

collected into a vector, a, then the vector of outputs from the next layer has the
form

  (w a + b).

(3)

here, w is matrix and b is a vector. we say that w contains the weights and
b contains the biases. the number of columns in w matches the number of
neurons that produced the vector a at the previous layer. the number of rows
in w matches the number of neurons at the current layer. the number of
components in b also matches the number of neurons at the current layer. to
emphasize the role of the ith neuron in (3), we could pick out the ith component
as

      (cid:88)

  

wijaj + bi

       ,

j

where the sum runs over all entries in a. throughout this article, we will be
switching between the vectorized and componentwise viewpoints to strike a
balance between clarity and brevity.

in the next section, we introduce a full set of notation that allows us to de   ne
a general network. before reaching that stage, we will give a speci   c example.
figure 3 represents an arti   cial neural network with four layers. we will apply
this form of network to the problem de   ned by figure 1. for the network in
figure 3 the    rst (input) layer is represented by two circles. this is because our
input data points have two components. the second layer has two solid circles,
indicating that two neurons are being employed. the arrows from layer one to
layer two indicate that both components of the input data are made available

4

figure 3: a network with four layers.

to the two neurons in layer two. since the input data has the form x     r2, the
weights and biases for layer two may be represented by a matrix w [2]     r2  2
and a vector b[2]     r2, respectively. the output from layer two then has the
form

  (w [2]x + b[2])     r2.

layer three has three neurons, each receiving input in r2. so the weights and
biases for layer three may be represented by a matrix w [3]     r3  2 and a vector
b[3]     r3, respectively. the output from layer three then has the form

(cid:16)

w [3]  (w [2]x + b[2]) + b[3](cid:17)     r3.

  

(cid:16)

w [4]  

the fourth (output) layer has two neurons, each receiving input in r3. so the
weights and biases for this layer may be represented by a matrix w [4]     r2  3
and a vector b[4]     r[2], respectively. the output from layer four, and hence
from the overall network, has the form

(cid:16)

w [3]  (w [2]x + b[2]) + b[3](cid:17)

+ b[4](cid:17)     r2.

f (x) =   

(4)
the expression (4) de   nes a function f : r2     r2 in terms of its 23
parameters   the entries in the weight matrices and bias vectors. recall that
our aim is to produce a classi   er based on the data in figure 1. we do this
by optimizing over the parameters. we will require f (x) to be close to [1, 0]t
for data points in category a and close to [0, 1]t for data points in category b.
then, given a new point x     r2, it would be reasonable to classify it according
to the largest component of f (x); that is, category a if f1(x) > f2(x) and
category b if f1(x) < f2(x), with some rule to break ties. this requirement on
f may be speci   ed through a cost function. denoting the ten data points in
figure 1 by {x{i}}10

i=1, we use y(x{i}) for the target output; that is,

(cid:21)
(cid:21)

                                 

(cid:20) 1
(cid:20) 0

0

1

y(x{i}) =

if x{i} is in category a,

if x{i} is in category b.

5

(5)

layer1(inputlayer)layer2layer3layer4(outputlayer)figure 4: visualization of output from an arti   cial neural network applied to
the data in figure 1.

our cost function then takes the form

(cid:16)

w [2], w [3], w [4], b[2], b[3], b[4](cid:17)

cost

10(cid:88)

i=1

=

1
10

1

2(cid:107)y(x{i})     f (x{i})(cid:107)2
2.

(6)

here, the factor 1
2 is included for convenience; it simpli   es matters when we start
di   erentiating. we emphasize that cost is a function of the weights and biases   
the data points are    xed. the form in (6), where discrepancy is measured by
averaging the squared euclidean norm over the data points, is often refered to as
a quadratic cost function. in the language of optimization, cost is our objective
function.

choosing the weights and biases in a way that minimizes the cost function
is refered to as training the network. we note that, in principle, rescaling an
objective function does not change an optimization problem. we should arrive
at the same minimizer if we change cost to, for example, 100 cost or cost/30.
so the factors 1/10 and 1/2 in (6) should have no e   ect on the outcome.

for the data in figure 1, we used the matlab optimization toolbox to
minimize the cost function (6) over the 23 parameters de   ning w [2], w [3],
w [4], b[2], b[3] and b[4]. more precisely, we used the nonlinear least-squares
solver lsqnonlin. for the trained network, figure 4 shows the boundary where
f1(x) > f2(x). so, with this approach, any point in the shaded region would
be assigned to category a and any point in the unshaded region to category b.
figure 5 shows how the network responds to additional training data. here
we added one further category b point, indicated by the extra cross at (0.3, 0.7),
and re-ran the optimization routine.

the example illustrated in figure 4 is small-scale by the standards of today   s
deep learning tools. however, the underlying optimization problem, minimizing
a non-convex objective function over 23 variables, is fundamentally di   cult.
we cannot exhaustively search over a 23 dimensional parameter space, and
we cannot guarantee to    nd the global minimum of a non-convex function.

6

figure 5: repeat of the experiment in figure 4 with an additional data point.

indeed, some experimentation with the location of the data points in figure 4
and with the choice of initial guess for the weights and biases makes it clear
that lsqnonlin, with its default settings, cannot always    nd an acceptable
solution. this motivates the material in sections 4 and 5, where we focus on
the optimization problem.

3 the general set-up

the four layer example in section 2 introduced the idea of neurons, represented
by the sigmoid function, acting in layers. at a general layer, each neuron receives
the same input   one real value from every neuron at the previous layer   and
produces one real value, which is passed to every neuron at the next layer. there
are two exceptional layers. at the input layer, there is no    previous layer    and
each neuron receives the input vector. at the output layer, there is no    next
layer    and these neurons provide the overall output. the layers in between
these two are called hidden layers. there is no special meaning to this phrase;
it simply indicates that these neurons are performing intermediate calculations.
deep learning is a loosely-de   ned term which implies that many hidden layers
are being used.

we now spell out the general form of the notation from section 2. we
suppose that the network has l layers, with layers 1 and l being the input and
output layers, respectively. suppose that layer l, for l = 1, 2, 3, . . . , l contains
nl neurons. so n1 is the dimension of the input data. overall, the network maps
from rn1 to rnl . we use w [l]     rnl  nl   1 to denote the matrix of weights at
layer l. more precisely, w[l]
jk is the weight that neuron j at layer l applies to the
output from neuron k at layer l     1. similarly, b[l]     rnl is the vector of biases
for layer l, so neuron j at layer l uses the bias b[l]
j .
in fig 6 we give an example with l = 5 layers. here, n1 = 4, n2 = 3, n3 = 4,
n4 = 5 and n5 = 2, so w [2]     r3  4, w [3]     r4  3, w [4]     r5  4, w [5]     r2  5,
b[2]     r3, b[3]     r4, b[4]     r5 and b[5]     r2.

7

figure 6: a network with    ve layers. the edge corresponding to the weight
w[3]
43 is highlighted. the output from neuron number 3 at layer 2 is weighted by
the factor w[3]

43 when it is fed into neuron number 4 at layer 3.

given an input x     rn1, we may then neatly summarize the action of the
j denote the output, or activation, from neuron j at layer

network by letting a[l]
l. so, we have

a[1] = x     rn1,
a[l] =   

w [l]a[l   1] + b[l](cid:17)     rnl ,

(cid:16)

for l = 2, 3, . . . , l.

(7)

(8)

it should be clear that (7) and (8) amount to an algorithm for feeding the input
forward through the network in order to produce an output a[l]     rnl . at the
end of section 5 this algorithm appears within a pseudocode description of an
approach for training a network.
for which there are given target outputs {y(x{i})}n
the quadratic cost function that we wish to minimize has the form

now suppose we have n pieces of data, or training points, in rn1, {x{i}}n

i=1,
i=1 in rnl . generalizing (6),

n(cid:88)

i=1

cost =

1
n

1

2(cid:107)y(x{i})     a[l](x{i})(cid:107)2
2,

(9)

where, to keep notation under control, we have not explicitly indicated that
cost is a function of all the weights and biases.

8

layer1(inputlayer)layer2layer3layer5(outputlayer)w[3]43layer44 stochastic gradient

we saw in the previous two sections that training a network corresponds to
choosing the parameters, that is, the weights and biases, that minimize the cost
function. the weights and biases take the form of matrices and vectors, but at
this stage it is convenient to imagine them stored as a single vector that we call
p. the example in figure 3 has a total of 23 weights and biases. so, in that case,
p     r23. generally, we will suppose p     rs, and write the cost function in (9)
as cost(p) to emphasize its dependence on the parameters. so cost : rs     r.
we now introduce a classical method in optimization that is often referred
to as steepest descent or id119. the method proceeds iteratively,
computing a sequence of vectors in rs with the aim of converging to a vector
that minimizes the cost function. suppose that our current vector is p. how
should we choose a perturbation,    p, so that the next vector, p+   p, represents
an improvement? if    p is small, then ignoring terms of order (cid:107)    p(cid:107)2, a taylor
series expansion gives

cost(p +    p)     cost(p) +

   pr.

(10)

s(cid:88)

    cost(p)

    pr

r=1

here     cost(p)/    pr denotes the partial derivative of the cost function with
respect to the rth parameter. for convenience, we will let    cost(p)     rs
denote the vector of partial derivatives, known as the gradient, so that

(   cost(p))r =

    cost(p)

    pr

.

then (10) becomes

cost(p +    p)     cost(p) +    cost(p)t    p.

(11)

our aim is to reduce the value of the cost function. the relation (11) motivates
the idea of choosing    p to make    cost(p)t    p as negative as possible. we can
address this problem via the cauchy   schwarz inequality, which states that for
any f, g     rs, we have |f t g|     (cid:107) f (cid:107)2(cid:107) g (cid:107)2. so the most negative that f t g
can be is    (cid:107) f (cid:107)2(cid:107) g (cid:107)2, which happens when f =    g. hence, based on (11), we
should choose    p to lie in the direction       cost(p). keeping in mind that (11)
is an approximation that is relevant only for small    p, we will limit ourselves
to a small step in that direction. this leads to the update

p     p          cost(p).

(12)

here    is small stepsize that, in this context, is known as the learning rate.
this equation de   nes the steepest descent method. we choose an initial vector
and iterate with (12) until some stopping criterion has been met, or until the
number of iterations has exceeded the computational budget.

9

our cost function (9) involves a sum of individual terms that runs over the
training data. it follows that the partial derivative    cost(p) is a sum over the
training data of individual partial derivatives. more precisely, let

cx{i} = 1

2(cid:107)y(x{i})     a[l](x{i})(cid:107)2
2.

then, from (9),

   cost(p) =

1
n

   cx{i} (p).

n(cid:88)

i=1

(13)

(14)

when we have a large number of parameters and a large number of training
points, computing the gradient vector (14) at every iteration of the steepest
descent method (12) can be prohibitively expensive. a much cheaper alternative
is to replace the mean of the individual gradients over all training points by the
gradient at a single, randomly chosen, training point. this leads to the simplest
form of what is called the stochastic gradient method. a single step may be
summarized as

1. choose an integer i uniformly at random from {1, 2, 3, . . . , n}.
2. update

p     p          cx{i} (p).

(15)

in words, at each step, the stochastic gradient method uses one randomly chosen
training point to represent the full training set. as the iteration proceeds, the
method sees more training points. so there is some hope that this dramatic
reduction in cost-per-iteration will be worthwhile overall. we note that, even
for very small   , the update (15) is not guaranteed to reduce the overall cost
function   we have traded the mean for a single sample. hence, although the
phrase stochastic id119 is widely used, we prefer to use stochastic
gradient.

the version of the stochastic gradient method that we introduced in (15) is
the simplest from a large range of possibilities. in particular, the index i in (15)
was chosen by sampling with replacement   after using a training point, it is
returned to the training set and is just as likely as any other point to be chosen
at the next step. an alternative is to sample without replacement; that is, to
cycle through each of the n training points in a random order. performing n
steps in this manner, refered to as completing an epoch, may be summarized as
follows:

1. shu   e the integers {1, 2, 3, . . . , n} into a new order, {k1, k2, k3, . . . , kn}.
2. for i = 1 upto n , update

p     p          cx{ki} (p).

(16)

if we regard the stochastic gradient method as approximating the mean over
all training points in (14) by a single sample, then it is natural to consider a
compromise where we use a small sample average. for some m (cid:28) n we could
take steps of the following form.

10

1. choose m integers, k1, k2, . . . , km, uniformly at random from {1, 2, 3, . . . , n}.
2. update

p     p       

1
m

   cx{ki} (p).

(17)

m(cid:88)

i=1

in this iteration, the set {x{ki}}n
i=1 is known as a mini-batch. there is a without
replacement alternative where, assuming n = km for some k, we split the
training set randomly into k distinct mini-batches and cycle through them.

because the stochastic gradient method is usually implemented within the
context of a very large scale computation, algorithmic choices such as mini-
batch size and the form of randomization are often driven by the requirements
of high performance computing architectures. also, it is, of course, possible to
vary these choices, along with others, such as the learning rate, dynamically as
the training progresses in an attempt to accelerate convergence.

section 6 describes a simple matlab code that uses a vanilla stochastic
in section 7 we use a state-of-the-art implementation and

gradient method.
section 8 has pointers to the current literature.

5 back propagation

we are now in a position to apply the stochastic gradient method in order
to train an arti   cial neural network. so we switch from the general vector
of parameters, p, used in section 4 to the entries in the weight matrices and
bias vectors. our task is to compute partial derivatives of the cost function
with respect to each w[l]
j . we saw that the idea behind the stochastic
gradient method is to exploit the structure of the cost function: because (9) is a
linear combination of individual terms that runs over the training data the same
is true of its partial derivatives. we therefore focus our attention on computing
those individual partial derivatives.
hence, for a    xed training point we regard cx{i} in (13) as a function of the
weights and biases. so we may drop the dependence on x{i} and simply write

jk and b[l]

c = 1

2(cid:107)y     a[l](cid:107)2
2.

(18)

we recall from (8) that a[l] is the output from the arti   cial neural network.
the dependence of c on the weights and biases arises only through a[l].

to derive worthwhile expressions for the partial derivatives, it is useful to

introduce two further sets of variables. first we let

z[l] = w [l]a[l   1] + b[l]     rnl ,

for l = 2, 3, . . . , l.

(19)

we refer to z[l]
j as the weighted input for neuron j at layer l. the fundamen-
tal relation (8) that propagates information through the network may then be
written

(cid:16)

z[l](cid:17)

a[l] =   

,

for l = 2, 3, . . . , l.

(20)

11

second, we let   [l]     rnl be de   ned by

  [l]
j =

    c
    z[l]
j

,

for 1     j     nl

and 2     l     l.

(21)

this expression, which is often called the error in the jth neuron at layer l,
is an intermediate quantity that is useful both for analysis and computation.
however, we point out that this useage of the term error is somewhat ambiguous.
at a general, hidden layer, it is not clear how much to    blame    each neuron for
discrepancies in the    nal output. also, at the output layer, l, the expression
(21) does not quantify those discrepancies directly. the idea of referring to   [l]
j
in (21) as an error seems to have arisen because the cost function can only be at
a minimum if all partial derivatives are zero, so   [l]
j = 0 is a useful goal. as we
mention later in this section, it may be more helpful to keep in mind that   [l]
j
measures the sensitivity of the cost function to the weighted input for neuron j
at layer l.
at this stage we also need to de   ne the hadamard, or componentwise, prod-
uct of two vectors. if x, y     rn, then x     y     rn is de   ned by (x     y)i = xiyi.
in words, the hadamard product is formed by pairwise multiplication of the
corresponding components.

with this notation, the following results are a consequence of the chain rule.

lemma 1 we have

  [l] =   (cid:48)(z[l])     (al     y),
  [l] =   (cid:48)(z[l])     (w [l+1])t   [l+1],
    c
    b[l]
j
    c
    w[l]
jk

j a[l   1]

=   [l]
j ,

=   [l]

k

.

(22)
for 2     l     l     1, (23)
for 2     l     l,

(24)

for 2     l     l.

(25)

are connected by a[l] =   (cid:0)z[l](cid:1), and hence

proof we begin by proving (22). the relation (20) with l = l shows that
and a[l]

z[l]
j

j

j

    a[l]
    z[l]

j

=   (cid:48)(z[l]
j ).

also, from (18),

nl(cid:88)

(yk     a[l]

k )2 =    (yj     a[l]
j ).

k=1

    c
    a[l]

j

=

   

    a[l]

j

1
2

so, using the chain rule,

  [l]
j =

    c
    z[l]

j

=

    c
    a[l]

j

j

    a[l]
    z[l]

j

= (a[l]

j     yj)  (cid:48)(z[l]
j ),

12

which is the componentwise form of (22).

to show (23), we use the chain rule to convert from z[l]
j

applying the chain rule, and using the de   nition (21),

to {z[l+1]

k

}nl+1
k=1 .

nl+1(cid:88)

nl+1(cid:88)

k=1

  [l]
j =

    c
   z[l]
j

=

    c

   z[l+1]

k

k=1

    z[l+1]
k
   z[l]
j

=

  [l+1]
k

    z[l+1]
k
   z[l]
j

.

(26)

now, from (19) we know that z[l+1]

j are connected via

hence,

in (26) this gives

z[l+1]
k

=

+ b[l+1]

.

k

nl(cid:88)

s=1

.

k

z[l]
s

z[l]
j

(cid:17)

w[l+1]
ks   

= w[l+1]

and z[l]

(cid:17)
(cid:16)
kj   (cid:48)(cid:16)
(cid:17)
kj   (cid:48)(cid:16)
(cid:17)(cid:16)
(w [l+1])t   [l+1](cid:17)
(cid:16)
z[l   1](cid:17)(cid:17)

  [l+1]
k w[l+1]

z[l]
j

+ b[l]
j .

,

j

    z[l+1]
k
   z[l]
j

k=1

  [l]
j =

nl+1(cid:88)
j =   (cid:48)(cid:16)
(cid:16)

z[l]
j =

  [l]

z[l]
j

w [l]  

which may be rearranged as

this is the componentwise form of (23).

to show (24), we note from (19) and (20) that z[l]
j

.

j

is connected to b[l]

j by

since z[l   1] does not depend on b[l]

j , we    nd that

    z[l]
j
    b[l]
j

= 1.

then, from the chain rule,

    c
    b[l]
j

=

    c
    z[l]
j

    z[l]
j
    b[l]
j

=

    c
    z[l]
j

=   [l]
j ,

using the de   nition (21). this gives (24).

finally, to obtain (25) we start with the componentwise version of (19),

z[l]
j =

jka[l   1]
w[l]

k

+ b[l]
j ,

nl   1(cid:88)

k=1

13

which gives

and

    z[l]
j
   w[l]
jk

= a[l   1]

k

,

independently of j,

= 0,

for s (cid:54)= j.

    z[l]
s
   w[l]
jk

(27)

(28)

in words, (27) and (28) follow because the jth neuron at layer l uses the weights
from only the jth row of w [l], and applies these weights linearly. then, from
the chain rule, (27) and (28) give

nl(cid:88)

s=1

    c
    w[l]
jk

=

    c
   z[l]
s

    z[l]
s
    w[l]
jk

=

    c
   z[l]
j

    z[l]
j
    w[l]
jk

=

    c
   z[l]
j

a[l   1]

k

=   [l]

j a[l   1]

k

,

where the last step used the de   nition of   [l]
j
(cid:4)

in (21). this completes the proof.

there are many aspects of lemma 1 that deserve our attention. we recall
from (7), (19) and (20) that the output a[l] can be evaluated from a forward pass
through the network, computing a[1], z[2], a[2], z[3], . . . , a[l] in order. having
done this, we see from (22) that   [l] is immediately available. then, from (23),
  [l   1],   [l   2], . . . ,   [2] may be computed in a backward pass. from (24) and
(25), we then have access to the partial derivatives. computing gradients in
this way is known as back propagation.

to gain further understanding of the back propagation formulas (24) and
(25) in lemma 1, it is useful to recall the fundamental de   nition of a partial
derivative. the quantity     c/    w[l]
jk measures how c changes when we make
a small perturbation to w[l]
jk. for illustration, figure 6 highlights the weight
w[3]
it is clear that a change in this weight has no e   ect on the output of
43 .
previous layers. so to work out     c/    w[3]
43 we do not need to know about
partial derivatives at previous layers. it should, however, be possible to express
    c/    w[3]
43 in terms of partial derivatives at subsequent layers. more precisely,
the activation feeding into the 4th neuron on layer 3 is z[3]
4 , and, by de   nition,
  [3]
4 measures the sensitivity of c with respect to this input. feeding in to this
neuron we have w[3]

3 + constant, so it makes sense that

43 a[2]

    c
    w[3]
43

=   [3]

4 a[2]
3 .

similarly, in terms of the bias, b[3]
explains why

4 + constant is feeding in to the neuron, which

    c
    b[3]
4

=   [3]

4    1.

14

we may avoid the hadamard product notation in (22) and (23) by in-
troducing diagonal matrices. let d[l]     rnl  nl denote the diagonal matrix
i ). then we see that   [l] = d[l](a[l]     y) and
with (i, i) entry given by   (cid:48)(z[l]
  [l] = d[l](w [l+1])t   [l+1]. we could expand this out as

  [l] = d[l](w [l+1])t d[l+1](w [l+2])t        d[l   1](w [l])t d[l](a[l]     y).

we also recall from (2) that   (cid:48)(z) is trivial to compute.

the relation (24) shows that   [l] corresponds precisely to the gradient of the
cost function with respect to the biases at layer l. if we regard    c/   w[l]
jk as
de   ning the (j, k) component in a matrix of partial derivatives at layer l, then
(25) shows this matrix to be the outer product   [l]a[l   1]t     rnl  nl   1 .

putting this together, we may write the following pseudocode for an algo-
rithm that trains a network using a    xed number, niter, of stochastic gradient
iterations. for simplicity, we consider the basic version (15) where single sam-
ples are chosen with replacement. for each training point, we perform a forward
pass through the network in order to evaluate the activations, weighted inputs
and overall output a[l]. then we perform a backward pass to compute the
errors and updates.

for counter = 1 upto niter

choose an integer k uniformly at random from {1, 2, 3, . . . , n}
x{k} is current training data point
a[1] = x{k}
for l = 2 upto l

z[l] = w [l]a[l   1] + b[l]

a[l] =   (cid:0)z[l](cid:1)
d[l] = diag(cid:0)  (cid:48)(z[l])(cid:1)
  [l] = d[l](cid:0)a[l]     y(x{k})(cid:1)

end

for l = l     1 downto 2

  [l] = d[l](w [l+1])t   [l+1]

end

for l = l downto 2

w [l]     w [l]          [l]a[l   1]t
b[l]     b[l]          [l]

end

end

15

6 full matlab example

we now give a concrete illustration involving back propagation and the stochas-
tic gradient method. listing 6.1 shows how a network of the form shown in
figure 3 may be used on the data in figure 1. we note that this matlab
code has been written for clarity and brevity, rather than e   ciency or elegance.
in particular, we have    hardwired    the number of layers and iterated through
the forward and backward passes line by line. (because the weights and biases
do not have the the same dimension in each layer, it is not convenient to store
them in a three-dimensional array. we could use a cell array or structure array,
[18], and then implement the forward and backward passes in for loops. how-
ever, this approach produced a less readable code, and violated our self-imposed
one page limit.)

the function netbp in listing 6.1 contains the nested function cost, which
evaluates a scaled version of cost in (6). because this function is nested, it
has access to the variables in the main function, notably the training data. we
point out that the nested function cost is not used directly in the forward and
backward passes. it is called at each iteration of the stochastic gradient method
so that we can monitor the progress of the training.

listing 6.2 shows the function activate, used by netbp, which applies the

sigmoid function in vectorized form.

at the start of netbp we set up the training data and target y values, as
de   ned in (5). we then initialize all weights and biases using the normal pseu-
dorandom number generator randn. for simplicity, we set a constant learning
rate eta = 0.05 and perform a    xed number of iterations niter = 1e6.

we use the the basic stochastic gradient iteration summarized at the end
of section 5. here, the command randi(10) returns a uniformly and indepen-
dently chosen integer between 1 and 10.

having stored the value of the cost function at each iteration, we use the

semilogy command to visualize the progress of the iteration.

in this experiment, our initial guess for the weights and biases produced a
cost function value of 5.3. after 106 stochastic gradient steps this was reduced
to 7.3    10   4. figure 7 shows the semilogy plot, and we see that the decay is
not consistent   the cost undergoes a    at period towards the start of the process.
after this plateau, we found that the cost decayed at a very slow linear rate   the
ratio between successive values was typically within around 10   6 of unity.

an extended version of netbp can be found in the supplementary material.
this version has the extra graphics commands that make figure 7 more read-
able. it also takes the trained network and produces figure 8. this plot shows
how the trained network carves up the input space. eagle-eyed readers will spot
that the solution in figure 8. di   ers slightly from the version in figure 4, where
the same optimization problem was tackled by the nonlinear least-squares solver
lsqnonlin. in figure 9 we show the corresponding result when an extra data
point is added; this can be compared with figure 5.

16

function netbp
%netbp uses id26 to train a network

%%%%%%% data %%%%%%%%%%%
x1 = [0.1,0.3,0.1,0.6,0.4,0.6,0.5,0.9,0.4,0.7];
x2 = [0.1,0.4,0.5,0.9,0.2,0.3,0.6,0.2,0.4,0.6];
y = [ones(1,5) zeros(1,5); zeros(1,5) ones(1,5)];

% initialize weights and biases
rng(5000);
w2 = 0.5*randn(2,2); w3 = 0.5*randn(3,2); w4 = 0.5*randn(2,3);
b2 = 0.5*randn(2,1); b3 = 0.5*randn(3,1); b4 = 0.5*randn(2,1);

% forward and back propagate
eta = 0.05;
niter = 1e6;
savecost = zeros(niter,1); % value of cost function at each iteration
for counter = 1:niter

% learning rate
% number of sg iterations

% choose a training point at random

k = randi(10);
x = [x1(k); x2(k)];
% forward pass
a2 = activate(x,w2,b2);
a3 = activate(a2,w3,b3);
a4 = activate(a3,w4,b4);
% backward pass
delta4 = a4.*(1-a4).*(a4-y(:,k));
delta3 = a3.*(1-a3).*(w4   *delta4);
delta2 = a2.*(1-a2).*(w3   *delta3);
% gradient step
w2 = w2 - eta*delta2*x   ;
w3 = w3 - eta*delta3*a2   ;
w4 = w4 - eta*delta4*a3   ;
b2 = b2 - eta*delta2;
b3 = b3 - eta*delta3;
b4 = b4 - eta*delta4;
% monitor progress
newcost = cost(w2,w3,w4,b2,b3,b4)
savecost(counter) = newcost;

% display cost to screen

end

% show decay of cost function
save costvec
semilogy([1:1e4:niter],savecost(1:1e4:niter))

function costval = cost(w2,w3,w4,b2,b3,b4)

costvec = zeros(10,1);
for i = 1:10

x =[x1(i);x2(i)];
a2 = activate(x,w2,b2);
a3 = activate(a2,w3,b3);
a4 = activate(a3,w4,b4);
costvec(i) = norm(y(:,i) - a4,2);

end
costval = norm(costvec,2)^2;

end % of nested function

end

listing 6.1: m-   le netbp.m.

17

function y = activate(x,w,b)
%activate evaluates sigmoid function.
%
%
%
%
%
%

the ith component of y is activate((wx+b)_i)
where activate(z) = 1/(1+exp(-z))

x is the input vector, y is the output vector
w contains the weights, b contains the shifts

y = 1./(1+exp(-(w*x+b)));

listing 6.2: m-   le activate.m.

figure 7: vertical axis shows a scaled value of the cost function (6). horizontal
axis shows the iteration number. here we used the stochastic gradient method
to train a network of the form shown in figure 3 on the data in figure 1. the
resulting classi   cation function is illustrated in figure 8.

18

figure 8: visualization of output from an arti   cial neural network applied to
the data in figure 1. here we trained the network using the stochastic gradient
method with back propagation   behaviour of cost function is shown in figure 7.
the same optimization problem was solved with the lsqnonlin routine from
matlab in order to produce figure 4.

figure 9: visualization of output from an arti   cial neural network applied
to the data in figure 1 with an additional data point. here we trained the
network using the stochastic gradient method with back propagation. the same
optimization problem was solved with the lsqnonlin routine from matlab
in order to produce figure 5.

19

7

image classi   cation example

we now move on to a more realistic task, which allows us to demonstrate the
power of the deep learning approach. we make use of the matconvnet tool-
box [33], which is designed to o   er key deep learning building blocks as simple
matlab commands. so matconvnet is an excellent environment for pro-
totyping and for educational use. support for gpus also makes matconvnet
e   cient for large scale computations, and pre-trained networks may be down-
loaded for immediate use.

applying matconvnet on a large scale problem also gives us the oppor-
tunity to outline further concepts that are relevant to practical computation.
these are introduced in the next few subsections, before we apply them to the
image classi   cation exercise.

7.1 convolutional neural networks

matconvnet uses a special class of arti   cial neural networks known as con-
volutional neural networks (id98s), which have become a standard tool in
id161 applications. to motivate id98s, we note that the general
framework described in section 3 does not scale well in the case of digital image
data. consider a color image made up of 200 by 200 pixels, each with a red,
green and blue component. this corresponds to an input vector of dimension
n1 = 200    200    3 = 120, 000, and hence a weight matrix w [2] at level 2 that
has 120, 000 columns. if we allow general weights and biases, then this approach
is clearly infeasible. id98s get around this issue by constraining the values that
are allowed in the weight matrices and bias vectors. rather than a single full-
sized linear transformation, id98s repeatedly apply a small-scale linear kernel,
or    lter, across portions of their input data. in e   ect, the weight matrices used
by id98s are extremely sparse and highly structured.

to understand why this approach might be useful, consider premultiplying

an input vector in r6 by the matrix

                  

1    1

1    1

1    1

1    1

1    1

                       r5  6.

(29)

this produces a vector in r5 made up of di   erences between neighboring values.
in this case we are using a    lter [1,   1] and a stride of length one   the    lter
advances by one place after each use. appropriate generalizations of this matrix
to the case of input vectors arising from 2d images can be used to detect edges
in an image   returning a large absolute value when there is an abrupt change in
neighboring pixel values. moving a    lter across an image can also reveal other
features, for example, particular types of curves or blotches of the same color.
so, having speci   ed a    lter size and stride length, we can allow the training
process to learn the weights in the    lter as a means to extract useful structure.

20

the word    convolutional    arises because the linear transformations involved
may be written in the form of a convolution. in the 1d case, the convolution of
the vector x     rp with the    lter g1   p, g2   p, . . . , gp   2, gp   1 has kth component
given by

p(cid:88)

n=1

yk =

xngk   n.

the example in (29) corresponds to a    lter with g0 = 1, g   1 =    1 and all other
gk = 0. in the case

             =

             a b

             y1

y2
y3
y4

            

c d
b
a

c d
a
b

c d
a
b

c d

,

(30)

                                                

                                                

x1
x2
x3
x4
x5
x6
x7
x8
x9
0

we are applying a    lter with four weights, a, b, c, and d, using a stride length
of two. because the dimension of the input vector x is not compatible with the
   lter length, we have padded with an extra zero value.

in practice, image data is typically regarded as a three dimensional tensor:
each pixel has two spatial coordinates and a red/green/blue value. with this
viewpoint, the    lter takes the form of a small tensor that is successsively applied
to patches of the input tensor and the corresponding convolution operation is
multi-dimensional. from a computational perspective, a key bene   t of id98s is
that the matrix-vector products involved in the forward and backward passes
through the network can be computed extremely e   ciently using fast transform
techniques.

a convolutional layer is often followed by a pooling layer, which reduces
dimension by mapping small regions of pixels into single numbers. for example,
when these small regions are taken to be squares of four neigboring pixels in a
2d image, a max pooling or average pooling layer replaces each set of four by
their maximum or average value, respectively.

7.2 avoiding over   tting

over   tting occurs when a trained network performs very accurately on the
given data, but cannot generalize well to new data. loosely, this means that the
   tting process has focussed too heavily on the unimportant and unrepresentative
   noise    in the given data. many ways to combat over   tting have been suggested,
some of which can be used together.

one useful technique is to split the given data into two distinct groups.

21

    training data is used in the de   nition of the cost function that de   nes the
optimization problem. hence this data drives the process that iteratively
updates the weights.

    validation data is not used in the optimization process   it has no e   ect
on the way that the weights are updated from step to step. we use the
validation data only to judge the performance of the current network. at
each step of the optimization, we can evaluate the cost function corre-
sponding to the validation data. this measures how well the current set
of trained weights performs on unseen data.

intuitively, over   tting corresponds to the situation where the optimization pro-
cess is driving down its cost function (giving a better    t to the training data),
but the cost function for the validation error is no longer decreasing (so the
performance on unseen data is not improving). it is therefore reasonable to ter-
minate the training at a stage where no improvement is seen on the validation
data.

another popular approach to tackle over   tting is to randomly and indepen-
dently remove neurons during the training phase. for example, at each step of
the stochastic gradient method, we could delete each neuron with id203
p and train on the remaining network. at the end of the process, because the
weights and biases were produced on these smaller networks, we could multiply
each by a factor of p for use on the full-sized network. this technique, known
as dropout, has the intuitive interpretation that we are constructing an average
over many trained networks, with such a consensus being more reliable than
any individual.

7.3 activation and cost functions

in sections 2 to 6 we used id180 of sigmoid form (1) and a
quadratic cost function (9). there are many other widely used choices, and
their relative performance is application-speci   c.
in our image classi   cation
setting it is common to use a recti   ed linear unit, or relu,

(cid:26) 0,

x,

  (x) =

for x     0,
for x > 0,

(31)

in the case where our training data {x{i}}n

as the activation.
i=1 comes from k labeled cat-
egories, let li     {1, 2, . . . , k} be the given label for data point x{i}. as an
alternative to the quadratic cost function (9), we could use a softmax log loss
approach, as follows. let the output a[l](x{i}) =: v{i} from the network take
the form of a vector in rk such that the jth component is large when the image
is believed to be from category j. the softmax operation

s(cid:80)k
(v{i})s (cid:55)    ev{i}
j=1 ev

.

{i}
j

22

boosts the large components and produces a vector of positive weights summing
to unity, which may be interpreted as probabilties. our aim is now to force
the softmax value for training point x{i} to be as close to unity as possible
in component li, which corresponds to the correct label. using a logarithmic
rather than quadratic measure of error, we arrive at the cost function

    n(cid:88)

i=1

log

       ev
li(cid:80)k

{i}

{i}
j

j=1 ev

       .

(32)

7.4

image classi   cation experiment

we now show results for a supervised learning task in image classi   cation. to
do this, we rely on the codes id98_cifar.m and id98_cifar_init.m that are
available via the matconvnet website. we made only minor edits, including
some changes that allowed us to test the use of dropout. hence, in particular,
we are using the network architecture and parameter choices from those codes.
we refer to the matconvnet documentation and tutorial material for the    ne
details, and focus here on some of the bigger picture issues.

we consider a set of images, each of which falls into exactly one of the
following ten categories: airplane, automobile, bird, cat, deer, dog, frog, horse,
ship, truck. we use labeled data from the freely available cifar-10 collection
[20]. the images are small, having 32 by 32 pixels, each with a red, green, and
blue component. so one piece of training data consists of 32    32    3 = 3, 072
values. we use a training set of 50,000 images, and use 10,000 more images as
our validation set. having completed the optimization and trained the network,
we then judge its performance on a fresh collection of 10,000 test images, with
1,000 from each category.

following the architecture used in the relevant matconvnet codes, we
set up a network whose layers are divided into    ve blocks as follows. here we
describe the dimemsions of the inputs/outputs and weights in compact tensor
notation. (of course, the tensors could be stretched into sparse vectors and
matrices in order to    t in with the general framework of sections 2 to 6. but we
feel that the tensor notation is natural in this context, and it is consistent with
the matconvnet syntax.)

block 1 consists of a a convolution layer followed by a pooling layer and ac-
tivation. this converts the original 32    32    3 input into dimension
16    16    32.
in more detail, the convolutional layer uses 5    5    lters
that also scan across the 3 color channels. there are 32 di   erent    lters, so
overall the weights can be represented in a 5  5  3  32 array. the output
from each    lter may be described as a feature map. the    lters are applied
with unit stride. in this way, each of the 32 feature maps has dimension
32    32. max pooling is then applied to each feature map using stride
length two. this reduces the dimension of the feature maps to 16   16. a
relu activation is then used.

23

figure 10: overview of the id98 used for the image classi   cation task.

block 2 applies convolution followed by activation and then a pooling layer.
this reduces the dimension to 8    8    32.
in more detail, we use 32
   lters. each is 5    5 across the dimensions of the feature maps, and also
scans across all 32 feature maps. so the weights could be regarded as a
5   5   32   32 tensor. the stride length is one, so the resulting 32 feature
maps are still of dimension 16    16. after relu activation, an average
pooling layer of stride two is then applied, which reduces each of the 32
feature maps to dimension 8    8.

block 3 applies a convolution layer followed by the activation function, and
then performs a pooling operation, in a way that reduces dimension to
4   4   64. in more detail, 64    lters are applied. each    lter is 5   5 across
the dimensions of the feature maps, and also scans across all 32 feature
maps. so the weights could be regarded as a 5    5    32    64 tensor. the
stride has length one, resulting in feature maps of dimension 8    8. after
relu activation, an average pooling layer of stride two is applied, which
reduces each of the 64 feature maps to dimension 4    4.

block 4 does not use pooling, just convolution followed by activation, leading
to dimension 1    1    64. in more detail, 64    lters are used. each    lter is
4    4 across the 64 feature maps, so the weights could be regarded as a
4    4    64    64 tensor, and each    lter produces a single number.

block 5 does not involve convolution. it uses a general (fully connected) weight
matrix of the type discussed in sections 2 to 6 to give output of dimension
1    1    10. this corresponds to a weight matrix of dimension 10    64.

a    nal softmax operation transforms each of the ten ouput components to

the range [0, 1].

figure 10 gives a visual overview of the network architecture.

our output is a vector of ten real numbers. the cost function in the opti-
mization problem takes the softmax log loss form (32) with k = 10. we specify
stochastic gradient with momentum, which uses a    moving average    of current

24

and past gradient directions. we use mini-batches of size 100 (so m = 100 in
(17)) and set a    xed number of 45 epochs. we prede   ne the learning rate for
each epoch:    = 0.05,    = 0.005 and    = 0.0005 for the    rst 30 epochs, next
10 epochs and    nal 5 epochs, respectively. running on a tesla c2075 gpu in
single precision, the 45 epochs can be completed in just under 4 hours.

as an additional test, we also train the network with dropout. here, on
each stochastic gradient step, any neuron has its output re-set to zero with
independent id203

    0.15 in block 1,
    0.15 in block 2,
    0.15 in block 3,
    0.35 in block 4,
    0 in block 5 (no dropout).

we emphasize that in this case all neurons become active when the trained
network is applied to the test data.

in figure 11 we illustrate the training process in the case of no dropout.
for the plot on the left, circles are used to show how the objective function
(32) decreases after each of the 45 epochs. we also use crosses to indicate the
objective function value on the validation data.
(more precisely, these error
measures are averaged over the individual batches that form the epoch   note
that weights are updated after each batch.) given that our overall aim is to
assign images to one of the ten classes, the middle plot in figure 11 looks
at the percentage of errors that take place when we classify with the highest
id203 choice. similarly, the plot on the right shows the percentage of cases
where the correct category is not among the top    ve. we see from figure 11 that
the validation error starts to plateau at a stage where the stochastic gradient
method continues to make signi   cant reductions on the training error. this gives
an indication that we are over   tting   learning    ne details about the training
data that will not help the network to generalize to unseen data.

figure 12 shows the analogous results in the case where dropout is used. we
see that the training errors are signi   cantly larger than those in figure 11 and
the validation errors are of a similar magnitude. however, two key features in the
dropout case are that (a) the validation error is below the training error, and (b)
the validation error continues to decrease in sync with the training error, both of
which indicate that the optimization procedure is extracting useful information
over all epochs.

figure 13 gives a summary of the performance of the trained network with
no dropout (after 45 epochs) in the form of a confusion matrix. here, the
integer value in the general i, j entry shows the number of occasions where the
network predicted category i for an image from category j. hence, o   -diagonal
elements indicate mis-classi   cations. for example, the (1,1) element equal to
814 in figure 13 records the number of airplane images that were correctly

25

figure 11: errors for the trained network. horizontal axis runs over the 45
epochs of the stochastic gradient method (that is, 45 passes through the train-
ing data). left: circles show cost function on the training data; crosses show
cost function on the validation data. middle: circles show the percentage of
instances where the most likely classi   cation from the network does not match
the correct category, over the training data images; crosses show the same mea-
sure computed over the validation data. right: circles show the percentage
of instances where the    ve most likely classi   cations from the network do not
include the correct category, over the training data images; crosses show the
same measure computed over the validation data.

26

figure 12: as for figure 11 in the case where dropout was used.

classi   ed as airplanes, and the (1,2) element equal to 21 records the number
of automobile images that were incorrectly classi   ed as airplanes. below each
integer is the corresponding percentage, rounded to one decimal place, given
that the test data has 1,000 images from each category. the extra row, labeled
   all   , summarizes the entries in each column. for example, the value 81.4%
in the    rst column of the    nal row arises because 814 of the 1,000 airplane
images were correctly classi   ed. beneath this, the value 18.6% arises because
186 of these airplane images were incorrectly classi   ed. the    nal column of the
matrix, also labeled    all   , summarizes each row. for example, the value 82.4%
in the    nal column of the    rst row arises because 988 images were classi   ed
by the network as airplanes, with 814 of these classi   cations being correct.
beneath this, the value 17.6% arises because the remaining 174 out of these
988 airplane classi   cations were incorrect. finally, the entries in the lower right
corner summarize over all categories. we see that 80.1% of all images were
correctly classi   ed (and hence 19.9% were incorrectly classi   ed).

figure 14 gives the corresponding results in the case where dropout was
used. we see that the use of dropout has generally improved performance,
and in particular has increased the overall success rate from 80.1% to 81.1%.
dropout gives larger values along the diagonal elements of the confusion matrix
in nine out of the ten categories.

to give a feel for the di   culty of this task, figure 15 shows 16 images ran-
domly sampled from those that were misclassi   ed by the non-dropout network.

27

figure 13: confusion matrix for the the trained network from figure 11.

28

figure 14: confusion matrix for the the trained network from figure 12, which
used dropout.

29

figure 15: sixteen of the images that were misclassi   ed by the trained network
from figure 11. predicted category is indicated, with correct category shown in
parentheses. note that images are low-resolution, having 32    32 pixels.

30

8 of things not treated

this short introductory article is aimed at those who are new to deep learning.
in the interests of brevity and accessibility we have ruthlessly omitted many
topics. for those wishing to learn more, a good starting point is the free online
book [26], which provides a hands-on tutorial style description of deep learning
techniques. the survey [22] gives an intuitive and accessible overview of many
of the key ideas behind deep learning, and highlights recent success stories. a
more detailed overview of the prize-winning performances of deep learning tools
can be found in [29], which also traces the development of ideas across more than
800 references. the review [35] discusses the pre-history of deep learning and
explains how key ideas evolved. for a comprehensive treatment of the state-of-
the-art, we recommend the book [10] which, in particular, does an excellent job
of introducing fundamental ideas from computer science/discrete mathematics,
applied/computational mathematics and id203/statistics/id136 before
pulling them all together in the deep learning setting. the recent review article
[3] focuses on optimization tasks arising in machine learning.
it summarizes
the current theory underlying the stochastic gradient method, along with many
alternative techniques. those authors also emphasize that optimization tools
must be interpreted and judged carefully when operating within this inherently
statistical framework. leaving aside the training issue, a mathematical frame-
work for understanding the cascade of linear and nonlinear transformations used
by deep networks is given in [24].

to give a feel for some of the key issues that can be followed up, we    nish
with a list of questions that may have occured to interested readers, along with
brief answers and further citations.

why use arti   cial neural networks? looking at figure 4, it is clear that
there are many ways to come up with a mapping that divides the x-y axis
into two regions; a shaded region containing the circles and an unshaded
region containing the crosses. arti   cial neural networks provide one useful
approach. in real applications, success corresponds to a small generaliza-
tion error ; the mapping should perform well when presented with new
data. in order to make rigorous, general, statements about performance,
we need to make some assumptions about the type of data. for example,
we could analyze the situation where the data consists of samples drawn
independently from a certain id203 distribution. if an algorithm is
trained on such data, how will it perform when presented with new data
from the same distribution? the authors in [15] prove that arti   cial neural
networks trained with the stochastic gradient method can behave well in
this sense. of course, in practice we cannot rely on the existence of such a
distribution. indeed, experiments in [36] indicate that the worst case can
be as bad as possible. these authors tested state-of-the-art convolutional
networks for image classi   cation. in terms of the heuristic performance
indicators used to monitor the progress of the training phase, they found
that the stochastic gradient method appears to work just as e   ectively

31

when the images are randomly re-labelled. this implies that the network
is happy to learn noise   if the labels for the unseen data are similarly
randomized then the classi   cations from the trained network are no bet-
ter than random choice. other authors have established negative results
by showing that small and seemingly unimportant perturbations to an
image can change its predicted class, including cases where one pixel is
altered [32]. related work in [4] showed proof-of-principle for an adver-
sarial patch, which alters the classi   cation when added to a wide range
of images; for example, such a patch could be printed as a small sticker
and used in the physical world. hence, although arti   cial neural networks
have outperformed rival methods in many application    elds, the reasons
behind this success are not fully understood. the survey [34] describes
a range of mathematical approaches that are beginning to provide useful
insights, whilst the discussion piece [25] includes a list of ten concerns.

which nonlinearity? the sigmoid function (1), illustrated in figure 2, and
the recti   ed linear unit (31) are popular choices for the activation function.
alternatives include the step function,

(cid:26) 0,

1,

for x     0,
for x > 0.

each of these can undergo saturation: produce very small derivatives that
thereby reduce the size of the gradient updates. indeed, the step function
and recti   ed linear unit have completely    at portions. for this reason, a
leaky recti   ed linear unit, such as,

(cid:26) 0.01x,

x,

f (x) =

for x     0,
for x > 0,

is sometimes preferred, in order to force a nonzero derivative for negative
inputs. the back propagation algorithm described in section 5 carries
through to general id180.

how do we decide on the structure of our net? often, there is a natu-
ral choice for the size of the output layer. for example, to classify images
of individual handwritten digits, it would make sense to have an output
layer consisting of ten neurons, corresponding to 0, 1, 2, . . . , 9, as used in
chapter 1 of [26]. in some cases, a physical application imposes natural
constraints on one or more of the hidden layers [16]. however, in gen-
eral, choosing the overall number of layers, the number of neurons within
each layer, and any constraints involving inter-neuron connections, is not
an exact science. rules of thumb have been suggested, but there is no
widely accepted technique.
in the context of image processing, it may
be possible to attribute roles to di   erent layers; for example, detecting
edges, motifs and larger structures as information    ows forward [22], and
our understanding of biological neurons provides further insights [10]. but
speci   c roles cannot be completely hardwired into the network design   the

32

weights and biases, and hence the tasks performed by each layer, emerge
from the training procedure. we note that the use of back propagation to
compute gradients is not restricted to the types of connectivity, activation
functions and cost functions discussed here. indeed, the method    ts into a
very general framework of techniques known as automatic di   erentiation
or algorithmic di   erentiation [13].

how big do deep learning networks get? the alexnet architecture [21] achieved

groundbreaking image classi   cation results in 2012. this network used
650,000 neurons, with    ve convolutional layers followed by two fully con-
nected layers and a    nal softmax. the programme alphago, developed
by the google deepmind team to play the board game go, rose to fame
by beating the human european champion by    ve games to nil in octo-
ber 2015 [30]. alphago makes use of two arti   cial neural networks with
13 layers and 15 layers, some convolutional and others fully connected,
involving millions of weights.

didn   t my numerical analysis teacher tell me never to use steepest descent?

it is known that the steepest descent method can perform poorly on ex-
amples where other methods, notably those using information about the
second derivative of the objective function, are much more e   cient. hence,
optimization textbooks typically downplay steepest descent [9, 27]. how-
ever, it is important to note that training an arti   cial neural network is a
very speci   c optimization task:

    the problem dimension and the expense of computing the objective

function and its derivatives, can be extremely high,

    the optimization task is set within a framework that is inherently

statistical in nature,

    a great deal of research e   ort has been devoted to the development
of practical improvements to the basic stochastic gradient method in
the deep learning context.

currently, a theoretical underpinning for the success of the stochastic gra-
dient method in training networks is far from complete [3]. a promising
line of research is to connect the stochastic gradient method with dis-
cretizations of stochastic di   erential equations, [31], generalizing the idea
that many deterministic optimization methods can be viewed as timestep-
ping methods for gradient odes, [17]. we also note that the introduction
of more traditional tools from the    eld of optimization may lead to im-
proved training algorithms.

is it possible to regularize? as we discussed in section 7, over   tting occurs
when a trained network performs accurately on the given data, but cannot
generalize well to new data. id173 is a broad term that describes
attempts to avoid over   tting by rewarding smoothness. one approach is

33

to alter the cost function in order to encourage small weights. for example,
(9) could be extended to

cost =

1
n

1

2(cid:107)y(x{i})     a[l](x{i})(cid:107)2

2 +

  
n

(cid:107) w [l] (cid:107)2
2.

(33)

n(cid:88)

i=1

l(cid:88)

l=2

here    > 0 is the id173 parameter. one motivation for (33) is
that large weights may lead to neurons that are sensitive to their inputs,
and hence less reliable when new data is presented. this argument does
not apply to the biases, which typically are not included in such a regu-
larization term. it is straightforward to check that using (33) instead of
(9) makes a very minor and inexpensive change to the back propagation
algorithm.

what about ethics and accountability? the use of    algorithms    to aid
decision-making is not a recent phenomenon. however, the increasing
in   uence of black-box technologies is naturally causing concerns in many
quarters. the recent articles [7, 14] raise several relevant issues and il-
lustrate them with concrete examples. they also highlight the particular
challenges arising from massively-parameterized arti   cial neural networks.
professional and governmental institutions are, of course, alert to these
matters. in 2017, the association for computing machinery   s us pub-
lic policy council released seven principles for algorithmic transparency
and accountability 1. among their recommendations are that

       systems and institutions that use algorithmic decision-making are
encouraged to produce explanations regarding both the procedures
followed by the algorithm and the speci   c decisions that are made   ,
and

       a description of the way in which the training data was collected
should be maintained by the builders of the algorithms, accompanied
by an exploration of the potential biases induced by the human or
algorithmic data-gathering process.   

article 15 of the european union   s general data protection regulation
2016/6792, which takes e   ect in may 2018, concerns    right of access
by the data subject,    and includes the requirement that    the data sub-
ject shall have the right to obtain from the controller con   rmation as to
whether or not personal data concerning him or her are being processed,
and, where that is the case, access to the personal data and the following
information:.   item (h) on the subsequent list covers

       the existence of automated decision-making, including pro   ling, re-
ferred to in article 22(1) and (4) and, at least in those cases, mean-
ingful information about the logic involved, as well as the signi   cance

1 https://www.acm.org/
2https://www.privacy-regulation.eu/en/15.htm

34

and the envisaged consequences of such processing for the data sub-
ject.   

what are some current research topics? deep learning is a fast-moving,
high-bandwith    eld, where many new advances are driven by the needs
of speci   c application areas and the features of new high performance
computing architectures. here, we brie   y mention three hot-topic areas
that have not yet been discussed.

training a network can be an extremely expensive task. when a trained
network is seen to make a mistake on new data, it is therefore tempting to
   x this with a local perturbation to the weights and/or network structure,
rather than re-training from scratch. approaches for this type of on the
   y tuning can be developed and justi   ed using the theory of measure
concentration in high dimensional spaces [12].

adversarial networks, [11], are based on the concept that an arti   cial neu-
ral network may be viewed as a generative model : a way to create realistic
data. such a model may be useful, for example, as a means to produce
realistic sentences, or very high resolution images. in the adversarial set-
ting, the generative model is pitted against a discriminative model. the
role of the discriminative model is to distinguish between real training
data and data produced by the generative model. by iteratively improv-
ing the performance of these models, the quality of both the generation
and discrimination can be increased dramatically.

the idea behind autoencoders [28] is, perhaps surprisingly, to produce
an overall network whose output matches its input. more precisely, one
network, known as the encoder, corresponds to a map f that takes an
input vector, x     rs, and produces a lower dimensional output vector
f (x)     rt. so t (cid:28) s. then a second network, known as the decoder,
corresponds to a map g that takes us back to the same dimension as x;
that is, g(f (x))     rs. we could then aim to minimize the sum of the
squared error (cid:107)x     g(f (x))(cid:107)2
2 over a set of training data. note that this
technique does not require the use of labelled data   in the case of images
we are attempting to reproduce each picture without knowing what it
depicts. intuitively, a good encoder is a tool for dimension reduction. it
extracts the key features. similarly, a good decoder can reconstruct the
data from those key features.

where can i    nd code and data? there are many publicly available codes
that provide access to deep learning algorithms. in addition to matcon-
vnet [33], we mention ca   e [19], keras [5], tensorflow [1], theano [2]
and torch [6]. these packages di   er in their underlying platforms and in
the extent of expert knowledge required. your favorite scienti   c comput-
ing environment may also o   er a range of proprietary and user-contributed
deep learning toolboxes. however, it is currently the case that making se-
rious use of modern deep learning technology requires a strong background
in numerical computing. among the standard benchmark data sets are

35

the cifar-10 collection [20] that we used in section 7, and its big sibling
cifar-100, id163 [8], and the handwritten digit database mnist
[23].

acknowledgements

we are grateful to the matconvnet team for making their package available
under a permissive bsd license. the matlab code in listings 6.1 and 6.2 can
be found at

http://personal.strath.ac.uk/d.j.higham/algfiles.html

as well as an exteneded version that produces figures 7 and 8, and a matlab
code that uses lsqnonlin to produce figure 4.

references

[1] m. abadi, p. barham, j. chen, z. chen, a. davis, j. dean,
m. devin, s. ghemawat, g. irving, m. isard, m. kudlur,
j. levenberg, r. monga, s. moore, d. g. murray, b. steiner,
p. tucker, v. vasudevan, p. warden, m. wicke, y. yu, and
x. zheng, tensorflow: a system for large-scale machine learning, in
12th usenix symposium on operating systems design and implemen-
tation (osdi 16), 2016, pp. 265   283.

[2] r. al-rfou, g. alain, a. almahairi, c. angermueller, d. bah-
danau, n. ballas, f. bastien, j. bayer, a. belikov, a. be-
lopolsky, y. bengio, a. bergeron, j. bergstra, v. bisson,
j. bleecher snyder, n. bouchard, n. boulanger-lewandowski,
x. bouthillier, a. de br  ebisson, o. breuleux, p.-l. carrier,
k. cho, j. chorowski, p. christiano, t. cooijmans, m.-a. c  ot  e,
m. c  ot  e, a. courville, y. n. dauphin, o. delalleau, j. de-
mouth, g. desjardins, s. dieleman, l. dinh, m. ducoffe, v. du-
moulin, s. ebrahimi kahou, d. erhan, z. fan, o. firat, m. ger-
main, x. glorot, i. goodfellow, m. graham, c. gulcehre,
p. hamel, i. harlouchet, j.-p. heng, b. hidasi, s. honari,
a. jain, s. jean, k. jia, m. korobov, v. kulkarni, a. lamb,
p. lamblin, e. larsen, c. laurent, s. lee, s. lefrancois,
s. lemieux, n. l  eonard, z. lin, j. a. livezey, c. lorenz,
j. lowin, q. ma, p.-a. manzagol, o. mastropietro, r. t.
mcgibbon, r. memisevic, b. van merri  enboer, v. michalski,
m. mirza, a. orlandi, c. pal, r. pascanu, m. pezeshki, c. raf-
fel, d. renshaw, m. rocklin, a. romero, m. roth, p. sadowski,
j. salvatier, f. savard, j. schl  uter, j. schulman, g. schwartz,
i. v. serban, d. serdyuk, s. shabanian, e. simon, s. spieck-
ermann, s. r. subramanyam, j. sygnowski, j. tanguay, g. van

36

tulder, j. turian, s. urban, p. vincent, f. visin, h. de vries,
d. warde-farley, d. j. webb, m. willson, k. xu, l. xue, l. yao,
s. zhang, and y. zhang, theano: a python framework for fast compu-
tation of mathematical expressions, arxiv e-prints, abs/1605.02688 (2016).

[3] l. bottou, f. curtis, and j. nocedal, optimization methods for

large-scale machine learning, arxiv:1606.04838, version 2, (2017).

[4] t. b. brown, d. man  e, a. r. m. abadi, and j. gilmer, adversarial

patch, arxiv:1712.09665 [cs.cv], (2017).

[5] f. chollet et al., keras, github, (2015).

[6] r. collobert, k. kavukcuoglu, and c. farabet, torch7: a matlab-
like environment for machine learning, in biglearn, nips workshop, 2011.

[7] j. h. davenport, the debate about algorithms, mathematics today,

(2017), p. 162.

[8] j. deng, w. dong, r. socher, l.-j. li, k. li, and f.-f. li, im-
agenet: a large-scale hierarchical image database., in cvpr, ieee com-
puter society, 2009, pp. 248   255.

[9] r. fletcher, practical methods of optimization, wiley, chichester, sec-

ond ed., 1987.

[10] i. goodfellow, y. bengio, and a. courville, deep learning, mit

press, boston, 2016.

[11] i. j. goodfellow, j. pouget-abadie, m. mirza, b. xu, d. warde-
farley, s. ozair, a. c. courville, and y. bengio, generative ad-
versarial nets, in advances in neural information processing systems 27,
montreal, canada, 2014, pp. 2672   2680.

[12] a. n. gorban and i. y. tyukin, stochastic separation theorems, neural

networks, 94 (2017), pp. 255   259.

[13] a. griewank and a. walther, evaluating derivatives: principles and
techniques of algorithmic di   erentiation, society for industrial and ap-
plied mathematics, philadelphia, second ed., 2008.

[14] p. grindrod, beyond privacy and exposure: ethical issues within citizen-
facing analytics, phil. trans. of the royal society a, 374 (2016), p. 2083.

[15] m. hardt, b. recht, and y. singer, train faster, generalize better:
stability of stochastic id119, in proceedings of the 33rd interna-
tional conference on machine learning, 2016, pp. 1225   1234.

[16] c. f. higham, r. murray-smith, m. j. padgett, and m. p. edgar,
deep learning for real-time single-pixel video, scienti   c reports, (to ap-
pear).

37

[17] d. j. higham, trust region algorithms and timestep selection, siam jour-

nal on numerical analysis, 37 (1999), pp. 194   210.

[18] d. j. higham and n. j. higham, matlab guide, society for industrial

and applied mathematics, philadelphia, pa, usa, third ed., 2017.

[19] y. jia, e. shelhamer, j. donahue, s. karayev, j. long, r. gir-
shick, s. guadarrama, and t. darrell, ca   e: convolutional archi-
tecture for fast feature embedding, arxiv preprint arxiv:1408.5093, (2014).

[20] a. krizhevsky, learning multiple layers of features from tiny images,

tech. rep., 2009.

[21] a. krizhevsky, i. sutskever, and g. e. hinton, id163 classi-
   cation with deep convolutional neural networks, in advances in neural
information processing systems 25, f. pereira, c. j. c. burges, l. bottou,
and k. q. weinberger, eds., 2012, pp. 1097   1105.

[22] y. lecun, y. bengio, and g. hinton, deep learning, nature, 521

(2015), pp. 436   444.

[23] y. lecun, l. bottou, y. bengio, and p. haffner, gradient-based
learning applied to document recognition, proceedings of the ieee, 86
(1998), pp. 2278   2324.

[24] s. mallat, understanding deep convolutional networks, philosophical

transactions of the royal society of london a, 374 (2016), p. 20150203.

[25] g. marcus, deep learning: a critical appraisal, arxiv:1801.00631 [cs.ai],

(2018).

[26] m. nielsen, neural networks and deep learning, determination press,

2015.

[27] j. nocedal and s. j. wright, numerical optimization, springer,

berlin, second ed., 2006.

[28] d. e. rumelhart, g. e. hinton, and r. j. williams, parallel dis-
tributed processing: explorations in the microstructure of cognition, vol. 1,
mit press, cambridge, ma, usa, 1986, ch. learning internal represen-
tations by error propagation, pp. 318   362.

[29] j. schmidhuber, deep learning in neural networks: an overview, neural

networks, 61 (2015), pp. 85   117.

[30] d. silver, a. huang, c. j. maddison, a. guez, l. sifre,
g. van den driessche, j. schrittwieser, i. antonoglou, v. pan-
neershelvam, m. lanctot, s. dieleman, d. grewe, j. nham,
n. kalchbrenner,
i. sutskever, t. lillicrap, m. leach,
k. kavukcuoglu, t. graepel, and d. hassabis, mastering the game
of go with deep neural networks and tree search, nature, 2529 (2016),
pp. 484   489.

38

[31] j. sirignano and k. spiliopoulos, stochastic id119 in con-

tinuous time, siam j. finan. math., 8 (2017), pp. 933   961.

[32] j. su, d. v. vargas, and s. kouichi, one pixel attack for fooling deep

neural networks, arxiv:1710.08864 [cs.lg], (2017).

[33] a. vedaldi and k. lenc, matconvnet: convolutional neural networks
for matlab, in acm international conference on multimedia, brisbane,
2015, pp. 689   692.

[34] r. vidal, r. giryes, j. bruna, and s. soatto, mathematics of deep

learning, proc. of the conf. on decision and control (cdc), (2017).

[35] h. wang and b. raj, on the origin of deep learning, arxiv:1702.07800

[cs.lg], (2017).

[36] c. zhang, s. bengio, m. hardt, b. recht, and o. vinyals, un-
derstanding deep learning requires rethinking generalization, in 5th inter-
national conference on learning representations, 2017.

39

