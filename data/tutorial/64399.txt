georgios n. yannakakis and julian togelius

arti   cial intelligence and games

january 26, 2018

springer

to our families

foreword

it is my great pleasure to write the foreword for this excellent and timely book.
games have long been seen as the perfect test-bed for arti   cial intelligence (ai)
methods, and are also becoming an increasingly important application area. game
ai is a broad    eld, covering everything from the challenge of making super-human
ai for dif   cult games such as go or starcraft, to creative applications such as the
automated generation of novel games.

game ai is as old as ai itself, but over the last decade the    eld has seen mas-
sive expansion and enrichment with the inclusion of video games, which now com-
prise more than 50% of all published work in the area and enable us to address a
broader range of challenges that have great commercial, social, economic and scien-
ti   c interest. a great surge in research output occurred in 2005, coinciding with both
the    rst ieee symposium (conference) on computational intelligence and games
(cig)   which i co-chaired with graham kendall   and the    rst aaai aiide con-
ference (arti   cial intelligence in digital entertainment). since then this rich area of
research has been more explored and better understood. the game ai community
pioneered much of the research which is now becoming (or about to become) more
mainstream ai, such as id169, procedural content generation,
playing games based on screen capture, and automated game design.

over the last decade, progress in deep learning has had a profound and transfor-
mational effect on many dif   cult problems, including id103, machine
translation, natural language understanding and id161. as a result, com-
puters can now achieve human-competitive performance in a wide range of percep-
tion and recognition tasks. many of these systems are now available to the program-
mer via a range of so-called cognitive services. more recently, deep reinforcement
learning has achieved ground-breaking success in a number of dif   cult challenges,
including go and the amazing feat of learning to play games directly from screen
capture (playing from pixels). it is fascinating to contemplate what this could mean
for games as we stumble towards human-level intelligence in an increasing number
of areas. the impacts will be signi   cant for the intelligence of in-game characters,
the way in which we interact with them and for the way games are designed and
tested.

vii

viii

foreword

this book makes an enormous contribution to this captivating, vibrant area of
study: an area that is developing rapidly both in breadth and depth as ai is able to
cope with a wider range of tasks (and to perform those tasks to increasing levels of
excellence). the service to the community will be felt for many years to come: the
book provides an easier and more comprehensive entry point for newcomers to the
   eld than previously available, whilst also providing an indispensable reference for
existing ai and games researchers wishing to learn about topics outside their direct
   eld of interest.

georgios yannakakis and julian togelius have been involved with the    eld ever
since its widespread expansion to video games, and they both presented papers at
the    rst 2005 cig. over the years they have made an enormous contribution to the
   eld with a great number of highly cited papers presenting both novel research and
comprehensive surveys. it is my opinion that these authors are best quali   ed to write
this book, and they do not disappoint. the book will serve the community very well
for many years to come.

london, august 2017

simon lucas

preface

of all the things that wisdom provides for the complete happiness of one   s entire life, by far
the greatest is friendship.

human beings, viewed as behaving systems, are quite simple. the apparent complexity of
our behavior over time is largely a re   ection of the complexity of the environment in which
we    nd ourselves.

epicurus, principal doctrines, 27

herbert a. simon

it would be an understatement to say that arti   cial intelligence (ai) is a popular
topic at the moment, and it is unlikely to become any less important in the future.
more researchers than ever work on ai in some form, and more non-researchers than
ever are interested in the    eld. it would also be an understatement to say that games
are a popular application area for ai research. while board games have been central
to ai research since the inception of the    eld, video games have during the last
decade increasingly become the domain of choice for testing and showcasing new
algorithms. at the same time, video games themselves have become more diverse
and sophisticated, and some of them incorporate advances in ai for controlling
non-player characters, generating content or adapting to players. game developers
have increasingly realized the power of ai methods to analyze large volumes of
player data and optimize game designs. and a small but growing community of
researchers and designers experiment with ways of using ai to design and create
complete games, automatically or in dialog with humans. it is indeed an exciting
time to be working on ai and games!

this is a book about ai and games. as far as we know, it is the    rst compre-
hensive textbook covering the    eld. with comprehensive, we mean that it features
all the major application areas of ai methods within games: game-playing, con-
tent generation and player modeling. we also mean that it discusses ai problems
in many different types of games, including board games and video games of many
genres. the book is also comprehensive in that it takes multiple perspectives of ai
and games: how games can be used to test and develop ai, how ai can be used

ix

x

preface

to make games better and easier to develop, and to understand players and design.
while this is an academic book which is primarily aimed at students and researchers,
we will frequently address problems and methods relevant for game designers and
developers.

we wrote this book based on our long experience doing research on ai for games,
each on our own and together, and helping lead and shape the research community.
we both independently started researching ai methods in games in 2004, and we
have been working together since 2009. together, we played a role in introducing
research topics such as procedural content generation and player modeling to the
academic research community, and created several of the most widely used game-
based ai benchmarks. this book is in a sense a natural outgrowth of the classes on
ai and games we have taught at three universities, and the several survey papers of
the    eld and of individual research topics within it that we have published over the
years. but the book is also a response to the lack of a good introductory book for the
research    eld. early discussions on writing such a book date back at least a decade,
but no-one actually wrote one, until now.

it could be useful to point out what this book is not. it is not a hands-on book
with step-by-step instructions on how to build ai for your game. it does not feature
discussions of any particular game engine or software framework, and it does not
discuss software engineering aspects or many implementation aspects at all. it is not
an introductory book, and it does not give a gentle introduction to basic ai or game
design concepts. for all these roles, there are better books available.

instead, this is a book for readers who already understand ai methods and con-
cepts to the level of having taken an introductory ai course, and the introductory
computer science or engineering courses that led up to that course. the book as-
sumes that the reader is comfortable with reading a pseudocode description of an
algorithm and implementing it. chapter 2 is a summary of ai methods used in the
book, but is intended more as a reference and refresher than as an introduction. the
book also assumes a basic familiarity with games, if not designing them then at least
playing them.

the use case for this textbook that we had in mind when writing it is for a one-
or a two-semester graduate-level or advanced undergraduate level class. this can
take several different shapes to support different pedagogical practices. one way of
teaching such a class would be a traditional class, with lectures covering the chapters
of the book in order, a conventional pen-and-paper exam at the end, and a small
handful of programming exercises. for your convenience, each of the main chapters
of the book include suggestions for such exercises. another way of organizing a
class around this book, more in line with how we personally prefer to teach such
courses, is to teach the course material during the    rst half of the semester and
spend the second half on a group project.

the material offered by this book can be used in various ways and, thus, support
a number of different classes. in our experience, a traditional two-semester class on
game arti   cial intelligence would normally cover chapter 2 and chapter 3 in the    rst
semester and then focus on alternative uses of ai in games (chapters 4 and 5) in the
second semester. when teaching the material in compressed (one-semester) fash-

preface

xi

ion instead, it is advisable to skip chapter 2 (using it as a reference when needed),
and focus the majority of the lectures on chapters 3, 4 and 5. chapters 6 and 7
can be used as material for inspiring advanced graduate-level projects in the area.
beyond the strict limits of game ai, chapter 4 (or sections of it) can complement
classes with a focus on game design or computational creativity whereas chapter 5
can complement classes with a focus on affective computing, user experience, and
data mining. it is of course also possible to use this book for an introductory under-
graduate class for students who have not taken an ai class before, but in that case
we advise the instructor to select a small subset of topics to focus on, and to com-
plement the book with online tutorials on speci   c methods (e.g., best-   rst search,
evolutionary computation) that introduce these topics in a more gentle fashion than
this book does.

chania, crete, greece
new york, ny, usa

september 2017

georgios n. yannakakis
julian togelius

acknowledgments

writing a book of this size would be impossible without the support and the contri-
butions of a large number of people. first, we would like to thank ronan nugent,
our editor at springer, who guided us and helped us from the book proposal phase
all the way to its    nal production.

we also would like to thank the following persons who read all (or parts of a
draft of) the book and provided useful feedback: amy hoover, amin babadi, sander
bakkes, vadim bulitko, phil carlisle, georgios chalkiadakis, dave churchill, mike
cook, renato cunha, kevin dill, nathaniel du preez-wilkinson, chris elion,
andy elmsley, david fogel, bernardo galv  ao, kazu-ma hashimoto, aaron isak-
sen, emil johansen, mark jones, niels justesen, graham kendall, jakub kowal-
ski, antonios liapis, nir lipovetzky, jhovan mauricio l  opez, simon lucas, jacek
ma  ndziuk, luciana mari  nelarena-dondena, chris martens, sean mealin, mark nel-
son, sven neuhaus, alexander osherenko, santiago onta  n  on, cale plut, mike
preuss, hartmut procha-ska, christoffer holmg  ard, florian richoux, sebastian
risi, christoph salge, andrea schiel, jacob schrum, magy seif el-nasr, adam
smith, gillian smith, dennis soemers, nathan sturtevant, gabriel synnaeve, nico-
las szilas, varunyu vorachart, james wen, marco wiering, mark winands, junkai
lu, francesco calimeri, diego p  erez li  ebana, corine jacobs, junkai lu, hana
rudova, and robert zubek. of these, we wish to especially thank simon lucas
for writing the foreword of the book, georgios chalkiadakis for providing substan-
tial input on parts of the book related to game theory, and mark nelson, antonios
liapis, mike preuss and adam smith for reviewing large parts of the book and pro-
viding particularly detailed feedback. we also want to thank all those who granted
us their permission to reproduce images and    gures from their papers; they are all
acknowledged in the    gure captions of the book. special thanks also go to rebecca
portelli and daniel mercieca for the artwork featured on the cover page of the book.
some chapters of this book build on papers or other book chapters that we have
co-authored. in some cases the papers are co-authored by more than the two of us;
for those papers our co-authors graciously gave us permission to reuse parts of the
material and we wish to thank them for that. in particular,

xiii

xiv
    chapter 1: [764, 700].
    chapter 4: chapter 2 and chapter 3 from [616], and [381].
    chapter 5: [778, 176, 782, 781].
    chapter 6: [785].
    chapter 7: [718, 458].

acknowledgments

writing this book has been a very long journey for both of us; a challenging
and overwhelming journey at times. there are a number of people who have sup-
ported this effort that we would like to thank. georgios wishes to thank the people
at nyu tandon school of engineering for hosting him during the early days of
book planning and the people at the technical university of crete for hosting him
during the later stages of this project. georgios would also like to thank the univer-
sity of malta for granting him a sabbatical leave, without which the book would not
have been possible. georgios and julian also wish to thank each other for putting up
with each other despite everything, and announce that they intend to buy each other
drinks to celebrate when they meet next.

last but not least, both of us wish to thank our families and all the people who
showed us their support, care, encouragement and love at times when they were
absolutely needed. you are too many to list here, but big thanks go to you all! geor-
gios would not have been able to write this book without the love and support of his
family: amyrsa and myrto have been his core inspiration, stavroula has been the
main driving force behind the writing at all times; this book is dedicated to you!

contents

part i background

1

2

introduction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.1 this book . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
1.1.1 why did we write this book? . . . . . . . . . . . . . . . . . . . . . . . .
1.1.2 who should read this book? . . . . . . . . . . . . . . . . . . . . . . . . .
1.1.3 a short note on terminology . . . . . . . . . . . . . . . . . . . . . . . . . .
1.2 a brief history of arti   cial intelligence and games . . . . . . . . . . . . .

3
4
5
6
7
8
1.2.1 academia . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 10
1.2.2
industry . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 11
1.2.3 the    gap    . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 13
1.3 why games for arti   cial intelligence . . . . . . . . . . . . . . . . . . . . . . . . . 15
1.3.1 games are hard and interesting problems . . . . . . . . . . . . . . . 15
1.3.2 rich human-computer interaction . . . . . . . . . . . . . . . . . . . . . 17
1.3.3 games are popular . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 18
1.3.4 there are challenges for all ai areas . . . . . . . . . . . . . . . . . . 20
1.3.5 games best realize long-term goals of ai . . . . . . . . . . . . . 21
1.4 why arti   cial intelligence for games . . . . . . . . . . . . . . . . . . . . . . . . . 23
1.4.1 ai plays and improves your game . . . . . . . . . . . . . . . . . . . . . 23
1.4.2 more content, better content . . . . . . . . . . . . . . . . . . . . . . . . . . 24
1.4.3 player experience and behavioral data analytics . . . . . . . . . 25
1.5 structure of this book . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 25
1.5.1 what we (don   t) cover in this book . . . . . . . . . . . . . . . . . . . 26
1.6 summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 28

ai methods. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 29
2.1 general notes . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
2.1.1 representation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 30
2.1.2 utility. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 31
2.1.3 learning = maximize utility (representation) . . . . . . . . . . . . 32
2.2 ad-hoc behavior authoring . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 32

xv

xvi

contents

2.2.1 finite state machines . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 33
2.2.2 behavior trees . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 34
2.2.3 utility-based ai . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 37
2.2.4 further reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
2.3 tree search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 39
2.3.1 uninformed search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 40
2.3.2 best-first search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41
2.3.3 minimax . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 42
2.3.4 id169 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 45
2.3.5 further reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
2.4 evolutionary computation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 49
2.4.1 local search . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 50
2.4.2 evolutionary algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 52
2.4.3 further reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
2.5 supervised learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 57
2.5.1 arti   cial neural networks . . . . . . . . . . . . . . . . . . . . . . . . . . . . 59
2.5.2 support vector machines. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 66
2.5.3 decision tree learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 68
2.5.4 further reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
2.6 id23 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 71
2.6.1 core concepts and a high-level taxonomy . . . . . . . . . . . . . . 73
2.6.2 id24 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 74
2.6.3 further reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 76
2.7 unsupervised learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
2.7.1 id91 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 77
2.7.2 frequent pattern mining . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 80
2.7.3 further reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
2.8 notable hybrid algorithms . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 82
2.8.1 neuroevolution . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 83
2.8.2 td learning with ann function approximators . . . . . . . . . 84
2.8.3 further reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 87
2.9 summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 88

part ii ways of using ai in games

3

playing games . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 91
3.1 why use ai to play games? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 92
3.1.1 playing to win in the player role . . . . . . . . . . . . . . . . . . . . . . . 93
3.1.2 playing to win in a non-player role . . . . . . . . . . . . . . . . . . . . 95
3.1.3 playing for experience in the player role . . . . . . . . . . . . . . . . 95
3.1.4 playing for experience in a non-player role . . . . . . . . . . . . . 96
3.1.5 summary of ai game-playing goals and roles . . . . . . . . . . . 98
3.2 game design and ai design considerations . . . . . . . . . . . . . . . . . . . . 98
3.2.1 characteristics of games . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 98
3.2.2 characteristics of ai algorithm design. . . . . . . . . . . . . . . . . . 105

contents

xvii

3.3 how can ai play games? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
3.3.1 planning-based approaches . . . . . . . . . . . . . . . . . . . . . . . . . . . 109
3.3.2 id23 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 115
3.3.3 supervised learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
3.3.4 chimeric game players . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 118
3.4 which games can ai play?. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
3.4.1 board games . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 119
3.4.2 card games. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 121
3.4.3 classic arcade games . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 123
3.4.4 strategy games . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 132
3.4.5 racing games . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 136
3.4.6 shooters and other first-person games . . . . . . . . . . . . . . . . . 139
3.4.7 serious games . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 141
3.4.8
interactive fiction . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 144
3.4.9 other games . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 145
3.5 further reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 148
3.6 exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
3.6.1 why ms pac-man? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 149
3.7 summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 150

4 generating content . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 151
4.1 why generate content? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 152
4.2 taxonomy . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
4.2.1 taxonomy for content . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 154
4.2.2 taxonomy for methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 155
4.2.3 taxonomy of roles . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 156
4.3 how could we generate content? . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
4.3.1 search-based methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 157
4.3.2 solver-based methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 161
4.3.3 grammar-based methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 162
4.3.4 cellular automata . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 165
4.3.5 noise and fractals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 169
4.3.6 machine learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171
4.4 roles of pcg in games . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 175
4.4.1 mixed-initiative . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 176
4.4.2 autonomous . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
4.4.3 experience-driven . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 180
4.4.4 experience-agnostic . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 182
4.5 what could be generated? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
4.5.1 levels and maps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 184
4.5.2 visuals . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 186
4.5.3 audio . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 187
4.5.4 narrative . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 189
4.5.5 rules and mechanics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 191
4.5.6 games . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 193

xviii

contents

4.6 evaluating content generators . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197
4.6.1 why is it dif   cult? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197
4.6.2 function vs. aesthetics . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 197
4.6.3 how can we evaluate a generator? . . . . . . . . . . . . . . . . . . . . 198
4.7 further reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201
4.8 exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201
4.8.1 maze generation . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 201
4.8.2 platformer level generation . . . . . . . . . . . . . . . . . . . . . . . . . . . 201
4.9 summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 202

5 modeling players . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 203
5.1 what player modeling is and what it is not . . . . . . . . . . . . . . . . . . . . 204
5.2 why model players? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 206
5.3 a high-level taxonomy of approaches . . . . . . . . . . . . . . . . . . . . . . . 207
5.3.1 model-based (top-down) approaches . . . . . . . . . . . . . . . . . . 208
5.3.2 model-free (bottom-up) approaches . . . . . . . . . . . . . . . . . . . 212
5.3.3 hybrids . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
5.4 what is the model   s input like? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 213
5.4.1 gameplay . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 214
5.4.2 objective . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 214
5.4.3 game context . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217
5.4.4 player pro   le . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 218
5.4.5 linked data . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219
5.5 what is the model   s output like? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 219
5.5.1 modeling behavior . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220
5.5.2 modeling experience . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 220
5.5.3 no output . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 229
5.6 how can we model players? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230
5.6.1 supervised learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 230
5.6.2 id23 . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 235
5.6.3 unsupervised learning . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 237
5.7 what can we model? . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 238
5.7.1 player behavior . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 238
5.7.2 player experience . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 245
5.8 further reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252
5.9 exercises . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252
5.9.1 player behavior . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 252
5.9.2 player experience . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 253
5.10 summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 254

contents

part iii the road ahead

xix

6 game ai panorama . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 259
6.1 panoramic views of game ai . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 260
6.1.1 methods (computer) perspective . . . . . . . . . . . . . . . . . . . . . . . 261
6.1.2 end user (human) perspective . . . . . . . . . . . . . . . . . . . . . . . . . 262
6.1.3 player-game interaction perspective . . . . . . . . . . . . . . . . . . . . 264
6.2 how game ai areas inform each other . . . . . . . . . . . . . . . . . . . . . . . 264
6.2.1 play games . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 266
6.2.2 generate content . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 269
6.2.3 model players . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 273
6.3 the road ahead . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 275
6.4 summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 277

7

frontiers of game ai research . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279
7.1 general general game ai . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 279
7.1.1 general play . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 281
7.1.2 general game generation and orchestration . . . . . . . . . . . . . 282
7.1.3 general game affective loop . . . . . . . . . . . . . . . . . . . . . . . . . 284
7.2 ai in other roles in games . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 285
7.3 ethical considerations . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 287
7.4 summary . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 290

references . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 293

index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 331

acronyms

asynchronous advantage actor-critic
a behavior language
alternative forced choice
arti   cial intelligence
arti   cial intelligence and interactive digital entertainment
arcade learning environment
arti   cial neural network
answer set programming
belief-desire-intention
behavior tree
brood war api
cellular automata
computational intelligence
computational intelligence and games
counterfactual regret minimization

a3c
abl
afc
ai
aiide
ale
ann
asp
bdi
bt
bwapi
ca
ci
cig
cfr
cma-es covariance matrix adaptation evolution strategy
id98
cppn
id25
ea
ecg
edpcg
eeg
emg
fps
id122
id122c
ga
gdc
ggp
gsp

convolutional neural network
compositional pattern producing network
deep q network
evolutionary algorithm
electrocardiography
experience-driven procedural content generation
electroencephalography
electromyography
first-person shooter
finite state machine
functional scaffolding for musical composition
genetic algorithm
game developers conference
general game playing
generalized sequential patterns

xxi

xxii

acronyms

galvanic skin response
general video game arti   cial intelligence
human-computer interaction
iterative dichotomiser 3
jump point search
long short-term memory
id169
markov decision process
multi-layer id88
multiplayer online battle arenas
neuroevolution of augmenting topologies
natural evolution strategy
natural language processing
non-player character
player character
procedural content generation
player experience of need satisfaction
preference learning toolbox
radial basis function
recti   ed linear unit
role-playing game
real-time strategy
id23
transactions on computational intelligence and ai in games
temporal difference
transactions on games
the open racing car simulator
tomb raider: underworld
traveling salesman problem

gsr
gvgai
hci
 
jps
lstm
mcts
mdp
mlp
moba
neat
nes
nlp
npc
pc
pcg
pens
plt
rbf
relu
rpg
rts
rl
tciaig
td
tog
torcs
tru
tsp
sc:bw starcraft: brood war
self-organizing map
som
stanford research institute problem solver
strips
id166
support vector machine
unreal tournament 2004
ut2k4
vgdl
video game description language

website

http://gameaibook.org/

this book is associated with the above website. the website complements the
material covered in the book with up-to-date exercises, lecture slides and readings.

1

part i
background

chapter 1
introduction

arti   cial intelligence (ai) has seen immense progress in recent years. it is both a
thriving research    eld featuring an increasing number of important research areas
and a core technology for an increasing number of application areas. in addition
to algorithmic innovations, the rapid progress in ai is often attributed to increas-
ing computational power due to hardware advancements. the success stories of ai
can be experienced in our daily lives through its many practical applications. ai ad-
vances have enabled better understanding of images and speech, emotion detection,
self-driving cars, web searching, ai-assisted creative design, and game-playing,
among many other tasks; for some of these tasks machines have reached human-
level status or beyond.

there is, however, a difference between what machines can do well and what
humans are good at. in the early days of ai, researchers envisaged computational
systems that would exhibit aspects of human intelligence and achieve human-level
problem solving or decision making skills. these problems were presented to the
machines as a set of formal mathematical notions within rather narrow and con-
trolled spaces, which could be solved by some form of symbol manipulation or
search in symbolic space. the highly formalized, symbolic representation allowed
ai to succeed in many cases. naturally, games   especially board games   have
been a popular domain for early ai attempts as they are formal and highly con-
strained, yet complex, decision making environments.

over the years the focus of much ai research has shifted to tasks that are rela-
tively simple for humans to do but are hard for us to describe how to do, such as
remembering a face or recognizing our friend   s voice over the phone. as a result, ai
researchers began to ask questions such as: how can ai detect and express emotion?
how can ai educate people, be creative or artistically novel? how can ai play a
game it has not seen before? how can ai learn from a minimal number of trials?
how can ai feel guilt? all these questions pose serious challenges to ai and cor-
respond to tasks that are not easy for us to formalize or de   ne objectively. perhaps
surprisingly (or unsurprisingly after the fact), tasks that require relatively low cog-
nitive effort from us often turn out to be much harder for machines to tackle. again,
games have provided a popular domain to investigate such abilities as they feature

3

4

chapter 1. introduction

aspects of a subjective nature that cannot be formalized easily. these include, for
instance, the experience of play or the creative process of game design [599].

ever since the birth of the idea of arti   cial intelligence, games have been help-
ing ai research progress. games not only pose interesting and complex problems
for ai to solve   e.g., playing a game well; they also offer a canvas for creativity
and expression which is experienced by users (people or even machines!). thus,
arguably, games are a rare domain where science (problem solving) meets art and
interaction: these ingredients have made games a unique and favorite domain for the
study of ai. but it is not only ai that is advanced through games; games have also
been advanced through ai research. we argue that ai has been helping games to get
better on several fronts: in the way we play them, in the way we understand their
inner functionalities, in the way we design them, and in the way we understand play,
interaction and creativity. this book is dedicated to all aspects of the intersection of
games and ai and the numerous ways both games and ai have been challenged, but
nevertheless, advanced through this relationship. it is a book about ai for games and
games for ai.

1.1 this book

the study of ai in and for games is what this book de   nes as the research    eld of
game arti   cial intelligence (in brief game ai, also occasionally referred to as ai
and games). the book offers an academic perspective of game ai and serves as
a comprehensive guidebook for this exciting and fast-moving research    eld. game
ai   in particular video game or computer game ai   has seen major advancements
in the (roughly)    fteen years of its existence as a separate research    eld. during this
time, the    eld has seen the establishment and growth of important yearly meetings   
including the ieee conference on computational intelligence and games (cig)
and the aaai arti   cial intelligence and interactive digital entertainment (aiide)
conference series   as well as the launch of the ieee transactions on com-
putational intelligence and ai in games (tciaig) journal   which will
be renamed ieee transactions on games (tog) from january 2018. since
the early days of game ai we have seen numerous success stories within the sev-
eral subareas of this growing and thriving research    eld. we can nowadays use ai
to play many games better than any human, we can design ai bots that are more
believable and human-like than human players, we can collaborate with ai to de-
sign better and unconventional (aspects of) games, we can better understand players
and play by modeling the overall game experience, we can better understand game
design by modeling it as an algorithm, and we can improve game design and tune
our monetization strategy by analyzing massive amounts of player data. this book
builds on these success stories and the algorithms that took us there by exploring
the different uses of ai for games and games for ai.

1.1. this book

5

1.1.1 why did we write this book?

both of us have been teaching and researching game arti   cial intelligence at under-
graduate and graduate levels in various research and educational institutions across
the globe for over a decade. both of us have felt, at times, that a comprehensive
textbook on game ai was necessary for our students and a service to the learning
objectives of our programs. meanwhile, an increasing number of fellow academics
felt the same way. such a book was not available, and given our extensive experi-
ence with the    eld, we felt we were well placed to write the book we needed. given
that we have been collaborating on game ai research since 2009, and known each
other since 2005, we knew our perspective was coherent enough to actually agree
on what should go into the book without undue bickering. while we have been try-
ing hard to write a book that will appeal to many and be useful for both students
and researchers from different backgrounds, it ultimately re   ects our perspective of
what game ai is and what is important within the    eld.

looking at the existing literature to allocate readings for a potential course on
game ai one can rely partly on a small number of relevant and recent surveys
and vision papers for speci   c game ai research areas. examples include papers
meant to serve as general introductions to game ai [407, 764, 785], general game
ai [718], monte-carlo tree search [77], procedural content generation [783, 720],
player modeling [782], emotion in games [781], computational narrative [562], ai
for game production [564], neuroevolution in games [567], and ai for games on
mobile devices [265]. there are also some earlier surveys re   ecting the state of the
art at the beginning of this research    eld, for example, on evolutionary computa-
tion in games [406] and computational intelligence in games [405]. no mere paper
can however on its own cover the breadth and depth required by a full course on
game ai. for this reason, the courses we have taught have generally been structured
around a set of papers, some of them surveys and some of them primary research
papers, together with slides and course notes.

the    rst, recently published, edited volumes on game ai research have been
great assets for teaching needs in game ai. these are books with a focus on a
particular area of game ai research such as procedural content generation [616],
emotion in games [325] and game data mining [186]. because of their more nar-
row domains they cannot serve as textbooks for a complete course on game ai but
rather as parts of a game ai course or, alternatively, as textbooks for independent
courses on procedural content generation, affective computing or game data mining,
for instance.

meanwhile several edited volumes or monographs which have covered aspects
of game ai programming are edited or written by game ai experts from the game
industry. these include the popular game ai programming wisdom series [546, 547,
548, 549] and other game ai programming volumes [604, 8, 552, 553, 80, 81, 425].
these books, however, target primarily professional or indie developers, game ai
programmers and practitioners, and do not always ful   ll the requirements of an aca-
demic textbook. as you will see, this is only one part of the    eld of game ai as we
de   ne it. further, some of the earlier books are somewhat outdated by now given the

6

chapter 1. introduction

fast pace of progress of the game ai research    eld [109, 62]. among the industry-
focused game ai books there are a few that aim to target educators and students
of game ai. they have a rather narrow scope, however, as they are limited to non-
player character ai [461], which is arguably the most important topic for game ai
practitioners in the gaming industry [764, 425] but only one of several research ar-
eas in academic game ai research [785]. in our terminology, the perspective of these
industry-focused textbooks tends to be almost exclusively on what we call playing
for experience, in particular generating interesting non-player character (npc) be-
havior that looks lifelike and functions within the con   nes of a game design. finally
there are game ai books that are tied to a particular language or software suite such
as lua [791] or unity [31], which also limits their usefulness as general textbooks.
in contrast to the above list of books, edited volumes and papers, this book aims
to present the research    eld as a whole and serve (a) as a comprehensive textbook
for game arti   cial intelligence, (b) as a guidebook for game ai programming, and
(c) as a    eld guide for researchers and graduate students seeking to orient them-
selves within this multifaceted research    eld. for this reason, we both detail the
state of knowledge of the    eld and also present research and original scholarship in
game ai. thus the book can be used for both research-based teaching and hands-
on applications of game ai. we detail our envisaged target audience in the section
below.

1.1.2 who should read this book?

with this book we hope to reach readers with a general interest in the application of
ai to games, who already know at least the basics of arti   cial intelligence. however,
while writing the book we particularly envisioned three groups of people bene   ting
directly from this book. the    rst group is university students, of graduate or ad-
vanced undergraduate level, who wish to learn about ai in games and use it to de-
velop their career in game ai programming or in game ai research. in particular, we
see this book being used in advanced courses for students who have already taken
an introductory ai course, but with care and some supplementary material it could
be used for an introductory course as well. the second group is ai researchers and
educators who want to use this book to inspire their research or, instead, use it as
a textbook for a class in arti   cial intelligence and games. we particularly think of
active researchers within some ai-related    eld wanting to start doing research in
game ai, and new ph.d. students in the area. the last target audience is computer
game programmers and practitioners who have limited ai or machine learning
background and wish to explore the various creative uses of ai in their game or
software application. here we provide a complement to the more industry-focused
books listed above by taking a broader view of what ai in and for games could be.
for further fostering the learning process and widening the practical application of
ai in games the book is accompanied by a website that features lectures, exercises
and additional resources such as readings and tools.

1.1. this book

7

this book is written with the assumption that its readers come from a techni-
cal background such as computer science, software engineering or applied math.
we assume that our readers have taken courses on the fundamentals of arti   cial in-
telligence (or acquired this knowledge elsewhere) as the book does not cover the
algorithms in detail; our focus, instead, is on the use of the algorithms in games and
their modi   cation for that purpose. to be more speci   c, we assume that the reader
is familiar with core concepts in tree search, optimization, supervised learning, un-
supervised learning and id23, and has implemented some basic
algorithms from these categories. chapter 2 provides an overview of core meth-
ods for game ai and a refresher for the reader whose knowledge is a bit rusty. we
also assume familiarity with programming and a basic understanding of algebra and
calculus.

1.1.3 a short note on terminology

the term    arti   cial and computational intelligence in games    is often used to re-
fer to the entire    eld covered in this book (e.g., see the title of [785]). this re   ects
the dual roots of the    eld in arti   cial intelligence and computational intelligence
(ci) research, and the use of these terms in the names of the major conferences in
the    eld (aiide and cig) and the    agship journal (ieee tciaig) explicitly tar-
geting both ci and ai research. there is no agreement on the exact meaning of
the terms ai and ci. historically, ai has been associated with logic-based or sym-
bolic methods such as reasoning, id99 and planning, and ci
has been associated with biologically-inspired or statistical methods such as neural
networks (including what is now known as deep learning) and evolutionary compu-
tation. however, there is considerable overlap and strong similarities between these
   elds. most of the methods proposed in both    elds aim to make computers perform
tasks that have at some point been considered to require intelligence to perform, and
most of the methods include some form of heuristic search. the    eld of machine
learning intersects with both ai and ci, and many techniques could be said to be
part of either    eld.

in the rest of the book we will use the terms    ai and games   ,    ai in games   
and    game ai    to refer to the whole research    eld, including those approaches that
originally come from the ci and machine learning    elds. there are three reasons for
this: simplicity, readability, and that we think that the distinction between ci and ai
is not useful for the purposes of this book or indeed the research    eld it describes.
our use of these terms is not intended to express any prejudice towards particular
methods or research questions. (for a non-exclusive list of methods we believe are
part of    ai    according to this de   nition, see chapter 2.)

8

chapter 1. introduction

1.2 a brief history of arti   cial intelligence and games

games and arti   cial intelligence have a long history together. much research on ai
for games is concerned with constructing agents for playing games, with or without
a learning component. historically, this has been the    rst and, for a long time, the
only approach to using ai in games. even since before arti   cial intelligence was
recognized as a    eld, early pioneers of computer science wrote game-playing pro-
grams because they wanted to test whether computers could solve tasks that seemed
to require    intelligence   . alan turing, arguably the principal inventor of computer
science, (re)invented the minimax algorithm and used it to play chess [725]. the
   rst software that managed to master a game was programmed by a. s. douglas
in 1952 on a digital version of the tic-tac-toe game and as part of his doctoral
dissertation at cambridge. a few years later, arthur samuel was the    rst to invent
the form of machine learning that is now called id23 using a
program that learned to play checkers by playing against itself [591].

most early research on game-playing ai was focused on classic board games,
such as checkers and chess. there was a conception that these games, where great
complexity can arise from simple rules and which had challenged the best human
minds for hundreds or even thousands of years, somehow captured the essence of
thought. after over three decades of research on tree search, in 1994, the chinook
checkers player managed to beat the world checkers champion marion tinsley
[594]; the game was eventually solved in 2007 [593]. for decades chess was seen as
   the drosophila of ai    in the sense of being the    model organism    that uncountable
new ai methods were tested on [194]   at least until we developed software capable
of playing better than humans, at which point chess-playing ai somehow seemed a
less urgent problem. the software that    rst exhibited superhuman chess capability,
ibm   s deep blue, consisted of a minimax algorithm with numerous chess-speci   c
modi   cations and a very highly tuned board evaluation function running on a cus-
tom supercomputer [98, 285]. deep blue famously won against the reigning grand-
master of chess, garry kasparov, in a much-publicized event back in 1997. twenty
years later, it is possible to download public domain software that will play better
than any human player when running on a regular laptop.

a milestone in ai research in games a few years before the successes of deep
blue and chinook is the backgammon software named td-gammon which was
developed by gerald tesauro in 1992. td-gammon employs an arti   cial neural
network which is trained via temporal difference learning by playing backgam-
mon against itself a few million times [688, 689]. td-gammon managed to play
backgammon at a level of a top human backgammon player. after deep blue ibm   s
next success story was watson, a software system capable of answering questions
addressed in natural language. in 2011, watson competed on the jeopardy! tv
game and won $1 million against former winners of the game [201].

following the successes of ai in traditional board games the latest board game
ai milestone was reached in 2016 in the game of go. soon after chinook and
deep blue, the game of go became the new benchmark for game playing ai with
a branching factor that approximates 250 and a vast search space many times larger

1.2. a brief history of arti   cial intelligence and games

9

than that of chess   . while human level go playing had been expected sometime in
the far future [368], already in 2016 lee sedol   a 9-dan professional go player   
lost a    ve-game match against google deepmind   s alphago software which fea-
tured a deep id23 approach [629]. just a few days before the re-
lease of the    rst draft of this book   between 23 and 27 may 2017   alphago won
a three-game go match against the world   s number 1 ranking player ke jie, running
on a single computer. with this victory, go was the last great classic board game
where computers have attained super-human performance. while it is possible to
construct classic-style board games that are harder than go for computers to play,
no such games are popular for human players.

but classic board games, with their discrete turn-based mechanics and where the
full state of the game is visible to both players, are not the only games in town,
and there is more to intelligence than what classic board games can challenge. in
the last decade and a half, a research community has therefore grown up around
applying ai to games other than board games, in particular video games. a large part
of the research in this community focuses on developing ai for playing games   
either as effectively as possible, or in the style of humans (or a particular human),
or with some other property. a notable milestone in video game ai playing was
reached in 2014 when algorithms developed by google deepmind learned to play
several games from the classic atari 2600 video game console on a super-human
skill level just from the raw pixel inputs [464]. one of the atari games that proved
to be hard to play well with that approach was ms pac-man (namco, 1982). the
game was practically solved a few days before the release of the second draft of the
book (june 2017) by the microsoft maluuba team using a hybrid reward architecture
id23 technique [738].

other uses of ai in video games (as detailed in this book) have come to be very
important as well. one of these is procedural content generation. starting in the
early 1980s, certain video games created some of their content algorithmically dur-
ing runtime, rather than having it designed by humans. two games that became very
in   uential early on are rogue (toy and wichmann, 1980), where dungeons and the
placement of creatures and items in them are generated every time a new game
starts, and elite (acornsoft, 1984), which stores a large universe as a set of random
seeds and creates star systems as the game is played. the great promise of games
that can generate some of their own content is that you can get more   potentially
in   nite   content without having to design it by hand, but it can also help reduce
storage space demands among many other potential bene   ts. the in   uence of these
games can be seen in recent successes such as diablo iii (blizzard entertainment,
2012), no man   s sky (hello games, 2016) and the chalice dungeons of bloodborne
(sony computer entertainment, 2015).

relatively recently, ai has also begun to be used to analyze games, and model
players of games. this is becoming increasingly important as game developers need
to create games that can appeal to diverse audiences, and increasingly relevant as
most games now bene   t from internet connectivity and can    phone home    to the
developer   s servers. facebook games such as farmville (zynga, 2009) were among
the    rst to bene   t from continuous data collection, ai-supported analysis of the data

10

chapter 1. introduction

and semi-automatic adaptation of the game. nowadays, games such as nevermind
(flying mollusk, 2016) can track the emotional changes of the player and adapt the
game accordingly.

very recently, research on believable agents in games has opened new horizons
in game ai. one way of conceptualizing believability is to make agents that can
pass game-based turing tests. a game turing test is a variant of the turing test
in which a number of judges must correctly guess whether an observed playing
behavior in a game is that of a human or an ai-controlled game bot [263, 619].
most notably, two ai-controlled bot entries managed to pass the game turing test in
unreal tournament 2004 (epic games, 2004) on turing   s centenary in 2012 [603].
in the next section we will outline the parallel developments in both academia
and industry and conclude the historical section on game ai with ways the two
communities managed to exchange practices and transfer knowledge for a common
two-fold goal: the advancement of ai and the improvement of games at large.

1.2.1 academia

in academic game ai we distinguish two main domains and corresponding research
activity: board games and video (or computer) games. below, we outline the two
domains in a chronological sequence, even though game ai research is highly active
in both of them.

1.2.1.1 early days on the board

when it comes to game ai research, classic board games such as chess, checkers
and go are clearly bene   cial to work with as they are very simple to model in code
and can be simulated extremely fast   one can easily make millions of moves per
second on a modern computer   which is indispensable for many ai techniques.
also, board games seem to require thinking to play well, and have the property
that they take    a minute to learn, but a lifetime to master   . it is indeed the case
that games have a lot to do with learning, and good games are able to constantly
teach us more about how to play them. indeed, to some extent the fun in playing
a game consists in learning it and when there is nothing more to learn we largely
stop enjoying them [351]. this suggests that better-designed games are also better
benchmarks for arti   cial intelligence. as mentioned above, board games were the
dominant domain for ai research from the early 1950s until quite recently. as we
will see in the other parts of this book   notably in chapter 3   board games remain
a popular game ai research domain even though the arrival of video and arcade
games in the 1980s has shifted a large part of the focus since then.

1.2. a brief history of arti   cial intelligence and games

11

1.2.1.2 the digital era

to the best of our knowledge, the    rst video game conference occurred at harvard   s
graduate school of education1 in 1983. the core focus of the conference was on
the educational bene   ts and positive social impact of video game playing.

the birth date of the digital game ai    eld can be safely considered to be around
year 2001. the seminal article by laird and van lent [360], emphasizing the role
of games as the killer application for ai, established the foundations of game ai
and inspired early work in the    eld [696, 235, 476, 292, 211, 694, 439, 766, 707]. in
those early days ai in digital games was mainly concerned with playing games,
agent architectures for npc behavior [401, 109], sometimes within interactive
drama [438, 399, 412, 483, 107], and path   nding [664]. early work in these areas
was presented primarily in the aaai spring symposia on ai and interactive enter-
tainment preceding the aiide (which started 2005) and the ieee cig (also started
in 2005) conferences. most of the early work in the game ai    eld was conducted by
researchers with ai, optimization and control background and research experience
in adaptive behavior, robotics and multi-agent systems. ai academics used the best
of their computational intelligence and ai tools to enhance npc behavior in gen-
erally simple, research-focused, non-scalable projects of low commercial value and
perspective.

1.2.2 industry

the    rst released video games back in the 1970s included little or nothing that we
would call arti   cial intelligence; npc behaviors were scripted or relied on simple
rules, partly because of the primitive state of ai research, but perhaps even more
because of the primitive hardware of the time. however, in parallel to developments
in academia, the game industry gradually made steps towards integrating more so-
phisticated ai in their games during the early days of game ai [109, 758].

a non-exhaustive list of ai methods and game features that advanced the game
ai state-of-practice in the industry [546] in chronological order includes the    rst
popular application of neural networks in creatures (millennium interactive, 1996)
with the aim to model the creatures    behavior; the advanced sensory system of
guards in thief (eidos, 1998); the team tactics and believable combat scenes in the
halo series (microsoft studios, 2011   2017)   halo 2 in particular popularized the
use of behavior trees in games; the behavior-based ai of blade runner (virgin inter-
active, 1997); the advanced opponent tactics in half-life (valve, 1998); the fusion
of machine learning techniques such as id88s, id90 and reinforce-
ment learning coupled with the belief-desire-intention cognitive model in black and
white (ea, 2000)   see fig. 1.1; the believable agents of the sims series (electronic
arts, 2000   2017); the imitation learning drivatar system of forza motorsport (ms

1 fox butter   eld, video game specialists come to harvard to praise pac-man; not to bury him.
new york times, may 24, 1983

12

chapter 1. introduction

fig. 1.1 a screenshot from black and white (ea, 2000), a highlight in game arti   cial intelligence
history that successfully integrated several ai methods into its design. the game features a creature
that learns through positive rewards and penalties in a id23 fashion. further, the
creature employs the belief-desire-intention model [224] for its decision making process during
the game. the desires of the creature about particular goals are modeled via simple id88s.
for each desire, the creature selects the belief that it has formed the best opinion about; opinions,
in turn, are represented by id90. image obtained from wikipedia (fair use).

game studios, 2005); the generation of context-sensitive behaviors via goal ori-
ented action planning [506]   a simpli   ed strips-like planning method   which
was speci   cally designed for f.e.a.r. (sierra entertainment, 2005) [507]; the pro-
cedurally generated worlds of the civilization series (microprose, activision, info-
grames entertainment, sa and 2k games, 1991   2016) and dwarf fortress (bay 12
games, 2006); the ai director of left 4 dead (valve, 2008); the realistic gun   ghts of
red dead redemption (rockstar games, 2010); the personality-based adaptation in
silent hill: shattered memories (konami, 2010); the affect-based cinematographic
representation of multiple cameras in heavy rain (quantic dream, 2010); the neu-
roevolutionary training of platoons in supreme commander 2 (square enix, 2010);
the buddy ai (named ellie) in the last of us (sony computer entertainment, 2013);
the companion character, elizabeth, in bioshock in   nite (2k games, 2013); the in-
teractive narratives of blood & laurels (emily short, 2014); the alien   s adaptive
behavior which adjusts its hunting strategy according to the player in alien: isola-
tion (sega, 2014); and the procedurally generated worlds of spelunky (mossmouth,
llc, 2013) and no man   s sky (hello games, 2016).

1.2. a brief history of arti   cial intelligence and games

13

the key criterion that distinguishes successful ai in commercial-standard games
had always been the level of integration and interweaving of ai in the design of
the game [599, 546]. an unsuccessful coupling of game design and ai may lead
to unjusti   able npc behaviors, break the suspension of disbelief and immediately
reduce player immersion. a typical example of such a mismatch between ai and
design is the broken navigation of bots that get stuck in a level   s dead end; in such
instances either the level design is not (re)considered appropriately to match the
design of ai or the ai is not tested suf   ciently, or both. on the other hand, the
successful integration of ai in the design process is likely to guarantee satisfactory
outcomes for the playing experience. the character design process, for instance,
may consider the limitations of the ai and, in turn, absorb potential    catastrophic   
failures of it. an example of such an interwoven process is the character design
in fac  ade [441] that was driven, in part, by the limitations of the natural language
processing and the interactive narrative components of the game.

it is important to note that this book is not necessarily about game ai as de   ned
and practiced in the game industry. instead, it is primarily an academic textbook
that refers to some of the techniques that have been used in and popularized through
the game industry   see for instance the ad-hoc behavior authoring section of chap-
ter 2. the reader with an interest in the ai state of practice in the game industry is
referred to the several introductory articles (e.g., [171, 369]) available in books such
as the game ai programming wisdom series [546, 547, 548, 549]. another valu-
able resource is the video recorded talks from top game ai programmers which
are hosted at the ai summit2 of the game developers conference (gdc) and are
available at the gdc vault.3 finally, talks and courses mostly relevant for game ai
programmers are available through the nucl.ai conference webpage.4

1.2.3 the    gap   

during the    rst decade of academic game ai research, whenever researchers from
academia and developers from industry would meet and discuss their respective
work, they would arrive at the conclusion that there exists a gap between them;
the gap had multiple facets such as differences in background knowledge, practice,
trends, and state-of-the-art solutions to important problems. academics and practi-
tioners would discuss ways to bridge that gap for their mutual bene   t on a frequent
basis [109] but that debate would persist for many years as developments on both
ends were slow. the key message from academic ai was that the game industry
should adopt a    high risk-high gain    business model and attempt to use sophisti-
cated ai techniques with high potential in their games. on the other end, the central
complaint of industrial game ai regarding game ai academics has been the lack of

2 http://www.gdconf.com/conference/ai.html
3 http://www.gdcvault.com/
4 https://nucl.ai/

14

chapter 1. introduction

domain-speci   c knowledge and practical wisdom when it comes to realistic prob-
lems and challenges faced during game production. perhaps above all there is a
difference in what is valued, with academics valuing new algorithms and new uses
of algorithms that achieve superior performance or create new phenomena or experi-
ences, and ai developers in industry valuing software architectures and algorithmic
modi   cations that reliably support speci   c game designs. but what happened since
then? does this gap really exist nowadays or is it merely a ghost from the past?

it is still true that the academic game ai research community and the game indus-
try ai development community largely work on different problems, using different
methods. there are also some topics and methods explored by the academic commu-
nity which are generally very unpopular within the game industry. real-time adap-
tation and learning in npcs is one such example; quite a few academic researchers
are excited by the idea of npcs that can learn and develop from their interactions
with the player and other npcs in the game. however, ai developers in industry
point out that it would be very hard to predict what these npcs will learn, and it
is very likely to    break the game    in the sense that it no longer works as designed.
conversely, there are methods and problems explored in industry which most aca-
demics do not care about, as they only make sense within the complex software
architecture of a complete game.

when thinking about the use of ai within modern video games, it is important to
remember that most game genres have developed evolutionarily from earlier game
designs. for example, the    rst platformers were released in the mid-1980s and the
   rst    rst-person shooters and real-time strategy games in the early 1990s. at that
time, the ability to build and deploy advanced ai was much less than it is today,
so designers had to design around the lack of ai. these basic design patterns have
largely been inherited by today   s games. it can therefore be said that many games
have been designed not to need ai. for the academic who wants to build interesting
ai for an in-game role, the best might therefore be to create new game designs that
start from the existence of the ai.

taking a positive stance on the topic we would argue that any existing gap be-
tween academic and industrial npc ai nowadays can be viewed as a healthy in-
dication of a parallel progress with a certain degree of collaboration. as industry
and academia do not necessarily attempt to solve the same problems with the same
approaches it may be that npc ai solutions emerging from industry can inspire
new approaches in academia and vice versa. in summary, the npc ai gap is clearly
smaller in tasks that both academia and industry care about. certain aspects of npc
ai, however, are far from being solved in an ideal fashion and others   such as mod-
eling emotion in role playing games   are still at the beginning stages of investiga-
tion. so while we can praise the npc ai of the elder scrolls v: skyrim (bethesda
softworks, 2011) we cannot be as positive about the companion ai of that game.
we can view the very existence of such limitations as an opportunity that can bring
industry and academia even closer to work on further improving existing npc ai
in games.

a different take on this discussion   which is supported by some game develop-
ers and game ai academics   is that npc ai is almost solved for most production

1.3. why games for arti   cial intelligence

15

tasks; some take it one step further and claim that game ai research and develop-
ment should focus solely on non-traditional uses of ai [477, 671]. the level of ai
sophistication in recent games such as left 4 dead (valve, 2008) and the elder
scrolls v: skyrim (bethesda softworks, 2011) supports this argument and suggests
that advances in npc ai have reached satisfactory levels for many npc control
challenges faced during game production. due to the rise of robust and effective
industrial game ai solutions, the convergence to satisfying npc performances, the
support of the multidisciplinary nature of game ai and a more pragmatic and holis-
tic view of the game ai problem, recent years have seen a shift of academic and
industrial interests with respect to game ai. it seems that we have long reached an
era where the primary focus of the application of ai in the domain of games is not
on agents and npc behaviors. the focus has, instead, started to shift towards inter-
weaving game design and game technology by viewing the role of ai holistically
and integrating aspects of procedural content generation and player modeling within
the very notion of game ai [764].

the view we take in this book is that ai can help us to make better games but
that this does not necessarily happen through better, more human-like or believable
npcs [764]. notable examples of non-npc ai in games include no man   s sky
(hello games, 2016) and its procedural generation of a quintillion different planets
and nevermind (flying mollusk, 2016) with its affective-based game adaptation
via a multitude of physiological sensors. but there might be other ai roles with
game design and game development that are still to be found by ai. beyond playing
games, modeling players or generating content, ai might be able to play the role of
a design assistant, a data analyst, a playtester, a game critic, or even a game director.
finally, ai could potentially play and design games as well as model their players
in a general fashion. the    nal chapter (chapter 7) of this book is dedicated to these
frontier research areas for game ai.

1.3 why games for arti   cial intelligence

there are a number of reasons why games offer the ideal domain for the study of
arti   cial intelligence. in this section, we list the most important of them.

1.3.1 games are hard and interesting problems

games are engaging due to the effort and skills required from people to complete
them or, in the case of puzzles, solve them. it is that complexity and interestingness
of games as a problem that makes them desirable for ai. games are hard because
their    nite state spaces, such as the possible strategies for an agent, are often vast.
their complexity as a domain rises as their vast search spaces often feature small

16

chapter 1. introduction

feasible spaces (solution spaces). further, it is often the case that the goodness of
any game state is hard (or even impossible) to assess properly.

from a computational complexity perspective, many games are np-hard (np
refers to    nondeterministic polynomial time   ), meaning that the worst-case com-
plexity of    solving    them is very high. in other words, in the general case an algo-
rithm for solving a particular game could run for a very long time. depending on a
game   s properties complexity can vary substantially. nevertheless, the list of games
that are np-hard is rather long and includes games such as the two-player incom-
plete information mastermind game [733, 660], the lemmings (psygnosis, 1991)
arcade game [334] and the minesweeper game by microsoft [331]. it should be
noted that this computational complexity characterization has little to do with how
hard the games are to play for humans, and does not necessarily say much about
how well heuristic ai methods can play them. however, it is clear that at least in
theory, and for arbitrary-size instances, many games are very hard.

the investigations of ai capacity in playing games that are hard and complex has
been benchmarked via a number of milestone games. as mentioned earlier, chess
and (to a lesser degree) checkers have traditionally been seen as the    drosophila for
ai research    even from the early days of ai. after the success of deep blue and
chinook in these two games we gradually invented and cited other more complex
games as ai    drosophilae   , or universal benchmarks. lemmings has been charac-
terized as such; according to mccarthy [446] it    connects logical formalizations
with information that is incompletely formalizable in practice   . in practice, games
for which better apis have been developed   such as super mario bros (nintendo,
1985)5 and starcraft (blizzard entertainment, 1998)   have become more popular
benchmarks.

the game of computer go has also been another core and traditional game ai
benchmark with decades of active research. as a measure of problem complexity a
typical game in go has about 10170 states. the    rst ai feature extraction investiga-
tions in go seem to date back to the 1970s [798]. the game received a lot of research
attention during several world computer go championships up until the recent suc-
cess of alphago [629]. alphago managed to beat two of the best go professional
human players using a combination of deep learning and id169.
in march 2016, alphago won against lee sedol and in may 2017 it won all three
games against the world   s number 1 ranked player, ke jie.

the starcraft (blizzard entertainment, 1998) real-time strategy game can be
characterized as perhaps the single hardest game for computers to play well. at the
time of writing this book the best starcraft bots only reach the level of amateur
players.6 the complexity of the game derives mainly from the multi-objective task
of controlling multiple and dissimilar units in a game environment of partial infor-
mation. while it is not trivial to approximate the state space of starcraft, according
to a recent study [729], a typical game has at least 101,685 possible states. in com-
parison, the number of protons in the observable universe is only about 1080 [182].

5 note that the original game title contains a dot, i.e., super mario bros.; for practical reasons,
however, we will omit the dot when referring to the game in the remainder of this book.
6 http://www.cs.mun.ca/  dchurchill/starcraftaicomp/

1.3. why games for arti   cial intelligence

17

the number of starcraft   s possible states sounds huge but, interestingly enough,
its search space can be of manageable size if represented by bytes. on that basis,
we require about 700 bytes of information to represent the starcraft search space
whereas the number of protons in the known universe is equivalent to the number of
con   gurations of about 34 bytes.

one could of course design games that are harder on purpose, but there is no
guarantee anyone would want to play those games. when doing ai research, work-
ing on games that people care about means you are working on relevant problems.
this is because games are designed to challenge the human brain and successful
games are typically good at this. starcraft (blizzard entertainment, 1998)   and
its successor starcraft ii (blizzard entertainment, 2010)   are played by millions
of people all over the world, with a very active competition scene of elite profes-
sional players and even dedicated tv channels such as ogn7   a south korean
cable television channel   or twitch channels8 that specialize in broadcasting video
game-related content and e-sports events.

many would claim that starcraft (blizzard entertainment, 1998) is the next ma-
jor target for ai research on playing to win. in academia, there is already a rich
body of work on algorithms for playing (parts of) starcraft [504, 569, 505, 124],
or generating maps for it [712]. beyond academia, industrial ai leaders google
deepmind and facebook seem to be in agreement and on a similar scienti   c mis-
sion. deepmind recently announced that starcraft ii will be one of their major new
testbeds, after their success at training deep networks to play atari games in the
arcade learning environment9 (ale) [40] framework. at the time of writing this
book, deepmind in collaboration with blizzard entertainment opened up starcraft
ii to ai researchers for testing their algorithms.10 facebook ai research has led the
development of torchcraft [681]   a bridge between the deep learning torch library
and starcraft   and recently published their    rst paper on using machine learning
to learn to play starcraft [729], showing that they take this challenge seriously.
another industrial game ai research lab collaborating with academia on solving
starcraft is hosted in alibaba [523]. given the game   s complexity, it is unlikely we
will conquer all of it soon [234] but it is a game through which we expect to see ai
advancements in the years to come.

1.3.2 rich human-computer interaction

computer games are dynamic media by de   nition and, arguably, offer one of the
richest forms of human-computer interaction (hci); at least at the time of writing
this book. the richness of interaction is de   ned in terms of the available options

7 http://ch.interest.me/ongamenet/
8 for instance, https://www.twitch.tv/starcraft
9 http://www.arcadelearningenvironment.org/
10 follow developments at: https://deepmind.com/blog/

18

chapter 1. introduction

a player has at any given moment and the ways (modalities) a player can interact
with the medium. the available options for the player are linked to the game action
space and the complexity associated with it in games such as starcraft ii (blizzard
entertainment, 2010). further, the modalities one may use to interact with games
nowadays extend beyond the traditional keyboard, mouse and tablet-like haptics, to
game controllers, physiology such as heart rate variability, body movement such as
body stance and gestures, text, and speech. as a result, many games would easily
top the list of information bits exchanged between them and their users per second
compared to any other hci medium; however, such comparative studies are not
currently available to further support our claims.

clearly, as we will see later in this book, games offer one of the best and most
meaningful domains for the realization of the affective loop, which de   nes a frame-
work that is able to successfully elicit, detect and respond to the cognitive, behav-
ioral and emotive patterns of its user [670]. the potential that games have to in   u-
ence players is mainly due to their ability to place the player in a continuous mode of
interaction with the game which elicits complex cognitive, affective and behavioral
responses to the player. this continuous interaction mode is enriched by fast-paced
and multimodal forms of user interactivity that are often possible in games. as every
game features a player   or a number of players   the interaction between the player
and the game is of key importance for ai research as it gives algorithms access to
rich player experience stimuli and player emotional manifestations. such complex
manifestations, however, cannot trivially be captured by standard methods in ma-
chine learning and data science. undoubtedly, the study of game-player interaction
via arti   cial intelligence not only advances our knowledge about human behavior
and emotion but also contributes to the design of better human-computer interac-
tion. as a result, it further pushes the boundaries of ai methods in order to address
the challenges of game-based interaction.

1.3.3 games are popular

while video games, back in the 1980s, were introduced as a niche activity for those
having access to a video arcade or to consoles such as atari 2600, they gradually
turned into a multi-billion industry generating, in the 2010s, a global market revenue
higher than any other form of creative industry, including    lm and music. at the
time of writing, games generate a worldwide total of almost $100 billion in revenue
which is expected to rise to approximately $120 billion by 2019.11

but why did games became so popular? beyond the obvious argument of games
being able to enhance a user   s intrinsic motivation and engagement by offering in-
teractivity capacities with a virtual environment, it was the technological advance-
ments over the last 40 years that drastically changed the demographics of players
[314]. back in the early 1980s games used to be played solely in arcade entertain-

11 see, for instance, the global games market report by newzoo:
https://newzoo.com/solutions/revenues-projections/global-games-market-report/

1.3. why games for arti   cial intelligence

19

ment machines; nowadays, however, they can be played using a multitude of devices
including a pc (e.g., multi-player online or casual games), a mobile phone, a tablet,
a handheld device, a virtual reality device, or a console (and obviously still an ar-
cade entertainment machine!). beyond the technological advancements that fostered
accessibility and democratized gameplay, it is also the culture that follows a new
medium and develops it into a new form of art and expression. not only the inde-
pendent scene of game design and development12 has contributed to this culture, but
also the outreach achieved from the multitude of purposes and objectives of games
beyond mere entertainment: games for art, games as art, games for a change, phys-
ical interactive games, games for education, games for training and health, games
for scienti   c discovery, and games for culture and museums. in brief, not only are
games everywhere and present in our daily lives but they also shape our social and
cultural values at large   as for instance evidenced by the recent massive success of
pok  emon go (niantic, 2016). as a byproduct of their popularity games offer easy
access to people with world-class performance in the domain. experts (i.e., profes-
sional players) for many board and digital games that are world-ranked according to
their gameplay performance have participated regularly in competitions against ai
algorithms; examples include garry kasparov (chess), and lee sedol and ke jie
(go).

as games become more popular, grow in quantity, and become more complex,
new ai solutions are constantly required to meet the new technological challenges.
this is where ai meets a domain with a strong industrial backing and a desire to
support sophisticated technology for bettering player experience. furthermore, very
few domains for ai offer the privilege of daily accessibility to new content and data
from their popular use. but let us look at these two aspects in more detail below.

1.3.3.1 popular means more content

the more people play (more) games, the more content is required for games. con-
tent takes effort to create but, over the years, mechanisms have been developed that
allow both machines and players to design and create various forms of content in
games. games have gradually developed to be content-intensive software applica-
tions that demand content that is both of direct use in the game and of suf   cient
novelty. the overwhelming demand for new and novel gaming experiences from a
massive community of users constantly pushes the boundaries of human and com-
putational creativity to new grounds; and naturally ai at large.

content in games, beyond any other form of multimedia or software application,
not only covers all possible forms of digital content such as audio, video, image,
and text but it also comes in massive numbers of different resolutions and represen-
tations. any algorithm that attempts to retrieve and process the variety and amount
of content within or across games is directly faced with the challenges of interoper-
ability and content convergence as well as scalability caused by such big data sets.

12 http://www.igf.com/

20

chapter 1. introduction

compare this with a typical robot simulator, where all the environments would
have to be painstakingly hand-crafted or adapted from data collected from the real
world. when using games as testbeds, there is no such content shortage.

1.3.3.2 popular means more data

massive content creation (either by games or players) is one major effect of games   
popularity; the other is massive data generation of game playthroughs and player
behavior. since the late 2000s, game companies have had access to accurate game
telemetry services that allow them to track and monitor player purchases, churn and
re-engagement, or the progress of play for debugging either the game or the play-
ers    experience. the algorithmic challenges met here follow the general challenges
of big data and big data mining research [445], which include data    ltering during
data acquisition, metadata generation, information extraction from erroneous and
missing data, automatic data analysis across dissimilar datasets, appropriate declar-
ative query and mining interfaces, scalable mining algorithms, and data visualiza-
tion [359]. luckily enough some of these datasets are nowadays openly available
for game analytics and game data mining research. indicatively, in march 2017, the
opendota project13   a community-maintained open source dota 2 data platform   
released a sanitized archive of over a billion matches (!) of dota 2 (valve corpora-
tion, 2013) that were played between march 2011 and march 2016.14

1.3.4 there are challenges for all ai areas

unlike some more narrow benchmarks, games challenge all core areas of ai. this
can be seen by taking a number of broadly accepted areas of ai and discussing the
challenges available for those areas in games. signal processing, for starters, meets
great challenges in games. data from players, for instance, not only come in dif-
ferent resolutions   in-game events vs. head pose vs. the player   s physiology   they
also originate from multiple modalities of fast-paced interaction in an environment
that elicits complex cognitive and affective patterns to the player. multi-modal in-
teraction and multi-modal fusion are non-trivial problems when building embodied
conversational agents and virtual characters. further, the complexity of the signal
processing task in games is augmented due to the spatio-temporal nature of the sig-
nals which is caused by the rich and fast-paced interaction with the game.

as discussed in the introductory section of this chapter checkers, chess, jeop-
ardy!, go and arcade games mark a historical trace of core major milestones for ma-
chine learning (go and arcade games), tree search (checkers and chess), knowl-
edge representation and reasoning (jeopardy!) and natural language processing

13 https://www.opendota.com/
14 https://blog.opendota.com/2017/03/24/datadump2/

1.3. why games for arti   cial intelligence

21

(jeopardy!, kinect games) and, in turn, they resulted in major breakthroughs for ai.
this historical association between ai accomplishments and games already pro-
vides clear evidence that all the above areas have traditionally been challenged by
games. while the full potential of machine learning remains to be discovered in
games such as starcraft ii (blizzard entertainment, 2010), natural language pro-
cessing (nlp) has been challenged deeply through games involving narrative and
natural language input. nlp is challenged even further in game environments that
wish to realize forms of interactive storytelling [148].

finally when it comes to planning and navigation, games have traditionally
offered environments of high and increasing complexity for algorithms to be tested
in. while games such as starcraft clearly de   ne major milestones for planning
algorithms, navigation and path   nding have reached a certain degree of maturity
through simulated and roborealistic game environments featuring multiple entities
(agents). an additional bene   t of games as a domain for behavioral planning is that
they offer a realistic yet a far more convenient and cheaper testbed compared to
robotics. beyond the extensive testing and advancement of variants of a* through
games, popular and highly effective tree search variants such as the monte carlo
tree search [77] algorithm have been invented in response to problems posed by
game-playing.

1.3.5 games best realize long-term goals of ai

one of the long-standing questions that ai is faced with is what is the ultimate
long-term goal for ai? while numerous debates and books have been dedicated to
this topic, the collaborative effort of wikipedia authors addressing this question15
reveals the areas of social intelligence and affective interaction, (computational)
creativity, and general intelligence as the most critical long-term goals of ai. our
reference has been critiqued for systemic bias (in any controversial question such as
the one above); we argue, however, that any reference on this topic would be sub-
jective anyhow. without aiming to be exclusive or biased, we believe that the three
aforementioned areas collectively contribute to better ai systems and we discuss
why games best realize these three goals below. these three long-term goals de   ne
frontier research areas for game ai and are further elaborated on in the last chapter
of this book.

1.3.5.1 social and emotional intelligence

affective computing [530] is the multidisciplinary area of study across computer
science, cognitive science and psychology that investigates the design and develop-
ment of intelligent software that is able to elicit, detect, model, and express emotion

15 wikipedia (accessed: may 2017): https://en.wikipedia.org/wiki/arti   cial intelligence

22

chapter 1. introduction

and social intelligence. the ultimate aim of affective computing is the realization of
the so-called affective loop [670] which, as we covered earlier, de   nes a system that
is able to successfully elicit, detect and respond to the emotions of its user. natu-
rally, both emotive and social aspects of intelligence are relevant for a system that
realizes the affective loop.

games can offer a highly meaningful realization of the affective loop and af-
fective interaction [781]. games are by de   nition both entertaining (whether used
for pure satisfaction, training or education) and interactive activities that are played
within fantasy worlds. thus, any limitations of affective interaction   such as the
dif   culty to justify affective-based game decisions or alterations of content to the
user   are absorbed naturally. for example, an erroneous affective response of a
game character can still be justi   ed if the design of the character and the game con-
text do not break the suspension of disbelief of the player   during which the player
ignores the medium and the interaction for the sake of her enjoyment. further, games
are designed to offer affective experiences which are in   uenced by player feed-
back and players are willing to go through, e.g., frustrating, anxious, and fearful
episodes of play for experiencing involvement. to that end, a user under gaming
conditions   more than any other form of human-computer interaction   is gener-
ally open to affective-based alterations of the interaction and in   uences of his/her
emotional state.

1.3.5.2 computational creativity

computational creativity studies the potential of software to autonomously generate
outcomes that can be considered creative or algorithmic processes that are deemed
to be creative [54, 754]. computer games can be viewed as the killer application
domain for computational creativity [381]. it is not only their unique features that
we covered in earlier sections of this chapter   i.e., being highly interactive, dynamic
and content-intensive software applications. most importantly it is their multifaceted
nature. in particular, it is the fusion of the numerous and highly diverse creative
domains   visual art, sound design, graphic design, interaction design, narrative,
virtual cinematography, aesthetics and environment beauti   cation   within a single
software application that makes games the ideal arena for the study of computational
creativity. it is also important to note that each art form (or facet) met in games elicits
different experiences to its users; their fusion in the    nal software targeting a rather
large and diverse audience is an additional challenge for computational creativity.

as a result, the study of computational creativity within and for computer games
[381] advances in both the    eld of ai and the domain of games. games can,    rst, be
improved as products via computational creations (for) and/or, second, be used as
the ultimate canvas for the study of computational creativity as a process (within).
computer games not only challenge computational creativity but they also provide a
creative sandbox for advancing the    eld. finally, games can offer an opportunity for
computational creativity methods to be extensively assessed via a huge population
of users of commercial-standard products of high impact and    nancial value.

1.4. why arti   cial intelligence for games

23

1.3.5.3 general intelligence

ai has investigated the general intelligence capacity of machines within the domain
of games more than any other domain thanks to the ideal properties of games for
that purpose: controlled yet interesting and computationally hard problems [598].
in particular, the capacity of ai to play unseen games well   i.e., general game
playing   has seen a number of advancements in recent years. starting with the
general game playing competition [223], focusing on board games and similar dis-
crete perfect information games, we now also have the arcade learning environ-
ment [40] and the general video game ai competition [528], which offer radically
different takes on arcade video games. advancements vary from the efforts to cre-
ate game description languages suitable for describing games used for general game
playing [533, 223, 400, 691, 354, 596, 181, 429] to the establishment of a set of
general video game ai benchmarks [223, 528, 40] to the recent success of deep q-
learning in playing arcade games with human-level performance just by processing
the screen   s pixels [464].

while general game playing is studied extensively and constitutes one of the key
areas of game ai [785], we argue that the focus of generality solely with regard to
the performance of game-playing agents is very narrow with respect to the spectrum
of roles for general intelligence in games. the types of general intelligence required
within game development include game and level design as well as player behavior
and experience modeling. such skills touch upon a diverse set of cognitive and
affective processes which have until now been ignored by general ai in games.
for general game ai to be truly general and advance ai algorithmically, it needs
to go beyond game playing while retaining the focus on addressing more than a
single game or player [718]. we further argue that the challenge of bringing together
different types of skillsets and forms of intelligence within autonomous designers
of games cannot only advance our knowledge about human intelligence but also
advance the capacity of general arti   cial intelligence.

1.4 why arti   cial intelligence for games

the various uses of ai in games are bene   cial for the design of better games for a
number of reasons. in this section we focus on the bene   ts obtained by allowing ai
to play a game, to generate content and to analyze player experience and behavior.

1.4.1 ai plays and improves your game

ai can improve games in several ways by merely playing them. the game industry
usually receives praise for the ai of their games   in particular, the non-player or
opponent ai   when the ai of the game adds to the commercial value of the game,

24

chapter 1. introduction

it contributes to better game reviews, and it enhances the experience of the player.
whether the underlying ai is based on a simple behavior tree, a utility-based ai
or alternatively on a sophisticated machine learned reactive controller is of limited
relevance as long as it serves the aforementioned purposes. an unconventional and
effective solution to an npc task can often be a critical factor that shapes manage-
ment, marketing and monetization strategies during and after production.

as we will see in chapter 3, ai plays games with two core objectives in mind:
play well and/or play believably (or human-like, or interestingly). further ai can
control either the player character or the non-player character of the game. ai that
plays well as a player character focuses on optimizing the performance of play   
performance is measured as the degree to which a player meets the objectives of
the game solely. such ai can be of tremendous importance for automatic game
testing and for the evaluation of the game design as a whole. ai that plays well
as a non-player character, instead, can empower dynamic dif   culty adjustment and
automatic game balancing mechanisms that will in turn personalize and enhance the
experience for the player (as in [651] among many). if the focus of ai is shifted on
controlling player characters that play believably or human-like (as in [96, 719, 264]
among many) then ai can serve as means for player experience debugging or as
demonstration of realistic play for design purposes. finally, a game that features a
rich interaction with npcs can only bene   t from ai that controls npcs which are
expressive and depict human-like and believable behaviors (as in [563, 683, 762]
among many).

1.4.2 more content, better content

there are several reasons for game designers and developers to be interested in
ai and, in particular, in content generation as covered in detail in chapter 4. the
   rst and most historical reason is memory consumption. content can typically
be compressed by keeping it    unexpanded    until needed. a good example is the
classic space trading and adventure game elite (acornsoft, 1984), which managed
to keep hundreds of star systems in a few tens of kilobytes of memory available
on the hardware. further, content generation might foster or further inspire human
creativity and allow the emergence of completely new types of games, game genres
or entirely new spaces of exploration and artistic expression [381]. moreover, if
new content can be generated with suf   cient variety, quality and quantity, then it
may become possible to create truly endless games with ultimate replay value.
finally, when content generation is associated with aspects of play we can expect
personalized and adaptive play to emerge via the modi   cation of content.

unlike other areas of game ai   such as general game playing which might be
considered more of an academic pursuit   content generation is a commercial ne-
cessity [381]. prior to the academic interest in content generation   which is rather
recent [704, 720, 616]   content generation systems had a long history of supporting
commercial standard games for creating engaging yet unpredictable game experi-

1.5. structure of this book

25

ences but, most importantly, lessening the burden of manual game content creation.
naturally, games that feature sophisticated content generation systems can garner
praise for their technologies   as in diablo iii (blizzard, 2012)   or even build
an entire marketing campaign on content generation   like no man   s sky (hello
games, 2016).

1.4.3 player experience and behavioral data analytics

the use of ai for the understanding of player experience can drive and enhance
the design process of games. game designers usually explore and test a palette of
mechanics and game dynamics that yield experience patterns they desire to put the
player through. player states such as engagement, fear and stress, frustration, an-
ticipation, and challenge de   ne critical aspects of the design of player experience,
which is dependent on the genre, the narrative and the objectives of the game. as a
result, the holy grail of game design   that is player experience   can be improved
and tailored to each player but also augmented via richer experience-based interac-
tion. further, as a direct consequence of better and faster design, the whole game
development process is boosted and improved.

beyond the experience of the player, data derived from games, their use and their
players provide a new and complementary way of designing games, of making man-
agerial and marketing decisions about games, of affecting the game production, and
of offering a better customer service [178]. any ai-informed decisions about the
future of a game   s design or development are based on evidence rather than intu-
ition, which showcases the potential of ai   via game analytics and game data min-
ing   for better design, development and quality assurance procedures. in summary,
as we will see in the remaining chapters of this book, ai-enabled and data-driven
game design can directly contribute to better games.

1.5 structure of this book

we structured this book into three main parts. in the    rst part (chapter 2) we outline
the core game ai methods that are important for the study of ai in and for games.
in the second part of the book we ask the question: how can ai be used in games?
answers to this question de   ne the main game ai areas identi   ed and covered as
corresponding chapters:
    ai can play games (chapter 3).
    ai can generate content (chapter 4).
    ai can model players (chapter 5).

in the    nal part of the book, we attempt a synthesis of the game ai areas that
make up this    eld and discuss the research trends in what we envisage as the game

26

chapter 1. introduction

fig. 1.2 illustrating the associations among the chapters of this book. light gray, blue and red
areas represent chapters of part i, part ii, and part iii of the book, respectively.

ai panorama (chapter 6). building on this synthesis, we conclude the book with a
chapter dedicated to the research areas we view as largely unexplored and important
for the study of game ai, namely frontier game ai research areas (chapter 7). an
illustration of how the different chapters    t together in this book is presented in
fig. 1.2. the readers of this book may wish to skip parts that are not of interest or
not appropriate given their background. for instance, readers with a background in
arti   cial intelligence may wish to skip the    rst part, while readers who wish to get a
rapid overview of the game ai    eld or a glimpse of frontier research trends in game
ai can solely focus on the    nal part of the book.

1.5.1 what we (don   t) cover in this book

the list of core uses of ai in games identi   ed in this book should not be regarded
as complete and inclusive of all potential areas of game ai research. it could also be
argued that the list of areas we cover is arbitrary. however, this could likely be said
of any research    eld in any discipline. (in software engineering, software design
overlaps with software requirements analysis, and in cognitive psychology, memory
research overlaps with attention research.) while it might be possible to perform an
analysis of this research    eld so that the individual areas have minimal or no overlap,
this would likely lead to a list of arti   cial areas that do not correspond to the areas
game ai students, researchers and practitioners perceive themselves to be working
in. it could also be argued that we are omitting certain areas. for example, we only
brie   y discuss the topic of path   nding in games, whereas some other authors see

1.5. structure of this book

27

this as a core concern of game ai. in our view, path   nding is a relatively isolated
area with restricted interaction with the other uses of ai in games. further, path   nd-
ing has been covered substantially in other game ai textbooks [109, 461, 62] al-
ready. another example is the area of computational narrative, which is viewed
as a domain for content generation and covered only relatively brie   y in chapter 4.
it would certainly be possible to write a whole textbook about computational nar-
rative, but that would be someone else   s job. beyond particular application areas of
game ai, in chapter 2 we cover a number of popular methods used in the    eld. the
list of methods is not inclusive of all ai areas that can    nd application in games; it
is a list, however, we consider suf   cient for covering the theoretical foundations of
a graduate game ai course. in that regard, we only partially cover planning meth-
ods and probabilistic methods such as bayesian approaches and methods based on
markov chains, respectively, in chapter 2 and chapter 4.

another important note is the relationship of this book with the general areas of
game theory [214, 472, 513] and other related research ai areas such as multia-
gent systems [626]. game theory studies mathematical models of rational decision
makers within abstract games, for the analysis of economic or social behavior in ad-
versarial [471] or cooperative [108] settings. more speci   cally, game theory focuses
on characterizing or predicting the actions of rational or bounded-rational agents,
and studies the related emerging    game solution concepts      such as the celebrated
nash equilibrium [478]. while the book does not cover these areas in detail, as they
are peripheral to the aims of game ai as currently envisioned, we nevertheless be-
lieve that it would be fruitful to incorporate foundational ideas and concepts from
game theory and multiagent systems research in the game ai    eld. particular game
ai areas such as game-playing and player (or opponent) modeling [214] could ben-
e   t from theoretical models of game-playing [214] and empirical implementations
of agent-based systems. similarly, we believe that game ai research and practice
can only help in advancing work on theoretical game theory and multiagent sys-
tems. of course, interweaving these    elds properly with the current stream of game
ai research is a non-trivial exercise, given the different focus and paths these    elds
have taken. further, there are limits to the degrees theoretical models can capture
the complexity of games covered in game ai. however, game theory undeniably
constitutes a key theoretical pillar for the study of rational decision making, and
rational decision making is arguably key for winning in games. some instances of
economic game theory that found successful applications in game ai include the
various implementations of theoretical models for playing abstract, card and board
games   notably a version of poker was used as a testbed of game theory by von
neumann and morgenstern [743] as far back as 1944 [406]. some of these im-
plementations are discussed in chapter 3. another example that bridged rational
decision making theory with game ai is the procedural personas approach covered
in chapter 5.

finally, note that this book is the effort of two authors with a high degree of
consensus among them and not an edited volume of several authors. as such, it
contains subjective views on how the game ai    eld is positioned within the greater

28

chapter 1. introduction

ai research scene and how the game ai areas are synthesized. your mileage may
vary.

1.6 summary

ai has a long-standing and healthy relationship with games. ai algorithms have
been advanced or even invented through games. games, their design and develop-
ment, in turn, have bene   ted largely by the numerous roles ai has taken in games.
this book focuses on the main uses of ai in games, namely, for playing games, for
generating content, and for modeling players, which are covered extensively in the
following chapters. before delving into the details of these ai uses, in the next chap-
ter we outline the core methods and algorithms used in the    eld of game arti   cial
intelligence.

chapter 2
ai methods

this chapter presents a number of basic ai methods that are commonly used in
games, and which will be discussed and referred to in the remainder of this book.
these are methods that are frequently covered in introductory ai courses   if you
have taken such a course, it should have exposed you to at least half of the methods
in this chapter. it should also have prepared you for easily understanding the other
methods covered in this chapter.

as noted previously, this book assumes that the reader is already familiar with
core ai methods at the level of an introductory university course in ai. therefore,
we recommend you to make sure that you are at least cursorily familiar with the
methods presented in this chapter before proceeding to read the rest of the book. the
algorithm descriptions in this chapter are high-level descriptions meant to refresh
your memory if you have learned about the particular algorithm at some previous
point, or to explain the general idea of the algorithm if you have never seen it before.
each section comes with pointers to the literature, either research papers or other
textbooks, where you can    nd more details about each method.

in this chapter we divide the relevant parts of ai (for the purposes of the book)
into six categories: ad-hoc authoring, tree search, evolutionary computation, super-
vised learning, id23 and unsupervised learning. in each section
we discuss some of the main algorithms in general terms, and give suggestions for
further reading. throughout the chapter we use the game of ms pac-man (namco,
1982) (or ms pac-man for simplicity) as an overarching testbed for all the algo-
rithms we cover. for the sake of consistency, all the methods we cover are employed
to control ms pac-man   s behavior even though they can    nd a multitude of other
uses in this game (e.g., generating content or analyzing player behavior). while
a number of other games could have been used as our testbed in this chapter, we
picked ms pac-man for its popularity and its game design simplicity as well as for
its high complexity when it comes to playing the game. it is important to remember
that ms pac-man is a non-deterministic variant of its ancestor pac-man (namco,
1980) which implies that the movements of ghosts involve a degree of randomness.
in section 2.1, we go through a quick overview of two key overarching compo-
nents of all methods in this book: representation and utility. behavior authoring,

29

30

chapter 2. ai methods

covered in section 2.2, refers to methods employing static ad-hoc representations
without any form of search or learning such as    nite state machines, behavior trees
and utility-based ai. tree search, covered in section 2.3, refers to methods that
search the space of future actions and build trees of possible action sequences, often
in an adversarial setting; this includes the minimax algorithm, and monte carlo tree
search. covered in section 2.4, evolutionary computation refers to population-
based global stochastic optimization algorithms such as id107, or evo-
lution strategies. supervised learning (see section 2.5) refers to learning a model
that maps instances of datasets to target values such as classes; target values are
necessary for supervised learning. common algorithms used here are backpropaga-
tion (arti   cial neural networks), support vector machines, and decision tree learning.
id23 is covered in section 2.6 and refers to methods that solve
id23 problems, where a sequence of actions is associated with
positive or negative rewards, but not with a    target value    (the correct action). the
paradigmatic algorithm here is temporal difference (td) learning and its popular in-
stantiation id24. section 5.6.3 outlines unsupervised learning which refers
to algorithms that    nd patterns (e.g., clusters) in datasets that do not have target
values. this includes id91 methods such as id116, hierarchical id91
and self-organizing maps as well as frequent pattern mining methods such as apri-
ori and generalized sequential patterns. the chapter concludes with a number of
notable algorithms that combine elements of the algorithms above to yield hybrid
methods. in particular we cover neuroevolution and td learning with ann function
approximation as the most popular hybrid algorithms used in the    eld of game ai.

2.1 general notes

before detailing each of the algorithm types we outline two overarching elements
that bind together all the ai methods covered in this book. the former is the algo-
rithm   s representation; the second is its utility. on the one hand, any ai algorithm
somehow stores and maintains knowledge obtained about a particular task at hand.
on the other hand, most ai algorithms seek to    nd better representations of knowl-
edge. this seeking process is driven by a utility function of some form. we should
note that the utility is of no use solely in methods that employ static knowledge
representations such as    nite state machines or behavior trees.

2.1.1 representation

appropriately representing knowledge is a key challenge for arti   cial intelligence
at large and it is motivated by the capacity of the human brain to store and retrieve
obtained knowledge about the world. the key questions that drive the design of
representations for ai are as follows. how do people represent knowledge and how

2.1. general notes

31

can ai potentially mimic that capacity? what is the nature of knowledge? how
generic can a representation scheme be? general answers to the above questions,
however, are far from trivial at this point.

as a response to the open general questions regarding knowledge and its repre-
sentation, ai has identi   ed numerous and very speci   c ways to store and retrieve
information which is authored, obtained, or learned. the representation of knowl-
edge about a task or a problem can be viewed as the computational mapping of the
task under investigation. on that basis, the representation needs to store knowledge
about the task in a format that a machine is able to process, such as a data structure.
to enable any form of arti   cial intelligence knowledge needs to be represented
computationally and the ways this can happen are many. representation types in-
clude grammars such as grammatical evolution, graphs such as    nite state ma-
chines or probabilistic models, trees such as id90, behavior trees and ge-
netic programming, connectionism such as arti   cial neural networks, genetic such
as id107 and evolutionary strategies and tabular such as temporal dif-
ference learning and id24. as we will see in the remainder of this book, all
above representation types    nd dissimilar uses in games and can be associated with
various game ai tasks.

one thing is certain for any ai algorithm that is tried on a particular task: the
chosen representation has a major impact on the performance of the algorithm. un-
fortunately, the type of representation to be chosen for a task follows the no free
lunch theorem [756], suggesting that there is no single representation type which
is ideal for the task at hand. as a general set of guidelines, however, the repre-
sentation chosen should be as simple as possible. simplicity usually comes as a
delicate balance between computational effort and algorithm performance as either
being over-detailed or over-simplistic will affect the performance of the algorithm.
furthermore, the representation chosen should be as small as possible given the
complexity of the task at hand. neither simplicity nor size are trivial decisions to
make with respect to the representation. good representations come with suf   cient
practical wisdom and empirical knowledge about the complexity and the qualitative
features of the problem the ai is trying to solve.

2.1.2 utility

utility in game theory (and economics at large) is a measure of rational choice
when playing a game. in general, it can be viewed as a function that is able to assist
a search algorithm to decide which path to take. for that purpose, the utility function
samples aspects of the search space and gathers information about the    goodness   
of areas in the space. in a sense, a utility function is an approximation of the so-
lution we try to    nd. in other words, it is a measure of goodness of the existing
representation we search through.

similar concepts to the utility include the heuristic used by computer science
and ai as an approximate way to solve a problem faster when exact methods are too

32

chapter 2. ai methods

slow to afford, in particular associated with the tree search paradigm. the concept
of    tness is used similarly as a utility function that measures the degree to which a
solution is good, primarily, in the area of evolutionary computation. in mathematical
optimization, the objective, loss, cost, or error function is the utility function to be
minimized (or maximized if that is the objective). in particular, in supervised learn-
ing the error function represents how well an approach maps training examples to
target (desired) outputs. in the area of id23 and markov decision
processes instead, the utility is named reward, which is a function an agent attempts
to maximize by learning to take the right action in a particular state. finally, in the
area of unsupervised learning utility is often provided internally and within the
representation via e.g., competitive learning or self-organization.

similarly to selecting an appropriate representation, the selection of a utility
function follows the no free lunch theorem. a utility is generally dif   cult to de-
sign and sometimes the design task is basically impossible. the simplicity of its de-
sign pays off, but the completeness as well. the quality of a utility function largely
depends on thorough empirical research and practical experience, which is gained
within the domain under investigation.

2.1.3 learning = maximize utility (representation)

the utility function is the drive for search and essential for learning. on that basis,
the utility function is the training signal of any machine learning algorithm as it
offers a measure of goodness of the representation we have. thereby it implicitly
provides indications on what to do to further increase the current goodness of the
presentation. systems that do not require learning (such as ai methods that are based
on ad-hoc designed representations; or expert-knowledge systems) do not require a
utility. in supervised learning the utility is sampled from data   i.e., good input-
output patterns. in id23 and evolutionary computation, instead,
the training signal is provided by the environment   i.e., rewards for doing some-
thing well and punishments for doing something wrong. finally, in unsupervised
learning the training signal derives from the internal structure of the representation.

2.2 ad-hoc behavior authoring

in this section we discuss the    rst, and arguably the most popular, class of ai
methods for game development. finite state machines, behavior trees and utility-
based ai are ad-hoc behavior authoring methods that have traditionally dominated
the control of non-player characters in games. their dominance is evident by the fact
that the term game ai in the game development scene is still nowadays synonymous
with the use of these methods.

2.2. ad-hoc behavior authoring

2.2.1 finite state machines

33

a finite state machine (id122) [230]   and id122 variants such as hierarchical
id122s   is the game ai method that dominated the control and decision making
processes of non-player characters in games up until the mid-2000s.

id122s belong to the expert-knowledge systems area and are represented as
graphs. an id122 graph is an abstract representation of an interconnected set of ob-
jects, symbols, events, actions or properties of the phenomenon that needs to be ad-
hoc designed (represented). in particular, the graph contains nodes (states) which
embed some mathematical abstraction and edges (transitions) which represent a
conditional relationship between the nodes. the id122 can only be in one state at
a time; the current state can change to another if the condition in the corresponding
transition is ful   lled. in a nutshell, an id122 is de   ned by three main components:
    a number of states which store information about a task   e.g., you are currently
    a number of transitions between states which indicate a state change and are
described by a condition that needs to be ful   lled   e.g., if you hear a    re shot,
move to the alerted state.
    a set of actions that need to be followed within each state   e.g., while in the

on the explore state.

explore state move randomly and seek opponents.

id122s are incredibly simple to design, implement, visualize, and debug. further
they have proven they work well with games over the years of their co-existence.
however, they can be extremely complex to design on a large scale and are, thereby,
computationally limited to certain tasks within game ai. an additional critical lim-
itation of id122s (and all ad-hoc authoring methods) is that they are not    exible and
dynamic (unless purposely designed). after their design is completed, tested and
debugged there is limited room for adaptivity and evolution. as a result, id122s end
up depicting very predictable behaviors in games. we can, in part, overcome such a
drawback by representing transitions as fuzzy rules [532] or probabilities [109].

2.2.1.1 an id122 for ms pac-man

in this section we showcase id122s as employed to control the ms pac-man agent.
a hypothetical and simpli   ed id122 controller for ms pac-man is illustrated in fig.
2.1. in this example our id122 has three states (seek pellets, chase ghosts and evade
ghosts) and four transitions (ghosts    ashing, no visible ghost, ghost in sight, and
power pill eaten). while in the seek pellets state, ms pac-man moves randomly
up until it detects a pellet and then follows a path   nding algorithm to eat as many
pellets as possible and as soon as possible. if a power pill is eaten, then ms pac-
man moves to the chase ghosts state in which it can use any tree-search algorithm
to chase the blue ghosts. when the ghosts start    ashing, ms pac-man moves to the
evade ghosts state in which it uses tree search to evade ghosts so that none is visible

34

chapter 2. ai methods

fig. 2.1 a high-level and simpli   ed id122 example for controlling ms pac-man.

within a distance; when that happens ms pac-man moves back to the seek pellets
state.

2.2.2 behavior trees

a behavior tree (bt) [110, 112, 111] is an expert-knowledge system which, simi-
larly to an id122, models transitions between a    nite set of tasks (or behaviors). the
strength of bts compared to id122s is their modularity: if designed well, they can
yield complex behaviors composed of simple tasks. the main difference between
bt and id122s (or even hierarchical id122s) is that they are composed of behaviors
rather than states. as with    nite state machines, bts are easy to design, test and
debug, which made them dominant in the game development scene after their suc-
cessful application in games such as halo 2 (microsoft game studios, 2004) [291]
and bioshock (2k games, 2007).

bt employs a tree structure with a root node and a number of parent and cor-
responding child nodes representing behaviors   see fig. 2.2 for an example. we
traverse a bt starting from the root. we then activate the execution of parent-child
pairs as denoted in the tree. a child may return the following values to the parent
in predetermined time steps (ticks): run if the behavior is still active, success if the

2.2. ad-hoc behavior authoring

35

behavior is completed, failure if the behavior failed. bts are composed of three
node types: the sequence, the selector, and the decorator the basic functionality of
which is described below:
    sequence (see blue rectangle in fig. 2.2): if the child behavior succeeds, the
sequence continues and eventually the parent node succeeds if all child behaviors
succeed; otherwise the sequence fails.
    selector (see red rounded rectangle in fig. 2.2): there are two main types of
selector nodes: the id203 and the priority selectors. when a id203 se-
lector is used child behaviors are selected based on parent-child probabilities set
by the bt designer. on the other hand if priority selectors are used, child behav-
iors are ordered in a list and tried one after the other. regardless of the selector
type used, if the child behavior succeeds the selector succeeds. if the child be-
havior fails, the next child in the order is selected (in priority selectors) or the
selector fails (in id203 selectors).
    decorator (see purple hexagon in fig. 2.2): the decorator node adds complex-
ity to and enhances the capacity of a single child behavior. decorator examples
include the number of times a child behavior runs or the time given to a child
behavior to complete the task.
compared to id122, bts are more    exible to design and easier to test; they still
however suffer from similar drawbacks. in particular, their dynamicity is rather low
given that they are static id99s. the id203 selector nodes
may add to their unpredictability and methods to adapt their tree structures have
already shown some promise [385]. there is also a certain degree of similarity be-
tween bts and abl (a behavior language) [440] introduced by mateas and stern
for story-based believable characters; their dissimilarities have also been reported
[749]. note however that this section barely scratches the surface of what is possi-
ble with bt design as there are several extensions to their basic structure that help
bts improve on their modularity and their capacity to deal with more complex be-
havior designs [170, 627].

2.2.2.1 a bt for ms pac-man

similarly to the id122 example above we use ms pac-man to demonstrate the use
of bts in a popular game. in fig. 2.3 we illustrate a simple bt for the seek pellets
behavior of ms pac-man. while in the seek pellets sequence behavior ms pac-man
will    rst move (selector), it will then    nd a pellet and    nally it will keep eating
pellets until a ghost is found in sight (decorator). while in the move behavior   
which is a priority selector   ms pac-man will prioritize ghost-free corridors over
corridors with pellets and over corridors without pellets.

36

chapter 2. ai methods

fig. 2.2 a behavior tree example. the root of the bt is a sequence behavior (attack enemy) which
executes the child behaviors spot enemy, select weapon, aim and shoot in sequence from left to
right. the select weapon behavior is a id203 selector giving higher id203   denoted by
the thickness of the parent-child connecting lines   to the mini gun (0.5) compared to the rocket
launcher (0.3) or the pistol (0.2). once in the shoot behavior the decorator until health = 0 requests
the behavior to run until the enemy dies.

fig. 2.3 a bt example for the seek pellets behavior of ms pac-man.

2.2. ad-hoc behavior authoring

2.2.3 utility-based ai

37

as has been pointed out by several industrial game ai developers the lack of behav-
ioral modularity across games and in-game tasks is detrimental for the development
of high quality ai [605, 171]. an increasingly popular method for ad-hoc behav-
ior authoring that eliminates the modularity limitations of id122s and bts is the
utility-based ai approach which can be used for the design of control and deci-
sion making systems in games [425, 557]. following this approach, instances in the
game get assigned a particular utility function that gives a value for the importance
of the particular instance [10, 169]. for instance, the importance of an enemy being
present at a particular distance or the importance of an agent   s health being low in
this particular context. given the set of all utilities available to an agent and all the
options it has, utility-based ai decides which is the most important option it should
consider at this moment [426]. the utility-based approach is grounded in the utility
theory of economics and is based on utility function design. the approach is similar
to the design of membership functions in a fuzzy set.

a utility can measure anything from observable objective data (e.g., enemy
health) to subjective notions such as emotions, mood and threat. the various utili-
ties about possible actions or decisions can be aggregated into linear or non-linear
formulas and guide the agent to take decisions based on the aggregated utility. the
utility values can be checked every n frames of the game. so while id122s and bts
would examine one decision at a time, utility-based ai architectures examine all
available options, assign a utility to them and select the option that is most appro-
priate (highest utility).

as an example of utility-based ai we will build on the one appearing in [426] for
weapon selection. for selecting a weapon an agent needs to consider the following
aspects: range, inertia, random noise, ammo and indoors. the range utility function
adds value to the utility of a weapon depending on the distance   for instance, if
the distance is short, pistols are assigned higher utility. inertia assigns higher utility
value to the current weapon so that changes of weapons are not very frequent. ran-
dom noise adds non-determinism to the selection so that the agent does not always
pick the same weapon given the same game situation. ammo returns a utility about
the current level of ammunition and indoors penalizes the use of particular weapons
indoors such as a grenade through a boolean utility function (e.g., 0 utility value if
the grenade is used indoors; 1 otherwise). our agent makes a regular check of the
available weapons, assigns utility scores to all of them and selects the weapon with
the best total utility.

utility-based ai has certain advantages compared to other ad-hoc authoring tech-
niques. it is modular as the decision of the game agent is dependent on a number
of different factors (or considerations); this list of factors can be dynamic. utility-
based ai is also extensible as we can easily author new types of considerations as
we see them    t. finally, the method is reusable as utility components can be trans-
fered from one decision to another and from a game to another game. as a result of
these advantages utility-based ai is gradually getting traction in the game industry
scene [557, 171]. utility-based ai has seen a widespread use across game genres

38

chapter 2. ai methods

fig. 2.4 a utility-based approach for controlling ms pac-man behavior. the threat level (x-axis) is
a function that lies between 0 and 1 which is based on the current position of ghosts. ms pac-man
considers the current level of threat, assigns utility values (through the three different curves) and
decides to follow the behavior with the highest utility value. in this example the utility of ghost
evading rises exponentially with the level of threat. the utility of ghost hunting decreases linearly
with respect to threat up to a point where it stabilizes; it then decreases linearly as the threat level
increases above a threshold value. finally, the utility of pellet seeking increases linearly up to
considerable threat level from which point it decreases exponentially.

and has been featured, among others, in kohan 2: kings of war (take two inter-
active and global star software, 2004), in iron man (sega, 2008) for controlling
the boss, in red dead redemption (rockstar games, 2010) for weapon and dialog
selection, and in killzone 2 (sony computer entertainment, 2009) and in f.e.a.r.
(sierra entertainment, 2005) for dynamic tactical decision making [426].

2.2.3.1 utility-based ai for ms pac-man

once again we use ms pac-man to demonstrate the use of utility-based ai. figure
2.4 illustrates an example of three simple utility functions that could be considered
by ms pac-man during play. each function corresponds to a different behavior that
is dependent on the current threat level of the game; threat is, in turn, a function of
current ghost positions. at any point in the game ms pac-man selects the behavior
with the highest utility value.

2.2.3.2 a short note on ad-hoc behavior authoring

it is important to remember that all three methods covered in this section (and, in
general, the methods covered in this chapter) represent the very basic variants of the
algorithms. as a result, the algorithms we covered appear as static representations

2.3. tree search

39

of states, behaviors or utility functions. it is possible, however, to create dynamic
variants of those by adding non-deterministic or fuzzy elements; for instance, one
may employ fuzzy transitions in an id122 or evolve behaviors in a bt. further, it
is important to note that these ad-hoc designed architectures can feature any of the
methods this book covers in the remainder of this chapter. basic processing elements
such as an id122 state, a bt behavior or a utility function or even more complex
hierarchies of nodes, trees or functions can be replaced by any other ai method
yielding hybrid algorithms and agent architectures. note that possible extensions of
the algorithms can be found in the work we cite in the corresponding section of each
algorithm but also in the reading list we provide next.

2.2.4 further reading

further details on how to build and test id122s and hierarchical id122s can be found
in [367]. for behavior trees we recommend the online tutorials and blogposts of
a. champandard found at the http://aigamedev.com/ portal [110, 111] and recent
adaptations of the basic behavior tree structure as in [627]. finally, the book of
dave mark [425] is a good starting point for the study of utility-based ai and its
application to control and decision making in games.

when it comes to software, a bt tool has been integrated within the unreal en-
gine1 while several other bt unity tools2 are available for the interested reader.
further, the behave system3 streamlines the iterative process of designing, integrat-
ing and debugging behavior trees and utility-based ai.

2.3 tree search

it has been largely claimed that most, if not all, of arti   cial intelligence is really just
search. almost every ai problem can be cast as a search problem, which can be
solved by    nding the best (according to some measure) plan, path, model, function,
etc. search algorithms are therefore often seen as being at the core of ai, to the
point that many textbooks (such as russell and norvig   s famous textbook [582])
start with a treatment of search algorithms.

the algorithms presented below can all be characterized as tree search algo-
rithms as they can be seen as building a search tree where the root is the node
representing the state where the search starts. edges in this tree represent actions
the agent takes to get from one state to another, and nodes represent states. because
there are typically several different actions that can be taken in a given state, the tree

1 https://docs.unrealengine.com/latest/int/engine/
2 for instance, see http://nodecanvas.paradoxnotion.com/ or http://www.opsive.com/.
3 http://eej.dk/community/documentation/behave/0-introduction.html

40

chapter 2. ai methods

branches. tree search algorithms mainly differ in which branches are explored and
in what order.

2.3.1 uninformed search

uninformed search algorithms are algorithms which search a state space without
any further information about the goal. the basic uninformed search algorithms are
commonly seen as fundamental computer science algorithms, and are sometimes
not even seen as ai.

depth-   rst search is a search algorithm which explores each branch as far as
possible before backtracking and trying another branch. at every iteration of its
main loop, depth-   rst search selects a branch and then moves on to explore the
resulting node in the next iteration. when a terminal node is reached   one from
which it is not possible to advance further   depth-   rst search advances up the list
of visited nodes until it    nds one which has unexplored actions. when used for
playing a game, depth-   rst search explores the consequences of a single move until
the game is won or lost, and then goes on to explore the consequences of taking a
different move close to the end states.

breadth-   rst search does the opposite of depth-   rst search. instead of exploring
all the consequences of a single action, breadth-   rst search explores all the actions
from a single node before exploring any of the nodes resulting from taking those
actions. so, all nodes at depth one are explored before all nodes at depth two, then
all nodes at depth three, etc.

while the aforementioned are fundamental uninformed search algorithms, there
are many variations and combinations of these algorithms, and new uninformed
search algorithms are being developed. more information about uninformed search
algorithms can be found in chapter 4 of [582].

it is rare to see uninformed search algorithms used effectively in games, but there
are exceptions such as iterative width search [58], which does surprisingly well in
general video game playing, and the use of breadth-   rst search to evaluate aspects
of strategy game maps in sentient sketchbook [379]. also, it is often illuminating to
compare the performance of state-of-the-art algorithms with a simple uninformed
search algorithm.

2.3.1.1 uninformed search for ms pac-man

a depth-   rst approach in ms pac-man would normally consider the branches of
the game tree until ms pac-man either completes the level or loses. the outcome
of this search for each possible action would determine which action to take at a
given moment. breadth-   rst instead would    rst explore all possible actions of ms
pac-man at the current state of the game (e.g., going left, up, down or right) and

2.3. tree search

41

would then explore all their resulting nodes (children) and so on. the game tree of
either method is too big and complex to visualize within a ms pac-man example.

2.3.2 best-first search

in best-   rst search, the expansion of nodes in the search tree is informed by some
knowledge about the goal state. in general, the node that is closest to the goal state
by some criterion is expanded    rst. the most well-known best-   rst search algorithm
is a* (pronounced a star). the a* algorithm keeps a list of    open    nodes, which
are next to an explored node but which have not themselves been explored. for each
open node, an estimate of its distance from the goal is made. new nodes are chosen
to explore based on a lowest cost basis, where the cost is the distance from the origin
node plus the estimate of the distance to the goal.

a* can easily be understood as navigation in two- or three-dimensional space.
variants of this algorithm are therefore commonly used for path   nding in games.
in many games, the    ai    essentially amounts to non-player characters using a*
path   nding to traverse scripted points. in order to cope with large, deceptive spaces
numerous modi   cations of this basic algorithm have been proposed, including hier-
archical versions of a* [61, 661], real-time heuristic search [82], jump point search
for uniform-cost grids [246], 3d path   nding algorithms [68], planning algorithms
for dynamic game worlds [495] that enable the animation of crowds in collision-
free paths [631] and approaches for path   nding in navigation meshes [68, 722]. the
work of steve rabin and nathan sturtevant on grid-based path   nding [551, 662]
and path   nding architectures [550] are notable examples. sturtevant and colleagues
have also been running a dedicated competition to grid-based path-planning [665]
since 2012.4 for the interested reader sturtevant [663] has released a list of bench-
marks for grid-based path   nding in games5 including dragon age: origins (elec-
tronic arts, 2009), starcraft (blizzard entertainment, 1998) and warcraft iii: reign
of chaos (blizzard entertainment, 2002).

however, a* can also be used to search in the space of game states, as opposed
to simply searching physical locations. this way, best-   rst search can be used for
planning rather than just navigation. the difference is in taking the changing state
of the world (rather than just the changing state of a single agent) into account.
planning with a* can be surprisingly effective, as evidenced by the winner of the
2009 mario ai competition   where competitors submitted agents playing super
mario bros (nintendo, 1985)   being based on a simple a* planner that simply
tried to get to the right end of the screen at all times [717, 705] (see also fig. 2.5).

4 http://movingai.com/gppc/
5 http://movingai.com/benchmarks/

42

chapter 2. ai methods

fig. 2.5 the a* controller of the 2009 mario ai competition champion by r. baumgarten [705].
the red lines illustrate possible future trajectories considered by the a* controller of mario, taking
the dynamic nature of the game into account.

2.3.2.1 best-first search for ms pac-man

best-   rst search can be applicable in pac-man in the form of a*. following the
paradigm of the 2009 mario ai competition champion, ms pac-man can be con-
trolled by an a* algorithm that searches through possible game states within a short
time frame and takes a decision on where to move next (up, down, left or right).
the game state can be represented in various ways: from a very direct, yet costly,
representation that takes ghost and pellet coordinates into account to an indirect rep-
resentation that considers the distance to the closest ghost or pellet. regardless of
the representation chosen, a* requires the design of a cost function that will drive
the search. relevant cost functions for ms pac-man would normally reward moves
to areas containing pellets and penalizing areas containing ghosts.

2.3.3 minimax

for single-player games, simple uninformed or informed search algorithms can be
used to    nd a path to the optimal game state. however, for two-player adversarial

2.3. tree search

43

games, there is another player that tries to win as well, and the actions of each
player depend very much on the actions of the other player. for such games we
need adversarial search, which includes the actions of two (or more) adversarial
players. the basic adversarial search algorithm is called minimax. this algorithm
has been used very successfully for playing classic perfect-information two-player
board games such as checkers and chess, and was in fact (re)invented speci   cally
for the purpose of building a chess-playing program [725].

the core loop of the minimax algorithm alternates between player 1 and player
2   such as the white and black player in chess   named the min and the max player.
for each player, all possible moves are explored. for each of the resulting states,
all possible moves by the other player are also explored, and so on until all the
possible combinations of moves have been explored to the point where the game
ends (e.g., with a win, a loss or a draw). the result of this process is the generation
of the whole game tree from the root node down to the leaves. the outcome of the
game informs the utility function which is applied onto the leaf nodes. the utility
function estimates how good the current game con   guration is for a player. then, the
algorithm traverses up the search tree to determine what action each player would
have taken at any given state by backing-up values from leaves through the branch
nodes. in doing so, it assumes that each player tries to play optimally. thus, from
the standpoint of the max player, it tries to maximize its score, whereas min tries to
minimize the score of max; hence, the name minimax. in other words, a max node of
the tree computes the max of its child values whereas a min node computes the min
of its child values. the optimal winning strategy is then obtained for max if, on min   s
turn, a win is obtainable for max for all moves that min can make. the corresponding
optimal strategy for min is when a win is possible independently of what move max
will take. to obtain a winning strategy for max, for instance, we start at the root of
the tree and we iteratively choose the moves leading to child nodes of highest value
(on min   s turn the child nodes with the lowest value are selected instead). figure 2.6
illustrates the basic steps of minimax through a simple example.

of course, exploring all possible moves and countermoves is infeasible for any
game of interesting complexity, as the size of the search tree increases exponentially
with the depth of the game or the number of moves that are simulated. indicatively,
tic-tac-toe has a game tree size of 9! = 362,880 states which is feasible to traverse
through; however, the chess game tree has approximately 10154 nodes which is
infeasible to search through with modern computers. therefore, almost all actual
applications of the minimax algorithm cut off search at a given depth, and use a state
evaluation function to evaluate the desirability of each game state at that depth. for
example, in chess a simple state evaluation function would be to merely sum the
number of white pieces on the board and subtract the number of black pieces; the
higher this number is, the better the situation is for the white player. (of course,
much more sophisticated board evaluation functions are commonly used.) together
with improvements to the basic minimax algorithm such as   -   pruning and the
use of non-deterministic state evaluation functions, some very competent programs
emerged for many classic games (e.g., ibm   s deep blue). more information about
minimax and other adversarial search algorithms can be found in chapter 6 of [582].

44

chapter 2. ai methods

fig. 2.6 an abstract game tree illustrating the minimax algorithm. in this hypothetical game of
two options for each player max (represented as red squares) plays    rst, min (represented as blue
diamonds) plays second and then max plays one last time. white squares denote terminal nodes
containing a winning (positive), a losing (negative) or a draw (zero) score for the max player.
following the minimax strategy, the scores (utility) are traversed up to the root of the game tree.
the optimal play for max and min is illustrated in bold. in this simple example if both players play
optimally, max wins a score of 5.

2.3.3.1 minimax for ms pac-man

strictly speaking, minimax is not applicable to ms pac-man as the game is non-
deterministic and, thus, the minimax tree is formally unknown. (of course minimax
variants with heuristic evaluation functions can be eventually applicable.) minimax
is however applicable to ms pac-man   s deterministic ancestor, pac-man (namco,
1980). again strictly speaking, pac-man is a single-player adversarial game. as
such minimax is applicable only if we assume that pac-man plays against adver-
saries (ghosts) who make optimal decisions. it is important to note that ghosts   
movements are not represented by tree nodes; instead, they are simulated based on
their assumed optimal play. game tree nodes in pac-man may represent the game
state including the position of pac-man, the ghosts, and the current pellets and power
pills available. the branches of the minimax tree are the available moves of the pac-
man in each game state. the terminal nodes can, for instance, feature either a binary
utility (1 if pac-man completes the level; 0 if pac-man was killed by a ghost) or the
   nal score of the game.

2.3. tree search

2.3.4 id169

45

there are many games which minimax will not play well. in particular, games with
a high branching factor (where there are many potential actions to take at any given
point in time) lead to minimax that will only ever search a very shallow tree. an-
other aspect of games which frequently throws spanners in the works of minimax
is when it is hard to construct a good state evaluation function. the board game go
is a deterministic, perfect information game that is a good example of both of these
phenomena. go has a branching factor of approximately 300, whereas chess typi-
cally has around 30 actions to choose from. the positional nature of the go game,
which is all about surrounding the adversary, makes it very hard to correctly esti-
mate the value of a given board state. for a long time, the best go-playing programs
in the world, most of which were based on minimax, could barely exceed the play-
ing strength of a human beginner. in 2007, id169 (mcts) was
invented and the playing strength of the best go programs increased drastically.

beyond complex perfect information, deterministic games such as go, chess and
checkers, imperfect information games such a battleship, poker, bridge and/or
non-deterministic games such as backgammon and monopoly cannot be solved via
minimax due to the very nature of the algorithm. in such games, mcts not only
overcomes the tree size limitation of minimax but, given suf   cient computation, it
approximates the minimax tree of the game.

so how does mcts handle high branching factors, lack of good state evaluation
functions, and lack of perfect information and determinism? to begin with, it does
not search all branches of the search tree to an even depth, instead it concentrates
on the more promising branches. this makes it possible to search certain branches
to a considerable depth even though the branching factor is high. further, to get
around the lack of good evaluation functions, determinism and imperfect informa-
tion, the standard formulation of mcts uses rollouts to estimate the quality of the
game state, randomly playing from a game state until the end of the game to see the
expected win (or loss) outcome. the utility values obtained via the random simu-
lations may be used ef   ciently to adjust the policy towards a best-   rst strategy (a
minimax tree approximation).

at the start of a run of the mcts algorithm, the tree consists of a single node rep-
resenting the current state of the game. the algorithm then iteratively builds a search
tree by adding and evaluating new nodes representing game states. this process can
be interrupted at any time, rendering mcts an anytime algorithm. mcts requires
only two pieces of information to operate: the game rules that would, in turn, yield
the available moves in the game and the terminal state evaluation   whether that is
win, a loss, a draw, or a game score. the vanilla version of mcts does not require
a heuristic function, which is, in turn, a key advantage over minimax.

the core loop of the mcts algorithm can be divided into four steps: selection,
expansion (the    rst two steps are also known as tree policy), simulation and back-
propagation. the steps are also depicted in fig. 2.7.

46

chapter 2. ai methods

selection:

in this phase, it is decided which node should be expanded. the
process starts at the root of the tree, and continues until a node is selected
which has unexpanded children. every time a node (action) is to be selected
within the existing tree a child node j is selected to maximise the ucb1
formula:

(cid:115)

ucb1 = x j + 2cp

2lnn
n j

(2.1)

   
where x j is the average reward of all nodes beneath this node, cp is an ex-
2), n is the number of times the parent
ploration constant (often set to 1/
node has been visited, and n j is the number of times the child node j has
been visited. it is important to note that while ucb1 is the most popular for-
mula used for action selection it is certainly not the only one available. be-
yond equation (2.1) other options include epsilon-greedy, thompson sam-
pling, and bayesian bandits. for instance, thompson sampling selects ac-
tions stochastically based on their posterior probabilities of being optimal
[692].

expansion: when a node is selected that has unexpanded children   i.e., that
represents a state from which actions can be taken that have not been at-
tempted yet   one of these children is chosen for expansion, meaning that a
simulation is done starting in that state. selecting which child to expand is
often done at random.

simulation (default policy): after a node is expanded, a simulation (or roll-
out) is done starting from the non-terminal node that was just expanded until
the end of game to produce a value estimate. usually, this is performed by
taking random actions until a termination state is reached, i.e., until the game
is either won or lost. the state at the end of the game (e.g.,    1 if losing, +1
if winning, but could be more nuanced) is used as the reward (   ) for this
simulation, and propagated up the search tree.

id26: the reward (the outcome of the simulation) is added to
the total reward x of the new node. it is also    backed up   : added to the total
reward of its parent node, its parent   s parent and so on until the root of the
tree.

the simulation step might appear counter-intuitive   taking random actions seems
like no good way to play a game   but it provides a relatively unbiased estimate of
the quality of a game state. essentially, the better a game state is, the more simu-
lations are likely to end up winning the game. at least, this is true for games like
go where a game will always reach a terminal state within a certain relatively small
number of moves (400 for go). for other games like chess, it is theoretically pos-
sible to play an arbitrary number of moves without winning or losing the game.
for many video games, it is probable that any random sequence of actions will not
end the game unless some timer runs out, meaning that most simulations will be

2.3. tree search

47

fig. 2.7 the four basic steps of mcts exempli   ed through one iteration of the algorithm. the
   gure is a recreation of the corresponding mcts outline    gure by chaslot et al. [118].

very long (tens or hundreds of thousands of steps) and not yield useful information.
for example, in super mario bros (nintendo,1985), the application of random ac-
tions would most likely make mario dance around his starting point until his time is
up [294]. in many cases it is therefore useful to complement the simulation step with
a state evaluation function (as commonly used in minimax), so that a simulation is
performed for a set number of steps and if a terminal state is not reached a state
evaluation is performed in lieu of a win-lose evaluation. in some cases it might even
be bene   cial to replace the simulation step entirely with a state evaluation function.
it is worth noting that there are many variations of the basic mcts algorithm   it
may in fact be more useful to see mcts as an algorithm family or framework rather
than a single algorithm.

2.3.4.1 mcts for ms pac-man

mcts can be applicable to the real-time control of the ms pac-man agent. there
are obviously numerous ways to represent a game state (and thereby a game tree
node) and design a reward function for the game, which we will not discuss in detail
here. in this section, instead, we will outline the approach followed by pepels et al.
[524] given its success in obtaining high scores for ms pac-man. their agent, named
maastricht, managed to obtain over 87,000 points and was ranked    rst (among 36
agents) in the ms pac-man competition of the ieee computational intelligence and
games conference in 2012.

when mcts is used for real-time decision making a number of challenges be-
come critical. first, the algorithm has limited rollout computational budget which
increases the importance of heuristic knowledge. second, the action space can be

48

chapter 2. ai methods

fig. 2.8 the junction-based representation of a game state for the maastricht mcts controller
[524]. all letter nodes refer to game tree nodes (decisions) for ms pac-man. imaged adapted from
[524] with permission from authors.

particularly    ne-grained which suggests that macro-actions are a more powerful
way to model the game tree; otherwise the agent   s planning will be very short-term.
third, there might be no terminal node in sight which calls for good heuristics and
possibly restricting the simulation depth. the mcts agent of pepels et al. [524]
managed to cope with all the above challenges of using mcts for real-time control
by using a restricted game tree and a junction-based game state representation (see
fig. 2.8).

2.4. evolutionary computation

2.3.5 further reading

49

the basic search algorithms are well covered in russell and norvig   s classic ai
textbook [582]. the a* algorithm was invented in 1972 for robot navigation [247];
a good description of the algorithm can be found in chapter 4 of [582]. there is
plenty of more advanced material on tailoring and optimizing this algorithm for
speci   c game problems in dedicated game ai books such as [546]. the different
components of id169 [141] were invented in 2006 and 2007 in
the context of playing go [142]; a good overview of and introduction to mcts and
some of its variants is given in a survey paper by browne et al. [77].

2.4 evolutionary computation

while tree search algorithms start from the root node representing an origin state,
and build a search tree based on the available actions, optimization algorithms do
not build a search tree; they only consider complete solutions, and not the path
taken to get there. as mentioned earlier in section 2.1, all optimization algorithms
assume that there is something to optimize solutions for; there must be an objective,
alternatively called utility function, evaluation function or    tness function, which
can assign a numerical value (the    tness) to a solution, which can be maximized (or
minimized). given a utility function, an optimization algorithm can be seen as an
algorithm that seeks in a search space solutions that have the highest (or lowest)
value of that utility.

a broad family of optimization algorithms is based on randomized variation of
solutions, where one or multiple solutions are kept at any given time, and new so-
lutions (or candidates, or search points; different terminology is used by different
authors) are created through randomly changing some of the existing solutions, or
maybe combining some of them. randomized optimization algorithms which keep
multiple solutions are called evolutionary algorithms, by analogy with natural evo-
lution.

another important concept when talking about optimization algorithms (and ai
at large as covered in section 2.1) is their representation. all solutions are repre-
sented in some way, for example, as    xed-size vectors of real numbers, or variable-
length strings of characters. generally, the same artifact can be represented in many
different ways; for example, when searching for a sequence of actions that solves a
maze, the action sequence can be represented in several different ways. in the most
direct representation, the character at step t determines what action to take at time
step t +1. a somewhat more indirect representation for a sequence of actions would
be a sequence of tuples, where the character at time step t decides what action to
take and the number t + n determines for how many time steps n to take that action.
the choice of representation has a big impact on the ef   ciency and ef   cacy of the
search algorithm, and there are several tradeoffs at play when making these choices.

50

chapter 2. ai methods

optimization is an extremely general concept, and optimization algorithms are
useful for a wide variety of tasks in ai as well as in computing more generally.
within ai and games, optimization algorithms such as evolutionary algorithms have
been used in many roles as well. in chapter 3 we explain how optimization algo-
rithms can be used for searching for game-playing agents, and also for searching for
action sequences (these are two very different uses of optimization that are both in
the context of game-playing); in chapter 4 we explain how we can use optimiza-
tion to create game content such as levels; and in chapter 5 we discuss how to use
optimization to    nd player models.

2.4.1 local search

the simplest optimization algorithms are the local optimization algorithms. these
are so called because they only search    locally   , in a small part of the search space,
at any given time. a local optimization algorithm generally just keeps a single solu-
tion candidate at any given time, and explores variations of that solution.

the arguably simplest possible optimization algorithm is the hill climber. in
its most common formulation, which we can call the deterministic formulation, it
works as follows:

1. initialization: create a solution s by choosing a random point in search

space. evaluate its    tness.

2. generate all possible neighbors of s. a neighbor is any solution that differs
from s by at most a certain given distance (for example, a change in a single
position).

3. evaluate all the neighbors with the    tness function.
4. if none of the neighbors has a better    tness score than s, exit the algorithm

5. otherwise, replace s with the neighbor that has the highest    tness value and

and return s.

go to step 2.

the deterministic hill climber is only practicable when the representation is such
that each solution has a small number of neighbors. in many representations there
are an astronomically high number of neighbors. it is therefore preferable to use
variants of hill climbers that may guide the search effectively. one approach is the
gradient-based hill climber that follows the gradient towards minimizing a cost
function. that algorithmic approach trains arti   cial neural networks for instance
(see section 2.5). another approach that we cover here is the randomized hill
climber. this instead relies on the concept of mutation: a small, random change
to a solution. for example, a string of letters can be mutated by randomly    ipping
one or two characters to some other character (see fig. 2.9), and a vector of real

2.4. evolutionary computation

51

(a) mutation: a number of genes is selected to
be mutated with a small id203 e.g., less
than 1%. the selected genes are highlighted
with a red outline at the top chromosome and
are mutated by    ipping their binary value (red
genes) at the bottom chromosome.

(b) inversion: two positions in the offspring
are randomly chosen and the positions between
them   the gene sequence highlighted by a red
outline at the top chromosome   are inversed
(red genes) at the bottom chromosome.

fig. 2.9 two ways of mutating a binary chromosome. in this example we use a chromosome of
eleven genes. a chromosome is selected (top bit-string) and mutated (bottom bit-string).

numbers can be mutated by adding another vector to it drawn from a random dis-
tribution around zero, and with a very small standard deviation. macro-mutations
such as gene inversion can also be applied as visualized in fig. 2.9. given a repre-
sentation,    tness function and mutation operator, the randomized hill climber works
as follows:

space. evaluate its    tness.

1. initialization: create a solution s by choosing a random point in the search
2. mutation: generate an offspring s(cid:48) by mutating s.
3. evaluation: evaluate the    tness of s(cid:48).
4. replacement: if s(cid:48) has higher    tness than s, replace s with s(cid:48).
5. go to step 2.

while very simple, the randomized hill climber can be surprisingly effective. its
main limitation is that it is liable to get stuck in local optima. a local optimum
is sort of a    dead end    in search space from which there is    no way out   ; a point
from which there are no better (higher-   t) points within the immediate vicinity.
there are many ways of dealing with this problem. one is to simply restart the hill
climber at a new randomly chosen point in the search space whenever it gets stuck.
another is simulated annealing, to accept moving to solutions with lower    tness
with a given id203; this id203 gradually diminishes during the search. a
far more popular response to the problem of local optima is to keep not just a single
solution at any time, but a population of solutions.

2.4.1.1 local search for ms pac-man

while we can think of a few ways one can apply local search in ms pac-man we
outline an example of its use for controlling path-plans. local search could, for

52

chapter 2. ai methods

instance, evolve short local plans (action sequences) of ms pac-man. a solution
could be represented as a set of actions that need to be taken and its    tness could be
determined by the score obtained after following this sequence of actions.

2.4.2 evolutionary algorithms

evolutionary algorithms are randomized global optimization algorithms; they are
called global rather than local because they search many points in the search space
simultaneously, and these points can be far apart. they accomplish this by keeping a
population of solutions in memory at any given time. the general idea of evolution-
ary computation is to optimize by    breeding    solutions: generate many solutions,
throw away the bad ones and keep the good (or at least less bad) ones, and create
new solutions from the good ones.

the idea of keeping a population is taken from darwinian evolution by natural
selection, from which evolutionary algorithms also get their name. the size of the
population is one of the key parameters of an evolutionary algorithm; a population
size of 1 yields something like a randomized hill climber, whereas populations of
several thousand solutions are not unheard of.

another idea which is taken from evolution in nature is crossover, also called re-
combination. this is the equivalent of sexual reproduction in the natural world; two
or more solutions (called parents) produce an offspring by combining elements of
themselves. the idea is that if we take two good solutions, a solution that is a com-
bination of these two   or intermediate between them   ought to be good as well,
maybe even better than the parents. the offspring operator is highly dependent on
the solution representation. when the solution is represented as a string or a vec-
tor, operators such as uniform crossover (which    ips a fair coin and randomly picks
values from each parent for each position in the offspring) or one-point crossover
(where a position p in the offspring is randomly chosen, and values of positions be-
fore p are taken from parent 1 and values of positions after p are taken from parent
2) can be used. crossover can be applied to any chromosome representation varying
from a bit-string to a real-valued vector. figure 2.10 illustrates these two crossover
operators. it is in no way guaranteed, however, that the crossover operator generates
an offspring that is anything as highly    t as the parents. in many cases, crossover can
be highly destructive. if crossover is used, it is therefore important that the offspring
operator is chosen with care for each problem. figure 2.11 illustrates this possibility
through a simple two-dimensional example.

the basic template for an evolutionary algorithm is as follows:

1. initialization: the population is    lled with n solutions created randomly,
i.e., random points in search space. known highly-   t solutions can also be
added to this initial population.

2.4. evolutionary computation

53

(a) 1-point crossover: the vertical line across
the two parents denotes the crossover point at
position p.

(b) uniform crossover: to select genes from
each parent to form offspring the operator    ips
a fair coin at each position of the chromosome.

fig. 2.10 two popular types of crossover used in evolutionary algorithms. in this example we
use a binary representation and a chromosome size of eleven genes. the two bit-strings used in
both crossover operators represent the two parents selected for recombination. red and blue genes
represent the two different offspring emerged from each crossover operator. note that the operators
are directly applicable to real-valued (   oating point) representations too.

2. evaluation: the    tness function is used to evaluate all solutions in the pop-

ulation and assign    tness values to them.

3. parent selection: based on    tness and possibly other criteria, such as dis-
tance between solutions, those population members that will be used for
reproduction are selected. selection strategies include methods directly or
indirectly dependent on the    tness of the solutions, including roulette-wheel
(proportionally to    tness), ranking (proportionally to rank in population) and
tournament.

4. reproduction: offspring are generated through crossover from parents, or

through simply copying parent solutions, or some combination of these.

5. variation: mutation is applied to some or all of the parents and/or offspring.
6. replacement: in this step, we select which of the parents and/or offspring
will make it to the next generation. popular replacement strategies of the
current population include the generational (parents die; offspring replace
them), steady state (offspring replaces worst parent if and only if offspring
is better) and elitism (generational, but best x% of parents survive) ap-
proaches.

7. termination: are we done yet? decide based on how many generations or
evaluations have elapsed (exhaustion), the highest    tness attained by any
solution (success), and/or some other termination condition.

8. go to step 2.

every iteration of the main loop (i.e., every time we reach step 2) is called a gen-
eration, keeping with the nature-inspired terminology. the total number of    tness
evaluations performed is typically proportional to the size of the population times
the number of generations.

this high-level template can be implemented and expanded in a myriad different
ways; there are thousands of evolutionary or evolution-like algorithms out there, and

54

chapter 2. ai methods

fig. 2.11 an illustration of the mutation and crossover operators in a simpli   ed two-dimensional
   tness landscape. the problem is represented by two real-valued variables (x1 and x2) that de   ne
the two genes of the vector chromosome. the    tness landscape is represented by the contour lines
on the 2d plane. chromosomes 1 and 2 are selected to be parents. they are recombined via 1-point
crossover (dotted arrows) which yields offspring 3 and 4. both offspring are mutated (solid arrows)
to yield solutions 5 and 6. operators that lead to poorer-   t or higher-   t solutions are, respectively,
depicted with green and red color.

many of them rearrange the overall    ow, add new steps and remove existing steps.
in order to make this template a bit more concrete, we will give a simple example of
a working evolutionary algorithm below. this is a form of evolution strategy, one
of the main families of evolutionary algorithms. while the    +    evolution strategy
is a simple algorithm that can be implemented in 10 to 20 lines of code, it is a
fully functional global optimizer and quite useful. the two main parameters are   ,
which signi   es the    elite    or the size of the part of the population that is kept every
generation, and    , the size of the part of the population that is re-generated every
generation.

1. fill the population with    +    randomly generated solutions.
2. evaluate the    tness of all solutions.

2.4. evolutionary computation

55

3. sort the population by decreasing    tness, so that the lowest-numbered solu-

tions have highest    tness.

4. remove the least    t    individuals.
5. replace the removed individuals with copies of the    best individuals.
6. mutate the offspring.
7. stop if success or exhaustion. otherwise go to step 2.

evolution strategies, the type of algorithms which the    +    evolution strategy
above is a simple example of, are characterized by a reliance on mutation rather
than crossover to create variation, and by the use of self-adaptation to adjust mu-
tation parameters (though that is not part of the simple algorithm above). they are
also generally well suited to optimize artifacts represented as vectors of real num-
bers, so-called continuous optimization. some of the very best algorithms for con-
tinuous optimization, such as the covariance matrix adaptation evolution strategy
(cma-es) [245] and the natural evolution strategy (nes) [753], are conceptual
descendants of this family of algorithms.

another prominent family of evolutionary algorithms is id107
(gas). these are characterized by a reliance on crossover rather than mutation for
variation (some id107 have no mutation at all),    tness-proportional se-
lection and solutions being often represented as bit-strings or other discrete strings.
it should be noted, however, that the distinctions between different types of evolu-
tionary algorithms are mainly based on their historical origins. these days, there are
so many variations and such extensive hybridization that it often makes little sense
to categorize a particular algorithm as belonging to one or the other family.

a variant of evolutionary algorithms emerges from the need of satisfying par-
ticular constraints within which a solution is not only    t but also feasible. when
evolutionary algorithms are used for constrained optimization we are faced with a
number of challenges such as that mutation and crossover cannot preserve or guar-
antee the feasibility of a solution. it may very well be that a mutation or a recombi-
nation between two parents may yield an infeasible offspring. one approach to deal
with constraint handling is repair, which could be any process that turns infeasible
individuals into feasible ones. a second approach is to modify the genetic opera-
tors so that the id203 of an infeasible individual to appear becomes smaller.
a popular approach is to merely penalize the existence of infeasible solutions by
assigning them low    tness values or, alternatively, in proportion to the number of
constraint violations. this strategy however may over-penalize the actual    tness of
a solution which in turn will result in its rapid elimination from the population. such
a property might be undesirable and is often accused for the weak performance of
evolutionary algorithms on handling constraints [456]. as a response to this limi-
tation the feasible-infeasible 2-population (fi-2pop) algorithm [341] evolves two
populations, one with feasible and one with infeasible solutions. the infeasible pop-
ulation optimizes its members towards minimizing the distance from feasibility. as
the infeasible population converges to the border of feasibility, the likelihood of dis-

56

chapter 2. ai methods

covering new feasible individuals increases. feasible offspring of infeasible parents
are transferred to the feasible population, boosting its diversity (and vice versa for
infeasible offspring). fi-2pop has been used in games on instances where we require
   t and feasible solutions such as well-designed and playable game levels [649, 379].
finally, another blend of evolutionary algorithms considers more than one ob-
jective when attempting to    nd a solution to a problem. for many problems it is
hard to combine all requirements and speci   cations into a single objective mea-
sure. it is also often true that these objectives are con   icting; for instance, if our
objectives are to buy the fastest and cheapest possible laptop we will soon realize
the two objectives are partially con   icting. the intuitive solution is to merely add
the different objective values   as a weighted sum   and use this as your    tness un-
der optimization. doing so, however, has several drawbacks such as the non-trivial
ad-hoc design of the weighting among the objectives, the lack of insight on the inter-
actions between the objectives (e.g., what is the price threshold above which faster
laptops are not more expensive?) and the fact that a weighted-sum single-objective
approach cannot reach solutions that achieve an optimal compromise among their
weighted objectives. the response to these limitations is the family of algorithms
known as multiobjective evolutionary algorithms. a multiobjective evolutionary
algorithm considers at least two objective functions   that are partially con   icting   
and searches for a pareto front of these objectives. the pareto front contains solu-
tions that cannot be improved in one objective without worsening in another. further
details about multiobjective optimization by means of evolutionary algorithms can
be found in [126]. the approach is applicable in game ai on instances where more
than one objective is relevant for the problem we attempt to solve: for instance, we
might wish to optimize both the balance and the asymmetry of a strategy game map
[712, 713], or design non-player characters that are interestingly diverse in their
behavioral space [5].

2.4.2.1 evolutionary algorithms for ms pac-man

a simple way to employ evolutionary algorithms (eas) in ms pac-man is as fol-
lows. you could design a utility function based on a number of important parame-
ters ms pac-man must consider for taking the right decision on where to move next.
these parameters, for instance, could be the current placement of ghosts, the pres-
ence of power pills, the number of pellets available on the level and so on. the next
step would be to design a utility function as the weighted sum of these parameters.
at each junction, ms pac-man would need to consult its utility function for all its
possible moves and pick the move with the highest utility. the weights of the utility
function are unknown of course and this is where an ea can be of help by evolving
the weights of the utility so that they optimize the score for ms pac-man. in other
words, the    tness of each chromosome (weight vector of utility) is determined by
the score obtained from ms pac-man within a number of simulation steps, or game
levels played.

2.5. supervised learning

2.4.3 further reading

57

we recommend three books for further reading on evolutionary computation: eiben
and smith   s introduction to evolutionary computing [184], ashlock   s evolutionary
computation for modeling and optimization [21] and    nally, the genetic program-
ming    eld guide by poli et al. [536].

2.5 supervised learning

supervised learning is the algorithmic process of approximating the underlying
function between labeled data and their corresponding attributes or features [49].
a popular example of supervised learning is that of a machine that is asked to dis-
tinguish between apples and pears (labeled data) given a set of features or data
attributes such as the fruits    color and size. initially, the machine learns to classify
between apples and pears by seeing a number of available fruit examples   which
contain the color and size of each fruit, on one hand, and their corresponding label
(apple or pear) on the other. after learning is complete, the machine should ideally
be able to tell whether a new and unseen fruit is a pear or an apple based solely on its
color and size. beyond distinguishing between apples and pears supervised learning
nowadays is used in a plethora of applications including    nancial services, medical
diagnosis, fraud detection, web page categorization, image and id103,
and user modeling (among many).

evidently, supervised learning requires a set of labeled training examples; hence
supervised. more speci   cally, the training signal comes as a set of supervised labels
on the data (e.g., this is an apple whereas that one is a pear) which acts upon a set
of characterizations of these labels (e.g., this apple has red color and medium size).
consequently, each data example comes as a pair of a set of labels (or outputs) and
features that correspond to these labels (or inputs). the ultimate goal of supervised
learning is not to merely learn from the input-output pairs but to derive a function
that approximates (better, imitates) their relationship. the derived function should
be able to map well to new and unseen instances of input and output pairs (e.g., un-
seen apples and pears in our example), a property that is called generalization. here
are some examples of input-output pairs one can meet in games and make supervised
learning relevant: {player health, own health, distance to player}     {action (shoot,
   ee, idle)}; {player   s previous position, player   s current position}     {player   s next
position}; {number of kills and headshots, ammo spent}     {skill rating}; {score,
map explored, average heart rate}     {level of player frustration}; {ms pac-man
and ghosts position, pellets available}     {ms pac-man direction}.
formally, supervised learning attempts to derive a function f : x     y , given a
set of n training examples {(x1,y1), . . . , (xn,yn)}; where x and y is the input and
output space, respectively; xi is the feature (input) vector of the i-th example and yi
is its corresponding set of labels. a supervised learning task has two core steps. in
the    rst training step, the training samples   attributes and corresponding labels   

58

chapter 2. ai methods

are presented and the function f between attributes and labels is derived. as we will
see in the list of algorithms below f can be represented as a number of classi   cation
rules, id90, or mathematical formulae. in the second testing step f can
be used to predict the labels of unknown data given their attributes. to validate the
generalizability of f and to avoid over   tting to the data [49], it is common practice
that f is evaluated on a new independent (test) dataset using a performance measure
such as accuracy, which is the percentage of test samples that are correctly predicted
by our trained function. if the accuracy is acceptable, we can use f to predict new
data samples.

but how do we derive this f function? in general, an algorithmic process modi   es
the parameters of this function so that we achieve a good match between the given
labels of our training samples and the function we attempt to approximate. there
are numerous ways to    nd and represent that function, each one corresponding to
a different supervised learning algorithm. these include arti   cial neural networks,
case-based reasoning, decision tree learning, id79s, gaussian regression,
naive bayes classi   ers, k-nearest neighbors, and support vector machines [49]. the
variety of supervised learning algorithms available is, in part, explained by the fact
that there is no single learning algorithm that works best on all supervised learning
problems out there. this is widely known as the no free lunch theorem [756].

before covering the details of particular algorithms we should stress that the data
type of the label determines the output type and, in turn, the type of the super-
vised learning approach that can be applied. we can identify three main types of
supervised learning algorithms depending on the data type of the labels (outputs).
first, we meet classi   cation [49] algorithms which attempt to predict categorical
class labels (discrete or nominal) such as the apples and pears of the previous ex-
ample or the level in which a player will achieve her maximum score. second, if
the output data comes as an interval   such as the completion time of a game level
or retention time   the supervised learning task is metric regression [49]. finally,
preference learning [215] predicts ordinal outputs such as ranks and preferences
and attempts to derive the underlying global order that characterizes those ordinal
labels. examples of ordinal outputs include the ranked preferences of variant cam-
era viewpoints, or a preference of a particular sound effect over others. the training
signal in the preference learning paradigm provides information about the relative
relation between instances of the phenomenon we attempt to approximate, whereas
regression and classi   cation provide information, respectively, about the intensity
and the classes of the phenomenon.

in this book, we focus on a subset of the most promising and popular super-
vised learning algorithms for game ai tasks such as game playing (see chapter 3),
player behavior imitation or player preference prediction (see chapter 5). the three
algorithms outlined in the remainder of this section are arti   cial neural networks,
support vector machines and decision tree learning. all three supervised learning
algorithms covered can be used for either classi   cation, prediction or preference
learning tasks.

2.5. supervised learning

59

fig. 2.12 an illustration of an arti   cial neuron. the neuron is fed with the input vector x through
n connections with corresponding weight values w. the neuron processes the input by calculating
the weighted sum of inputs and corresponding connection weights and adding a bias weight (b):
x    w + b. the resulting formula feeds an activation function (g), the value of which de   nes the
output of the neuron.

2.5.1 arti   cial neural networks

arti   cial neural networks (anns) are a bio-inspired approach for computational
intelligence and machine learning. an ann is a set of interconnected processing
units (named neurons) which was originally designed to model the way a biolog-
ical brain   containing over 1011 neurons   processes information, operates, learns
and performs in several tasks. biological neurons have a cell body, a number of den-
drites which bring information into the neuron and an axon which transmits elec-
trochemical information outside the neuron. the arti   cial neuron (see fig. 2.12)
resembles the biological neuron as it has a number of inputs x (corresponding to
the neuron dendrites) each with an associated weight parameter w (corresponding
to the synaptic strength). it also has a processing unit that combines inputs with
their corresponding weights via an inner product (weighted sum) and adds a bias
(or threshold) weight b to the weighted sum as follows: x   w + b. this value is then
fed to an activation function g (cell body) that yields the output of the neuron (cor-
responding to an axon terminal). anns are essentially simple mathematical models
de   ning a function f : x     y.

various forms of anns are applicable for regression analysis, classi   cation,
and preference learning, and even unsupervised learning (via e.g., hebbian learning
[256] and self-organizing maps [347]). core application areas include pattern recog-
nition, robot and agent control, game-playing, decision making, gesture, speech and
text recognition, medical and    nancial applications, affective modeling, and im-
age recognition. the bene   ts of anns compared to other supervised learning ap-

60

chapter 2. ai methods

proaches is their capacity to approximate any continuous real-valued function given
suf   ciently large ann architectures and computational resources [348, 152]. this
capacity characterizes anns as universal approximators [279].

2.5.1.1 id180

which activation function should one use in an ann? the original model of a
neuron by mcculloch and pitts [450] in 1943 featured a heaviside step activation
function which either allows the neuron to    re or not. when such neurons are em-
ployed and connected to a multi-layered ann the resulting network can merely
solve linearly separable problems. the algorithm that trains such anns was in-
vented in 1958 [576] and is known as the rosenblatt   s id88 algorithm. non-
linearly separable problems such as the exclusive-or gate could only be solved after
the invention of the id26 algorithm in 1975 [752]. nowadays, there
are several id180 used in conjunction with anns and their train-
ing. the use of the activation function, in turn, yields different types of anns.
examples include gaussian activation function that is used in radial basis function
(rbf) networks [71] and the numerous types of id180 that can be
used in the compositional pattern producing networks (cppns) [653]. the most
common function used for ann training is the sigmoid-shaped logistic function
(g(x) = 1/(1 + e   x)) for the following properties: 1) it is bounded, monotonic and
non-linear; 2) it is continuous and smooth and 3) its derivative is calculated trivially
as g(cid:48)(x) = g(x)(1    g(x)). given the properties above the logistic function can be
used in conjunction with gradient-based optimization algorithms such as backprop-
agation which is described below. other popular id180 for training
deep architectures of neural networks include the recti   er   named recti   ed lin-
ear unit (relu) when employed to a neuron   and its smooth approximation, the
softplus function [231]. compared to sigmoid-shaped id180, relus
allow for faster and (empirically) more effective training of deep anns, which are
generally trained on large datasets (see more in section 2.5.1.6).

2.5.1.2 from a neuron to a network

to form an ann a number of neurons need to be structured and connected. while
numerous ways have been proposed in the literature the most common of them all
is to structure neurons in layers. in its simplest form, known as the multi-layer
id88 (mlp), neurons in an ann are layered across one or more layers but
not connected to other neurons in the same layer (see fig. 2.13 for a typical mlp
structure). the output of each neuron in each layer is connected to all the neurons
in the next layer. note that a neuron   s output value feeds merely the neurons of
the next layer and, thereby, becomes their input. consequently, the outputs of the
neurons in the last layer are the outputs of the ann. the last layer of the ann is
also known as the output layer whereas all intermediate layers between the output

2.5. supervised learning

61

fig. 2.13 an mlp example with three inputs, one hidden layer containing four hidden neurons
and two outputs. the ann has labeled and ordered neurons and example connection weight labels.
bias weights b j are not illustrated in this example but are connected to each neuron j of the ann.

and the input are the hidden layers. it is important to note that the inputs of the
ann, x, are connected to all the neurons of the    rst hidden layer. we illustrate this
with an additional layer we call the input layer. the input layer does not contain
neurons as it only distributes the inputs to the    rst layer of neurons. in summary,
mlps are 1) layered because they are grouped in layers; 2) feed-forward because
their connections are unidirectional and always forward (from a previous layer to
the next); and 3) fully connected because every neuron is connected to all neurons
of the next layer.

2.5.1.3 forward operation

in the previous section we de   ned the core components of an ann whereas in this
section we will see how we compute the output of the ann when an input pattern
is presented. the process is called forward operation and propagates the inputs of
the ann throughout its consecutive layers to yield the outputs. the basic steps of
the forward operation are as follows:

1. label and order neurons. we typically start numbering at the input layer and
increment the numbers towards the output layer (see fig. 2.13). note that

62

chapter 2. ai methods

the input layer does not contain neurons, nevertheless is treated as such for
numbering purposes only.

2. label connection weights assuming that wi j is the connection weight from
neuron i (pre-synaptic neuron) to neuron j (post-synaptic neuron). label
bias weights that connect to neuron j as b j.

3. present an input pattern x.
4. for each neuron j compute its output as follows:    j = g(   i{wi j  i} + b j),
where    j and   i are, respectively, the output of and the inputs to neuron
j (n.b.   i = xi in the input layer); g is the activation function (usually the
logistic sigmoid function).

5. the outputs of the neurons of the output layer are the outputs of the ann.

2.5.1.4 how does an ann learn?

how do we approximate f (x;w,b) so that the outputs of the ann match the desired
outputs (labels) of our dataset, y? we will need a training algorithm that adjusts the
weights (w and b) so that f : x     y. a training algorithm as such requires two
components. first, it requires a cost function to evaluate the quality of any set of
weights. second, it requires a search strategy within the space of possible solutions
(i.e., the weight space). we outline these aspects in the following two subsections.

cost (error) function

before we attempt to adjust the weights to approximate f , we need some measure of
mlp performance. the most common performance measure for training anns in
a supervised manner is the squared euclidean distance (error) between the vectors
of the actual output of the ann (  ) and the desired labeled output y (see equation
2.2).

e =

(y j        j)2

1
2    

j

(2.2)

where the sum is taken over all the output neurons (the neurons in the    nal layer).
note that the y j labels are constant values and more importantly, also note that e is
a function of all the weights of the ann since the actual outputs depend on them.
as we will see below, ann training algorithms build strongly upon this relationship
between error and weights.

2.5. supervised learning

id26

63

the id26 (or backprop) [579] algorithm is based on id119
optimization and is arguably the most common algorithm for training anns. back-
propagation stands for backward propagation of errors as it calculates weight up-
dates that minimize the error function   that we de   ned earlier (2.2)   from the out-
put to the input layer. in a nutshell, id26 computes the partial derivative
(gradient) of the error function e with respect to each weight of the ann and ad-
justs the weights of the ann following the (opposite direction of the) gradient that
minimizes e.

as mentioned earlier, the squared euclidean error of (2.2) depends on the weights
as the ann output which is essentially the f (x;w,b) function. as such we can cal-
) and any bias weight (   e
culate the gradient of e with respect to any weight (   e
)
  b j
  wi j
in the ann, which in turn will determine the degree to which the error will change if
we change the weight values. we can then determine how much of such change we
desire through a parameter        [0,1] called learning rate. in the absence of any in-
formation about the general shape of the function between the error and the weights
but the existence of information about its gradient it appears that a id119
approach would seem to be a good    t for attempting to    nd the global minimum of
the e function. given the lack of information about the e function, the search can
start from some random point in the weight space (i.e., random initial weight values)
and follow the gradient towards lower e values. this process is repeated iteratively
until we reach e values we are happy with or we run out of computational resources.
more formally, the basic steps of the id26 algorithm are as follows:

1. initialize w and b to random (commonly small) values.
2. for each training pattern (input-output pair):

present input pattern x, ideally normalized to a range (e.g., [0,1]).

(a)
(b) compute ann actual outputs    j using the forward operation.
(c) compute e according to (2.2).
(d) compute error derivatives with respect to each weight   e
  wi j

weight   e
  b j

(e) update weights and bias weights as    wi j =         e
  wi j

of the ann from the output all the way to the input layer.
and    b j          e
  b j

,

and bias

respectively.

3. if e is small or you are out of computational budget, stop! otherwise go to

step 2.

note that we do not wish to detail the derivate calculations of step 2(d) as doing
so would be out of scope for this book. we instead refer the interested reader to the
original id26 paper [579] for the exact formulas and to the reading list
at the end of this section.

64

limitations and solutions

chapter 2. ai methods

it is worth noting that id26 is not guaranteed to    nd the global minimum
of e given its local search (hill-climbing) property. further, given its gradient-based
(local) search nature, the algorithm fails to overcome potential plateaux areas in
the error function landscape. as these are areas with near-zero gradient, crossing
them results in near-zero weight updates and further in premature convergence of
the algorithm. typical solutions and enhancements of the algorithm to overcome
convergence to local minima include:
    random restarts: one can rerun the algorithm with new random connection
weight values in the hope that the ann is not too dependent on luck. no ann
model is good if it depends too much on luck   for instance, if it performs well
only in one or two out of ten runs.
    dynamic learning rate: one can either modify the learning rate parameter and
observe changes in the performance of the ann or introduce a dynamic learn-
ing rate parameter that increases when convergence is slow whereas it decreases
when convergence to lower e values is fast.
    momentum: alternatively, one may add a momentum amount to the weight up-

date rule as follows:

   w(t)

i j = m   w(t   1)

i j       

(2.3)
where m     [0,1] is the momentum parameter and t is the iteration step of the
weight update. the addition of a momentum value of the previous weight up-
date (a   w(t   1)
) attempts to help id26 to overcome a potential local
minimum.

i j

  e
  wi j

while the above solutions are directly applicable to anns of small size, practical
wisdom and empirical evidence with modern (deep) ann architectures, however,
suggests that the above drawbacks are largely eliminated [366].

batch vs. non-batch training

id26 can be employed following a batch or a non-batch learning mode.
in non-batch mode, weights are updated every time a training sample is presented
to the ann. in batch mode, weights are updated after all training samples are pre-
sented to the ann. in that case, errors are accumulated over the samples of the
batch prior to the weight update. the non-batch mode is more unstable as it itera-
tively relies on a single data point; however, this might be bene   cial for avoiding a
convergence to a local minimum. the batch mode, on the other hand, is naturally
a more stable id119 approach as weight updates are driven by the aver-
age error of all training samples in the batch. to best utilize the advantages of both
approaches it is common to apply batch learning of randomly selected samples in
small batch sizes.

2.5. supervised learning

2.5.1.5 types of anns

65

beyond the standard feedforward mlp there are numerous other types of ann used
for classi   cation, regression, preference learning, data processing and    ltering, and
id91 tasks. notably, recurrent neural networks (such as hop   eld networks
[278], id82s [4] and long short-term memory [266]) allow con-
nections between neurons to form directed cycles, thus enabling an ann to capture
dynamic and temporal phenomena (e.g., time-series processing and prediction). fur-
ther, there are ann types mostly used for id91 and data dimensionality reduc-
tion such as kohonen self-organizing maps [347] and autoencoders [41].

2.5.1.6 from shallow to deep

a critical parameter for ann training is the size of the ann. so, how wide and
deep should my ann architecture be to perform well on this particular task? while
there is no formal and de   nite answer to this question, there is a generally accepted
rule-of-thumb suggesting that the size of the network should match the complexity
of the problem. according to goodfellow et al. in their deep learning book [231]
an mlp is essentially a deep (feedforward) neural network. its depth is determined
by the number of hidden layers it contains. goodfellow et al. state that    it is from
this terminology that the name deep learning arises   . on that basis, training of
ann architectures containing (at least) a hidden layer can be viewed as a deep
learning task whereas single output-layered architectures can be viewed as shallow.
various methods have been introduced in recent years to enable training of deep
architectures containing several layers. the methods largely rely on gradient search
and are covered in detail in [231] for the interested reader.

2.5.1.7 anns for ms pac-man

as with every other method in this chapter we will attempt to employ anns in
the ms pac-man game. one straightforward way to use anns in ms pac-man is
to attempt to imitate expert players of the game. thus, one can ask experts to play
the game and record their playthroughs, through which a number of features can
be extracted and used as the input of the ann. the resolution of the ann input
may vary from simple statistics of the game   such as the average distance between
ghosts and ms pac-man   to detailed pixel-to-pixel rgb values of the game level
image. the output data, on the other hand, may contain the actions selected by
ms pac-man in each frame of the game. given the input and desired output pairs,
the ann is trained via id26 to predict the action performed by expert
players (ann output) given the current game state (ann input). the size (width
and depth) of the ann depends on both the amount of data available from the
expert ms pac-man players and the size of the input vector considered.

66

chapter 2. ai methods

2.5.2 support vector machines

support vector machines (id166s) [139] are an alternative and very popular set of
supervised learning algorithms that can be used for classi   cation, regression [179]
and preference learning [302] tasks. a support vector machine is a binary linear
classi   er that is trained so as to maximize the margin between the training examples
of the separate classes in the data (e.g., apples and pears). as with every other super-
vised learning algorithm, the attributes of new and unseen examples are seeding the
id166 which predicts the class they belong to. id166s have been used widely for text
categorization, id103, image classi   cation, and hand-written character
recognition among many other areas.

similarly to anns, id166s construct a hyperplane that divides the input space
and represents the function f that maps between the input and the target outputs. in-
stead of implicitly attempting to minimize the difference between the model   s actual
output and the target output following the gradient of the error (as id26
does), id166s construct a hyperplane that maintains the largest distance to the nearest
training-data point of any other class. that distance is called a maximum-margin
and its corresponding hyperplane divides the points (xi) of class with label (yi) 1
from those with label    1 in a dataset of n samples in total. in other words, the dis-
tance between the derived hyperplane and the nearest point xi from either class is
maximized. given the input attributes of a training dataset, x, the general form of a
hyperplane can be de   ned as: w   x    b = 0 where, as in id26 training,
w is the weight (normal) vector of the hyperplane and b(cid:107)w(cid:107) determines the offset
(or weight threshold/bias) of the hyperplane from the origin (see fig. 2.14). thus,
formally put, an id166 is a function f (x;w,b) that predicts target outputs (y) and
attempts to

minimize (cid:107)w(cid:107),
subject to yi(w   xi     b)     1,for i = 1, . . . , n

(2.4)
(2.5)

the weights w and b determine the id166 classi   er. the xi vectors that lie nearest
to the derived hyperplane are called support vectors. the above problem is solvable
if the training data is linearly separable (also known as a hard-margin classi   cation
task; see fig. 2.14). if the data is not linearly separable (soft-margin) the id166
instead attempts to

minimize

max (0,1    yi(w   xi     b))

+   ||w||2

(2.6)

which equals   ||w||2 if the hard constraints of equation 2.5 are satis   ed   i.e., if
all data points are correctly classi   ed on the right side of the margin. the value of
equation (2.6) is proportional to the distance from the margin for misclassi   ed data
and    is designed so as to qualitatively determine the degree to which the margin-
size should be increased versus ensuring that the xi will lie on the correct side of the

(cid:34)

1
n

n

   

i=1

(cid:35)

2.5. supervised learning

67

fig. 2.14 an example of a maximum-margin hyperplane (red thick line) and margins (black lines)
for an id166 which is trained on data samples from two classes. solid and empty circles correspond
to data with labels 1 and    1, respectively. the classi   cation is mapped onto a two-dimensional
input vector (x1,x2) in this example. the two data samples on the margin   the circles depicted
with red outline   are the support vectors.

margin. evidently, if we choose a small value for    we approximate the hard-margin
classi   er for linearly separable data.

the standard approach for training soft-margin classi   ers is to treat the learning
task as a quadratic programming problem and search the space of w and b to    nd
the widest possible margin that matches all data points. other approaches include
sub-id119 and coordinate descent.

in addition to linear classi   cation tasks, id166s can support non-linear classi   -
cation by employing a number of different non-linear kernels which map the in-
put space onto higher-dimensional feature spaces. the id166 task remains similar,
except that every dot product is replaced by a nonlinear id81. this al-
lows the algorithm to    t the maximum-margin hyperplane in a transformed feature
space. popular kernels used in conjunction with id166s include polynomial func-
tions, gaussian radial basis functions or hyperbolic tangent functions.

68

chapter 2. ai methods

while id166s were originally designed to tackle binary classi   cation problems
there exist several id166 variants that can tackle multi-class classi   cation [284], re-
gression [179] and preference learning [302] that the interested reader can refer to.
id166s have a number of advantages compared to other supervised learning ap-
proaches. they are ef   cient in    nding solutions when dealing with large, yet sparse,
datasets as they only depend on support vectors to construct hyperplanes. they also
handle well large feature spaces as the learning task complexity does not depend on
the dimensionality of the feature space. id166s feature a simple id76
problem which can be guaranteed to converge to a single global solution. finally,
over   tting can be controlled easily through the soft margin classi   cation approach.

2.5.2.1 id166s for ms pac-man

similarly to anns, id166s can be used for imitating the behavior of ms pac-man
expert players. the considerations about the feature (input) space and the action
(output) space remain the same. in addition to the design of the input and output
vectors, the size and quality of the data obtained from expert players will determine
the performance of the id166 controlling ms pac-man towards maximizing its score.

2.5.3 decision tree learning

in decision tree learning [67], the function f we attempt to derive uses a decision
tree representation which maps attributes of data observations to their target values.
the former (inputs) are represented as the nodes and the latter (outputs) are repre-
sented as the leaves of the tree. the possible values of each node (input) are repre-
sented by the various branches of that node. as with the other supervised learning
algorithms, id90 can be classi   ed depending on the output data type they
attempt to learn. in particular, id90 can be distinguished into classi   cation,
regression and rank trees if, respectively, the target output is a    nite set of values, a
set of continuous (interval) values, or a set of ordinal relations among observations.
an example of a decision tree is illustrated in fig. 2.15. tree nodes correspond
to input attributes; there are branches to children for each of the possible values of
each input attribute. further leaves represent values of the output   car type in this
example   given the values of the input attributes as determined by the path from
the root to the leaf.

the goal of decision tree learning is to construct a mapping (a tree model) that
predicts the value of target outputs based on a number of input attributes. the basic
and most common approach for learning id90 from data follows a top-
down recursive tree induction strategy which has the characteristics of a greedy
process. the algorithm assumes that both the input attributes and the target outputs
have    nite discrete domains and are of categorical nature. if inputs or outputs are
continuous values, they can be discretized prior to constructing the tree. a tree is

2.5. supervised learning

69

fig. 2.15 a decision tree example: given age, employment status and salary (data attributes) the
tree predicts the type of car (target value) a person owns. tree nodes (blue rounded rectangles)
represent data attributes, or inputs, whereas leaves (gray ovals) represent target values, or outputs.
tree branches represent possible values of the corresponding parent node of the tree.

.

gradually constructed by splitting the available training dataset into subsets based
on selections made for the attributes of the dataset. this process is repeated on a
attribute-per-attribute basis in a recursive manner.

there are several variants of the above process that lead to dissimilar decision-
tree algorithms. the two most notable variants of decision tree learning, however,
are the iterative dichotomiser 3 ( ) [544] and its successor c4.5 [545]. the
basic tree learning algorithm has the following general steps:

1. at start, all the training examples are at the root of the tree.
2. select an attribute on the basis of a heuristic and pick the attribute with the

maximum heuristic value. the two most popular heuristics are as follows:
    information gain: this heuristic is used by both the   and the c4.5
tree-generation algorithms. information gain g(a) is based on the con-
cept of id178 from id205 and measures the difference in
id178 h from before to after the dataset d is split on an attribute a.

g(a) = h(d)    ha(d)
(2.7)
where h(d) is the id178 of d (h(d) =       m
i pi log2(pi)); pi is the
id203 that an arbitrary sample in d belongs to class i; m is the total
number of classes; ha(d) is the information needed (after using attribute
a to split d into v partitions) to classify d and is calculated as ha(d) =
      v

j(|d j|/|d|)h(d j) with |x| being the size of x.

70

chapter 2. ai methods

    gain ratio: the c4.5 algorithm uses the gain ratio heuristic to reduce the
bias of information gain towards attributes with a large number of values.
the gain ratio normalizes information gain by taking into account the
number and size of branches when choosing an attribute. the information
gain ratio is the ratio between the information gain and the intrinsic value
iva of attribute a:

where

gr(a) = g(a)/iva(d)

iva(d) =     v
   

j

|d j|
|d| log2(

|d j|
|d| )

(2.8)

(2.9)

3. based on the selected attribute from step 2, construct a new node of the
tree and split the dataset into subsets according to the possible values of the
selected attribute. the possible values of the attribute become the branches
of the node.

4. repeat steps 2 and 3 until one of the following occurs:

    all samples for a given node belong to the same class.
    there are no remaining attributes for further partitioning.
    there are no data samples left.

2.5.3.1 id90 for ms pac-man

as with anns and id166s, decision tree learning requires data to be trained on.
presuming that data from expert ms pac-man players would be of good quality
and quantity, id90 can be constructed to predict the strategy of ms pac-
man based on a number of ad-hoc designed attributes of the game state. figure
2.16 illustrates a simpli   ed hypothetical decision tree for controlling ms pac-man.
according to that example if a ghost is nearby then ms pac-man checks if power
pills are available in a close distance and aims for those; otherwise it takes actions so
that it evades the ghost. if alternatively, ghosts are not visible ms pac-man checks
for pellets. if those are nearby or in a fair distance then it aims for them; otherwise
it aims for the fruit, if that is available on the level. it is important to note that the
leaves of the tree in our example represent control strategies (macro-actions) rather
than actual actions (up, down, left, right) for ms pac-man.

2.6. id23

71

fig. 2.16 a decision tree example for controlling ms pac-man. the tree is trained on data from
expert ms pac-man players. given the distance from the nearest ghost, power pill and pellet (data
attributes) the tree predicts the strategy ms pac-man needs to follow.

2.5.4 further reading

the core supervised learning algorithms are covered in detail in the russell and
norvig classic ai textbook [582] including decision tree learning (chapter 18) and
arti   cial neural networks (chapter 19). detailed descriptions of arti   cial neural net-
works and id26 can also be found in the book of haykin [253]. deep
architectures of anns are covered in great detail in the deep learning book by good-
fellow et al. [231]. finally, support vector machines are covered in the tutorial paper
of burges [86].

the preference learning version of id26 in shallow and deep archi-
tectures can be found in [430, 436] whereas rankid166 is covered in the original
paper of joachims [303].

2.6 id23

id23 (rl) [672] is a machine learning approach inspired by
behaviorist psychology and, in particular, the way humans and animals learn to take
decisions via (positive or negative) rewards received by their environment. in rein-
forcement learning, samples of good behavior are usually not available (as in su-
pervised learning); instead, similarly to evolutionary (reinforcement) learning, the
training signal of the algorithm is provided by the environment based on how an
agent is interacting with it. at a particular point in time t, the agent is on a particular
state s and decides to take an action a from all the available actions in its current
state. as a response the environment delivers an immediate reward, r. through

72

chapter 2. ai methods

fig. 2.17 a id23 example. the agent (triangle) attempts to reach the goal (g)
by taking an action (a) among all available actions in its current state (s). the agent receives an
immediate reward (r) and the environment noti   es the agent about its new state after taking the
action.

.

the continuous interaction between the agent and its environment, the agent gradu-
ally learns to select actions that maximize its sum of rewards. rl has been studied
from a variety of disciplinary perspectives including operations research, game the-
ory, id205, and id107 and has been successfully applied in
problems which involve a balance between long-term and short-term rewards such
as robot control and games [464, 629]. an example of the reinforcement problem is
illustrated through a maze navigation task in fig. 2.17.

more formally, the aim of the agent is to discover a policy (  ) for selecting
actions that maximize a measure of a long-term reward such as the expected cumu-
lative reward. a policy is a strategy that the agent follows in selecting actions, given
the state it is in. if the function that characterizes the value of each action either
exists or is learned, the optimal policy (     ) can be derived by selecting the action
with the highest value. the interactions with the environment occur in discrete time
steps (t = {0,1,2, . . .}) and are modeled as a markov decision process (mdp). the
mdp is de   ned by
    s: a set of states {s1, ...,sn}     s. the environment states are a function of the
    a: a set of actions {a1, ...,am}     a possible in each state s. the actions represent
the different ways the agent can act in the environment.
    p(s,s(cid:48),a): the id203 of transition from s to s(cid:48) given a. p gives the prob-
ability of ending in state s(cid:48) after picking action a in state s and it follows the
markov property implying that future states of the process depend only upon
the present state, not on the sequence of events that preceded it. as a result, the
markov property of p makes predictions of 1-step dynamics possible.
    r(s,s(cid:48),a): the reward function on transition from s to s(cid:48) given a. when the agent
in state s picks an action a and moves to state s(cid:48), it receives an immediate reward
r from the environment.

agent   s information about the environment (i.e., the agent   s inputs).

2.6. id23

73

p and r de   ne the world model and represent, respectively, the environment   s
dynamics (p) and the long-term reward (r) for each policy. if the world model is
known there is no need to learn to estimate the transition id203 and reward
function and we thus directly calculate the optimal strategy (policy) using model-
based approaches such as id145 [44]. if, instead, the world model
is unknown we approximate the transition and the reward functions by learning es-
timates of future rewards given by picking action a in state s. we then calculate
our policy based on these estimates. learning occurs via model-free methods such
as monte carlo search and temporal difference learning [672]. in this section we
put an emphasis on the latter set of algorithms and in particular, we focus on the
most popular algorithm of td learning: id24. before delving into the details
of the id24 algorithm, we    rst discuss a few core rl concepts and provide a
high-level taxonomy of rl algorithms according to rl problems and tools used for
tackling them. we will use this taxonomy to place id24 with respect to rl as
a whole.

2.6.1 core concepts and a high-level taxonomy

a central question in rl problems is the right balance between the exploitation of
current learned knowledge versus the exploration of new unseen territories in the
search space. both randomly selecting actions (no exploitation) and always greed-
ily selecting the best action according to a measure of performance or reward (no
exploration) are strategies that generally yield poor results in stochastic environ-
ments. while several approaches have been proposed in the literature to address
the exploration-exploitation balance issue, a popular and rather ef   cient mechanism
for rl action selection is called   -greedy, determined by the        [0,1] parameter.
according to   -greedy the rl agent chooses the action it believes will return the
highest future reward with id203 1       ; otherwise, it chooses an action uni-
formly at random.

rl problems can be classi   ed into episodic versus incremental. in the former
class, algorithm training occurs of   ine and within a    nite horizon of multiple train-
ing instances. the    nite sequence of states, actions and reward signals received
within that horizon is called an episode. monte carlo methods that rely on repeated
random sampling, for instance, are a typical example of episodic rl. in the lat-
ter class of algorithms, instead, learning occurs online and it is not bounded by an
horizon. we meet td learning under incremental rl algorithms.

another distinction is between off-policy and on-policy rl algorithms. an off-
policy learner approximates the optimal policy independently of the agent   s actions.
as we will see below, id24 is an off-policy learner since it estimates the return
for state-action pairs assuming that a greedy policy is followed. an on-policy rl
algorithm instead approximates the policy as a process being tied to the agent   s
actions including the exploration steps.

74

chapter 2. ai methods

id64 is a central notion within rl that classi   es algorithms based on
the way they optimize state values. id64 estimates how good a state is
based on how good we think the next state is. in other words, with id64
we update an estimate based on another estimate. both td learning and dynamic
programming use id64 to learn from the experience of visiting states and
updating their values. monte carlo search methods instead do not use id64
and thus learn each state value separately.

finally, the notion of backup is central in rl and acts as a distinctive feature
among rl algorithms. with backup we go backwards from a state in the future,
st+h, to the (current) state we want to evaluate, st, and consider the in-between state
values in our estimates. the backup operation has two main properties: its depth   
which varies from one step backwards to a full backup   and its breadth   which
varies from a (randomly) selected number of sample states within each time step to
a full-breadth backup.

based on the above criteria we can identify three major rl algorithm types:

1. id145. in id145 knowledge of the world
model (p and r) is required and the optimal policy is calculated via bootstrap-
ping.

2. monte carlo methods. knowledge of the world model is not required for
monte carlo methods. algorithms of this class (e.g., mcts) are ideal for off-
line (episodic) training and they learn via sample-breadth and full-depth backup.
monte carlo methods do not use id64, however.

3. td learning. as with monte carlo methods knowledge of the world model is
not required and it is thus estimated. algorithms of this type (e.g., id24)
learn from experience via id64 and variants of backup.
in the following section we cover the most popular td learning algorithm in the

rl literature with the widest use in game ai research.

2.6.2 id24

id24 [748] is a model-free, off-policy, td learning algorithm that relies on
a tabular representation of q(s,a) values (hence its name). informally, q(s,a) rep-
resents how good it is to pick action a in state s. formally, q(s,a) is the expected
discounted reinforcement of taking action a in state s. the id24 agent learns
from experience by picking actions and receiving rewards via id64.

the goal of the id24 agent is to maximize its expected reward by pick-
ing the right action at each state. the reward, in particular, is a weighted sum of
the expected values of the discounted future rewards. the id24 algorithm is
a simple update on the q values in an iterative fashion. initially, the q table has
arbitrary values as set by the designer. then each time the agent selects an action

2.6. id23

75
a from state s, it visits state s(cid:48), it receives an immediate reward r, and updates its
q(s,a) value as follows:

a(cid:48) q(s(cid:48),a(cid:48))    q(s,a)}

q(s,a)     q(s,a) +   {r +    max

(2.10)
where        [0,1] is the learning rate and        [0,1] is the discount factor. the
learning rate determines the extent to which the new estimate for q will override
the old estimate. the discount factor weights the importance of earlier versus later
rewards; the closer    is to 1, the greater the weight is given to future reinforcements.
as seen from equation (2.10), the algorithm uses id64 since it maintains
estimates of how good a state-action pair is (i.e., q(s,a)) based on how good it thinks
the next state is (i.e., q(s(cid:48),a(cid:48))). it also uses a one-step-depth, full-breadth backup to
estimate q by taking into consideration all q values of all possible actions a(cid:48) of
the newly visited state s(cid:48). it is proven that by using the learning rule of equation
(2.10) the q(s,a) values converge to the expected future discounted reward [748].
the optimal policy can then be calculated based on the q-values; the agent in state
s selects the action a with the highest q(s,a) value. in summary, the basic steps of
the algorithm are as follows:

given an immediate reward function r and a table of q(s,a) values for all pos-
sible actions in each state:
1. initialize the table with arbitrary q values; e.g., q(s,a) = 0.
2. s     start state.
3. while not    nished* do:

(a) choose an action a based on policy derived from q (e.g.,   -greedy).
(b) apply the action, transit to state s(cid:48), and receive an immediate reward

r.

(c) update the value of q(s,a) as per (2.10).
(d)

s     s(cid:48).

*the most commonly used termination conditions are the algorithm   s speed   
i.e., stop within a number of iterations   or the quality of convergence   i.e.,
stop if you are satis   ed with the obtained policy.

2.6.2.1 limitations of id24

id24 has a number of limitations associated primarily with its tabular repre-
sentation. first of all, depending on the chosen state-action representation the size
of the state-action space might be computationally very expensive to handle. as
the q table size grows our computational needs for memory allocation and infor-
mation retrieval increase. further, we may experience very long convergence since
learning time is exponential to the size of the state-action space. to overcome these

76

chapter 2. ai methods

obstacles and get decent performance from rl learners we need to devise a way of
reducing the state-action space. section 2.8 outlines the approach of using arti   cial
neural networks as q-value function approximators, directly bypassing the q-table
limitation and yielding compressed representations for our rl learner.

2.6.2.2 id24 for ms pac-man

id24 is applicable for controlling ms pac-man as long as we de   ne a suitable
state-action space and we design an appropriate reward function. a state in ms pac-
man could be represented directly as the current snapsnot of the game   i.e., where
ms pac-man and ghosts are and which pellets and power pills are still available.
that representation, however, yields a prohibitive number of game states for a q-
table to be constructed and processed. instead, it might be preferred to choose a
more indirect representation such as whether ghosts and pellets are nearby or not.
possible actions for ms pac-man could be that it either keeps its current direction,
it turns backward, it turns left, or it turns right. finally, the reward function can be
designed to reward ms pac-man positively when it eats a pellet, a ghost or a power
pill, whereas it could penalize ms pac-man when it dies.

it is important to note that both pac-man and ms pac-man follow the markov
property in the sense that any future game states may depend only upon the present
game state. there is one core difference however: while the transition id203 in
pac-man is known given its deterministic nature, it is largely unknown in ms pac-
man given the stochastic behavior of the ghosts in that game. thereby, pac-man can
theoretically be solved via model-based approaches (e.g., id145)
whereas the world model of ms pac-man can only be approximated via model-free
methods such as temporal difference learning.

2.6.3 further reading

the rl book of sutton and barto [672] is highly recommended for a thorough
presentation of rl including id24 (chapter 6). the book is freely available
online.6 a draft version of the latest (2017) version of the book is also available.7
the survey paper of kaelbling et al. [316] is another recommended reading of the
approaches covered. finally, for an in-depth analysis of model-based rl approaches
you are referred to the id145 book of bertsekas [44].

6 http://incompleteideas.net/sutton/book/ebook/the-book.html
7 http://incompleteideas.net/sutton/book/the-book-2nd.html

2.7. unsupervised learning

2.7 unsupervised learning

77

as stated earlier, the utility type (or training signal) determines the class of the ai
algorithm. in supervised learning the training signal is provided as data labels (target
outputs) and in id23 it is derived as a reward from the environ-
ment. unsupervised learning instead attempts to discover associations of the input
by searching for patterns among all input data attributes and without having access
to a target output   a machine learning process that is usually inspired by hebbian
learning [256] and the principles of self-organization [20]. with unsupervised learn-
ing we focus on the intrinsic structure of and associations in the data instead of
attempting to imitate or predict target values. we cover two unsupervised learning
tasks with corresponding algorithms: id91 and frequent pattern mining.

2.7.1 id91

id91 is the unsupervised learning task of    nding unknown groups of a num-
ber of data points so that data within a group (or else, cluster) is similar to each
other and dissimilar to data from other clusters. id91 has found applications in
detecting groups of data across multiple attributes and in data reduction tasks such
as data compression, noise smoothing, outlier detection and dataset partition. clus-
tering is of key importance for games with applications in player modeling, game
playing and content generation.

as with classi   cation, id91 places data into classes; the labels of the classes,
however, are unknown a priori and id91 algorithms aim to discover them by
assessing their quality iteratively. since the correct clusters are unknown, similar-
ity (and dissimilarity) depends only on the data attributes used. good clusters are
characterized by two core properties: 1) high intra-cluster similarity, or else, high
compactness and 2) low inter-cluster similarity, or else, good separation. a popular
measure of compactness is the average distance between every sample in the cluster
and the closest representative point   e.g., centroid   as used in the id116 algo-
rithm. examples of separation measures include the single link and the complete
link: the former is the smallest distance between any sample in one cluster and any
sample in the other cluster; the latter is the largest distance between any sample in
one cluster and any sample in the other cluster. while compactness and separation
are objective measures of cluster validity, it is important to note that they are not
indicators of cluster meaningfulness.

beyond the validity metrics described above, id91 algorithms are de   ned by
a membership function and a search procedure. the membership function de   nes
the structure of the clusters in relation to the data samples. the search procedure is
a strategy we follow to cluster our data given a membership function and a validity
metric. examples of such strategies include splitting all data points into clusters at
once (as in id116), or recursively merging (or splitting) clusters (as in hierarchical
id91).

78

chapter 2. ai methods

id91 can be realized via a plethora of algorithms including hierarchical
id91, id116 [411], k-medoids [329], dbscan [196] and self-organizing
maps [347]. the algorithms are dissimilar in the way they de   ne what a cluster
is and how they form it. selecting an appropriate id91 algorithm and its cor-
responding parameters, such as which distance function to use or the number of
clusters to expect, depends on the aims of the study and the data available. in the
remainder of the section we outline the id91 algorithms we    nd to be the most
useful for the study of ai in games.

2.7.1.1 id116 id91

id116 [411] is a vector quantization method that is considered the most popular
id91 algorithm as it offers a good balance between simplicity and effective-
ness. it follows a simple data partitioning approach according to which it partitions
a database of objects into a set of k clusters, such that the sum of squared euclidean
distances between data points and their corresponding cluster center (centroid) is
minimized   this distance is also known as the quantization error.

in id116 each cluster is de   ned by one point, that is the centroid of the clus-
ter, and each data sample is assigned to the closest centroid. the centroid is the
mean of the data samples in the cluster. the intra-cluster validity metric used by
id116 is the average distance to the centroid. initially, the data samples are ran-
domly assigned to a cluster and then the algorithm proceeds by alternating between
the re-assignment of data into clusters and the update of the resulting centroids. the
basic steps of the algorithm are as follows:

given k
1. randomly partition the data points into k nonempty clusters.
2. compute the position of the centroids of the clusters of the current partition-

ing. centroids are the centers (mean points) of the clusters.

3. assign each data point to the cluster with the nearest centroid.
4. stop when the assignment does not change; otherwise go to step 2.

while id116 is very popular due to its simplicity it has a number of con-
siderable weaknesses. first, it is applicable only to data objects in a continuous
space. second, one needs to specify the number of clusters, k, in advance. third,
it is not suitable to discover clusters with non-convex shapes as it can only    nd
hyper-spherical clusters. finally, id116 is sensitive to outliers as data points with
extremely large (or small) values may substantially distort the distribution of the
data and affect the performance of the algorithm. as we will see below, hierarchical
id91 manages to overcome some of the above drawbacks, suggesting a useful
alternative approach to data id91.

2.7. unsupervised learning

2.7.1.2 hierarchical id91

79

id91 methods that attempt to build a hierarchy of clusters fall under the hi-
erarchical id91 approach. generally speaking there are two main strategies
available: the agglomerative and the divisive. the former constructs hierarchies in
a bottom-up fashion by gradually merging data points together, whereas the lat-
ter constructs hierarchies of clusters by gradually splitting the dataset in a top-down
fashion. both id91 strategies are greedy. hierarchical id91 uses a distance
matrix as the id91 strategy (whether agglomerative or divisive). this method
does not require the number of clusters k as an input, but needs a termination con-
dition.

indicatively, we present the basic steps of the agglomerative id91 algorithm

which are as follows:

given k
1. create one cluster per data sample.
2. find the two closest data samples   i.e.,    nd the shortest euclidean distance

between two points (single link)   which are not in the same cluster.

3. merge the clusters containing these two samples.
4. stop if there are k clusters; otherwise go to step 2.

in divisive hierarchical id91 instead, all data are initially in the same cluster
which is split until every data point is on its own cluster following a split strategy   
e.g., divisive analysis id91 (diana) [330]   or employing another cluster-
ing algorithm to split the data in two clusters   e.g., 2-means.

once clusters of data are iteratively merged (or split), one can visualize the clus-
ters by decomposing the data into several levels of nested partitioning. in other
words, one can observe a tree representation of clusters which is also known as a
dendrogram. the id91 of data is obtained by cutting the dendrogram at the
desired level of squared euclidean distance. for the interested reader, a dendrogram
example is illustrated in chapter 5.

hierarchical id91 represents clusters as the set of data samples contained in
them and, as a result, a data sample belongs to the same cluster as its closest sample.
in id116 instead, each cluster is represented by a centroid and thus a data sample
belongs to the cluster represented by the closest centroid. further, when it comes to
cluster validity metrics, agglomerative id91 uses the shortest distance between
any sample in one cluster and a sample in another whereas id116 uses the average
distance to the centroid. due to these different algorithmic properties hierarchical
id91 has the capacity to cluster data that come in any form of a connected
shape; id116, on the other hand, is only limited to hyper-spherical clusters.

80

chapter 2. ai methods

2.7.1.3 id91 for ms pac-man

one potential application of id91 for controlling ms pac-man would be to
model ghost behaviors and use that information as an input to the controller of
ms pac-man. whether it is id116 or hierarchical id91, the algorithm would
consider different attributes of ghost behavior   such as level exploration, behavior
divergence, distance between ghosts, etc.   and cluster the ghosts into behavioral
patterns or pro   les. the controller of ms pac-man would then consider the ghost
pro   le met in a particular level as an additional input for guiding the agent better.

arguably, beyond agent control, we can think of better uses of id91 for this
game such as pro   ling ms pac-man players and generating appropriate levels or
challenges for them so that the game is balanced. as mentioned earlier, however,
the focus of the ms pac-man examples is on the control of the playing agent for the
purpose of maintaining a consistent paradigm throughout this chapter.

2.7.2 frequent pattern mining

frequent pattern mining is a set of techniques that attempt to derive frequent
patterns and structures in data. patterns include sequences and itemsets. frequent
pattern mining was    rst proposed for mining association rules [6], which aims to
identify a number of data attributes that frequently associate to each other, thereby
forming conditional rules among them. there are two types of frequent pattern min-
ing that are of particular interest for game ai: frequent itemset mining and fre-
quent sequence mining. the former aims to    nd structure among data attributes
that have no particular internal order whereas the latter aims to    nd structure among
data attributes based on an inherent temporal order. while associated with the unsu-
pervised learning paradigm, frequent pattern mining is dissimilar in both the aims
and the algorithmic procedures it follows.

popular and scalable frequent pattern mining methods include the apriori al-
gorithm [6] for itemset mining, and spade [793] and gsp [652, 434, 621] for
sequence mining. in the remainder of this section we outline apriori and gsp as
representative algorithms for frequent itemset and frequent sequence mining, re-
spectively.

2.7.2.1 apriori

apriori [7] is an algorithm for frequent itemset mining. the algorithm is appropriate
for mining datasets that contain sets of instances (also named transactions) that each
feature a set of items, or an itemset. examples of transactions include books bought
by an amazon customer or apps bought by a smartphone user. the algorithm is
very simple and can be described as follows: given a predetermined threshold named
support (t ), apriori detects the itemsets which are subsets of at least t transactions

2.7. unsupervised learning

81

in the database. in other words, apriori will attempt to identify all itemsets that have
at least a minimum support which is the minimum number of times an itemset exists
in the dataset.

to demonstrate apriori in a game example, below we indicatively list events

shield of the magi>

from four players of an online role playing game:
    <completed more than 10 levels; most achievements unlocked; bought the
    <completed more than 10 levels; bought the shield of the magi>
    <most achievements unlocked; bought the shield of the magi; found the wiz-
    <most achievements unlocked; found the wizard   s purple hat; completed more

ard   s purple hat>

than 10 levels; bought the shield of the magi>

if in the example dataset above we assume that the support is 3, the following
1-itemsets (sets of only one item) can be found: <completed more than 10 levels>,
<most achievements unlocked> and <bought the shield of the magi>. if instead,
we seek 2-itemsets with a support threshold of 3 we can    nd <completed more than
10 levels, bought the shield of the magi>, as three of the transactions above contain
both of these items. longer itemsets are not available (not frequent) for support
count 3. the process can be repeated for any support threshold we wish to detect
frequent itemsets for.

2.7.2.2 generalized sequential patterns

frequent itemset mining algorithms are not adequate if the sequence of events is
the critical information we wish to mine from a dataset. the dataset may contain
events in an ordered set of sequences such as temporal sequence data or time series.
instead, we need to opt for a frequent sequence mining approach. the sequence min-
ing problem can be simply described as the process of    nding frequently occurring
subsequences given a sequence or a set of sequences.

more formally, given a dataset in which each sample is a sequence of events,
namely a data sequence, a sequential pattern de   ned as a subsequence of events is
a frequent sequence if it occurs in the samples of the dataset regularly. a frequent
sequence can be de   ned as a sequential pattern that is supported by, at least, a min-
imum amount of data-sequences. this amount is determined by a threshold named
minimum support value. a data sequence supports a sequential pattern if and only
if it contains all the events present in the pattern in the same order. for example, the
data-sequence < x0,x1,x2,x3,x4,x5 > supports the pattern < x0,x5 >. as with fre-
quent itemset mining, the amount of data sequences that support a sequential pattern
is referred as the support count.

the generalized sequential patterns (gsp) algorithm [652] is a popular method
for mining frequent sequences in data. gsp starts by extracting the frequent se-
quences with a single event, namely 1-sequences. that set of sequences is self-
joined to generate all 2-sequence candidates for which we calculate their support

82

chapter 2. ai methods

count. those sequences that are frequent (i.e., their support count is greater than a
threshold value) are then self-joined to generate the set of 3-sequence candidates.
the algorithm is gradually increasing the length of the sequences in each algorith-
mic step until the next set of candidates is empty. the basic principle of the algo-
rithm is that if a sequential pattern is frequent, then its contiguous subsequences are
also frequent.

2.7.2.3 frequent pattern mining for ms pac-man

patterns of events of sequences can be extracted to assist the control of ms pac-man.
itemsets may be identi   ed across successful events of expert ms pac-man play-
ers given a particular support count. for instance, an apriori algorithm running on
events across several different expert players might reveal that a frequent 2-itemset
is the following: <player went for the upper left corner    rst, player ate the bottom
right power pill    rst>. such information can be useful explicitly for designing rules
for controlling ms pac-man.

beyond itemsets, frequencies of ghost events can be considered for playing ms
pac-man. for example, by running gsp on extracted attributes of ghosts it might
turn out that when ms pac-man eats a power pill it is very likely that the blinky
ghost moves left (<power pill, blinky left>). such frequent sequences can form
additional inputs of any ms pac-man controller   e.g., an ann. chapter 5 details
an example on this frequent sequence mining approach in a 3d prey-predator game.

2.7.3 further reading

a general introduction to frequent pattern mining is offered in [6]. the apriori
algorithm is detailed in the original article of agrawal and srikant [7] whereas gsp
is covered throughly in [652].

2.8 notable hybrid algorithms

ai methods can be interwoven in numerous ways to yield new sophisticated algo-
rithms that aggregate the strengths of their combined parts, often with an occurring
gestalt effect. you can, for instance, let gas evolve your behavior trees or id122s;
you can instead empower mcts with ann estimators for tree pruning; or you can
add a component of local search in every search algorithm covered earlier. we name
the resulting combinations of ai methods as hybrid algorithms and in this section
we cover the two most in   uential, in our opinion, hybrid game ai algorithms: neu-
roevolution and temporal difference learning with ann function approximators.

2.8. notable hybrid algorithms

2.8.1 neuroevolution

83

the evolution of arti   cial neural networks, or else neuroevolution, refers to the
design of arti   cial neural networks   their connection weights, their topology, or
both   using evolutionary algorithms [786]. neuroevolution has been successfully
applied in the domains of arti   cial life, robot control, generative systems and com-
puter games. the algorithm   s wide applicability is primarily due to two main rea-
sons. first, many ai problems can be viewed as function optimization problems
whose underlying general function can be approximated via an ann. second, neu-
roevolution is a method grounded in biological metaphors and evolutionary theory
and inspired by the way brains evolve [567].

this evolutionary (reinforcement) learning approach is applicable either when
the error function available is not differentiable or when target outputs are not avail-
able. the former may occur, for instance, when the id180 employed
in the ann are not continuous and, thus, not differentiable. (this is a prominent
phenomenon, for instance, in the compositional pattern producing networks [653].)
the latter may occur in a domain for which we have no samples of good (or bad)
behavior or it is impossible to de   ne objectively what a good behavior might be. in-
stead of backpropagating the error and adjusting the ann based on gradient search,
neuroevolution designs anns via metaheuristic (evolutionary) search. in contrast to
supervised learning, neuroevolution does not require a dataset of input-output pairs
to train anns. rather, it requires only a measure of a ann   s performance on the
problem under investigation, for instance, the score of a game playing agent that is
controlled by an ann.

the core algorithmic steps of neuroevolution are as follows:

1. a population of chromosomes that represent anns is evolved to optimize
a    tness function that characterizes the utility (quality) of the ann repre-
sentation. the population of chromosomes (anns) is typically initialized
randomly.

2. each chromosome is encoded into an ann which is, in turn, tested on the

task under optimization.

3. the testing procedure assigns a    tness value for each ann of the popula-
tion. the    tness of an ann de   nes its measure of performance on the task.
4. once the    tness values for all genotypes in the current population are deter-
mined, a selection strategy (e.g., roulette-wheel, tournament) is applied to
pick the parents for the next generation.

5. a new population of offspring is generated by applying genetic operators
on the selected ann-encoded chromosomes. mutation and/or crossover are
applied on the chromosomes in the same way as in any evolutionary algo-
rithm.

6. a replacement strategy (e.g., steady-state, elitism, generational) is applied

to determine the    nal members of the new population.

84

chapter 2. ai methods

7. similarly to a typical evolutionary algorithm, the generational loop (steps 2
to 6) is repeated until we exhaust our computational budget or we are happy
with the obtained    tness of the current population.

typically there are two types of neuroevolution approaches: those that consider
the evolution of a network   s connection weights only and those that evolve both the
connection weights and the topology of the network (including connection types
and id180). in the former type of neuroevolution, the weight vector is
encoded and represented genetically as a chromosome; in the latter type, the genetic
representation includes an encoding of the ann topology. beyond simple mlps,
the ann types that have been considered for evolution include the neuroevolution
of augmenting topologies (neat) [655] and the compositional pattern producing
networks [653].

neuroevolution has found extensive use in the games domain in roles such as
those of evaluating the state-action space of a game, selecting an appropriate ac-
tion, selecting among possible strategies, modeling opponent strategies, generating
content, and modeling player experience [567]. the algorithm   s ef   ciency, scalabil-
ity, broad applicability, and open-ended learning are a few of the reasons that make
neuroevolution a good general method for many game ai tasks [567].

2.8.1.1 neuroevolution for ms pac-man

one simple way to implement neuroevolution in ms pac-man is to    rst design an
ann that considers the game state as input and output actions for ms pac-man.
the weights of the ann can be evolved using a typical evolutionary algorithm
and following the steps of neuroevolution as described above. the    tness of each
ann in the population is obtained by equipping ms pac-man with each ann in the
population and letting her play the game for a while. the performance of the agent
within that simulation time (e.g., the score) can determine the    tness value of the
ann. figure 2.18 illustrates the steps of ann encoding and    tness assignment in
this hypothetical implementation of neuroevolution in ms pac-man.

2.8.2 td learning with ann function approximators

id23 typically uses tabular representations to store knowledge.
as mentioned earlier in the rl section, representing knowledge this way may drain
our available computational resources since the size of the look-up table increases
exponentially with respect to the action-state space. the most popular way of ad-
dressing this challenge is to use an ann as a value (or q value) approximator,
thereby replacing the table. doing so makes it possible to apply the algorithm to

2.8. notable hybrid algorithms

85

fig. 2.18 neuroevolution in ms pac-man. the    gure visualizes step 2 (ann encoding) and step
3 (   tness assignment) of the algorithm for assigning a    tness value to chromosome 2 in the popu-
lation (of size p). in this example, only the weights of the ann are evolved. the n weights of the
chromosome are    rst encoded in the ann and then the ann is tested in ms pac-man for a number
of simulation steps (or game levels). the result of the game simulation determines the    tness value
( f2) of the ann.

larger spaces of action-state representations. further, an ann as a function approx-
imator of q, for instance, can handle problems with continuous state spaces which
are in   nitely large.

in this section, we outline two milestone examples of algorithms that utilize the
ann universal approximation capacity for temporal difference learning. the al-
gorithms of td-gammon and deep q network have been applied, respectively, to
master the game of backgammon and play atari 2600 arcade games at super-human
level. both algorithms are applicable to any rl task beyond these particular games,
but the games that made them popular are used to describe the algorithms below.

2.8.2.1 td-gammon

arguably one of the most popular success stories of ai in games is that of tesauro   s
td-gammon software that plays backgammon on the grandmaster-level [689]. the
learning algorithm was a hybrid combination of an mlp and a temporal difference

86

chapter 2. ai methods

variant named td(   ); see chapter 7 of [672] for further details on the td(   ) algo-
rithm.

td-gammon used a standard multilayer neural network to approximate the value
function. the input of the mlp was a representation of the current state of the board
(tesauro used 192 inputs) whereas the output of the mlp was the predicted proba-
bility of winning given the current state. rewards were de   ned as zero for all board
states except those on which the game was won. the mlp was then trained itera-
tively by playing the game against itself and selecting actions based on the estimated
id203 of winning. each game was treated as a training episode containing a
sequence of positions which were used to train the weights of the mlp by back-
propagating temporal difference errors of its output.

td-gammon 0.0 played about 300,000 games against itself and managed to
play as well as the best backgammon computer of its time. while td-gammon
0.0 did not win the performance horse race, it gave us a    rst indication of what is
achievable with rl even without any backgammon expert knowledge integrated in
the ai algorithm. the next iteration of the algorithm (td-gammon 1.0) naturally
incorporated expert knowledge through specialized backgammon features that al-
tered the input of the mlp and achieved substantially higher performance. from
that point onwards the number of hidden neurons and the number of self-payed
games determined greatly the version of the algorithm and its resulting capacity.
from td-gammon 2.0 (40 hidden neurons) to td-gammon 2.1 (80 hidden neu-
rons) the performance of td-gammon gradually increased and, with td gammon
3.0 (160 hidden neurons), it reached the playing strength of the best human player
in backgammon [689].

2.8.2.2 deep q network

while the combination of rl and anns results in very powerful hybrid algorithms,
the performance of the algorithm traditionally depended on the design of the in-
put space for the ann. as we saw earlier, even the most successful applications
of rl such as the td-gammon agent managed to reach human-level playing per-
formance by integrating game speci   c features in the input space, thereby adding
expert knowledge about the game. it was up until very recently that the combination
of rl and anns managed to reach human-level performance in a game without
considering ad-hoc designed features but rather discovering them merely through
learning. a team from google   s deepmind [464] developed a reinforcement learn-
ing agent called deep q network (id25) that trains a deep convolutional ann via
id24. id25 managed to reach or exceed human-level playing performance in
29 out of 46 arcade (atari 2600) games of the arcade learning environment [40] it
was trained on [464].

id25 is inspired by and based upon td-gammon since it uses an ann as the
function approximator for td learning via id119. as in td-gammon, the
gradient is calculated by backpropagating the temporal difference errors. however,
instead of using td(   ) as the underlying rl algorithm, id25 uses id24. fur-

2.8. notable hybrid algorithms

87

ther, the ann is not a simple mlp but rather a deep convolutional neural network.
id25 played each game of ale for a large amount of frames (50 million frames).
this amounts to about 38 days of playing time for each game [464].

the id25 analyses a sequence of four game screens simultaneously and approx-
imates the future game score per each possible action given its current state. in par-
ticular, the id25 uses the pixels from the four most recent game screens as its inputs,
resulting in ann input size of 84   84 (screen size in pixels)   4. no other game-
speci   c knowledge was given to the id25 beyond the screen pixel information. the
architecture used for the convolutional ann has three hidden layers that yield 32
20   20, 64 9   9 and 64 7   7 feature maps, respectively. the    rst (low-level) lay-
ers of the id25 process the pixels of the game screen and extract specialized visual
features. the convolutional layers are followed by a fully connected hidden layer
and an output layer. each hidden layer is followed by a recti   er nolinearity. given
a game state represented by the network   s input, the outputs of the id25 are the es-
timated optimal action values (optimal q-values) of the corresponding state-action
pairs. the id25 is trained to approximate the q-values (the actual score of the game)
by receiving immediate rewards from the game environment. in particular, the re-
ward is +1 if the score increases in between two successive time steps (frames), it
is    1 if the score decreases, and 0 otherwise. id25 uses an   -greedy policy for its
action-selection strategy. it is worth mentioning that, at the time of writing, there
are newer and more ef   cient implementations of the deep id23
concept such as the asynchronous advantage actor-critic (a3c) algorithm [463].

2.8.2.3 td learning with ann function appoximator for ms pac-man

we can envisage a id25 approach for controlling ms pac-man in a similar fashion
to that with which ale agents were trained [464]. a deep convolutional neural net-
work scans the level image on a pixel-to-pixel basis (see fig. 2.19). the image goes
through a number of convolution and fully connected layers which eventually feed
the input of an mlp that outputs the four possible actions for ms pac-man (keep
direction, move backwards, turn left, turn right). once an action is applied, the score
of the game is used as the immediate reward for updating the weights of the deep
network (the convolutional ann and the mlp). by playing for a suf   cient time pe-
riod the controller gathers experience (image snapshots, actions, and corresponding
rewards) which trains the deep ann to approximate a policy that maximizes the
score for ms pac-man.

2.8.3 further reading

for a recent thorough survey on the application of neuroevolution in games the
reader may refer to [567]. for a complete review of neuroevolution please refer to
floreano et al. [205]. cppns and neat are covered in detail in [653] and [655]

88

chapter 2. ai methods

fig. 2.19 a deep id24 approach for ms pac-man. following [464], the network   s    rst part
contains a set of convolution layers which are followed by recti   er nonlinearities. the    nal layers
of the id25 we present in this example are fully connected employing relus, as in [464].

respectively. td-gammon and id25 are covered in detail in [689] and [464], re-
spectively. both are also placed within the greater rl    eld in the upcoming second
edition of [672]. details about the a3c algorithm can be found in [463] and imple-
mentations of the algorithm can be found directly as part of tensor   ow.

2.9 summary

this chapter covered the ai methods we feel the reader of this book needs to be
familiar with. we expect, however, that our readers have a basic background in ai
or have completed a course in fundamentals of ai prior to reading this book. hence,
the algorithms were not covered in detail since the emphasis of this book is on
the application of ai within the domain of games and not on ai per se. on that
basis, we used the game of ms pac-man as the overarching application testbed of
all algorithms throughout this chapter.

the families of algorithms we discussed include traditional ad-hoc behavior au-
thoring methods (such as    nite state machines and behavior trees), tree search (such
as best-   rst, minimax and id169), evolutionary computation (such
as local search and evolutionary algorithms), supervised learning (e.g., neural net-
works, support vector machines and id90), id23 (e.g.,
id24), unsupervised learning (such as id91 and frequent pattern min-
ing), and hybrid algorithms such as evolving arti   cial neural networks and arti   cial
neural networks as approximators of expected rewards.

with this chapter we reached the end of the    rst, introductory, part of the book.
the next part begins with a chapter on the most traditional and widely explored task
of ai in games: playing!

part ii
ways of using ai in games

chapter 3
playing games

when most people think of ai in games they think of an ai playing the game, or
controlling the non-player characters you meet in the game. this might be because
of the association between ai and the idea of autonomous action, or the association
between game characters and robots. while playing games is far from the only in-
teresting application for ai in games, it is a very important one and the one with
the longest history. many methods for content generation (chapter 4) and player
modeling (chapter 5) are also dependent on methods for playing games, and there-
fore it makes sense to discuss playing games before content generation and player
modeling.

this chapter is devoted to ai methods for playing games, including methods for
creating interesting non-player characters in games. while winning a game, appear-
ing human-like, and providing entertainment are very different objectives, they face
many of the same challenges. in fact, there are many different reasons why one
might want to use ai methods to play a game. we start the chapter with discussing
these various motivations (section 3.1). regardless of why you want to use ai to
play a game, which methods you can effectively use to play the game is determined
by the various characteristics of the game that, in turn, affect the choice and de-
sign of the ai method. so the next section in this chapter (section 3.2) is devoted
to characterizing games and ai algorithms according to several criteria. once you
have understood your game suf   ciently, you can make an informed choice of which
algorithm to play it. the following section (section 3.3) is devoted to discussing the
various methods that can be used to play games, and how the right choice of method
depends on the characteristics of the game. most of the methods discussed here will
have been brie   y and somewhat abstractly discussed in chapter 2, but this chapter
will go into some depth about the application of these methods to playing games.

next, a long section (section 3.4) divides up the space of games by game genre,
and discusses how ai methods can be applied in various types of games. this sec-
tion will contain plenty of examples from the literature, and some from published
games. this section also introduces several commonly used game-based frame-
works and competitions for testing ai game-playing algorithms. throughout the

91

92

chapter 3. playing games

chapter we will mostly discuss the use of ai methods to play to win, but also make
numerous references to the experience-creation aspect of game-playing.

3.1 why use ai to play games?

the question of why you might want to deploy some kind or arti   cial intelligence
to play a game can be reduced to two more speci   c questions:

is the ai playing to win?

the question here is whether achieving as high a performance as possible in the
game is the overarching goal of the ai method. high performance here means get-
ting a high score, winning over the opponent, surviving for a long time or similar.
it is not always possible to de   ne what high performance and    playing to win   
means   for example, the sims (electronic arts, 2000) has no clear winning state
and the winning condition in minecraft (mojang, 2011) is not strongly related to
playing the game well   but in a very large number of games, from tetris (alexey
pajitnov and vladimir pokhilko, 1984) to go to the halo (microsoft studios, 2001   
2015) series, it is straightforward to de   ne what playing better means. however,
not all players play to win, and few players play to win in every game all the time.
players play to pass time, relax, test new strategies, explore the game, role-play,
keep their friends company and so on (see a more detailed discussion on this topic
in chapter 5). an ai algorithm might likewise be used in a number of roles beyond
simply playing as well as possible. for example, the agent might play in a human-
like manner, play in an entertaining manner, or behave predictably. it is important to
note that optimizing an agent for playing a game to win might be at odds with some
of the other ways of playing: many high-performing ai agents play in distinctly
non-human, boring and/or unpredictable ways, as we will see in some case studies.

is the ai taking the role of a human player?

some games are single-player, and some games are multi-player where all players
are human. this is particularly true for classic board games. but many, probably
most, video games include various non-player characters. these are controlled by
the computer software in some way   in fact, for many game developers    game ai   
refers to the program code that controls the npcs, regardless of how simple or so-
phisticated that code is. obviously, the role of npcs varies sharply between games,
and within games. in the discussion of this chapter we refer to non-player roles as
those that a human could not take, or would not want to take. thus, all roles in an
exclusively multi-player    rst-person shooter (fps) such as counter-strike (valve
corporation, 2000) are player roles, whereas a typical single-player role-playing

3.1. why use ai to play games?

93

fig. 3.1 why use ai to play games? the two possible goals (win, experience) ai can aim for and
the two roles (player, non-player) ai can take in a gameplaying setting. we provide a summary of
motivations and some indicative examples for each of the four ai uses for gameplaying.

game (rpg) such the elder scrolls v: skyrim (bethesda softworks, 2011) has only
one player role, the rest are non-player characters. in general, non-player roles have
more limited possibilities than player roles.

in summary, ai could be playing a game to win or for the experience of play
either by taking the role of the player or the role of a non-player character. this
yields four core uses of ai for playing games as illustrated in fig. 3.1. with these
distinctions in mind, we will now look at these four key motivations for building
game-playing ai in further detail.

3.1.1 playing to win in the player role

perhaps the most common use of ai together with games in academic settings is
to play to win, while taking the role of a human player. this is especially common
when using games as an ai testbed. games have been used to test the capabilities
and performance of ai algorithms for a very long time, as we discussed in sec-
tion 1.2. many of the milestones in ai and games research have taken the form of
some sort of ai program beating the best human player in the world at some games.
see, for example, ibm   s deep blue winning over garry kasparov in chess, google
deepmind   s alphago winning over lee sedol [629] and ke jie in go, and ibm   s

94

chapter 3. playing games

watson winning jeopardy! [201]. all of these were highly publicized events widely
seen as con   rmations of the increasing capabilities of ai methods. as discussed in
chapter 1, ai researchers are now increasingly turning to video games to    nd appro-
priate challenges for their algorithms. the number of active competitions associated
with the ieee cig and aiide conferences is testament to this, as is deepmind   s
and facebook ai research   s choice of starcraft ii (blizzard entertainment, 2015)
as a testbed for their research.

games are excellent testbeds for arti   cial intelligence for a number of reasons,
as elaborated on in section 1.3. an important reason is that games are made to test
human intelligence. well-designed games exercise many of our cognitive abilities.
much of the fun we have in playing games comes from learning the games through
playing them [351], meaning that well-designed games are also great teachers. this,
in turn, means that they offer the kind of gradual skill progression that allows for
testing of ai at different capability levels.

there are some reasons besides ai benchmarking for why you might want to use
an ai in the place of a human to play games to win. for example, there are some
games where you need strong ai to provide a challenge to players. this includes
many strategic games of perfect information, such as classic board games, including
chess, checkers and go. however, for games with hidden information, it is often
easier to provide challenge by simply    cheating   , for example, by giving the ai
player access to the hidden state of the game or even by modifying the hidden state
so as to make it harder to play for the human. for example, in the epic strategy game
civilization (microprose, 1991), all civilizations can be played by human players.
however, playing any civilization game well under the same conditions as a human
is very challenging, and there is, to our knowledge, no ai capable of playing these
games as well as a good human player. therefore, when playing against several
computer-controlled civilizations, the game typically cheats by providing these with
preferential conditions in various ways.

another use case for ai that plays to win in a player role is to test games. when
designing a new game, or a new game level, you can use a game-playing agent
to test whether the game or level is playable, so called simulation-based testing.
however, in many cases you want the agent to also play the game in a human-like
manner to make the testing more relevant; see below on playing for experience.

historically, the use of ai to play to win in a player role has been so dominant in
academic work that some researchers have not even considered other roles for ai in
playing games. in game development, on the other hand, this particular motivation
for game-playing ai is much more rare; most game-playing ai in existing games
is focused on non-player roles and/or playing for experience. this mismatch has
historically contributed to the lack of understanding between academia and industry
on game ai. in recent years however, there has been a growing understanding of the
multitude of motivations for game-playing ai.

3.1. why use ai to play games?

95

3.1.2 playing to win in a non-player role

non-player characters are very often designed to not offer maximum challenge
or otherwise be as effective as possible, but instead to be entertaining or human-
like; see below for non-player characters playing for experience. however, there
are instances when you want a non-player character to play as well as possible. as
mentioned above, strategy games such as civilization (microprose, 1991) have an
(unanswered) need for high-performing non-cheating opponents, though here we
are talking about playing roles that other human players could in principle have
taken. other strategy games, such as xcom: enemy unknown (2k games, 2012),
have playing roles that humans would not play, creating a need for npc ai playing
to win.

other times, creating an npc playing to win is a necessary precursor to creating
an npc playing for experience. for example, in a racing game, you might want to
implement    rubber band ai    where the npc cars adapt their speed to the human
player, so that they are never too far behind or ahead. doing this is easy, but only
if you already have an ai controller that can play the game well, either through
actually playing the game well or through cheating in a way that cannot easily be
detected. the performance of the controller can then be reduced when necessary so
as to match the player   s performance.

3.1.3 playing for experience in the player role

why would you want an agent that takes the role of a human player, but that does not
focus on winning? for example, when you want a human-like agent. perhaps the
most important reason for such agents is alluded to above: simulation-based testing.
this is important both when designing games and game content manually, and when
generating content procedurally; in the latter case, the quality of the game content
is often evaluated automatically with the help of an agent playing the game, as dis-
cussed in chapter 4. when trying to see how the game would be played by a human
it is therefore important that the agent plays in a human-like manner, meaning that
it has performance comparable to a human, has similar reaction speed, makes the
same sort of mistakes that a human would do, is curious about and explores the same
areas as a human would, etc. if the ai agent plays signi   cantly differently from how
a human would play, it might give the wrong information about e.g., whether a
game is winnable (it might be winnable but only if you have superhuman re   exes)
or whether a game mechanic is used (maybe a human would use it, but not an ai
that tries to play optimally).

another situation where human-like play is necessary is when you want to
demonstrate how to play a level to a human player. a common feature of games
is some kind of demo mode, which shows the game in action. some games even
have a demonstration feature built into the core gameplay mode. for example, new
super mario bros (nintendo, 2006) for the nintendo wii will show you how to play

96

chapter 3. playing games

a particular part of a level if you fail it repeatedly. the game simply takes over the
controls and plays for you for about 10 to 20 seconds, and lets you continue after-
wards. if all the level content is known beforehand, and there are no other players,
such demonstrations can be hardcoded. if some parts of the game are user-designed,
or procedurally generated, the game needs to generate these demonstrations itself.
playing in a    human-like    fashion may seem a rather fuzzy and subjective aim,
and it is. there are many ways in which a typical ai agent plays differently from
a typical human player. how humans and ais differ depends on the algorithm used
to play the game, the nature of the game itself, and a multitude of other factors. to
investigate these differences further, and spur the development of agents that can
play in a human-like manner, two different turing test-like competitions have been
held. the 2k botprize was held from 2008 to 2013, and challenged competitors
to develop agents that could play the fps unreal tournament 2004 (epic games,
2004) in such a way that human participants thought that the bots were human [263,
262, 647]. similarly, the turing test track of the mario ai competition let people
submit playing agents of super mario bros (nintendo, 1985), who were judged by
human onlookers as to whether they were human or not [619, 717]. while it takes
us too far to go through all of the results of these competitions here, there are some
very obvious signs of non-humanness that recur across games for many types of ai
agents. these include having extremely fast reactions, switching between actions
faster than a human could, not attempting actions which fail (because of having a
too good model of the outcome of actions), not doing unnecessary actions (such as
jumping when one could just be running) and not hesitating or stopping to think.

of course, not all players of a game play in the same way. in fact, as discussed
further in chapter 5, if one analyzes a set of play traces of any game one can often
   nd a number of player    archetypes    or    personas   , clusters of players who play the
game in markedly different ways in terms of e.g., aggression, speed, curiosity and
skill. within work on ai that plays games in human-like styles, there has been work
both on learning and mirroring the playstyle of individual players [422, 423, 511,
328, 603] and on learning to play games in the style of one of several personas [267,
269].

3.1.4 playing for experience in a non-player role

almost certainly the most common goal for game-playing ai in the game industry
is to make non-player characters act, almost always in ways which are not primarily
meant to beat the player or otherwise    win    the game (for many npcs it may not
even be de   ned what winning the game means). npcs may exist in games for many,
sometimes overlapping, purposes: to act as adversaries, to provide assistance and
guidance, to form part of a puzzle, to tell a story, to provide a backdrop to the
action of the game, to be emotively expressive and so on [724]. the sophistication
and behavioral complexity of npcs likewise vary widely, from the regular left-right
movements of the aliens in space invaders (midway, 1978) and koopas in the super

3.1. why use ai to play games?

97

mario bros (nintendo, 1985   2016) series to the nuanced and varied behavior of
non-player characters in bioshock in   nite (2k games, 2013) and the alien in alien:
isolation (sega, 2014).

depending on the role of the npc, very different tasks can be asked of the ai
algorithms that control it. (it can certainly be argued that many of the scripts that
control npcs cannot truthfully be described as arti   cial intelligence in any con-
ventional way, but we will stick with the acronym here as it is commonly used for
all code that controls non-player characters in the game industry.) in many cases
what the game designers look for is the illusion of intelligence: for the player to
believe that the npc in some sense is intelligent even though the code controlling it
is very simple. human-likeness in the sense discussed in the previous section might
or might not be the objective here, depending on what kind of npc it is (a robot or
a dragon should perhaps not behave in a too human-like manner).

in other cases, the most important feature of an npc is its predictability. in a
typical stealth game, a large part of the challenge is for the player to memorize and
predict the regularities of guards and other characters that should be avoided. in such
cases, it makes sense that the patrols are entirely regular, so that their schedule can
be gleaned by the player. similarly, the boss monsters in many games are designed
to repeat certain movements in a sequence, and are only vulnerable to the player   s
attack when in certain phases of the animation cycle. in such cases, too    intelligent   
and adaptive behavior would be incompatible with the game design.

it should be noted that even in cases where you would expect to need supple,
complex behavior from npcs, an agent that plays to win might be very problem-
atic. many high-performing strategies are seen as very boring by the player, and
prime examples of    unsportsmanlike    behavior. for example, in an experiment with
building high-performing ai for a turn-based strategy game, it was found that one
of the solutions (based on neuroevolution) was extremely boring to play against,
as it simply took a defensive position and attacked any incoming units with long-
distance attacks [490]. similarly, camping (staying stationary in a protected position
and waiting for enemies to expose themselves to    re) is a behavior that is generally
frowned on and often banned in fps games, but it is often highly effective and easy
to learn for an ai (incidentally, real-life military training often emphasizes camping-
like tactics   what is effective is often not fun). another interesting example is the
work by denzinger et al. [165] in which an evolutionary algorithm found that the
best way to score a goal in fifa 99 (electronic arts, 1999) was by forcing a penalty
kick. the evolutionary process found a local optimum in the    tness landscape cor-
responding to a sweet spot or exploit of the game   s mechanics which yielded highly
ef   cient, yet predictable and boring gameplay. exploiting the game   s bugs for win-
ning is a creative strategy that is not only followed by ais but also by human players
[381].

98

chapter 3. playing games

3.1.5 summary of ai game-playing goals and roles

we argued above that playing to win in the player role has been overemphasized, to
the point of neglecting other perspectives, in much of academic research. in the same
way, work on ai in the game industry has generally overemphasized playing for
experience in a non-player role, to the point of neglecting other perspectives. this
has led to an emphasis in the industry on behavior authoring methods such as    nite
state machines and behavior trees, as ai methods based on search, optimization
and learning have been seen as not conducive to playing for experience; a common
gripe has been a perceived lack of predictability and authorial control with such
methods. however, given a better understanding of what roles ai can be used to
play in games, this neglect of methods and perspectives is hopefully coming to an
end in both academia and industry.

3.2 game design and ai design considerations

when choosing an ai method for playing a particular game (in any of the roles
discussed in section 3.1) it is crucial to know the characteristics of the game you
are playing and the characteristics of the algorithms you are about to design. these
collectively determine what type of algorithms can be effective. in this section we
   rst discuss the challenges we face due to the characteristics of the game per se
(section 3.2.1) and then we discuss aspects of ai algorithmic design (section 3.2.2)
that need to be considered independently of the game we examine.

3.2.1 characteristics of games

in this section we discuss a number of characteristics of games and the impact they
have on the potential use of ai methods. all characteristics covered are tied to the
design of the game but a few (e.g., input representation and forward model) are also
dependent on the technical implementation of the game and possibly amenable to
change. much of our discussion is inspired by the book characteristics of games
by elias et al. [192], which discusses many of these factors from a game design
perspective. for illustrative purposes, fig. 3.2 places a number of core game ex-
amples onto the three-dimensional space of observability, stochasticity and time
granularity.

3.2.1.1 number of players

a good place to start is the number of players a game has. elias et al. [192] distin-
guish between:

3.2. game design and ai design considerations

99

fig. 3.2 characteristics of games: game examples across the dimensions of stochasticity, observ-
ability and time granularity. note that the game examples presented are sorted by complexity (ac-
tion space and branching factor) within each cube. minimax can theoretically solve merely any
deterministic, turn-based game of perfect information (red cube in the    gure)   in practice, it is
still impossible to solve games with substantially large branching factors and action spaces such as
go via minimax. any ai method that eventually approximates the minimax tree (e.g., mcts) can
be used to tackle imperfect information, non-determinism and real-time decision making (see blue
cubes in    gure). strictly speaking, super mario bros (nintendo, 1985) involves a small degree of
non-determinism only when a player helps creating a particular scene; we can, thus, safely classify
the game as deterministic [163].

    single-player games, such as puzzles and time-trial racing;
    one-and-a-half-player games, such as the campaign mode of an fps with non-
    two-player games, such as chess, checkers and spacewar! (russell, 1962); and
    multi-player games, such as league of legends (riot games, 2009), the mario

trivial npcs;

kart (nintendo, 1992   2014) series and the online modes of most fps games.
the distinction between single-player and one-and-a-half-player games is not a
sharp one   there is no clear boundary for how advanced npcs should be to count
as a    half player   . in the case of multi-player games, many can be played with only
two players, at which point they are effectively two-player games. it is not always
the case that other players (or npcs) are adversarial and try to stop the player   
there are many collaborative games, or games where relations between players are
complex and have elements of both competition and cooperation. still, keeping the

100

chapter 3. playing games

number of players in mind is very useful when thinking about algorithms for playing
games.

when using tree search algorithms to play games, some algorithms    t particu-
larly well with some numbers of players. standard single-agent tree search algo-
rithms such as breadth-   rst, depth-   rst and a*    t the single-player case particularly
well (including games which have npcs, but where those npcs are so simple and
predictable as to be treated as part of the environment). in such games, what happens
in the game is determined entirely by the actions the player takes and any potential
random effects; there are no other    intentional    players. this    ts very well with
single-agent tree search algorithms, which are based on the markov property, that
the next state is entirely determined by the previous state and the action taken at that
point.

a particular case is two-player zero-sum adversarial games, i.e., there are ex-
actly two players; one player will win, the other will lose (or perhaps there will be
a draw). we do not know what the other player will do, but we can safely assume
that she will do everything she can to win, and thereby deny you the victory. the
minimax algorithm (with or without   -   pruning) is perfectly suited to this case,
and will lead to optimal play given suf   cient computation time.

but how do we cope with the challenge when we have many players, or perhaps
a single player surrounded by very complicated non-player agents? while it is the-
oretically possible to expand minimax to multiple players, this only works if there
can be no collusion (or alliances of any kind) between players and the zero-sum na-
ture of the game still remains (which it usually does not). further, the computational
complexity of minimax quickly gets unmanageable with more than two players, as
for every move you take you do not just need to consider the countermove of one
player, but of all players. so this approach is rarely workable.

it is more common in the multi-player case to treat the game as a single-player
game, but use some kind of model of what the other players do. this could be an
assumption that the other players will oppose the player, a learned model based on
observed behavior or even a random model. with an appropriate model of what the
other players will do, many standard single-player game-playing methods can be
used in multi-player settings.

3.2.1.2 stochasticity

a common way in which many games violate the markov property is by being
stochastic (or non-deterministic). in many games, some of what happens is ran-
dom. as standard digital computer architectures do not allow for    true    random-
ness, effective randomness is provided by pseudo-random number generators. the
word    stochastic    is used to denote processes which cannot be practically predicted,
whether they result from true randomness or complex calculations. games can have
varying amounts of stochasticity, from completely deterministic games like chess
to games dominated by stochastic outcomes like roulette, ludo, yahtzee or even
monopoly. it is common for games to have mostly or fully deterministic game

3.2. game design and ai design considerations

101

mechanics combined with some stochastic element through card-drawing, dice-
throwing or some similar mechanism to reduce the possibility of planning. however,
stochasticity can occur in essentially any part of a game.

in a game with stochasticity, the outcome of the game is not entirely determined
by the actions the players take. in other words, if you play several playthroughs
of the same game, taking the same actions at the same points in time, you are not
guaranteed the same outcome. this has consequences for ai algorithms. for tree
search algorithms, it means that we cannot be sure about the state which a sequence
of actions will lead to, and therefore about the results of the algorithm. this leads to
problems with using many tree search algorithms in their canonical forms, and re-
quires that we add some modi   cations to address the non-deterministic uncertainty
in the forward model. for example, in id169 modi   cations such
as determinization are used, where the different possible outcomes of each action
are explored separately [77]. while these algorithm variations can be effective, they
generally increase the computational complexity of the base algorithm.

for id23 approaches, including evolutionary reinforcement
learning, it means that we have reduced certainty in exactly how good a given strat-
egy/policy is   a good policy may achieve bad outcomes, or a bad policy good
outcomes, because of random events in the game. such outcome uncertainty can
be mitigated by evaluating every policy multiple times, though this has signi   cant
computational cost. on the other hand, stochasticity can sometimes actually be an
advantage when learning policies: a policy which is learned for a stochastic game
may be more robust than one learned for a deterministic game, as in the latter case
it is possible to learn a very brittle policy that only works for a speci   c con   gura-
tion of the game. for example, learning a policy which attacks enemies in speci   c
places at speci   c times, rather than being able to handle enemies that might arrive
from any direction at any time.

while it is very common for digital games to include some form of stochas-
ticity, an interesting case is very early games hardware such as the 1977-vintage
atari 2600, which does not have the facilities for implementing pseudo-random
number generators (mainly because it lacks a system clock). if a player takes ex-
actly the same actions at exactly the same times (including the key press that starts
the game), exactly the same outcome will be achieved. the arcade learning en-
vironment is a widely used game-based ai-benchmark built around an emulator of
the atari 2600 [40]. when training ai agents to play games with no stochasticity,
it is entirely possible to learn brittle policies that effectively bypass the complexi-
ties of the full game (whether this actually happens, or whether most agents learn
more general strategies, is an open question). as we already saw across the various
examples of chapter 2 ms pac-man (namco, 1982) is arguably the most popular
non-deterministic arcade game of that era.

102

3.2.1.3 observability

chapter 3. playing games

observability is a characteristic that is strongly related to stochasticity. it refers to
how much information about the game state is available to the player(s). at one
extreme we have classic board games such as chess, go and checkers, where the
full board state is always available to the players, and puzzles such as sudoku and
spelltower. these games have perfect information. at the other extreme we can
think of classic text adventures such as zork (personal software, 1980) or colossal
cave adventure, where initially very little of the world and its state is revealed to
the player and much of the game is about exploring what the world is like. those
games have hidden information and therefore only partial observability. many,
if not most, computer games have signi   cant hidden information: think of a typical
platform game such as super mario bros (nintendo, 1985), or fps such as the halo
series (microsoft studios, 2001   2015), where at any point you can only perceive a
small part of the game world. within computer strategy games such as starcraft
ii (blizzard entertainment, 2015) or civilization (microprose, 1991) the common
term for hidden information is fog of war. even many classic non-digital games have
hidden information, including most card games where players keep their hands of
cards private (such as poker) and board games such as battleship.

when developing an ai agent for a game with hidden information, the simplest
approach you can follow is to merely ignore the hidden information. at each point in
time, just feed the available information to the agent and use that to decide the next
action. doing so actually works quite well in some games, notably action-focused
games with linear levels; for example, simple super mario bros (nintendo, 1985)
levels can be played well based on only instantaneously available information [706].
however, if you play a strategy game such as starcraft (blizzard entertainment,
1998) based on only the available information, you are not even going to see the
enemy until it is too late   good play involves active information gathering. even
in super mario bros (nintendo, 1985), complicated levels that feature backtracking
require remembering off-screen parts of the level [322]. in a trick-taking card game
such as poker the available information (your own hand) is actually of compara-
tively less relevance; the core of the game is modeling the hidden information (your
adversaries    hands and minds).

therefore, effective ai for games with partial observability often requires some
kind of modeling of the hidden information. for some games, notably variants
of poker such as heads-up limit hold   em, considerable research has been done on
game-speci   c methods for modeling hidden information that includes opponents   
play [63]. there are also more generic methods of adding some form of hidden
state modeling to existing algorithms, such as information set monte carlo tree
search [146]. just like when it comes to methods for dealing with stochasticity, these
methods typically add considerable computational complexity compared to the base
algorithm.

3.2. game design and ai design considerations

103

3.2.1.4 action space and branching factor

when you play the minimalist-masochist mobile game flappy bird (dotgears,
2013), you have a single choice at any point in time: to    ap or not to    ap. (flapping
is accomplished by touching the screen, and makes the protagonist bird rise in the
air.) flappy bird and similar one-button games, such as canabalt (beatshapers,
2009), probably have the lowest possible branching factor. the branching factor
is the number of different actions you can take at any decision point. the branching
factor of flappy bird is 2:    ap or no    ap.

for comparison, pac-man (namco, 1980) has a branching factor of 4: up, down,
left and right. super mario bros (nintendo,1985) has a branching factor of around
32: eight d-pad directions times two buttons (though you may argue that some of
these combinations are nonsensical and should not actually be considered). chess
has an average branching factor of 35, whereas checkers has a somewhat lower
branching factor. go has a whooping 400 for the very    rst move; as the board is
populated, the branching factor decreases, but there are typically a few hundred
potential positions to put every stone.

while 400 is a very high branching factor compared to 35 or 2, it dwarfs in com-
parison to many computer strategy games where multiple units can be moved every
turn. considering each combination of movements of individual units as an action,
this means that the branching factor of the game is the product of the branching
factor of the individual units. if you have 6 different units that can each take 10
different actions at a given time   a rather conservative estimate compared to typi-
cal games of, say, starcraft (blizzard entertainment, 1998) or civilization (micro-
prose, 1991)   then your branching factor is a million!

but wait, it gets worse. for many games, it is not even possible to enumerate all
the actions, as the input space is continuous. think of any modern    rst-person game
played on a computer or console. while it is true that computers do not really capture
in   nities well, and that    continuous    inputs such as computer mice, touchscreens
and thumbsticks (on e.g., xbox and playstation controllers) actually return a digital
number, that number has such    ne resolution that it is for all practical purposes
continuous. the only way to create a practically enumerable set of actions is to
discretize the continuous input space somehow, and strike a compromise between
overwhelming branching factors and reducing the input space so much as to not be
able to play the game effectively.

the branching factor is a key determinant of the effectiveness of tree search al-
gorithms. the complexity of the breadth-   rst algorithm (for single-player games)
and the minimax algorithm (for adversarial two-player games) for searching to
depth d is bd, where b is the branching factor. in other words, a high branching
factor makes it almost impossible to search more than a few steps ahead. this fact
has very tangible consequences for which games can be played with tree search
methods; for example, go has an order of magnitude higher branching factor than
chess, and this was arguably the main reason for the very poor performance of all
kinds of ai methods on go for decades (during which the same methods performed
well on chess). id169 handles high branching factors better be-

104

chapter 3. playing games

cause it builds imbalanced trees, but it is by no means immune to the problem. once
the branching factor gets high enough (say, a million, or maybe a billion, depending
on the speed of the simulator), it becomes impractical to enumerate even the actions
at depth 1 and therefore to use tree search at all.

high branching factors are an issue for id23 algorithms as
well, including evolutionary id23. mostly this has to do with the
controller/policy representation. if you are using a neural network (or some other
function approximator) for representing your policy, you may need to have outputs
for each action; alternatively, if you are using the network to assign values to all
actions, you need to iterate over them. in both cases, a large number of possible
actions carries a cost. another problem is the exploration-exploitation dilemma: the
higher the number of possible actions, the longer it will take to explore them all
while learning.

a    nal comment on branching factors is that for many games, they are not con-
stant. in chess, you have fewer moves available at the beginning of the game when
most of your pieces are blocked, more towards the midgame, and fewer again in
the endgame when most pieces may be blocked. in a typical rpg such as those in
the final fantasy series (square enix, 1987   2016) the number of available actions
increases as the player character accrues items, spells and other possibilities. as
mentioned above, the number of available actions in go decreases as you play.

3.2.1.5 time granularity

when discussing branching factors above, we talked about the number of possible
actions to take at any    point in time   . but how often is that? how often can the player
take an action? a fundamental distinction is that between turn-based and real-time
games. most classic board games are turn-based games. in such games, players take
turns, and at each turn a player can take an action, or a speci   ed number of actions.
the amount of real time that passes between turns is generally not of any importance
inside the game (though tournaments and professional play often incorporate some
form of time limit). real-time games include many popular genres of computer
games, such as fps, racing games and platformers. even within real-time games,
there is considerable variation in how often an in-game action can in practice be
taken. at the extreme there is the screen update frequency; the current generation of
video games typically strives to have an update frequency of 60 frames per second
to ensure a perceived smooth movement, but many games update the screen half as
often or even less because of the complexity of rendering complicated scenes. in
practice, the number of actions a player character (or any other in-game character)
could take per second is usually more limited than that.

to take two examples far apart on the time granularity scale, let us consider two
adversarial games: chess and starcraft (blizzard entertainment, 1998). a game of
chess between skilled players on average lasts about 40 turns.1 in starcraft (bliz-

1 http://chess.stackexchange.com/questions/2506/

3.2. game design and ai design considerations

105

zard entertainment, 1998), a highly competitive real-time strategy (rts) game, pro-
fessional players often take three to    ve actions per second (each action is typically
executed with a mouse click or a shortcut key). with a typical game lasting 10 to
20 minutes, this means that thousands of actions are taken in a game. but there are
not that many more signi   cant events in a game of starcraft (blizzard entertain-
ment, 1998) than in a game of chess   the lead does not change much more often,
and grand strategic decisions are not made that much more often. this means that
the number of actions between signi   cant game events is much higher in starcraft
(blizzard entertainment, 1998) than in chess.

time granularity affects ai game-playing methods through limiting how far
ahead you can look. a given depth of search means very different things depending
on the time granularity of the game. ten turns in chess is enough to execute a whole
strategy; ten actions ahead in starcraft (blizzard entertainment, 1998) might just
be a few seconds, during which the game might not have changed in any signi   -
cant way. to play starcraft (blizzard entertainment, 1998) well using tree search,
one would need an exceptional search depth, in the hundreds or thousands of ac-
tions, which would clearly be computationally infeasible. one way to address this
challenge is to consider macro-actions (e.g., as in [525, 524]), which are sets or
sequences of smaller,    ne-grained, actions.

3.2.2 characteristics of ai algorithm design

in the following, we discuss some important issues in applying ai algorithms to
games. these are design choices relating not so much to game design (covered in
the previous section), as to ai algorithm design and the constraints under which
the algorithm is used. this section expands the discussion about representation and
utility covered in chapter 2 with a focus on game-playing ai.

3.2.2.1 how is the game state represented?

games differ in what information they present to the player, and how. text adven-
tures output text, the state of a classic board game can be described by the positions
of all board pieces, and graphical video games serve moving graphics together with
sound and occasionally outputs such as controller rumble. for digital games, the
technical limitations of the hardware on which the game is implemented in   uences
how it is presented; as processor speed and memory capacity increases, the pixel
resolution and scene complexity of video games has increased commensurably.

importantly, the same game can be represented in different ways, and which way
it is represented matters greatly to an algorithm playing the game. to take a rac-
ing game as an example, the algorithm could receive a    rst-person view out of the
windscreen of the car rendered in 3d, or an overhead view of the track rendering
the track and various cars in 2d. it could also simply receive a list of positions and

106

chapter 3. playing games

velocities of all cars on the track in the frame of reference of the track (along with a
model of the track), or a set of angles and distances to other cars (and track edges)
in the frame of reference of the track.

the choices regarding input representation matter a lot when designing a game.
if you want to learn a policy for driving a car around a track, and the inputs to the
policy are the three continuous variables associated with speed and distance to the
left and right edge of the track, learning a decent driving policy is comparatively
simple. if your input is instead an unprocessed visual feed   i.e., tens of thousands
of pixel values      nding a decent policy is likely to be much harder. not only is
the policy search space in the latter case vastly greater, the proportion of the search
space that corresponds to decently-performing policies is likely to be much smaller,
as many more nonsensical policies are possible (e.g., turn left if even-numbered
pixels are lighter than odd-numbered pixels; this policy does not map to the game
state in any sensible way, and if it works it is a    uke). in order to learn to drive
well based on visual input   at least in cases where illumination, roadside scenery,
etc. vary signi   cantly   you likely need to learn a visual system of some kind. in
light of this, most naive policies applied to full visual input would likely not have
fared very well. continuing the car racing example, even in cases where you have
very few inputs, how these are represented matters; for example, it is much easier
to learn a good driving policy if the inputs are represented in the frame of reference
of the car rather than that of the track [707, 714]. a somewhat more comprehensive
discussion on ways of representing low-dimensional inputs to neural networks can
be found in [567].

in recent years, several groups of researchers have focused on learning poli-
cies that use full visual feeds as inputs. for example, koutnik et al. evolved neural
networks to play the open racing car simulator (torcs) from high-resolution
video [353], kempka et al. used the pixels of the screen as input to a deep q network
that was trained to play a version of doom (gt interactive, 1993) [333], and mnih
et al. trained deep networks to play atari 2600 games using id24 [464]. using
the raw pixel inputs is often motivated by giving the ai the same conditions as a
human would have, and thus achieving a level playing    eld between human and ai.
another motivation is that if you want to use your algorithm to play a game    out of
the box   , without any api or additional engineering to expose the internal state of
the game, you will likely have to resort to using the raw visual feed. however, in
cases where you have access to the source code of the game or a useful api   as you
would almost always have when developing ai for a new game   there is no reason
to not utilize the    digested    game state in whatever form makes the task of the ai
algorithm easiest. whether or not to present information that the human player does
not have access to, i.e.,    cheating   , is a separate question.

3.2.2.2 is there a forward model?

a very important factor when designing an ai to play a game is whether there is a
simulator of the game, a so-called forward model, available. a forward model is a

3.2. game design and ai design considerations

107
model which, given a state s and an action a, reaches the same state s(cid:48) as the real
game would reach if it it was given a at s. in other words, it is a way of playing the
game in simulation, so that consequences of multiple actions can be explored before
actually taking some of those actions in the real game. having a forward model of
the game is necessary in order to be able to use any tree search-based approaches to
playing a game, as those approaches depend on simulating the outcome of multiple
actions.

a very desirable property of a forward model, in addition to that it exists, is that
it is fast. in order to be able to use a tree search algorithm effectively for control in
a real-time game, one would generally need to be able to simulate gameplay at least
a thousand times faster than real-time, preferably tens or hundreds of thousands of
times faster.

it is very easy to construct a forward model for classic board games such as
chess and go, as the game state is simply the board state and the rules are very easy
to encode. for many video games, constructing a forward model can be done by
simply copying (or otherwise reusing) the same code as is used for controlling the
game itself, but without waiting for user input or displaying graphics, and without
performing all the calculations involved with graphics rendering. for some video
games   notably games that were originally implemented for much older hardware,
such as classic arcade games that were implemented on 8-bit or 16-bit processors   
forward models can be made much faster than real-time, as the core game loop is not
that computationally complex. (it might also be possible to do this with some mod-
ern games, by running them inside emulators that can replace the graphics routines
with dummy code.)

for many games, however, it is impossible or at least very hard to obtain a fast
forward model. for most commercial games, the source code is not available, unless
you are working at the company that develops the game. even if the source code is
available, current software engineering practices in the game industry make it very
hard to extract forward models from game code, as the core control loops are often
closely tied up with user interface management, rendering, animation and some-
times network code. a change in software engineering practices to separate the core
game loop more cleanly from various input/output functions so that forward models
could more easily be built would be one of the most important enablers of advanced
ai methods in video games. however, in some cases the computational complexity
of the core game loop might still be so high that any forward models built on the
core game code would be too slow to be usable. in some of such cases, it might be
practical to build and/or learn a simpli   ed or approximate forward model, where
the state resulting from a series of actions taken in the forward model is not guaran-
teed to be identical to the state resulting from the same series of actions in the actual
game. whether an approximate forward model is acceptable or not depends on the
particular use case and motivation for the ai implementation. note that a somewhat
less than accurate forward model might still be desirable. for example, when there
is signi   cant hidden information or stochasticity the ai designer might not want to
provide the ai agent with an oracle that makes the hidden information observable

108

chapter 3. playing games

and tells the agent which random actions will happen. taking such a design decision
might lead to unreasonably good performance and the appearance of cheating.

when a forward model cannot be produced, tree search algorithms cannot be
applied. it is still possible to manually construct agents, and also to learn agents
through supervised learning or some form of id23, such as
temporal difference learning or evolutionary id23. however, note
that while the id23 approaches in general do not need a complete
forward model in the sense that the results of taking any action in any state can be
predicted, they still need a way to run the game faster than real-time. if the game
cannot be sped up signi   cantly beyond the pace at which it is naturally played, it is
going to take the algorithm a very long time to learn to play.

3.2.2.3 do you have time to train?

a crude but useful distinction in arti   cial intelligence is between algorithms that try
to decide what to do in a given situation by examining possible actions and future
states   roughly, tree search algorithms of various kinds   and algorithms that learn
a model (such as a policy) over time   i.e., machine learning. the same distinction
exists within ai for playing games. there are algorithms developed that do not
need to learn anything about the game, but do need a forward model (tree search);
there are algorithms that do not need a forward model, but instead learn a policy
as a mapping from state(s) to action (model-free id23); and there
are algorithms that require both a forward model and training time (model-based
id23 and tree search with adaptive hyperparameters).

what type of algorithm you will want to use depends largely on your motivation
for using ai to play games. if you are using the game as a testbed for your ai algo-
rithm, your choice will be dictated by the type of algorithm you are testing. if you
are using the ai to enable player experience in a game that you develop   for exam-
ple, in a non-player role   then you will probably not want the ai to perform any
learning while the game is being played, as this risks interfering with the gameplay
as designed by the designer. in other cases you are looking for an algorithm that can
play some range of games well, and do not have time to retrain the agent for each
game.

3.2.2.4 how many games are you playing?

an aim the ai designer might wish to achieve is that of general game playing.
here, we are not looking for a policy for a single game, we are looking for a more
generic agent that can play any game that it is presented with   or at least any game
from within a particular distribution or genre, and which adheres to a given interface.
general game playing is typically motivated by a desire to use games to progress
towards arti   cial general intelligence, i.e., developing ai that is not only good at one
thing but at many different things [598, 679, 744]. the idea is to avoid over   tting

3.3. how can ai play games?

109

(manually or automatically) a given game and come up with agents that generalize
well to many different games; it is a common phenomenon that when developing
agents for a particular game, for example, for a game-based ai competition, many
special-purpose solutions are devised that do not transfer well to other games [701].
for this reason, it is common to evaluate general game playing agents on un-
seen games, i.e., games on which they have not been trained and which the design-
ers of the agent were not aware of when developing the agent. there are several
frameworks for general game playing, including the general game playing com-
petition [223], the general video game ai competition [528, 527] and the arcade
learning environment [40]. these will be discussed later in the chapter.

general video game playing, where ai is developed to play for performance in
the player role across many games (ideally all games), can be seen as diametrically
opposed to the typical use of ai for playing games in commercial game develop-
ment, where the ai is playing for experience in a non-player role, and is carefully
tuned to a particular game. however, the development of ai methods for general
game playing certainly bene   ts commercial game ai in the end. and even when
developing game ai as part of game development, it is good engineering practice to
develop methods that are reusable to some extent.

3.3 how can ai play games?

in chapter 2, we reviewed a number of important ai methods. most of these meth-
ods can be used to play games in one way or another. this section will focus on the
core ai methods, and for each family of algorithms it will go through on how they
can be used to play games.

3.3.1 planning-based approaches

algorithms that select actions through planning a set of future actions in a state
space are generally applicable to games, and do not in general require any training
time. they do require a fast forward model if searching in the game   s state space,
but not if simply using them for searching in the physical space (path-planning).
tree search algorithms are widely used to play games, either on their own or in
supporting roles in game-playing agent architectures.

3.3.1.1 classic tree search

classic tree search methods, which feature little or no randomness, have been used
in game-playing roles since the very beginning of research on ai and games. as
mentioned in the introduction of this book the minimax algorithm and   -   pruning

110

chapter 3. playing games

were originally invented in order to play classic board games such as chess and
checkers [725]. while the basic concepts of adversarial tree search have not really
changed since then, there have been numerous tweaks to existing algorithms and
some new algorithms. in general, classic tree search methods can easily be applied
in games that feature full observability, a low branching factor and a fast forward
model. theoretically they can solve any deterministic game that features full ob-
servability for the player (see the red cube in fig. 3.2); in practice, they still fail in
games containing large state spaces.

best-   rst search, in particular a myriad variations of the a* algorithm, is very
commonly used for path-planning in modern video games. when an npc in a
modern 3d fps or rpg decides how to get from point a to point b, this is typi-
cally done using some version of a*. in such instances, search is usually done in
(in-game) physical space rather than state space, so no forward model is necessary.
as the space is pseudo-continuous, search is usually done on the nodes of a mesh
or lattice overlaid on the area to be traversed. note that best-   rst search is only used
for navigation and not for the full decision-making of the agent; methods such as
behavior trees or    nite-state machines (which are usually hand-authored) are used to
determine where to go, whereas a* (or some variation of it) is used to determine how
to get there. indeed, in games where player input is by pointing to and clicking at
positions to go   think of an overhead brawler like diablo (blizzard entertainment,
1996) or an rts like starcraft (blizzard entertainment, 1998)   the execution of
the player   s order usually involves a path-planning algorithm as well. recent addi-
tions to the family of best-   rst algorithms include jump point search (jps), which
can improve performance by orders of magnitude compared to standard a* under
the right circumstances [662]. hierarchical path   nding is its own little research area
based on the idea of dividing up an area into subareas and using separate algorithms
for deciding how to go between and within the areas. choosing a path-planning al-
gorithm for a modern video game is usually a matter of choosing the algorithm that
works best given the shape of the environments the npcs (or pcs) are traversing,
the particular way a grid or movement graph is overlaid on top of this space, and
the demands of the animation algorithm. generally, one size does not    t all; some
textbooks devoted to industry-oriented game ai discuss this in more depth [461].

beyond path-planning, best-   rst algorithms such as a* can be used for control-
ling all aspects of npc behavior. the key to doing this is to search in the state
space of the game, not just the physical space. (obviously, this requires a fast for-
ward model.) to take an example, the winner of the 2009 mario ai competition
was entirely based on id67 in state space [705]. this competition tasked com-
petitors with developing agents that could play a java-based clone of the classic
platform game super mario bros (nintendo, 1985)   it later evolved into a multi-
track competition [322]. while a forward model was not supplied with the original
competition software, the winner of the competition, robin baumgarten, created
one by adapting parts of the core game code. he then built an a* agent which at
any point simply tried to get to the right edge of the screen. (an illustration of the
agent can be seen in figs. 3.3 and 2.5.) this worked extremely well: the resulting
agent played seemingly optimally, and managed to get to the end of all levels in-

3.3. how can ai play games?

111

fig. 3.3 an illustration of the key steps of id67 for playing super mario bros (nintendo,
1985). the agent considers a maximum of nine possible actions at each frame of the game, as a
result of combining the jump and speed buttons with moving right or left (top    gure). then the
agent picks the action with the highest heuristic value (middle    gure). finally, the mario agent
takes the action (i.e., right, jump, speed in this example), moves to a new state and evaluates the
new action space in this new state (bottom    gure). more details about the a* agent that won the
mario ai competition in 2009 can be found in [705].

112

chapter 3. playing games

cluded in the competition software. a video showing the agent navigating one of
the levels gathered more than a million views on youtube;2 the appeal of seeing the
agent playing the game is partly the extreme skill of the agent in navigating among
multiple enemies.

it is important to note that the success of this agent is due to several factors. one
is that the levels are fairly linear; in a later edition of the competition, levels with
dead ends which required back-tracking were introduced, which defeated the pure
a* agent [322]. two other factors are that super mario bros (nintendo, 1985) is
deterministic and has locally perfect information (at any instant the information in
the current screen is completely known) and of course that a good forward model is
available: if the a* would not have used a complete model of the game including
the movement of enemies, it would have been impossible to plan paths around these
enemies.

3.3.1.2 stochastic tree search

the mcts algorithm burst onto the scene of go research in 2006 [141, 77], and her-
alded a quantum leap in performance of go-playing ai. classic adversarial search
had performed poorly on go, partly because the branching factor is too high (about
an order of magnitude higher than chess) and partly because the nature of go makes
it very hard to algorithmically judge the value of a board state. mcts partly over-
comes these challenges by building imbalanced trees where not all moves need to
be explored to the same depth (reduces effective branching factor) and by doing
random rollouts until the end of the game (reduces the need for a state evaluation
function). the alphago [629] software which beat two of the best human go play-
ers in the world in 2016 and 2017, is built around the mcts algorithm.

the success of mcts on go has led researchers and practitioners to explore its
use for playing a wide variety of other games, including trading card games [746],
platform games [294], real-time strategy games [311, 645], racing games [203] and
so on. of course, these games differ in many ways from go. while go is a de-
terministic perfect information game, a real-time strategy game such as starcraft
(blizzard entertainment, 1998), a trading card game such as magic: the gathering,
or any poker variant feature both hidden information and stochasticity. methods
such as information set id169 are one way of dealing with these
issues, but impose computational costs of their own [146].

another problem is that in games with    ne time granularity, it might take a pro-
hibitively long time for a rollout to reach a terminal state (a loss or a win); in many
video games it is possible to take an arbitrary number of actions without winning
or losing the game, or even doing something that materially affects the outcome
of the game. for example, in super mario bros (nintendo, 1985), most randomly
generated action sequences would not see mario escaping the original screen, but
basically pacing back and forth until time runs out, thousands of time steps later.

2 https://www.youtube.com/watch?v=dlkms4zhhr8

3.3. how can ai play games?

113

one response to this problem is to only roll out a certain number of actions, and if a
terminal state is not encountered use a state evaluation function [77]. other ideas in-
clude pruning the action selection so as to make the algorithm search deeper [294].
given the large number of modi   cations to all components of the mcts algorithm,
it makes more sense to think of mcts as a general algorithmic framework rather
than as a single algorithm.

many games could be played either through mcts, uninformed search (such as
breadth-   rst search) or informed search (such as a*). deciding which method to
use is not always straightforward, but luckily these methods are relatively simple
to implement and test. generally speaking, minimax can only be used for (two-
player) adversarial games whereas other forms of uninformed search are best used
for single-player games. best-   rst search requires some kind of estimate of a dis-
tance to a goal state, but this does not need to be a physical position or the end goal
of the game. varieties of mcts can be used for both single-player and two-player
games, and often outperform uninformed search when branching factors are high.

3.3.1.3 evolutionary planning

interestingly, decision making through planning does not need to be built on tree
search. alternatively, one can use optimization algorithms for planning. the basic
idea is that instead of searching for a sequence of actions starting from an initial
point, you can optimize the whole action sequence. in other words, you are search-
ing the space of complete action sequences for those that have maximum utility.
evaluating the utility of a given action sequence is done by simply taking all the
actions in the sequence in simulation, and observing the value of the state reached
after taking all those actions.

the appeal of this idea is that an optimization algorithm might search the plan
space in a very different manner compared to a tree search algorithm: all tree search
algorithms start from the root of the tree (the origin state) and build a tree from that
point. evolutionary algorithms instead regard the plan as simply a sequence, and
can perform mutations or crossover at any point in the string. this could help in
guiding the search at different areas of the plan space that a tree search algorithm
would explore for the same problem.

while many different optimization algorithms could be used, the few studies on
optimization-based planning in games that can be found in the literature use evo-
lutionary algorithms. perez et al. proposed using evolutionary planning for single-
player action games, calling this approach    rolling horizon evolution    [526]. in the
particular implementation for the physical traveling salesman problem (a hybrid
between the classic tsp problem and a racing game), an evolutionary algorithm
was used to generate a plan every time step. the plan was represented as a sequence
of 10-20 actions, and a standard evolutionary algorithm was used to search for plans.
after a plan was found, the    rst step of the plan was executed, just as would be the
case with a tree search algorithm. agents based on evolutionary planning generally
perform competitively in the general video game ai competition [528].

114

chapter 3. playing games

evolutionary planning is particularly promising as a technique for handling very
large branching factors, as we have seen that games with multiple independent units
(such as strategy games) can have. justesen et al. [309] applied evolutionary com-
putation to select actions in the turn-based strategy game hero academy (robot
entertainment, 2012), calling this approach    online evolution   . given the number
of units the player controls and the number of actions available per unit, the branch-
ing factor is about one million; therefore, only a single turn ahead was planned.
evolutionary planning was shown to outperform id169 by a wide
margin in that game. wang et al. [745], and justesen and risi [310] later applied
variants of this technique to starcraft (blizzard entertainment, 1998) tactics. given
the continuous-space nature of the game, the branching factor would be extreme if
every possible movement direction for every unit was considered as a separate ac-
tion. what was evolved was therefore not a sequence of actions, but rather which
of several simple scripts (tactics) each unit would use in a given time step (this idea
was borrowed from churchill and buro, who combined a    portfolio    of scripts with
simple tree search [123]). wang et al. [745] showed that evolutionary planning per-
formed better than several varieties of tree search algorithms in this simple starcraft
(blizzard entertainment, 1998) scenario.

evolutionary planning in games is a recent invention, and there are only a limited
number of studies on this technique so far. it is not well understood under what
conditions this technique performs well, or even really why it performs so well
when it does. a major unsolved problem is how to perform evolutionary adversarial
planning [586]; whereas planning based on tree search works in the presence of an
adversary (for example, see the minimax algorithm), it is not clear how to integrate
this into a genotype. perhaps through competitive coevolution of actions taken by
different players? there is, in other words, plenty of scope for further research in
this area.

3.3.1.4 planning with symbolic representations

while planning on the level of in-game actions requires a fast forward model, there
are other ways of using planning in games. in particular, one can plan in an abstract
representation of the game   s state space. the    eld of automated planning has studied
planning on the level of symbolic representations for decades [228]. typically, a
language based on    rst-order logic is used to represent events, states and actions, and
tree search methods are applied to    nd paths from the current state to an end state.
this style of planning originated with the strips representation used in shakey,
the world   s    rst digital mobile robot [494]; symbolic planning has since been used
extensively in numerous domains.

the horror-themed    rst-person shooter f.e.a.r. (sierra entertainment, 2005) be-
came famous within the ai community for its use of planning to coordinate npc
behavior. the game   s ai also received nice reviews in the gaming press, partly be-
cause the player is able to hear the npcs communicate with each other about their
plan of attack, heightening immersion. in f.e.a.r. (sierra entertainment, 2005),

3.3. how can ai play games?

115

a strips-like representation is used to plan which npcs perform which actions
(   ank, take cover, suppress,    re, etc.) in order to defeat the player character. the
representation is on the level of individual rooms, where movement between one
room and the next is usually a single action [507]. using this high-level representa-
tion, it is possible to plan much further ahead than would be possible when planning
on the scale of individual game actions. such a representation, however, requires
manually de   ning states and actions.

3.3.2 id23

as discussed in chapter 2, a id23 algorithm is any algorithm that
solves a id23 problem. this includes algorithms from the tempo-
ral difference or approximate id145 family (for simplicity, we will
refer to such algorithms as classic id23 methods), applications of
evolutionary algorithms to id23 such as neuroevolution and ge-
netic programming, and other methods. in this section, we will discuss both classic
methods (including those that involve deep neural networks) and evolutionary meth-
ods as they are applied for playing games. another way of describing the difference
between these methods is the difference between ontogenetic (which learns during
   lifetimes   ) and phylogenetic (which learns between    lifetimes   ) methods [715].

id23 algorithms are applicable to games when there is learn-
ing time available. usually this means plenty of training time: most reinforcement
learning methods will need to play a game thousands, or perhaps even millions, of
times in order to play it well. therefore, it is very useful to have a way of playing
the game much faster than real-time (or a very large server farm). some reinforce-
ment learning algorithms, but not all, also require a forward model. once it has been
trained, a reinforcement-learned policy can usually be executed very fast.

it is important to note that the planning-based methods (described in the previ-
ous section) for playing games cannot be directly compared with the reinforcement
learning methods described in this section. they solve different problems: plan-
ning requires a forward model and signi   cant time at each time step; reinforcement
learning instead needs learning time and may or may not need a forward model.

3.3.2.1 classic and deep id23

as already mentioned in the introduction of this book, classic reinforcement learn-
ing methods were used with games early on, in some cases with considerable suc-
cess. arthur samuel devised an algorithm   which can be said to be the    rst clas-
sic id23 algorithm   in 1959 to create a self-learning checkers
player. despite the very limited computational resources of the day, the algorithm
learned to play well enough to beat its creator [591]. another success for classic
id23 in game-playing came a few decades later, when gerald

116

chapter 3. playing games

tesauro used the modern formulation of temporal difference learning to teach a
simple neural network to play backgammon, named td-gammon; it learned to play
surprisingly well, after starting with no information and simply playing against it-
self [689] (td-gammon is covered in more detail in chapter 2). this success moti-
vated much interest in id23 during the 1990s and early 2000s.

however, progress was limited by the lack of good function approximators for
the value function (e.g., the q function). while algorithms such as id24 will
provably converge to the optimal policy under the right conditions, the right condi-
tions are in fact very restrictive. in particular, they include all state values or {state,
action} values that are stored separately, for example, in a table. however, for most
interesting games there are far too many possible states for this to be feasible   
almost any video game has at least billions of states. this means that the table would
be too big to    t in memory, and that most states would never be visited during learn-
ing. it is clearly necessary to use a compressed representation of the value function
that occupies less memory and also does not require every state to be visited in or-
der to calculate its value. it can, instead, calculate it based on neighboring states that
have been visited. in other words, what is needed is a function approximator, such
as a neural network.

however, using neural networks together with temporal difference learning turns
out to be non-trivial. it is very easy to encounter    catastrophic forgetting   , where
sophisticated strategies are unlearned in favor of degenerate strategies (such as al-
ways taking the same action). the reasons for this are complex and go beyond the
discussion in this chapter. however, to intuitively understand one of the mecha-
nisms involved, consider what would usually happen for a id23
agent playing a game. rewards are very sparse, and the agent will typically see long
stretches of no reward, or negative reward. when the same reward is encountered
for a long time, the id26 algorithm will be trained only with the target
value of that reward. in terms of supervised learning, this is akin to training for a
long term on a single training example. the likely outcome is that the network learns
to only output that target value, regardless of the input. more details on the method
of approximating a value function using an ann can be found in section 2.8.2.3.

a major success in the use of id23 of the temporal difference
variety together with function approximators came in 2015, when google deep-
mind published a paper where they managed to train deep neural networks to play
a number of different games from the classic atari 2600 games console [464]. each
network was trained to play a single game, with the inputs being the raw pixels of
the game   s visuals, together with the score, and the output being the controller   s
directions and    re button. the method used to train the deep networks is deep q
networks, which is essentially standard id24 applied to neural networks with
many layers (some of the layers used in the architecture were convolutional). cru-
cially, they managed to overcome the problems associated with using temporal dif-
ference techniques together with neural networks by a method called experience
replay. here, short sequences of gameplay are stored, and replayed to the network
in varying order, in order to break up the long chains of similar states and reward.

3.3. how can ai play games?

117

this can be seen as akin to batch-based training in supervised learning, using small
batches.

3.3.2.2 evolutionary id23

the other main family of id23 methods is evolutionary methods.
in particular, using evolutionary algorithms to evolve the weights and/or topology of
neural networks (neuroevolution) or programs, typically structured as expression
trees (genetic programming). the    tness evaluation consists in using the neural
network or program to play the game, and using the result (e.g., score) as a    tness
function.

this basic idea has been around for a long time, but was surprisingly under-
explored for a long time. john koza, a prominent researcher within genetic pro-
gramming, used an example of evolving programs for playing pac-man in his 1992
book [356]. a couple of years later, pollack and blair showed that evolutionary com-
putation can be used to train backgammon players using the same setup as tesauro
used in his experiments with td learning, and with similar results [537]. outside
of games, a community of researchers was forming in the 1990s exploring the idea
of using evolutionary computation to learn control strategies for small robots; this
   eld came to be called evolutionary robotics [496]. training robots to solve sim-
ple tasks of e.g., navigation, obstacle-avoidance and situational learning has very
much in common with training npcs to play games, in particular two-dimensional
arcade-like games [567, 767, 766].

starting around 2005, a number of advances were made in applying neuroevolu-
tion to playing different types of video games. this includes applications to car rac-
ing [707, 709, 392, 353],    rst-person shooters [518], strategy games [79], real-time
strategy games [654] and classic arcade games such as pac-man [766, 403]. perhaps
the main takeaway from this work is that neuroevolution is extremely versatile, and
can be applied to a wide range of games, usually in several different ways for each
game. for example, for a simple car racing game it was shown that evolving neural
networks that acted as state evaluators, even in combination with a simple one-step
lookahead search, substantially outperformed evolving neural networks working as
action evaluators (q functions) [408]. input representation matters too; as discussed
in section 3.2.2.1, egocentric inputs are generally strongly preferred, and there are
additional considerations for individual game types, such as how to represent mul-
tiple adversaries [654].

neuroevolution has seen great success in learning policies in cases where the
state can be represented using relatively few dimensions (say, fewer than 50 units
in the neural network   s input layer), and is often easier to tune and get working
than classic id23 algorithms of the temporal difference variety.
however, neuroevolution seems to have problems scaling up to problems with very
large input spaces that require large and deep neural networks, such as those using
high-dimensional pixel inputs. the likely reason for this is that stochastic search in
weight space suffers from the curse of dimensionality in a way that id119

118

chapter 3. playing games

search (such as id26) does not. currently, almost all successful exam-
ples of learning directly from high-dimensional pixel inputs use deep id24
or similar methods, though there are approaches that combine neuroevolution with
unsupervised learning, so that controllers are learned that use a compressed repre-
sentation of the visual feed as input [353].

for more details on the general method of neuroevolution and pointers to the
literature the reader is referred to section 2.8.1, and to the recent survey paper on
neuroevolution in games [567].

3.3.3 supervised learning

games can also be played using supervised learning. or rather, policies or con-
trollers for playing games can be learned through supervised learning. the basic
idea here is to record traces of human players playing a game and train some func-
tion approximator to behave like the human player. the traces are stored as lists of
tuples <features, target> where the features represent the game state (or an observa-
tion of it that would be available to the agent) and the target is the action the human
took in that state. once the function approximator is adequately trained, the game
can be played   in the style of the human(s) it was trained on   by simply taking
whatever action the trained function approximator returns when presented with the
current game state. alternatively, instead of learning to predict what action to take,
one can also learn to predict the value of states, and use the trained function ap-
proximator in conjunction with a search algorithm to play the game. further details
about the potential supervised algorithms that can be used in games are described in
chapter 2.

3.3.4 chimeric game players

while planning, id23 and supervised learning are fundamentally
different approaches to playing games, solving the game-playing problem under
different constraints, which does not mean that they cannot be combined. in fact,
there are many examples of successful hybrids or chimeras of approaches from
these three broad classes. one example is dynamic scripting [650] which can be
viewed as a form of a learning classi   er system [363] in that it involves a rule-
based (here called script-based) representation coupled with id23.
dynamic scripting adjusts the importance of scripts via id23 at
runtime and is based on the current game state and immediate rewards obtained.
dynamic scripting has seen several applications in games including    ghting games
[417] and real-time strategy games [409, 154]. the approach has been used mainly
for ai that adapts to the skills of the player, thereby aiming at the experience of the
player and not necessarily at wining the game.

3.4. which games can ai play?

119

another good example is alphago. this extremely high-performing go-playing
agent actually combines planning through search, id23 and super-
vised learning [629]. at the core of the agent is a id169 algorithm
which searches in the state space (planning). rollouts, however, are combined with
evaluations from a neural network which estimates the value of states, and node
selection is informed by a position estimation network. both the state network and
position network are initially trained on databases of games between grandmasters
(supervised learning), and later on further trained by self-play (reinforcement learn-
ing).

3.4 which games can ai play?

different games pose different challenges for ai playing, in the same way they pose
different challenges for human playing. not only are there differences in what kind
of access the ai player has to the games, but also between different game types:
a policy for playing chess is unlikely to be pro   cient at playing the games in the
grand theft auto (rockstar games, 1997   2013) series. this section is organized
according to game genres, and for each game genre it discusses what the particu-
lar cognitive, perceptual, behavioral and kinesthetic challenges games of that genre
generally pose, and then gives an overview of how ai methods have been used to
play that particular game genre. it also includes several extended examples, giving
some detail about particular implementations. once again it is important to note that
the list is not inclusive of all possible game genres ai can play as a player or non-
player character; the selection is made on the basis of popularity of game genres and
the available published work on ai for playing games in each genre.

3.4.1 board games

as discussed in the introduction of this book, the earliest work on ai for playing
games was done in classic board games, and for a long time that was the only way in
which ai was applied to playing games. in particular, chess was so commonly used
for ai research that it was called the    drosophila of arti   cial intelligence    [194], al-
luding to the use of the common fruit    y as a model organism in genetics research.
the reasons for this seem to have been that board games were simple to implement,
indeed possible at all to implement on the limited computer hardware available in
the early days of ai research, and that these games were seen to require something
akin to    pure thought   . what a game such as chess or go does require is adversar-
ial planning. classic board games typically place no demand at all on perception,
reactions, motor skills or estimation of continuous movements, meaning that their
skill demands are particularly narrow, especially compared to most video games.

120

chapter 3. playing games

most board games have very simple discrete state representations and determin-
istic forward models   the full state of the game can often be represented in less
than 100 bytes, and calculating the next state of the game is as simple as applying
a small set of rules   and reasonably small branching factors. this makes it very
easy to apply tree search, and almost all successful board game-playing agents use
some kind of tree search algorithm. as discussed in the sections on tree search in
chapter 2, the minimax algorithm was originally invented in the context of playing
chess. decades of research concentrated on playing chess (with a lesser amount of
research on checkers and go), with speci   c conferences dedicated to this kind of
research, led to a number of algorithmic advances that improved the performance of
the minimax algorithm on some particular board game. many of these have limited
applicability outside of the particular game they were developed on, and it would
take us too far to go into these algorithmic variations here. for an overview of ad-
vances in chess playing, the reader is referred to [98].

in checkers the reigning human champion was beaten by the chinook software
in 1994 [594] and the game was solved in 2007, meaning that the optimal set of
moves for both players was found (it is a draw if you play optimally) [593]; in
chess, garry kasparov was famously beaten by deep blue in 1997 [98]. it took until
2016 for google deepmind to beat a human go champion with their alphago soft-
ware [629], mainly because of the algorithmic advances necessary. whereas chess
and checkers can be played effectively with some variation of the minimax algo-
rithm combined with relatively shallow state evaluations, the larger branching factor
of go necessitated and spurred the development of mcts [77].

while mcts can be utilized to play board games without a state evaluation func-
tion, supplementing that algorithm with state and action evaluation functions can
massively enhance the performance, as seen in the case of alphago, which uses
deep neural networks for state and action evaluation. on the other hand, when using
some version of minimax it is necessary to use state evaluation functions as all inter-
esting board games (more complex than tic-tac-toe) have too large state spaces to
be searched until the end of the game in acceptable time. these evaluation functions
can be manually constructed, but in general it is a very good idea to use some form of
learning algorithm to learn their parameters (even though the structure of the func-
tion is speci   ed by the algorithm designer). as discussed above, samuel was the
   rst to use a form of id23 to learn a state evaluation function in a
board game (or any kind of game) [591], and tesauro later used td learning to very
good effect in backgammon [689]. evolutionary computation can also be used to
learn evaluation functions, for example, pollack showed that co-evolution could per-
form well on backgammon using a very similar setup to tesauro [537]. noteworthy
examples of strong board game players based on evolved evaluation functions are
blondie24 [207] and blondie25 [208], a checkers- and a chess-playing program re-
spectively. the evaluation functions were based on    ve-layered deep convolutional
networks, and blondie25 in particular performed well against very strong chess
players.

while classic board games such as go and chess have existed for hundreds or
even thousands of years, the past few decades have seen a rejuvenation of board

3.4. which games can ai play?

121

game design. many of the more recently designed board games mix up the formula
of classic board games with design thinking from other game genres. a good exam-
ple is ticket to ride (days of wonder, 2004), which is a board game that includes
elements of card games, such as variable numbers of players, hidden information
and stochasticity (in the draw of the cards). for these reasons, it is hard to construct
well-performing ai players based on standard tree-search methods; the best known
agents include substantial domain knowledge yet perform poorly compared to hu-
man players [160]. creating generic well-performing agents for this type of game is
an interesting research challenge.

given the simplicity of using tree search for board game playing, it is not surpris-
ing that every approach we have discussed so far builds on one tree search algorithm
or another. however, it is possible to play board games without forward models   
usually with results that are    interesting    rather than good. for example, stanley and
miikkulainen developed a    roving eye    approach to playing go, where an evolved
neural network self-directedly scans the go board and decides where to place the
next piece [656]. relatedly, it is reportedly possible for the position evaluation net-
work of alphago to play a high-quality game of go on its own, though it naturally
plays stronger if combined with search.

3.4.2 card games

card games are games centered on one or several decks of cards; these might or
might not be the standard 52-card french deck which is commonly used in classic
card games. most card games involve players possessing different cards that change
ownership between players, or between players and the deck, or other positions on
the table. another important element of most card games is that some cards are
visible to the player who possesses them but not to other players. therefore, almost
all card games feature a large degree of hidden information. in fact, card games
are perhaps the type of games where hidden information most dominates gameplay.
for example, take the classic card game poker, which is currently very popular
in its texas hold    em variety. the rules are relatively simple: the player which at
the end of a few rounds holds the best cards (the    best hand   ) wins. between the
rounds, the player can exchange a number of cards for fresh cards drawn from the
deck. if there were perfect information, i.e., all players could see each others    hands,
this would be an uninteresting game that could be played according to a lookup
table. what makes texas hold    em   and similar poker variants   challenging and
interesting is that each player does not know what cards the other players have.
the cognitive challenges of playing these games involve acting in the absence of
information, which implies inferring the true game state from incomplete evidence,
and potentially affecting other players    perception of the true game state. in other
words, a game of poker is largely about guessing and bluf   ng.

a key advance in playing poker and similar games is the counterfactual regret
minimization (cfr) algorithm [797]. in cfr, algorithms learn by self-play in a

122

chapter 3. playing games

similar fashion to how temporal difference learning and other reinforcement learn-
ing algorithms have been used in perfect information games like backgammon and
checkers. the basic principle is that after every action, when some hidden state has
been revealed, it computes the alternative reward of all other actions that could have
been taken, given the newly revealed information. the difference between the re-
ward attained from the action that was actually taken and the best action that could
have been taken is called the regret. the policy is then adjusted so as to minimize
the regret. this is done iteratively, slowly converging on a policy that is optimal in
the sense that it loses as little as possible over a large number of games. however,
for games as complex as texas hold    em, simpli   cations have to be done in order to
use the cfr algorithm in practice.

deepstack is a recent agent and algorithm that has reached world-class perfor-
mances in texas hold    em [467]. like cfr, deepstack uses self-play and recursive
reasoning to learn a policy. however, it does not compute an explicit strategy be-
fore play. instead, it uses tree search in combination with a state value approxima-
tion to select actions at each turn. in this sense, it is more like the heuristic search
of alphago (but in a setting with plenty of imperfect information) than like the
reinforcement-learned policy of td-gammon.

another, much more recent, card game which is drawing increasing interest from
the research community is hearthstone (blizzard entertainment, 2014); see fig. 3.4.
this is a collectible card game in the tradition of magic: the gathering, but with
somewhat simpler rules and only played on computers. a game of hearthstone takes
place between two players, with each player having a deck of 30 cards. each card
represents either a creature or a spell. each player has a handful of cards (< 7) in
hand (invisible for the other player), and at each turn draws a new card and has
the option of playing one or more cards. creature cards convert to creatures that
are placed on the player   s side of the table (visible for both players), and creatures
can be used to attack the opponent   s creatures or player character. spells have a
multiplicity of different effects. the hundreds of different cards in the game, the
possibility of choosing to take multiple actions each turn, the long time taken to
play a game (20 to 30 turns is common), the presence of stochasticity and of course
the hidden information (mainly what cards are in the opponent   s hand) conspire
to make hearthstone (blizzard entertainment, 2014) a hard game to play for both
humans and machines.

perhaps the simplest approach to playing hearthstone (blizzard entertainment,
2014) is to simply ignore the hidden information and play each turn in a greedy
fashion, i.e., search the space of possible actions within a single turn and choose
the one that optimizes some criterion such as health point advantage at the end of
that turn, given the available information only. agents that implement such greedy
policies are included with some open source hearthstone simulators, such as meta-
stone.3 standard tree search algorithms such as minimax or mcts are generally
ineffective here (as in poker) because of the very high degree of hidden informa-
tion. one approach to constructing high-performing agents is instead to hand-code

3 http://www.demilich.net/

3.4. which games can ai play?

123

fig. 3.4 a screenshot from hearthstone (blizzard entertainment, 2014) displaying a number of
different creature or spell cards available in the game. image obtained from wikipedia (fair use).

domain knowledge, for example, by building an ontology of cards and searching in
an abstract symbolic space [659].

unlike in poker, where the player has no control over what cards it is dealt, in
hearthstone (blizzard entertainment, 2014) the player can also construct a deck
with which to play the game. this adds another level of challenge to playing the
game: in addition to choosing what action(s) to take at each turn, the successful
player must also construct what allows her to implement her strategy. the com-
position of the deck effectively constrains what strategy can be chosen, and then
implemented tactically through action selection. while these two levels interplay   
a strong player takes the composition of the deck and the strategy it affords into
account when choosing a move, and vice versa   it is also true that the problems of
deck building and action selection can to some extent be treated separately, and im-
plemented in different agents. one approach to deck building is to use evolutionary
computation. the deck is seen as the genome, and the    tness function involves sim-
ple heuristic agents using the deck for playing [218]. a similar approach has also
been used in the multi-player card game dominion [416].

3.4.3 classic arcade games

classic arcade games, of the type found in late 1970s and early 1980s arcade cabi-
nets, home video game consoles and home computers, have been commonly used as
ai benchmarks within the last decade. representative platforms for this game type

124

chapter 3. playing games

(a) track & field (konami, 1983) is a game
about athletics. the game screenshot depicts
the start of the 100 m dash. image obtained
from wikipedia (fair use).

(b) in tapper (bally midway, 1983) the
player controls a bartender who serves
drinks to customers. image obtained from
wikipedia (fair use).

fig. 3.5 track & field (konami, 1983), tapper (bally midway, 1983), and most classic arcade
games require rapid reactions and precision.

are the atari 2600, nintendo nes, commodore 64 and zx spectrum. most classic
arcade games are characterized by movement in a two-dimensional space (some-
times represented isometrically to provide the illusion of three-dimensional move-
ment), heavy use of graphical logics (where game rules are triggered by intersection
of sprites or images), continuous-time progression, and either continuous-space or
discrete-space movement.

the cognitive challenges of playing such games vary by game. most games re-
quire fast reactions and precise timing, and a few games, in particular early sports
games such as track & field (konami, 1983) and decathlon (activision, 1983), rely
almost exclusively on speed and reactions (fig. 3.5(a)). very many games require
prioritization of several co-occurring events, which requires some ability to predict
the behavior or trajectory of other entities in the game. this challenge is explicit
in e.g., tapper (bally midway, 1983)   see fig. 3.5(b)   but also in different ways
part of platform games such as super mario bros (nintendo, 1985), shooting gal-
leries such as duck hunt (nintendo, 1984) or missile command (atari inc., 1980)
and scrolling shooters such as defender (williams electronics   taito, 1981) or r-
type (irem, 1987). another common requirement is navigating mazes or other com-
plex environments, as exempli   ed most clearly by games such as pac-man (namco,
1980), ms pac-man (namco, 1982), frogger (sega, 1981) and boulder dash (first
star software, 1984), but also common in many platform games. some games, such
as montezuma   s revenge (parker brothers, 1984), require long-term planning in-
volving the memorization of temporarily unobservable game states. some games
feature incomplete information and stochasticity, others are completely determinis-
tic and fully observable.

3.4. which games can ai play?

3.4.3.1 pac-man and ms pac-man

125

various versions and clones of the classic pac-man (namco, 1981) game have been
frequently used in both research and teaching of arti   cial intelligence, due to the
depth of challenge coupled with conceptual simplicity and ease of implementation.
in all versions of the game, the player character moves through a maze while avoid-
ing pursuing ghosts. a level is won when all pills distributed throughout the level
are collected. special power pills temporarily give the player character the power
to consume ghosts rather than being consumed by them. as seen in chapter 2, the
differences between the original pac-man (namco, 1981) and its successor ms pac-
man (namco, 1982) may seem minor but are actually fundamental; the most impor-
tant is that one of the ghosts in ms pac-man (namco, 1982) has non-deterministic
behavior, making it impossible to learn a    xed sequence of actions as a solution
to the game. the appeal of this game to the research community is evidenced by a
recent survey covering over 20 years of active ai research using these two games as
testbeds [573].

several frameworks exist for pac-man-based experimentation, some tied to com-
petitions. the pac-man screen capture competition is based around the microsoft
revenge of arcade version of the original game, and does not provide a forward
model nor facilities for speeding up the game [404]. the ms pac-man vs ghost
team competition framework is written in java and includes both a forward model
and ability to speed up the game signi   cantly; it also includes an interface for con-
trolling the ghost team rather than ms pac-man, the player character [574]. the
atari 2600 version of ms pac-man (namco, 1982) is available as part of the ale
framework.4 there is also a python-based pac-man framework used for teaching ai
at uc berkeley.5

as expected, the performance of ai players varies depending on the availabil-
ity of a forward model, which allows the simulation of ghost behavior. the screen
capture-based competition, which does not offer a forward model, is dominated by
heuristic approaches (some of them involve path   nding in the maze without tak-
ing ghost movement into account), which perform at the level of beginner human
players [404]. it has been observed that even searching one step ahead, and using
a state evaluator based on an evolved neural network, can be an effective method
for playing the game [403]. of course, searching deeper than a single ply yields
additional bene   ts; however, the stochasticity introduced in ms pac-man (namco,
1982) poses challenges even in the presence of a forward model. mcts has been
shown to work well in this case [590, 524]. model-free approaches to reinforcement
learning have also been used for playing the game with some success [57]. in gen-
eral, the best competitors in the ms pac-man vs ghost team competition play at
the level of intermediate-skill human players [574]. at the moment of writing this
book ms pac-man (namco, 1982) is reported to be practically solved (reaching the
maximum possible score of 999,990 points) by the microsoft maluuba team. the

4 www.arcadelearningenvironment.org
5 http://ai.berkeley.edu/project overview.html

126

chapter 3. playing games

team used an rl technique called hybrid reward architecture [738] which decom-
poses the reward function of the environment into different rl problems (a set of
reward functions) that a corresponding number of agents need to solve. each agent
selects its actions by considering the aggregated q values for each action across all
agents.

pac-man (namco, 1980) can also be played for experience rather than perfor-
mance. in a series of experiments, neural networks that controlled the ghosts in a
clone of the game were evolved to make the game more entertaining for human
players [766]. the experiment was conceptually based on malone   s de   nition of
fun in games as challenge, curiosity and fantasy dimensions [419] and sought to
   nd ghost behavior that maximized these traits. in particular, the    tness was com-
posed of three factors: 1) the appropriate level of challenge (i.e., when the game is
neither too hard nor too easy), 2) the diversity of ghost behavior, and 3) the ghosts   
spatial diversity (i.e., when ghosts behavior is explorative rather than static). the
   tness function used to evolve interesting ghost behaviors was cross-validated via
user studies [770].

3.4.3.2 super mario bros

versions and clones of nintendo   s landmark platformer super mario bros (nin-
tendo, 1985) have been extremely popular for ai research, including research on
game playing, content generation and player modeling (research using this game is
described in several other parts of this book). a large reason for this is the mario
ai competition, which was started in 2009 and included several different tracks
focused on playing for performance, playing in a human-like manner and generat-
ing levels [322, 717]. the software framework for that competition6 was based on
in   nite mario bros (notch, 2008), a java-based clone of super mario bros (nin-
tendo, 1985) featuring simple level generation [706, 705]. different versions of the
competition software, generally referred to as the mario ai framework or mario
ai benchmark, have since been used in many dozens of research projects. in the
following, we will for simplicity refer to methods for playing various versions of
super mario bros (nintendo, 1985), in   nite mario bros or the mario ai frame-
work/benchmark simply as playing    mario   .

the    rst version of the mario ai could be simulated thousands of times faster
than real-time, but did not include a forward model. therefore the    rst attempts to
learn a mario-playing agent was through learning a function from a state observa-
tion directly to mario actions [706]. in that project, neural networks were evolved
to guide mario through simple procedurally generated levels. the inputs were the
presence or absence of environment features or enemies in a coarse grid centered
on mario, and the outputs were interpreted as the button presses on the nintendo
controller (up, down, left, right). see fig. 3.6 for an illustration of the state represen-
tation. a standard feedforward mlp architecture was used for the neural network,

6 http://julian.togelius.com/mariocompetition2009/

3.4. which games can ai play?

127

fig. 3.6 the inputs to the mario-playing neural network are structured as a moore neighborhood
centered on mario. each input is 1 if the corresponding tile is occupied by a tile (such as ground)
that mario cannot pass through, and 0 otherwise. in another version of the experiment, a second set
of inputs was added where an input was 1 if there was an enemy at the corresponding tile. image
adapted from [706].

and the    tness function was simply how far the controller was able to progress on
each level. using this setup and a standard evolution strategy, neural networks were
evolved that could win some levels but not all, and generally played at the strength
of a human beginner.

however, as is so often the case, having a forward model makes a big difference.
the    rst mario ai competition, in 2009, was won by robin baumgarten, who con-
structed a forward model for the game by reusing some of the open-source game
engine code [705]. using this model, he constructed an agent based on id67 in
state space. at each time frame, the agent searches for the shortest path towards the
right edge of the screen, and executes the    rst action in the resulting plan. as the
search utilizes the forward model and therefore takes place in state space rather than
just physical space, it can incorporate the predicted movements of the (determinis-
tic) enemies in its planning. this agent was able to    nish all the levels used in the
2009 mario ai competition, and produces behavior that appears optimal in terms
of time to complete levels (it does not focus on collecting coins or killing enemies).
see section 2.3.2 for an explanation of the algorithm and a    gure illustrating its use
in mario.

128

chapter 3. playing games

fig. 3.7 an example level generated for the 2010 mario ai competition. note the overhanging
structure in the middle of the screenshot, creating a dead end for mario; if he chooses to go beneath
the overhanging platform, he will need to backtrack to the start of the platform and take the upper
route instead after discovering the wall at the end of the structure. agents based on simple a*
search are unable to do this.

given the success of the a*-based agent in the 2009 competition, the next year   s
edition of the competition updated the level generator so that it generated more
challenging levels. importantly, the new level generator created levels that included
   dead ends   , structures where mario can take the wrong path and if so must back-
track to take the other path [322]. see fig. 3.7 for an example of such a dead end.
these structures effectively    trap    agents that rely on simple best-   rst search, as
they end up searching a very large number of paths close to the current position,
and time out before    nding a path that backtracks all the way to beginning of the
structure. the winner of the 2010 mario ai competition was instead the realm
agent [56]. this agent uses an evolved rule-based system to decide sub-goals within
the current segment of the level, and then navigates to these sub-goals using a*.
realm successfully handles the dead ends that were part of the levels in the 2010
competition, and is as far as we know the highest-performing mario-playing agent
there is.

other search algorithms beyond a* have been tried for playing mario, including
id169 [294]. it was found that the standard formulation of mcts
did not perform very well, because the algorithm did not search deep enough and
because the way the average reward of a branch is calculated results in risk-averse
behavior. however, with certain modi   cations to remedy these problems, an mcts
variant was found that could play mario as well as a pure a* algorithm. in a follow-
up experiment, noise was added to the mario ai benchmark and it was found that
mcts handled this added noise much better than a*, probably because mcts
relies on statistical averaging of the reward whereas a* assumes a deterministic
world.

all of the above work has been focused on playing for performance. work on
playing mario for experience has mostly focused on imitating human playing styles,
or otherwise creating agents that play mario similarly to a human. to further this
research, a turing test track of the mario ai competition was created [619]. in this
track, competitors submitted agents, and their performance on various levels was
recorded. videos of the agents playing different levels where shown to human spec-
tators along with videos of other humans playing the same levels, and the spectators
were asked to indicate which of the videos were of a human player. agents were
scored based on how often they managed to fool humans, similarly to the setup of

213.1marioaibenchmarkfigure3.3:levelgenerated:exampleofamorecomplexlevelrequir-ingadvancedlearningtechniquesor/andheuristicsinvolved.correspondingcommand-lineoptionspassedtocmdlineoptionsclassare:"-lfoff-ltbon-ll400-ld12-ldeon-lcon-lcoon-ls352-ion",whichmeans"level   atdis-abled,leveltubesenabled,levellength400,leveldif   culty12,leveldead-endsenabled,levelcannonsenabled,levelcoinsenabled,levelseed352,invulnera-bilityformarioenabled(otherwiseyou   llhavehardtimetryingtoclearthelevelwithoutthisnicecheating)"figure3.4:levelgenerated:exampleofanothercomplexlevelofunder-groundtype.correspondingcommand-lineoptionspassedtocmdlineoptionsclassare:"-lfoff-ltbon-ll400-ld12-ldeon-lcon-lcoon-ls1352-lt1",whichisalmostthesameasinfigure3.3,soonlythedifferenceis"levelseed1352,leveltype1(underground)"3.4. which games can ai play?

129

the original turing test. the results indicated simple heuristic solutions that included
hand-coded routines for such things as sometimes standing still (giving the impres-
sion of    thinking about the next action   ) or occasionally misjudging a jump can
be very effective in giving the appearance of human playing style. another way of
providing human-like behavior is to explicitly mimic humans by learning from play
traces. ortega et al. describe a method for creating mario-playing agents in the style
of particular human players [511]: evolve neural networks where the    tness func-
tion is based on whether the agent would perform the same action as the human,
when faced with the same situation. this was shown to generate more human-like
behavior than evolving the same neural network architecture with a more straight-
forward    tness function. in a similar effort to create human-like mario ai players
munoz et al. [469] used both play traces and information about the player   s eyes
position on the screen (obtained via gaze tracking) as inputs of an ann, which was
trained to approximate which keyboard action is to be performed at each game step.
their results yield a high prediction accuracy of player actions and show promise to-
wards the development of more human-like mario controllers based on information
beyond gameplay data.

3.4.3.3 the ale framework

the arcade learning environment (ale) is an environment for general game-
playing research based on an emulation of the classic video game console atari
2600 [40]. (while the environment can technically accommodate other emulators as
well, the atari 2600 emulator is the one that has been used in practice, to the point
that the ale framework is sometimes simply referred to as    atari   .) the atari 2600
is a console from 1976 with 128 bytes of ram, maximum 32 kilobytes of rom per
game and no screen buffer, posing severe limitations on the type of games that could
be implemented on the system [466]. ale provides an interface for agents to control
games via the standard joystick input, but does not provide any processed version
of the internal state; instead, it provides the 160    210 pixel screen output to the
agent, which will need to parse this visual information somehow. there is a forward
model, but it is relatively slow and generally not used.

some of the early work using ale used neuroevolution; in particular a study
compared several neuroevolution algorithms on 61 atari games [251]. they found
that they could use the popular neuroevolution algorithm neat to evolve decent-
quality players for individual games, provided that these algorithms were given po-
sitions of in-game objects as recognized by a id161 algorithm. the hy-
perneat algorithm, an indirect encoding neuroevolution algorithm that can create
arbitrarily large networks, was able to learn agents that could play based on the raw
pixel inputs, even surpassing human performance in three of the tested games. in
that paper, the neuroevolution approaches generally performed much better than the
classic id23 methods tried.

later, ale was used in google deepmind   s research on deep id24, which
was reported in a nature paper in 2015 [464]. as detailed in chapter 2, the study

130

chapter 3. playing games

showed that by training a deep neural network (   ve layers, where the    rst two
are convolutional) with id24 augmented with experience replay, human-level
playing performance could be reached in 29 out of 49 tested atari games. that
research spurred a    urry of experiments in trying to improve the core deep rein-
forcement formula presented in that paper.

it is worth noting that in almost all of the ale work focuses on learning neural
networks (or occasionally other agent representations) for individual games. that
is, the network architecture and input representation is the same across all games,
but the parameters (network weights) are learned for a single game and can only
play that game. this seems to be at odds with the idea of general game playing,
i.e., that you could learn agents that play not a single game, but any game you
give them. it could also be noted that ale itself is better suited for research into
playing individual games than for research on general game playing, as there is
only a limited number of atari 2600 games, and it is highly non-trivial to create
new games for this platform. this makes it possible to tune architectures and even
agents to individual games.

3.4.3.4 general video game ai

the general video game ai (gvgai) competition is a game-based ai competi-
tion that has been running since 2014 [528]. it was designed partly as a response to
a trend seen in many of the existing game-based ai competitions, e.g., those orga-
nized at the cig and aiide conferences, that submissions were getting increasingly
game-speci   c by incorporating more and more domain knowledge. a central idea
of gvgai is therefore that submissions to the competition are tested on unseen
games, i.e., games that have not been released to the competitors before and which
are therefore impossible to tailor the submissions to. at the time of writing, the gv-
gai repository includes around 100 games, with ten more games being added for
every competition event.

to simplify the development of games in gvgai, a language called the video
game description language (vgdl) was developed [181, 597]. this language al-
lows for concise speci   cation of games in a python-like syntax; a typical game de-
scription is 20-30 lines, with levels speci   ed in separate    les. given the underlying
assumptions of 2d movement and graphical logics, most of the games in gvgai
corpus are remakes of (or inspired by) classic arcade games such as frogger (sega,
1981) (see fig. 3.8(b)), boulder dash (first star software, 1984) or space invaders
(taito, 1978) (see fig. 3.8(a)), but some are versions of modern indie games such as
a good snow man is hard to build (hazelden and davis, 2015).

the original track of the gvgai competition, for which the most results are
available, is the single-player planning track. here, agents are given a fast forward
model of the game, and 40 milliseconds to use it to plan for the next action. given
these conditions, it stands to reason that planning algorithms of various kinds would
rule the day. most of the top performers in this track have been based on vari-
ations on mcts or mcts-like algorithms, such as the open loop expectimax

3.4. which games can ai play?

131

(a) missile command

(b) freeway

fig. 3.8 two example games that have been used in the gvgai competition.

tree search algorithm [528] or mcts with options search [161]. one surprisingly
high-performing agent uses iterative width search, where the core idea is to build
a propositional database of all the facts and then use this to prune a breadth-   rst
search algorithm to only explore those branches which provide a speci   ed amount
of novelty, as measured by the size of the smallest set of facts seen for the    rst
time [389]. agents based on evolutionary planning also perform well, but not as
well as those based on stochastic tree search or tree search with novelty pruning.

while some agents are better than others overall, there is clear non-transitivity in
the rankings, in the sense that the best algorithms for one particular game may not
be the best for another game   in fact, there seem to be patterns where families of
algorithms perform better on families of games [213, 59]. given these patterns, a
natural idea for achieving higher playing performance is to use hyper-heuristics or
algorithm selection to select at runtime which algorithm to use for which game, an
approach which has seen some success so far [453].

two other gvgai tracks are related to gameplay, namely the two-player plan-
ning track and the learning track. the two-player planning track resembles the
single-player planning track but features a number of two-player games, some of
which are cooperative and some competitive. at the time of writing, the best agents
in this track are slightly modi   ed versions of single-player track agents that make
naive assumptions about the behavior of the other player [216]; it is expected that
agents with more sophisticated player models will eventually do better. the learn-
ing track, by contrast, features single-player games and provides players with time
to learn a policy but does not provide them with a forward model. it is expected that
algorithms such as deep id23 and neuroevolution will do well
here, but there are as yet no results; it is conceivable that algorithms that learn a
forward model and then perform tree search will dominate.

3.4.3.5 other environments

in addition to ale and gvgai, there are several other environments that can be
used for ai experimentation with arcade-style games. the retro learning environ-
ment is a learning environment similar in concept to ale, but instead based on an

132

chapter 3. playing games

emulation of the super nintendo console [45]. a more general, and less focused,
system is openai universe,7 which acts as a uni   ed interface to a large number of
different games, ranging from simple arcade games to complex modern adventure
games.

3.4.4 strategy games

strategy games, particularly computer strategy games, are games where the player
controls multiple characters or units, and the objective of the game is to prevail in
some sort of conquest or con   ict. usually, but not always, the narrative and graphics
re   ect a military con   ict, where units may be e.g., knights, tanks or battleships. the
perhaps most important distinction within strategy games is between turn-based
and real-time strategy games, where the former leave plenty of time for the player
to decide which actions to take each time, and the latter impose a time pressure.
well-known turn-based strategy games include epic strategy games such as the civ-
ilization (microprose, 1991) and the xcom (microprose, 1994) series, as well as
shorter games such as hero academy (robot entertainment, 2012). prominent real-
time strategy games include starcraft i (blizzard entertainment, 1998) and ii (bliz-
zard entertainment, 2010), the age of empires (microsoft studios, 1997   2016) se-
ries and the command and conquer (electronic arts, 1995   2013) series. another
distinction is between single-player games that focus on exploration, such as the
civilization games, and multi-player competitive games such as starcraft (blizzard
entertainment, 1998   2015). most, but not all, strategy games feature hidden infor-
mation.

the cognitive challenge in strategy games is to lay and execute complex plans
involving multiple units. this challenge is in general signi   cantly harder than the
planning challenge in classical board games such as chess mainly because multiple
units must be moved at every turn; the number of units a player controls can eas-
ily exceed the limits of short-term memory. the planning horizon can be extremely
long, where for example in civilization v (2k games, 2010) decisions you make
regarding the building of individual cities will affect gameplay for several hundred
turns. the order in which units are moved can signi   cantly affect the outcome of
a move, in particular because a single action might reveal new information dur-
ing a move, leading to a prioritization challenge. in addition, there is the challenge
of predicting the moves of one or several adversaries, who frequently have multi-
ple units. for real-time strategy games, there are additional perceptual and motoric
challenges related to the speed of the game. this cognitive complexity is mirrored
in the computational complexity for agents playing these games   as discussed in
section 3.2.1.4, the branching factor for a strategy game can easily reach millions
or more.

7 https://universe.openai.com/

3.4. which games can ai play?

133

the massive search spaces and large branching factors of strategy games pose
serious problems for most search algorithms, as just searching a single turn forward
might already be infeasible. one way of handling this is to decompose the prob-
lem, so unit acts on its own; this creates one search problem for each unit, with
the branching factor equivalent to the branching factor of the individual unit. this
has the advantage of being tractable and the disadvantage of preventing coordinated
action among units. nevertheless, heuristic approaches where units are treated sep-
arately are used in the built-in ai in many strategy games. not coincidentally the
built-in ai of many strategy games is generally considered inadequate.

in research on playing strategy games, some solutions to this involve cleverly
sub-sampling the space of turns so that standard search algorithms can be used. an
example of such an approach is an mcts variant based on decomposition through
naive sampling [503]. another approach is non-linear monte carlo, which was
applied to civilization ii (microprose, 1996) with very promising results [65]. the
basic idea here is to sample the space of turns (where each turn consists of actions
for all units) randomly, and get an estimate for the value of each turn by performing
a rollout (take random actions) until a speci   ed point. based on these estimates, a
neural network was trained to predict the value of turns; regression can then be used
to search for the turn with the highest predicted value.

but planning does not need to be based on tree search. justesen et al. applied
online evolutionary planning to hero academy (robot entertainment, 2012), a two-
player competitive strategy game with perfect information and a relatively low num-
ber of moves per turn (   ve in the standard setting) [309]. each chromosome con-
sisted of the actions to take during a single turn, with the    tness function being the
material difference at the end of the turn. it was found that this approach vastly
outperformed mcts (and other tree search algorithms) despite the shallow search
depth of a single turn, likely because the branching factor made it impossible for the
tree search algorithms to suf   ciently explore even the space of this single turn.

evolution has also been used to create agents that play strategy games. for exam-
ple, neat-based macro-management controllers were trained for the strategy game
globulation 2 (2009). in that study, however, the neat controller does not aim to
win but rather play for the experience; in particular, it is evolved to take macro-
actions (e.g., build planning, battle planning) in order to provide a balanced game
for all players [499]. ai approaches based on arti   cial evolution that also have been
used as playtesting mechanisms for a number of other strategy games [588, 297].

3.4.4.1 starcraft

the original starcraft, released in 1998 by blizzard entertainment, is still widely
played competitively, a testament to its strong game design and in particular its
unusual depth of challenge (see fig. 3.10). it is usually played with the brood war
expansion, and referred to as sc:bw. the existence of brood war api (bwapi),8 an

8 https://github.com/bwapi/bwapi

134

chapter 3. playing games

interface for playing the game with arti   cial agents, has enabled a thriving commu-
nity of researchers and hobbyists working an ai for starcraft (blizzard entertain-
ment, 1998). several competitions are held annually based on sc:bw and bwapi,9
including competitions at the ieee cig and aiide conferences [87]. torchcraft
is an environment built on top of sc:bw and bwapi to facilitate machine learn-
ing, especially deep learning, research using starcraft [681]. in parallel, a similar
api was recently released for interfacing ai agents with the follow-up game star-
craft ii (blizzard entertainment, 2010), which is mechanically and conceptually
very similar but with numerous technical differences. given the existing api and
competitions, almost all existing research has been done using sc:bw.

as sc:bw is such a complex game and the challenge of playing it well is so im-
mense, most research focuses on only part of the problem, most commonly through
playing it at some level of abstraction. it is common to divide the different lev-
els of decision-making in sc:bw (and similar real-time strategy games) into three
levels, depending on the time scale: strategy, tactics and micro-management (see
fig. 3.9). so far, no agents have been developed that can play a complete game at
the level of even an intermediate human player; however, there has been signi   cant
progress on several sub-problems of the very formidable problem of playing this
game.

for a fuller overview of research on ai for playing sc:bw, the reader is referred
to a recent survey [504]. below, we will exemplify some of the research done in this
space, with no pretense of complete coverage.

on the micro level ai plays out over the timescale of usually less than a minute,
where time between taking actions is typically on the order of a second. when fo-
cusing on this most low-level form of sc:bw battle, one need not consider base
building, research, fog of war, exploration and many other aspects of the full sc:bw
game. usually, two factions face off, each with a set of a few or a few dozen units.
the goal is to destroy the opponent   s units. this game mode can be played in the
actual game, which does not allow for signi   cant speed-up and does not provide a
forward model, or in the simulator sparcraft [123], which does provide a forward
model. (there is a also a java version of sparcraft, called jarcraft [311].).

in the model-free scenario, agents must be based on either hand-crafted policies
or policies learned through id23 or supervised learning, without
the luxury of a forward model. hand-crafted policies can be implemented e.g., based
on potential    elds, where different units are attracted to or repelled by other units
in order to create effective combat patterns [242], or on fuzzy logic [541]. when
it comes to machine learning methods for model-free scenarios, standard [622] and
deep id23 [729] have been used with some effect to learn policies.
typically, the problem is decomposed so that a single q-function is learned that is
then applied to each unit separately [729].

using the sparcraft simulator, we can do more because of the availability of a
forward model. churchill and buro developed a simple approach to dealing with the
excessive branching factor called portfolio greedy search [123]. the core idea is

9 http://www.starcraftai.com/

3.4. which games can ai play?

135

fig. 3.9 three different levels of decision making in starcraft (blizzard entertainment, 1998).
the width of the triangle represents amount of information whereas its colored gradient illustrates
the degree of partial observability. for instance, at the highest strategic level both the level of
observability and available information to the player are relatively low. on the other end of the
triangle, at the lowest level of micro-management the player must consider the type, position, and
other dynamic properties of each of the units she controls; that information is mostly observable.
for reference, a full game of starcraft (blizzard entertainment, 1998) often takes around 20 min-
utes, though there is considerable variation. the image is reproduced with permission from gabriel
synnaeve.

that instead of selecting between actions for each unit, a small number (a portfolio)
of simple heuristics called scripts are used, and a greedy search algorithm is used to
assign one of these scripts to each unit. this approach prunes the branching drasti-
cally, but limits the space of discoverable policies to those that can be described as
combinations of the scripts. subsequently, it was shown that the portfolio of scripts
idea can be combined with mcts with good results [311]. even better results can
be obtained by doing portfolio selection through evolutionary planning [745]; it is
likely that these ideas generalize to many strategy games and other games with high
branching factors due to their controlling of many units simultaneously.

moving to the other end of the micro-management-tactics-strategy continuum,
large-scale strategy adaptation remains a very hard problem. existing sc:bw bots
are rarely able to implement multiple strategies, let alone adapt their strategy based
on how the game progresses. in order to do this, it is necessary to create a model of

136

chapter 3. playing games

fig. 3.10 a screenshot from starcraft: brood war (blizzard entertainment, 1998) displaying a
number of different units available in the game. at the time of writing, playing well this real-time
strategy game is considered one of the next grand challenges for ai research. image obtained from
wikipedia (fair use).

what the opponent is trying to do based on limited evidence. here, pioneering work
by weber and mateas focused on mining logs of sc:bw matches to predict what
strategy will be taken by a player from early-game actions [750].

a few more ambitious attempts have been made to create complete agents that
can handle strategy, tactics and micro-management in a principled fashion. for ex-
ample, synnaeve and bessi`ere built an agent based on bayesian programming that
is able to perform reasonably well [680].

3.4.5 racing games

racing games are games where the player is tasked with controlling some kind of
vehicle or character so as to reach a goal in the shortest possible time, or as to tra-
verse as far as possible along a track in a given time. usually the game employs a
   rst-person perspective, or a vantage point from just behind the player-controlled
vehicle. the vast majority of racing games take a continuous input signal as a steer-
ing input, similar to a steering wheel. some games, such as those in the forza mo-

3.4. which games can ai play?

137

fig. 3.11 a screenshot from torcs which has been predominately used in the simulated car
racing championship. image obtained from https://sourceforge.net/projects/torcs/ (fair use).

torsport (microsoft studios, 2005   2016) or real racing (firemint and ea games,
2009   2013) series, allow for complex input including gear stick, clutch and hand-
brake, whereas more arcade-focused games such as those in the need for speed
(electronic arts, 1994   2015) series typically have a simpler set of inputs and thus
lower branching factor. racing games such as those in the wipeout (sony computer
entertainment europe, 1995   2012) and mario kart (nintendo, 1992   2017) series
introduce additional elements, such as weapons that can be used to temporarily in-
capacitate competitors    vehicles.

while the cognitive challenges in playing racing games may appear simple, most
racing games actually require multiple simultaneous tasks to be executed and have
signi   cant skill depth. at the most basic level, the agent needs to control for the
position of the vehicle and adjust the acceleration or braking, using    ne-tuned con-
tinuous input, so as to traverse the track as fast as possible. doing this optimally
requires at least short-term planning, one or two turns (of the track) forward. if there
are resources to be managed in the game, such as fuel, damage or speed boosts, this
requires longer-term planning. when other vehicles are present on the track, there
is an adversarial planning aspect added, in trying to manage or block overtaking;
this planning is often done in the presence of hidden information (position and re-
sources of other vehicles on different parts of the track) and under considerable time
pressure, and bene   ts from models of the adversarial drivers.

one relatively early commercial game application that stands out is the ai for
forza motorsport (microsoft studios, 2005), which was marketed under the name
drivatar [259]. the drivatar agents are built on a form of supervised lazy learning.
to train the agents, humans drive a number of racing tracks, which are composed
of a number of segments; all tracks in the game need to be composed of segments

138

chapter 3. playing games

drawn from the same    alphabet   . during driving, the agent selects the driving com-
mands that most closely approximate the racing line taken by the players on the
relevant segment. this approach was successful in realizing personalized driving
agents, i.e., agents that could drive new tracks in the style of human players they
had been trained on, but posed restrictions on the design of the tracks.

there are various approaches to training agents to drive without supervision,
through id23. a sequence of papers has shown how neuroevolu-
tion can be used to train agents that drive a single track in the absence of other cars
as well as a good human driver [707], how incremental evolution can be used to
train agents with suf   ciently general driving skills to drive unseen tracks [709], and
how competitive co-evolution can be used to adversarially train agents to drive more
or less aggressively in the presence of other cars [708]. in all these experiments, the
weights of a relatively small    xed-topology network were trained with an evolu-
tion strategy. the inputs to the network were the speed of the car and a handful of
range   nder sensors that returned the distance to the edges of the track, or other cars.
the low dimensionality of the resulting network enabled high-performing networks
to be found relatively easily.

the simulated car racing championship, which has run annually since 2007, is
partly based on this work, and uses a similar sensor model. the    rst year, the com-
petition was based on simple 2d racing game, and the winner of the competition
was a controller based on fuzzy logic [710]. in 2008, the competition software was
rebuilt around torcs, a 3d racing game with a reasonably sophisticated physics
model [393] (see fig. 3.11). in the following years, a large number of competitors
submitted agents based on various different architectures to the competition, includ-
ing evolutionary computation, temporal difference learning, supervised learning and
simple hand-coded rule-based systems [393]. a general trend has been observed
over the course of the competition that the winning agents incorporate more and
more domain knowledge in the form of hand-coded mechanisms, with learning al-
gorithms generally only used for tuning parameters of these mechanisms. the best
agents, such as cobostar [90] or mr. racer [543] generally drive as well as or
better than a good human driver when driving alone on a track, but still struggle
with overtaking and other forms of adversarial driving.

as discussed above, the simulated car racing championship provides infor-
mation in a form that is relatively easy to map to driving commands, making the
learning of at least basic driving strategy (but not    ne-tuning) relatively easy. how-
ever, some authors have attempted learning to drive from raw pixel data. early work
on this topic includes that by floreano et al., who evolved a neural network with
a movable    retina    to drive in a simple simulated environment. the output of the
neural network included both driving commands and commands for how to move
the retina, and only the relatively few pixels in the retina were used as inputs to the
network [206]. later, koutnik et al. managed to evolve controllers that used higher-
dimensional input by evolving the networks in compressed weight space; essen-
tially, the parameters of a jpeg encoding of the network connections was evolved,
allowing evolutionary search to work effectively in the space of large neural net-

3.4. which games can ai play?

139

works [353]. supervised learning of deep networks has also been applied to visual
driving, yielding high-performing torcs drivers that learn from examples [795].
the examples above do not make use of a forward model of any kind. how-
ever, car dynamics are relatively simple to model, and it is easy to create a fast
approximate model for racing games. given such a model, standard tree search al-
gorithms can easily be applied to car control. for example, fischer et al. showed
that mcts coupled with a simple forward model can produce decent performance
in torcs [203].

3.4.6 shooters and other first-person games

first-person shooters constitute an important genre of video games ever since the
success of doom (gt interactive, 1993) and wolfenstein 3d (apogee software
and formgen, 1992) in the early 1990s. while a basic tenet of an fps would seem
to be that the world is observed through a    rst-person point of view, there are games
that are generally recognized as fpses, such as the gears of war (microsoft studios,
2006   2016) series, which have the camera positioned slightly behind and/or above
the player. similarly, the word    shooter    signi   es that the games revolve around
shooting projectiles with some kind of weapon. on that basis, a game such as portal
(electronic arts, 2007) can be seen as an fps though it is debatable whether the
player implement is actually a weapon.

shooters are often seen as fast-paced games where speed of perception and reac-
tion is crucial, and this is true to an extent, although the speed of gameplay varies
between different shooters. obviously, quick reactions are in general not a prob-
lem for a computer program, meaning that an ai player has a certain advantage
over a human by default. but there are other cognitive challenges as well, including
orientation and movement in a complex three-dimensional environment, predict-
ing actions and locations of multiple adversaries, and in some game modes also
team-based collaboration. if visual inputs are used, there is the added challenge of
extracting relevant information from pixels.

there has been some early work on optimizing parameters for existing agents in
order to improve their ef   ciency [127], but extensive work on ai for fps games was
spurred by two competitions:    rst, the 2k botprize and more recently vizdoom.

3.4.6.1 unreal tournament 2004 and the 2k botprize

unreal tournament 2004 (ut2k4) (epic games, 2004) is an fps which was re-
leased in 2004, with what was at the time state-of-the-art graphics and gameplay.
while the game itself has not been open sourced, a team based at the charles uni-
versity in prague created pogamut, a java-based api that allows for simple control
of the game [222]. pogamut supplies the agent with an object-based information in-
terface, which the agent can query about the locations of objects and characters, and

140

chapter 3. playing games

(a) the judges    room

(b) the players    room

fig. 3.12 the    rst 2k botprize competition held in perth, australia, on 17 december 2008, as
part of the 2008 ieee symposium on computational intelligence and games.

also provides convenience functions for executing actions such as    ring a projectile
towards a speci   c point.

some work using ut2k4 tries to achieve high-performing agents for one or
several in-game tasks, using techniques such as neuroevolution. for example, van
hoorn et al. subdivided the task of playing ut2k4 into three sub-tasks: shooting, ex-
ploring and path-following [734]. using an earlier approach [698], which combines
neuroevolution with the subsumption architecture of rodney brooks [70], they then
evolved neural networks for each of these tasks in succession. the resulting agent
was able to play some game scenarios relatively effectively.

however, the main use of the ut2k4 benchmark has been in the 2k botprize
(see fig. 3.12). this competition, which ran from 2008 to 2014, stands out among
game-based ai competitions for not focusing on playing for performance, but rather
for playing for experience. speci   cally, it was a form of turing test, where submit-
ted agents were judged not by how well they survived    re   ghts with other agents,
but by whether they could fool human judges (who in later con   gurations of the
competition also participated in the game) that they were humans [262, 263, 264].
the winners of the    nal 2k botprize in 2014 were two teams whose bots man-
aged to convince more than half of the human judges that they (the bots) were
human. the    rst winning team, ut  2, from the university of texas at austin, is
primarily based on neuroevolution through multiobjective evolution [603]. it con-
sists of a number of separate controllers, where most of these are based on neural
networks; at each frame, it cycles through all of these controllers, and uses a set of
priorities to decide the outputs of which controller will command various aspects
of the agent. in addition to neural networks, some controllers are built on different
principles, in particular the human retrace controller, which uses traces of human
players to help the agent navigate out of stuck positions. the second winner, mir-
rorbot by mihai polceanu, is built around the idea of observing other players in the
game and mirroring their behavior [535].

3.4. which games can ai play?

141

3.4.6.2 raw screen inputs and the visual doom ai challenge

the vizdoom framework [333] is build around a version of the classic doom (gt
interactive, 1993) fps game that allows researchers to develop ai bots that play
the game using only the screen buffer. vizdoom was developed as an ai testbed
by a team of researchers at the institute of computing science, poznan university
of technology (see fig. 3.13). the framework includes several tasks of varying
complexity, from health pack collection and maze navigation to all-out deathmatch.
an annual competition based on vizdoom is held at the ieee cig conference since
2016, and the framework is also included in openai gym,10 a collection of games
which can be used for ai research.

most of the published work on vizdoom has been based on deep reinforcement
learning with convolutional neural networks, given that method   s proven strength in
learning to act based on raw pixel inputs. for example, arnold, a well-performing
agent in the    rst vizdoom competition, is based on deep id23 of
two different networks, one for exploration and one for    ghting [115].

but it is also possible to use evolutionary computation to train neural network
controllers. as the very large input size requires huge networks, which do not work
well with evolutionary optimization in general, it is necessary to compress the in-
formation somehow. this can be done by using an autoencoder trained on the visual
stream as the game is played; the activations of the bottleneck layer of the autoen-
coder can then be used as inputs to a neural network that decides about the actions,
and the weights of the neural network can be evolved [12]. previous attempts at
evolving controllers acting on visual input in the related game quake (gt interac-
tive, 1996) have met with only limited success [519].

3.4.7 serious games

the genre of serious games, or games with a purpose beyond entertainment, has
become a focus domain of recent studies in game ai. one could argue that most
existing games are serious by nature as they incorporate some form of learning
for the player during play. games such as minecraft (mojang, 2011), for example,
were not designed with a particular learning objective in mind; nevertheless they
have been used broadly in classrooms for science education. further, one could ar-
gue that serious games do not have a particular genre of their own; games may
have a purpose regardless of the genre they were designed on. strictly speaking
the design of serious games involves a particular set of learning objectives. learn-
ing objectives may be educational objectives such as those considered in stem
education   a popular example of such a game is the dragonbox (wewanttoknow,
2011) series that teaches primary school students equation solving skills, and basic
addition and subtraction skills. (a serious academic effort on game-based stem

10 https://gym.openai.com/

142

chapter 3. playing games

fig. 3.13 a screenshot from the vizdoom framework which   at the moment of writing   is used
in the visual doom ai challenge. the framework is giving access to the depth of the level (en-
abling 3d vision). image obtained from http://vizdoom.cs.put.edu.pl/ with permission.

education is the narrative-centered crystal island game series for effective science
learning [577, 584].) the learning objective can, instead, be the training of social
skills such as con   ict resolution and social inclusion through games; village voices
[336] (see fig. 3.14(a)), my dream theater [100] (see fig. 3.14(b)), and prom week
[447] are examples of such soft skill training games. alternatively, the aim could be
that war veterans suffering from post-traumatic stress disorder are trained to cope
with their cognitive-behavioral manifestations when faced with in-game stressors in
games such as startlemart [272, 270] and virtual iraq [227]. the learning objec-
tive could also be that of soliciting collective intelligence for scientists. a number
of scienti   c games have recently led to the discovery of new knowledge via crowd-
playing (or else human computation); arguably one of the most popular scienti   c
discovery games is foldit [138] through which players collectively discovered a
novel algorithm for protein folding.

the cognitive and emotional skills required to play a serious game largely de-
pend on the game and the underlying learning objectives. a game about math would
normally require computation and problem solving skills. a game about stress in-
oculation and exposure therapy would instead require cognitive-behavioral coping
mechanisms, metacognition and self-control of cognitive appraisal. the breadth of

3.4. which games can ai play?

143

(a) village voices. screenshot image adapted
from [336].

(b) my dream theater. screenshot
adapted from [99].

image

fig. 3.14 the village voices and the my dream theater games for con   ict resolution. village
voices realizes experiential learning of con   ict in social, multi-player settings, whereas my dream
theater offers a single-player con   ict management experience. in the    rst game the ai takes the
role of modeling con   ict and generating appropriate quests for the players, whereas   more rele-
vant to the aims of this chapter   in my dream theater ai takes the role of controlling expressive
agent (npc) behaviors.

cognitive and emotional skills required from players is as wide as the number of
different learning objectives a serious game can integrate into its design.

many serious games have npcs and ai can help in making those npcs be-
lievable, human-like, social and expressive. ai in serious games is generally useful
for modeling npc behavior and playing the game as an npc but not for winning;
rather for the experience of play. whether the game is for education, health or sim-
ulation purposes npc agents need to act believably and emotively in order to em-
power learning or boost the engagement level of the game. years of active research
have been dedicated on this task within the    elds of affective computing and vir-
tual agents. the usual approach followed is the construction of top-down (ad-hoc
designed) agent architectures that represent various cognitive, social, emotive and
behavioral abilities. the focus has traditionally being on both the modeling of the
agents behavior but also on its appropriate expression under particular contexts. a
popular way of constructing a computational model of agent behavior is to base it
on a theoretical cognitive model such as the occ model [512, 183, 16, 189, 237],
which attempts to effect human-like decision making, appraisal and coping mech-
anisms dependent on a set of perceived stimuli. for the interested reader, marsella
et al. [428] cover the most popular computational models of emotion for agents in a
thorough manner.

expressive and believable conversational agents such as greta [534] and rea
[105] or virtual humans [674] that embody affective manifestations can be consid-
ered in the design of serious games. the use of such character models has been dom-
inant in the domains of intelligent tutoring systems [131], embodied conversational
agents [104, 16], and affective agents [238] for educational and health purposes.
notable examples of such agent architecture systems include the work of lester   s

144

chapter 3. playing games

group in the crystal island game series [578, 577, 584], the expressive agents of
prom week [447] and fac  ade [441], the agents of the world of minds [190] game,
and the fatima [168] enabled agents of my dream theater [100].

3.4.8 interactive fiction

while there are several variations, games within the interactive    ction genre nor-
mally contain a fantasy world consisting of smaller areas such as rooms; however,
a simulated environment is not a necessity. importantly, players need to use text
commands to play the game. the player can normally interact with the objects and
available game characters, collect objects and store them in her inventory, and solve
various puzzles. games of this genre are also named text-based adventure games or
often associated with text-based role-playing games. popular examples include the
games of the zork series (infocom, 1979   1982) and fac  ade [441].

in this game genre, ai can play the role of understanding text as coming from
players in a natural language format. in other words, the game ai can feature nat-
ural language processing (nlp) for playing the game as the player   s companion
or as an opponent. further nlp can be used as an input for the generation of a di-
alog, a text or a story in an interactive fashion with the player. it is normally the
case that text-based input is used to drive a story (interactive narrative) which is of-
ten communicated via embodied conversational agents and is represented through
the lens of a virtual camera. similarly to traditional cinematography, both the cam-
era position and the communicated narrative contribute to the experience of the
viewer. opposed to traditional cinematography, however (but similarly to interac-
tive drama), the story in games can be in   uenced by the player herself. it goes with-
out saying that research in text-based games is naturally interwoven with research
in believable conversational agents (as covered in the previous section), computa-
tional and interactive narrative [693, 441, 562, 792] and virtual cinematography
[252, 193, 300, 84, 15, 578]. the discussion on the interplay between interactive
narrative and virtual cinematography is expanded in chapter 4 and in particular in
the section dedicated to narrative generation.

work on text-based ai in games starts from the early language-based interaction
with eliza [751] and the z-machine used by text adventure games such as zork i
(infocom, 1980), to fac  ade [438, 441] and to recent id97 [459] approaches
(e.g., its tensorflow implementation [2]) for playing q & a games [340] and text-
based adventure games [352]. it is important to note that beyond the use of ai to
understand natural language we can use ai to play text-based games. a notable re-
cent example of an agent that manages to handle both tasks is the one developed by
kostka et al. [352], named golovin. the golovin agent uses related corpora such
as fantasy books to create language models (via id97 [459]) that are appropri-
ate to this game domain. to play the game the agent uses    ve types of command
generators: battle mode, gathering items, inventory commands, general actions and
movement. golovin is validated on 50 interactive    ction games demonstrating com-

3.4. which games can ai play?

145

parable performance to the current state of the art. another example is the agent
of narasimhan et al. [475] that plays multi-user dungeon games, a form of multi-
player or collaborative interactive    ction. their agent converts text representations
to state representations using long short-term memory (lstm) networks. these
representations feed a deep q network which learns approximate evaluations for
each action in a given game state [475]. their approach signi   cantly outperforms
other baselines in terms of number of completed quests in small-, and even medium-
sized, games. for the interested reader a dedicated annual competition on text-based
adventure game ai was initiated in conjunction with the ieee cig conference in
2016.11 participants of the competition submit agents that play games for the z-
machine.

examples of useful development tools for text-based games include the inform
series of design systems and programming languages, which are inspired by the z-
machine and have led to the development of several text-based games and interactive
   ction based on natural language. notably, inform 712 was used for the design of
the mystery house possessed (emily short, 2005) game.

3.4.9 other games

the list of games ai can play is not limited to the genres covered above. while the
genres we covered in more detail are, in our opinion, the most representative there
are ai studies focusing on other game genres, a number of which we outline below.
a game type with an increasing interest is casual games due to their growing
popularity and accessibility via mobile devices in recent years. casual games are
often simple and are designed as short episodes of play (levels) to allow    exibility
with respect to gameplay time. this feature gives the player the ability to conclude
an episode in a short period of time without needing to save the game. as a re-
sult, the player can engage on a single level for a few seconds, or play a number
of levels throughout the day, or instead repeatedly play new levels up to hours of
gameplay. the game skills required to play casual games depend on the genre of
the casual game which can vary from puzzle such as bejeweled (popcap games,
2001), angry birds (chillingo, 2009), and cut the rope (chillingo, 2010), to adven-
ture such as dream chronicles (katgames, 2007), to strategy such as diner dash
(playfirst, 2004), to arcade such as plants vs. zombies (popcap games, 2009) and
feeding frenzy (popcap games, 2004), to card and board games such as slingo
quest (funkitron, inc., 2006).

notable academic efforts on casual games include the work of isaksen et al.
[288, 289] where an ai agent is built to test the dif   culty of flappy bird (dot-
gears, 2013) levels. the baseline ai player follows a simple path   nding algo-
rithm that performs well in completing the flappy bird levels. to imitate human

11 http://atkrye.github.io/ieee-cig-text-adventurer-competition/
12 http://inform7.com/

146

chapter 3. playing games

play, however, the ai player features elements of human motor skills such as pre-
cision, reaction time, and actions per second. another example on that line of work
is the use of ai agents to test the generation of game levels in a variant of cut
the rope (chillingo, 2010). the ai agents featured in the ropossum authoring tool
both perform automatic playtesting and also optimize the playability of a level us-
ing    rst-order logic [614]. the level generation elements of ropossum are further
discussed in the next chapter. another casual game that has recently attracted the
interest of game ai research is angry birds (chillingo, 2009). the game has an
established ai competition [560], named the angry birds ai competition,13 that
runs since 2012 mainly in conjunction with the international joint conference on
arti   cial intelligence. ai approaches in angry birds (chillingo, 2009) have so far
focused mainly on planning and reasoning techniques. examples include a qual-
itative spatial reasoning approach which evaluates level structural properties and
game rules, and infers which of these are satis   ed for each building block of the
level [796]. the usefulness of each level building block (i.e., how good it is to hit
it) is then computed based on these requirements. other approaches model discrete
knowledge about the current game state of angry birds (chillingo, 2009) and then
attempt to satisfy the constraints of the modeled world [92] based on extensions of
answer set programming [69].

beyond casual games the genre of    ghting games has received a considerable
amount of interest from both academic and industrial players. fighting games re-
quire cognitive skills mostly related to kinesthetic control and spatial navigation
but also related to reaction times and decision making, both of which need to be
fast [349]. popular approaches for    ghting games include classic reinforcement
learning   in particular, the sarsa algorithm for on-policy learning of q values
which are represented by linear and ann function approximators   as applied by
the microsoft research team in the tao feng: fist of the lotus (microsoft game
studios, 2003) game [235]. id23 has also been applied with
varying degrees of success for adaptive dif   culty adjustment in    ghting games
[158, 561, 27]; i.e., ai that plays for the experience of the player. evolutionary rein-
forcement learning variants have also been investigated for the task [437]. a notable
effort in the    ghting games ai research scene has been on the java-based    ghting
game fightingice provided by the fighting game ai competition14 [402] (see fig.
3.15). the competition is organized by the ritsumeikan university in japan and has
run since 2013 with the aim to derive the best possible    ghting bot; i.e., ai that
plays to win. approaches using fightingice vary from dynamic scripting [417],
to k-nearest neighbor [760], to id169 [790], to neuroevolution
[357], among others. so far mcts-based approaches appear to be advantageous on
winning in    ghting games.

the last game we will cover in this section is minecraft (mojang, 2011) for its
unique properties as a testbed for game ai research. minecraft (mojang, 2011) is a
sandbox game played in a 3d procedurally generated world that players can navi-

13 https://aibirds.org/
14 http://www.ice.ci.ritsumei.ac.jp/  ftgaic/

3.4. which games can ai play?

147

fig. 3.15 a screenshot from the java-based fightingice framework for    ghting games.

gate through. the game features game mechanics that enable players to build con-
structions out of cubes (see fig. 3.16) but it does not have a speci   c goal for the
player to accomplish. beyond exploration and building, players can also gather re-
sources, craft objects and combat opponents. the game has sold more than 121 mil-
lion copies across all platforms [51], making it the second best-selling video game
of all time, only behind tetris (alexey pajitnov and vladimir pokhilko, 1984).15
the 3d open-world nature of minecraft (mojang, 2011) and the lack of speci   c
goals provides players ultimate freedom to play and explore the world in dissimi-
lar ways. the bene   ts of playing minecraft (mojang, 2011) appear to be many and
some of them have already been reported by the educational research community
[479]. for example, the blocks available in the game can be arranged to produce
any object a player might think of, thereby fostering the player   s creativity [479]
and diagrammatic lateral thinking [774]. further, the blocks    functionalities that
can be combined and extended may result in new knowledge for the players that is
acquired gradually. moreover, the simple stylized voxel-based graphics of the game
allow the player to concentrate on the gameplaying and exploration tasks within a
simple, yet aesthetically pleasing, environment. overall, the multitude of reasons
that make minecraft (mojang, 2011) so appealing to millions of players are also the
reasons that make the game a great testbed for ai and game ai research. in particu-
lar, the game offers an ai player an open world ready to be explored with numerous
possibilities for open-ended play. further, in-game tasks for an ai agent vary from

15 https://en.wikipedia.org/wiki/list of best-selling video games

148

chapter 3. playing games

fig. 3.16 a screenshot from minecreaft (mojang, 2011) showcasing a city hall structure made by
the mcfrarchitect build team. image obtained from wikipedia (fair use).

exploration and seeking treasure to making objects and building structures, alone or
as a team of agents.

a notable and recent effort on the use of minecraft (mojang, 2011) for ai is
project malmo [305] which is supported by microsoft research. project malmo is
a java-based ai experimentation platform built as a game mod of the original game
and designed to support research within the areas of robotics, id161, ma-
chine learning, planning, and multi-agent systems and general game ai [305]. note
that the open-source platform is accessible via github.16 early experiments with ai
in project malmo include the application of deep neural networks for navigating the
3d mazes [465] and for    ghting the opponents of the game [726]. beyond project
malmo, it is also worth noting that various other mods of the game have been used
directly for teaching robotics [11]   including algorithms for maze navigation and
planning   and teaching general ai methods [38].

3.5 further reading

the methods used for playing games have an extensive body of literature that is
covered in detail both in chapter 2 and here. the different game genres that we
covered in this chapter contain a corresponding literature the interested reader could
use as a starting point for further exploration.

16 https://github.com/microsoft/malmo#getting-started

3.6. exercises

3.6 exercises

149

prior to moving to the next chapter about generating content herein we provide a
general exercise that allows you to apply any of the algorithms covered in chapter 2
in a single domain. the purpose of the exercise is for you to get familiar with those
methods before testing them in more complicated and complex domains and tasks.
as discussed above, the ms pac-man vs ghost team competition is a contest held
at several ai conferences around the world in which ai controllers for ms pac-man
and the ghost team compete for the highest ranking. for this exercise, you will have
to develop a number of ms pac-man ai players to compete against the ghost team
controllers included in the software package. this is a simulator entirely written in
java with a well-documented interface. while the selection of two to three different
agents within a semester period has been shown to be a good educational practice
we will leave the    nal number of ms pac-man agents to be developed on you or
your class instructor.

the website of the book contains code for the game and a number of different
sample code classes in java to get you started. all ai methods covered in chapter 2
are applicable to the task of controlling ms pac-man. you might    nd out, however,
that some of them are more relevant and ef   cient than others. so which methods
would work best? how do they compare in terms of performance? which state
representation should you use? which utility function is the most appropriate? do
you think you can make the right implementation decisions so that your ms pac-
man plays at a professional level? how about at a world champion, or even at a
superhuman level?

3.6.1 why ms pac-man?

some of our readers might object to this choice of game and think that there should
be more interesting games ai can play with. while ms pac-man (namco, 1982)
is very old it is arguably a classic game that is still fun and challenging to play,
as well as a simple testbed to start experimenting with the various ai methods and
approaches introduced in this chapter and the previous one. ms pac-man (namco,
1982) is simple to understand and play but is not easy to master. this controversial
element of play simplicity combined with problem complexity makes ms pac-man
(namco, 1982) the ideal testbed for trying out different ai methodologies for con-
trolling the main character, ms pac-man. another exciting feature of this game is its
non-deterministic nature. randomness not only augments the fun factor of the game
but it also increases the challenge for any ai approach considered. as discussed, an-
other argument for the selection of ms pac-man (namco, 1982) is that the game and
its variants have been very well studied in the literature, tested through several game
ai competitions, but also covered for years on ai (or game ai) courses in several
universities across the globe. the reader is also referred to a recent survey paper

150

chapter 3. playing games

by rohlfshagen et al. [573], covering over 20 years of research in pac-man and a
youtube video17 about the importance of pac-man in game ai research.

3.7 summary

in this chapter we discussed the different roles ai can take and the different char-
acteristics games and ai methods have, the various methods that are available for
playing games and the different games it can play. in particular, ai can either play to
win or play in order to create a particular experience for a human player or observer.
the former goal involves maximizing a utility that maps to the game performance
whereas the latter goal involves objectives beyond merely winning such as engage-
ment, believability, balance and interestingness. ai as an actor can take the role of
either a player character or a non-player character that exists in a game. the charac-
teristics of games an ai method needs to consider when playing include the number
of players, the level of stochasticity of the game, the amount of observability avail-
able, the action space and the branching factor, and the time granularity. further,
when we design an algorithm to play a game we also need to consider algorith-
mic aspects such as the state representation, the existence of a forward model, the
training time available, and the number of games ai can play.

the above roles and characteristics were detailed in the    rst part of the chapter as
they are important and relevant regardless of the ai method applied. when it comes
to the methods covered in this chapter, we focused on tree-search, reinforcement
learning, supervised learning, and hybrid approaches for playing games. in a sense,
we tailored the methods outlined in chapter 2 to the task of gameplaying. the chap-
ter concluded with a detailed review of the studies and the relevant methodologies
on a game genre basis. speci   cally, we saw how ai can play board, card, arcade,
strategy, racing, shooter, and serious games, interactive    ction, and a number of
other game genres such as casual and    ghting games.

17 https://www.youtube.com/watch?t=49&v=w5kfmdkriuy

chapter 4
generating content

procedural content generation (pcg) [616] is an area of game ai that has seen
an explosive growth of interest. while games that incorporate some procedurally
generated content have existed since the early 1980s   in particular, the dungeon
crawler rogue (toy and wichmann, 1980) and the space trading simulator elite
(acornsoft, 1984) are early trailblazers   research interest in academia has really
picked up within the second half of the last decade.

simply put, pcg refers to methods for generating game content either au-
tonomously or with only limited human input. game content is that which is con-
tained in a game: levels, maps, game rules, textures, stories, items, quests, music,
weapons, vehicles, characters, etc. typically, npc behavior and the game engine
itself are not thought of as content. probably the most common current usage of
pcg is for generating levels and terrains, but in the future we might see widespread
generation of all kinds of content, possibly even complete games.

seeing pcg from an ai perspective, content generation problems are ai prob-
lems where the solutions are content artifacts (e.g., levels) that ful   ll certain con-
straints (e.g., being playable, having two exits) and/or maximize some metrics (e.g.,
length, difference in outcomes between different strategies). and as we will see,
many ai methods discussed in chapter 2 can be used for pcg purposes, including
evolutionary algorithms and neural networks. but there are also a number of meth-
ods that are commonly used for pcg that are not typically thought of as ai; some
of these will be presented in this chapter.

this chapter is devoted to methods for generating game content, as well as
paradigms for how to incorporate them into games. we start with discussing why
you want to use pcg at all   just like for playing games, there are some very dif-
ferent motivations for generating content. then in section 4.2 we present a general
taxonomy for pcg methods and possible roles in games. next, section 4.3 summa-
rizes the most important methods for the generation of content. shifting attention
to which roles pcg can take in games section 4.4 discusses ways of involving de-
signers and players in the generative process. section 4.5 takes the perspective of
content types, and presents examples of generating some common and uncommon
types of game content. finally, section 4.6 discusses how to evaluate pcg methods.

151

152

chapter 4. generating content

4.1 why generate content?

perhaps the most obvious reason to generate content is that it could remove the need
to have a human designer or artist creating that content. humans are expensive and
slow, and it seems we need more and more of them all the time. ever since computer
games were invented, the number of person-months that go into the development of
a successful commercial game has increased more or less constantly.1 it is now
common for a game to be developed by hundreds of people over a period of several
years. this leads to a situation where fewer games are pro   table, and fewer develop-
ers can afford to develop a game, leading in turn to less risk-taking and less diversity
in the games marketplace. many of the costly employees necessary in this process
are designers and artists rather than programmers. a game development company
that could replace some of the artists and designers with algorithms would have a
competitive advantage, as games could be produced faster and cheaper while pre-
serving quality. (this argument was made forcefully by legendary game designer
will wright in his talk    the future of content    at the 2005 game developers con-
ference, a talk which helped reinvigorate interest in procedural content generation.)
figure 4.1 illustrates a cost breakdown of an average aaa game and showcases
the dominance of artwork and marketing in that process. art, programming, and de-
bugging constitute around 50% of the cost of an aaa game. essentially, pcg can
assist in the processes of art and content production, thus directly contributing to the
reduction of around 40% of a game   s cost.

of course, threatening to put them out of their jobs is not a great way to sell pcg
to designers and artists. it is also true that at the current stage of technology, we are
far from being able to replace all that a designer or artist can do. we could therefore
turn the argument around: content generation, especially embedded in intelligent de-
sign tools, can augment the creativity of individual human creators. humans, even
those of the    creative    vein, tend to imitate each other and themselves. algorithmic
approaches might come up with radically different content than a human would cre-
ate, through offering an unexpected but valid solution to a given content generation
problem. some evidence for this is already available in the literature [774]. this
could make it possible for small teams without the resources of large companies,
and even for hobbyists, to create content-rich games by freeing them from worry-
ing about details and drudge work while retaining overall directorship of the games.
pcg can then provide a way for democratizing game design by offering reliable and
accessible ways for everyone to make better games in less time.

both of these arguments assume that what we want to make is something like the
games we have today. but pcg methods could also enable completely new types
of games. to begin with, if we have software that can generate game content at the
speed it is being    consumed    (played), there is in principle no reason why games
need to end. for everyone who has ever been disappointed by their favorite game

1 at least, this is true for    aaa    games, which are boxed games sold at full price worldwide. the
recent rise of mobile games seems to have made single-person development feasible again, though
average development costs are rising on that front too.

4.1. why generate content?

153

fig. 4.1 average cost breakdown estimate of aaa game development. data source:
http://monstervine.com/2013/06/chasing-an-industry-the-economics-of-videogames-turned-
hollywood/.

not having any more levels to clear, characters to meet, areas to explore, etc., this is
an exciting prospect.

even more excitingly, the newly generated content can be tailored to the tastes
and needs of the player playing the game. by combining pcg with player modeling,
for example through measuring and using neural networks to model the response of
players to individual game elements, we can create player-adaptive games that
seek to maximize the enjoyment of players (see the roles of pcg in section 4.4).
the same techniques could be used to maximize the learning effects of a serious
game, or perhaps the addictiveness of a    casual    game.

finally, a completely different but no less important reason for developing pcg
methods is to understand design and creativity. computer scientists are fond of
saying that you do not really understand a process until you have implemented it in
code (and the program runs). creating software that can competently generate game
content could help us understand the process by which we    manually    generate
the content, and clarify the affordances and constraints of the design problem we
are addressing. this is an iterative process, whereby better pcg methods can lead

154

chapter 4. generating content

fig. 4.2 an illustration of the pcg taxonomy discussed in section 4.2.

to better understanding of the design process, which in turn can lead to better pcg
algorithms enabling a co-creativity process between designers and algorithms [774].

4.2 taxonomy

with the variety of content generation problems, methods and approaches that are
available, it helps to have a structure that can highlight the differences and similari-
ties between them. in the following, we introduce a revised version of the taxonomy
of pcg that was originally presented by togelius et al. [720]. it consists of a number
of dimensions, where an individual method or solution should usually be thought of
as lying somewhere on a continuum between the ends of that dimension. beyond
the taxonomy for the content types (section 4.2.1) and the properties of the pcg
methods, which we cover in section 4.3, we provide an outline of the roles a pcg
algorithm can take, which we cover extensively in section 4.4.

4.2.1 taxonomy for content

we identify the type of the generated outcome as the sole dimension that relates to
content in this taxonomy (see also fig. 4.2).

4.2. taxonomy

155

4.2.1.1 type: necessary versus optional

pcg can be used to generate necessary game content that is required for the com-
pletion of a level, or it can be used to generate optional content that can be discarded
or exchanged for other content. the main distinguishing feature between necessary
and optional content is that necessary content should always be correct while this
condition does not hold for optional content. necessary needs to be consumed or
passed as the player makes their way through the game, whereas optional content
can be avoided or bypassed. an example of optional content is the generation of dif-
ferent types of weapons in    rst-person shooter games [240] or the auxiliary reward
items in super mario bros (nintendo, 1985). necessary content can be the main
structure of the levels in super mario bros (nintendo, 1985), or the collection of
certain items required to pass to the next level.

4.2.2 taxonomy for methods

pcg algorithms can be classi   ed according to a number of properties such as their
level of controllability, determinism and so on. this section outlines the three dimen-
sions across which pcg methods can be classi   ed. figure 4.2 offers an illustration
of the taxonomy that we discuss in this section.

4.2.2.1 determinism: stochastic versus deterministic

our    rst distinction with regards to pcg methods concerns the amount of random-
ness in content generation. the right amount of variation in outcomes between dif-
ferent runs of an algorithm with identical parameters is a design decision. stochas-
ticity2 allows an algorithm (such as an evolutionary algorithm) to offer great vari-
ation, necessary for many pcg tasks, at the cost of controllability. while content
diversity and expressivity are desired properties of generators, the effect of random-
ness on the    nal outcomes can only be observed and controlled after the fact. com-
pletely deterministic pcg algorithms, on the other hand, can be seen as a form of
data compression. a good example of deterministic pcg is the    rst-person shooter
.kkrieger (.theprodukkt 2004), which manages to compress all of its textures, ob-
jects, music and levels together with its game engine in just 96 kb of storage space.

2 strictly speaking there is a distinction between a stochastic and a non-deterministic process in
that the former has a de   ned random distribution whereas the latter does not. for the purposes of
this book, however, we use the two terms interchangeably.

156

chapter 4. generating content

4.2.2.2 controllability: controllable versus non-controllable

the generation of content by pcg can be controlled in different ways. the use of
a random seed is one way to gain control over the generation space; another way
is to use a set of parameters that control the content generation along a number
of dimensions. random seeds were used when generating the world in minecraft
(mojang, 2011), which means the same world can be regenerated if the same seed
is used [755]. a vector of content features was used in [617] to generate levels for
in   nite mario bros (persson, 2008) that satisfy a set of feature speci   cations.

4.2.2.3 iterativity: constructive versus generate-and-test

a    nal distinction may be made between algorithms that can be called construc-
tive and those that can be described as generate-and-test. a constructive algorithm
generates the content once, and is done with it; however, it needs to make sure that
the content is correct or at least    good enough    as it is being constructed. an ex-
ample of this approach is using fractals or cellular automata to generate terrains
or grammars to generate levels (also refer to the corresponding pcg method sec-
tions below). a generate-and-test algorithm, instead, incorporates both a generate
and a test mechanism. after a candidate content instance is generated, it is tested
according to some criteria (e.g., is there a path between the entrance and exit of the
dungeon, or does the tree have proportions within a certain range?). if the test fails,
all or some of the candidate content is discarded and regenerated, and this process
continues until the content is good enough. a popular pcg framework that builds
upon the generate-and-test paradigm is the search-based [720] approach discussed
in section 4.3.

4.2.3 taxonomy of roles

in this section we identify and brie   y outline the four possible roles a pcg algorithm
can take in the game design process classi   ed across the dimensions of autonomy
and player-based adaptivity. the various pcg roles are illustrated in fig. 4.2 and
are extensively discussed in section 4.4.

4.2.3.1 autonomy: autonomous versus mixed-initiative

the generative process that does not consider any input from the human designer is
de   ned as autonomous pcg whereas mixed-initiative pcg refers to the process
that involves the human designer in the creative task. both roles are discussed in
further detail in section 4.4.

4.3. how could we generate content?

157

4.2.3.2 adaptivity: experience-agnostic versus experience-driven

experience-agnostic content generation refers to the paradigm of pcg where con-
tent is generated without taking player behavior or player experience into account,
as opposed to experience-driven [783], adaptive, personalized or player-centered
content generation where player interaction with the game is analyzed and content
is created based on a player   s previous behavior. most commercial games tackle
pcg in a generic, experience-agnostic way, while experience-driven pcg has been
receiving increasing attention in academia. recent extensive reviews of pcg for
player-adaptive games can be found in [783, 784].

4.3 how could we generate content?

there are many different algorithmic approaches to generating content for games.
while many of these methods are commonly thought of as ai methods, others are
drawn from graphics, theoretical computer science or even biology. the various
methods differ also in what types of content they are suitable to generate. in this sec-
tion, we discuss a number of pcg methods that we consider important and include
search-based, solver-based, and grammar-based methods but also cellular automata,
noise and fractals.

4.3.1 search-based methods

the search-based approach to pcg [720] has been intensively investigated in aca-
demic pcg research in recent years. in search-based procedural content generation,
an evolutionary algorithm or some other stochastic search or optimization algorithm
is used to search for content with the desired qualities. the basic metaphor is that
of design as a search process: a good enough solution to the design problem exists
within some space of solutions, and if we keep iterating and tweaking one or many
possible solutions, keeping those changes which make the solution(s) better and
discarding those that are harmful, we will eventually arrive at the desired solution.
this metaphor has been used to describe the design process in many different disci-
plines: for example, will wright   designer of simcity (electronic arts, 1989) and
the sims (electronic arts, 2000)   described the game design process as search in
his talk at the 2005 game developers conference. others have previously described
the design process in general, and in other specialized domains such as architecture,
the design process can be conceptualized as search and implemented as a computer
program [757, 55].

the core components of the search-based approach to solving a content genera-

tion problem are the following:

chapter 4. generating content
158
    a search algorithm. this is the    engine    of a search-based method. often rel-
atively simple evolutionary algorithms work well enough, however sometimes
there are substantial bene   ts to using more sophisticated algorithms that take
e.g., constraints into account, or that are specialized for a particular content rep-
resentation.
    a content representation. this is the representation of the artifacts you want to
generate, e.g., levels, quests or winged kittens. the content representation could
be anything from an array of real numbers to a graph to a string. the content
representation de   nes (and thus also limits) what content can be generated, and
determines whether effective search is possible; see also the discussion about
representation in chapter 2.
    one or more evaluation functions. an evaluation function is a function from an
artifact (an individual piece of content) to a number indicating the quality of the
artifact. the output of an evaluation function could indicate e.g., the playabil-
ity of a level, the intricacy of a quest or the aesthetic appeal of a winged kitten.
crafting an evaluation function that reliably measures the aspect of game qual-
ity that it is meant to measure is often among the hardest tasks in developing a
search-based pcg method. refer also to the discussion about utility in chapter
2.

let us look at some of the choices for content representations. to take a very
well-known example, a level in super mario bros (nintendo, 1985) might be repre-
sented in any of the following ways:

1. directly, as a level map, where each variable in the genotype corresponds to one

   block    in the phenotype (e.g., bricks, question mark blocks, etc.).

2. more indirectly, as a list of the positions and properties of the different game
entities such as enemies, platforms, gaps and hills (an example of this can be
found in [611]).

3. even more indirectly, as a repository of different reusable patterns (such as col-
lections of coins or hills), and a list of how they are distributed (with various
transforms such as rotation and scaling) across the level map (an example of this
can be found in [649]).

4. very indirectly, as a list of desirable properties such as the number of gaps, ene-
mies, or coins, the width of gaps, etc. (an example of this can be found in [617]).

5. most indirectly, as a random number seed.

while it clearly makes no sense to evolve random number seeds (it is a represen-
tation with no locality whatsoever) the other levels of abstraction can all make sense
under certain circumstances. the fundamental tradeoff is between more direct, more
   ne-grained representations with potentially higher locality (higher correlation of
   tness between neighboring points in search space) and less direct, more coarse-
grained representations with probably lower locality but smaller search spaces.
smaller search spaces are in general easier to search. however, larger search spaces
would (all other things being equal) allow for more different types of content to be
expressed, or in other words increase the expressive range of the generator.

4.3. how could we generate content?

159

the third important choice when designing a search-based pcg solution is the
evaluation function known as the    tness function. the evaluation function assesses
all candidate solutions, and assigns a score (a    tness value or evaluation value) to
each candidate. this is essential for the search process; if we do not have a good
evaluation function, the evolutionary process will not work as intended and will not
   nd good content. it could be argued that designing an entirely accurate content
quality evaluation is    ai-complete    in the sense that to really understand what a
human    nds fun, you actually have to be a human or understand humans in depth.
however, like for other problems in various areas of ai, we can get pretty far with
well-designed domain-speci   c heuristics. in general, the evaluation function should
be designed to model some desirable quality of the artifact, e.g., its playability,
regularity, entertainment value, etc. the design of an evaluation function depends
to a great extent on the designer and what she thinks are the important aspects that
should be optimized and how to formulate that.

in search-based pcg, we can distinguish between three classes of evaluation

functions: direct, simulation-based, and interactive.
    direct evaluation functions map the generated content (or features extracted from
it) directly to a content quality value and, in that sense, they base their    tness cal-
culations directly on the phenotype representation of the content. no simulation
of the gameplay is performed during the mapping. some direct evaluation func-
tions are hand-coded, and some are learned from data. direct evaluation functions
are fast to compute and often relatively easy to implement, but it is sometimes
hard to devise a direct evaluation function for some aspects of game content. ex-
ample features include the placement of bases and resources in real-time strategy
games [712], the size of the ruleset in strategy games [415] or the current mood
of the game scene based on visual attention theory [185]. the mapping between
features and    tness might be contingent on a model of the playing style, prefer-
ences or affective state of players. an example of this form of    tness evaluation
can be seen in the study done by shaker et al. [617, 610] for personalizing player
experience using models of players to give a measure of content quality. in that
study, the authors trained neural networks to predict the player experience (such
as challenge, frustration and enjoyment) of players given a playing style and
the characteristics of a level as inputs. these trained neural networks can then
be used as    tness functions by searching for levels that, for example, maximize
predicted enjoyment while minimizing frustration. or the exact opposite, if you
wish.
    simulation-based evaluation functions use ai agents that play through the gen-
erated content in order to estimate its quality. statistics are calculated about the
agents    behavior and playing style and these statistics are then used to score game
content. the type of the evaluation task determines the area of pro   ciency of the
ai agent. if content is evaluated on the basis of playability, e.g., the existence of
a path from the start to the end in a maze or a level in a 2d platform game, then
ai agents should be designed that excel in reaching the end of the game. on the
other hand, if content is optimized to maximize a particular player experience,
then an ai agent that imitates human behavior should generally be adopted. an

160

chapter 4. generating content

(a)

(b)

fig. 4.3 examples of evolved weapons in galactic arms races. images obtained from
www.aigameresearch.org.

example study that implements a human-like agent for assessing content quality
is presented in [704] where neural-network-based controllers are trained to drive
like human players in a car racing game and then used to evaluate the generated
tracks. each track generated is given a    tness value according to statistics calcu-
lated while the ai controller is playing. another example of a simulation-based
evaluation function is measuring the average    ghting time of bots in a    rst-person
shooter game [103]. in that study, levels were simply selected to maximize the
amount of time bots spent on the level before killing each other.
    interactive evaluation functions evaluate content based on interaction with a hu-
man, so they require a human    in the loop   . examples of this method can be
found in the work by hastings et al. [250], who implemented this approach by
evaluating the quality of the personalized weapons evolved implicitly based on
how often and how long the player chooses to use these weapons. figure 4.3
presents two examples of evolved weapons for different players. cardamone et
al. [102] also used this form of evaluation to score racing tracks according to
the users    reported preferences.   lsted et al. used the same approach to design
levels for    rst-person shooter games [501]. the    rst case is an example of an
implicit collection of data, i.e., that the players did not answer direct questions
about their preferences, while players    preferences were collected explicitly in
the second. the problem with explicit data collection is that, if not well inte-
grated, it requires the gameplay session to be interrupted. this method, however,
provides a reliable and accurate estimator of player experience, as opposed to
implicit data collection, which is usually noisy and based on assumptions. hy-
brid approaches are sometimes employed to mitigate the drawbacks of these two
methods by collecting information across multiple modalities such as combining
player behavior with eye gaze and/or skin conductance. example applications
of this approach can be found in biofeedback-based camera viewpoint genera-
tion [434], level generation [610] and visuals generation in physical interactive
games [771].

4.3. how could we generate content?

161

search-based methods have extremely broad applicability, as evolutionary com-
putation can be used to construct almost any kind of game content. however, this
generality comes with a number of drawbacks. one is that it is generally a rather
slow method, requiring the evaluation of a large number of candidate content items.
the time required to evolve a good solution can also not be precisely predicted, as
there is no runtime guarantee for evolutionary algorithms. this might make search-
based pcg solutions unsuitable for time-critical content generation, such as when
you only have a few seconds to serve up a new level in a game. it should also be
noted that the successful application of search-based pcg methods relies on judi-
cious design choices when it comes to the particular search algorithm, representation
and evaluation function.

as we will see below, there are several algorithms that are generally better suited
than evolutionary algorithms for generating game content of speci   c types. how-
ever, none of them have the versatility of the search-based approach, with abilities
to incorporate all kinds of objectives and constraints. as we will see, many other al-
gorithms for content generation can also be combined with search-based solutions,
so that evolutionary algorithms can be used to search the parameter space of other
algorithms.

4.3.2 solver-based methods

while the search-based approach to content generation means using one or several
objective functions, perhaps in conjunction with constraints, to specify for a ran-
domized search algorithm such as an evolutionary algorithm what to look for, there
is another approach to pcg which is also based on the idea of content generation as
search in a space of artifacts. solver-based methods for pcg use constraint solvers,
such as those used in logic programming, to search for content artifacts that satisfy
a number of constraints.

constraint solvers allow you to specify a number of constraints in a speci   c
language; some solvers require you to specify the constraints mathematically, others
use a logic language for speci   cation. behind the scenes they can be implemented
in many different ways. while there are some solvers that are based on evolutionary
computation, it is more common to use specialized methods, such as reducing the
problem to a sat (satis   ability) problem and using a sat solver to    nd solutions.
many such solvers progress not through evaluating whole solutions, but searching in
spaces of partial solutions. this has the effect of iteratively pruning the search space:
eliminating parts of the search space repeatedly until only viable solutions are left.
this marks a sharp difference with the search-based paradigms, and also suggests
some differences in the use cases for these classes of algorithms. for example, while
evolutionary algorithms are anytime algorithms, i.e., they can be stopped at any
point and some kind of solution will be available (though a better solution would
probably have been available if you had the algorithm run for longer), this is not
always the case with id124 methods   though the time taken until a

162

chapter 4. generating content

viable solution is found can be very low, depending on how many constraints need to
be satis   ed. unlike with evolutionary algorithms, it is possible to prove bounds on
the worst-case complexity of sat solvers and the algorithms that depend on them.
however, while the worst-case complexity is often shockingly high, such algorithms
can be very fast when applied (judiciously) in practice.

an example of solver-based methods is the level generator for smith and white-
head   s tanagra mixed-initiative platform level design tool [642]. at the core of the
tool is a constraint-based generator of platform game levels. the constraint solver
uses a number of constraints on what constitutes a solvable platform level (e.g.,
maximum jump length, and distance from jumps to enemies) as well as constraints
based on aesthetic considerations, such as the    rhythm    of the level, to generate
new platform game levels or level segments. this generation happens very fast and
produces good results, but is limited to fairly linear levels. another example is the
work by el-nasr et al. on procedural generation of lighting [188, 185]. the system
developed in those studies con   gures and continuously modulates the lighting in
a scene with the aim to enhance player experience by using constraint non-linear
optimization to select the best lighting con   guration.

one approach to constraint solving which can be particularly useful for pcg be-
cause of its generality is answer set programming (asp) [638]. asp builds on
ansprolog, a constraint programming language which is similar to prolog [69].
complex sets of constraints can be speci   ed in ansprolog, and an asp solver can
then be used to    nd all models (all con   gurations of variables) that satisfy the con-
straints. for pcg purposes, the model (the set of parameters) can be used to describe
a world, a story or similar, and the constraints can specify playability or various aes-
thetic considerations. an example of an asp application for level and puzzle gener-
ation is the refraction game (see fig. 4.4). for a good introduction to and overview
of the use of asp in pcg you may refer to [638, 485].

generally solver-based methods can be suitable when the whole problem can
be encoded in the language of the constraint solver (such as ansprolog). it is gen-
erally complicated to include simulation-based tests or any other call to the game
engine inside a id124 program. an alternative if simulation-based
tests need to be performed is evolutionary algorithms, which can also be used to
solve id124 problems. this allows a combination of    tness values
and constraints to drive evolution [376, 382, 240].

4.3.3 grammar-based methods

grammars are fundamental structures in computer science that also have many ap-
plications in procedural content generation. in particular, they are very frequently
used for producing plants, such as trees, which are commonly used in many differ-
ent types of games. however, grammars have also been used to generate missions
and dungeons [173, 174], rocks [159], underwater environments [3] and caves [424].
in these cases, grammars are used as a constructive method, creating content with-

4.3. how could we generate content?

163

fig. 4.4 a screenshot from the refraction educational game. a solver-based pcg method (asp)
is used to generate the levels and puzzles of the game. further details about the application of asp
to refraction can be found in [635, 89].

out any evaluation functions or re-generation. however, grammar methods can also
be used together with search-based methods, so that the grammar expansion is used
a genotype-to-phenotype mapping.
a (formal) grammar is a set of production rules for rewriting strings, i.e., turn-
ing one string into another. each rule is of the form (symbol(s))     (other symbol(s)).
here are some example production rules:
1. a     ab
2. b     b
expanding a grammar is as simple as going through a string, and each time a symbol
or sequence of symbols that occurs in the left-hand side of a rule is found, those
symbols are replaced by the right-hand side of that rule. for example, if the initial
string is a, in the    rst rewriting step the a would be replaced by ab by rule 1, and
the resulting string will be ab. in the second rewriting step, the a would again be
transformed to ab and the b would be transformed to b using rule 2, resulting in
the string abb. the third step yields the string abbb and so on. a convention in
grammars is that upper-case characters are nonterminal symbols, which are on the
left-hand side of rules and therefore rewritten further, whereas lower-case characters
are terminal symbols which are not rewritten further.

164

chapter 4. generating content

starting with the axiom a (in l-systems the seed strings are called axioms) the

   rst few expansions look as follows:

a
ab
aba
abaab
abaababa
abaababaabaab
abaababaabaababaababa
abaababaabaababaababaabaababaabaab

this particular grammar is an example of an l-system. l-systems are a class of
grammars whose de   ning feature is parallel rewriting, and was introduced by the
biologist aristid lindenmayer in 1968 explicitly to model the growth of organic
systems such as plants and algae [387]. with time, they have turned out to be very
useful for generating plants in games as well as in theoretical biology.

one way of using the power of l-systems to generate 2d (and 3d) artifacts is to
interpret the generated strings as instructions for a turtle in turtle graphics. think
of the turtle as moving across a plane holding a pencil, and simply drawing a line
that traces its path. we can give commands to the turtle to move forwards, or to turn
left or right. for example, we can de   ne the l-system alphabet {f, +, -, [, ]} and
then use the following key to interpret the generated strings:
    f: move forward a certain distance (e.g., 10 pixels).
    +: turn left 30 degrees.
       : turn right 30 degrees.
    [: push the current position and orientation onto the stack.
    ]: pop the position and orientation off the stack.

bracketed l-systems can be used to generate surprisingly plant-like structures.
consider the l-system de   ned by the single rule f     f[   f]f[+f][f]. figure 4.5
shows the graphical interpretation of the l-system after 1, 2, 3 and 4 rewrites start-
ing from the single symbol f. minor variations of the rule in this system generate
different but still plant-like structures, and the general principle can easily be ex-
tended to three dimensions by introducing symbols that represent rotation along the
axis of drawing. for this reason, many standard packages for generating plants in
game worlds are based on l-systems or similar grammars. for a multitude of beau-
tiful examples of plants generated by l-systems refer to the book the algorithmic
beauty of plants by prusinkiewicz and lindenmayer [542].

there are many extensions of the basic l-system formalism, including non-
deterministic l-systems, which can help with increasing diversity of the generated
content, and context-sensitive l-systems, which can produce more complicated pat-
terns. formally specifying l-systems can be a daunting task, in particular as the
mapping between the axiom and rules on the one hand and the results after expan-
sion on the other are so complex. however, search-based methods can be used to

4.3. how could we generate content?

165

fig. 4.5 four rewrites of the bracketed l-system f     f[   f]f[+f][f].

   nd good axioms or rules, using for example desired height or complexity of the
plant in the evaluation function [498].

4.3.4 cellular automata

a cellular automaton (plural: cellular automata) is a discrete model of computa-
tion which is widely studied in computer science, physics, complexity science and
even some branches of biology, and can be used to computationally model biologi-
cal and physical phenomena such as growth, development, patterns, forms, or even
emergence. while cellular automata (ca) have been the subject of extensive study,
the basic concept is actually very simple and can be explained in a sentence or two:
cellular automata are a set of cells placed on a grid that change through a number of
discrete time steps according to a set of rules; these rules rely on the current state of
each cell and the state of its neighboring cells. the rules can be applied iteratively
for as many time steps as we desire. the conceptual idea behind cellular automata
was introduced by stanislaw ulam and john von neumann [742, 487] back in the
1940s; it took about 30 more years, however, for us to see an application of cel-
lular automata that showed their potential beyond basic research. that application
was the two-dimensional cellular automaton designed in conway   s game of life
[134]. the game of life is a zero-player game; its outcome is not in   uenced by
the player   s input throughout the game and it is solely dependent on its initial state
(which is determined by the player).

geometric interpretations of  l-systems were proposed in order to turn them into aversatile tool for fractal and plant modeling. an interpretation based on turtle geome-try, was proposed by prusinkiewics et al. (1990). the basic idea of turtle interpreta-tion is given below.a state of the turtle is defined as a triplet (x, y,   ), where the cartesian coordinates(x, y) represent the turtle's position, and the angle   , called the heading, is interpretedas the direction in which the turtle is facing. given the step size d and the angle in-crement   , the turtle can respond to the commands represented by the followingsymbols:f  move forward a step of length d. the state of the  turtle changes to (x   , y   ,   ),where x    = x + d cos    and   y    = y + d sin   . . a line segment between points(x, y) and (x, y   ) is drawn.f   move forwards a step of length d without drawing a line. the state of the tur-tle changes as above.+  turn left by angle   . the next state of the turtle is (x, y,   +  ).-   turn left by angle   . the next state of the turtle is (x, y,   -  ).to represent branching structures, the l-system alphabet is extended with twonew symbols,    [    and    ]   , to delimit a branch. they are interpreted by the turtle asfollows:[push the current state of the turtle onto a pushdown stack.]pop a state from the stack and make it the current state of the turtle.given a string v, the initial state of the turtle (x0, y0,   0), and fixed parameters d and  , the turtle interpretation of v is the figure (set of lines) drawn by the turtle in re-sponse to the string v. this description gives us a rigorous method for mappingstrings to pictures, which may be applied to interpret strings generated by l-systems.an example of a bracketed l-system and its turtle interpretation, obtained in deri-vations of length n = 1 - 4, is shown in fig. 2. these figures were obtained by inter-preting strings generated by the following l-system:{w: f, p: f      f[-f]f[+f][f]}.  n = 1n = 2n = 3n = 4fig. 2. generating a plant-like structure.166

chapter 4. generating content

a cellular automaton contains a number of cells represented in any number of
dimensions; most cellular automata, however, are either one-dimensional (vectors)
or two-dimensional (matrices). each cell can have a    nite number of states; for in-
stance, the cell can be on or off. a set of cells surrounding each cell de   ne its neigh-
borhood. the neighborhood de   nes which cells around a particular cell affect the
cell   s future state and its size can be represented by any integer number greater than
1. for one-dimensional cellular automata, for instance, the neighborhood is de   ned
by the number of cells to the left or the right of the cell. for two-dimensional cellu-
lar automata, the two most common neighborhood types are the moore and the von
neumann neighborhood. the former neighborhood type is a square consisting of
the cells surrounding a cell, including those surrounding it diagonally; for example,
a moore neighborhood of size 1 contains the eight cells surrounding each cell. the
latter neighborhood type, instead, forms a cross of cells which are centered on the
cell considered. for example, a von neumann neighborhood of size 1 consists of
the four cells surrounding the cell, above, below, to the left and to the right.

at the beginning of an experiment (at time t = 0) we initialize the cells by as-
signing a state for each one of them. at each time step t we create a new generation
of cells according to a rule or a mathematical function which speci   es the new state
of each cell given the current state of the cell and the states of the cells in its neigh-
borhood at time t     1. normally, the rule for updating the state of the cells remains
the same across all cells and time steps (i.e., it is static) and is applied to the whole
grid.

cellular automata have been used extensively in games for modeling environ-
mental systems like heat and    re, rain and    uid    ow, pressure and explosions
[209, 676] and in combination with in   uence maps for agent decision making
[678, 677]. another use for cellular automata has been for thermal and hydraulic
erosion in procedural terrain generation [500]. of particular interest for the pur-
poses of this section is the work of johnson et al. [304] on the generation of in   nite
cave-like dungeons using cellular automata. the motivation in that study was to cre-
ate an in   nite cave-crawling game, with environments stretching out endlessly and
seaid113ssly in every direction. an additional design constraint was that the caves are
supposed to look organic or eroded, rather than having straight edges and angles. no
storage medium is large enough to store a truly endless cave, so the content must
be generated at runtime, as players choose to explore new areas. the game does not
scroll but instead presents the environment one screen at a time, which offers a time
window of a few hundred milliseconds in which to create a new room every time
the player exits a room.

the method introduced by johnson et al. [304] used the following four parame-

ters to control the map generation process:
    a percentage of rock cells (inaccessible areas) at the beginning of the process;
    the number of ca generations (iterations);
    a neighborhood threshold value that de   nes a rock;
    the moore neighborhood size.

4.3. how could we generate content?

167

(a) a random map

(b) a map generated with cellular automata

fig. 4.6 cave generation: comparison between a ca and a randomly generated map. the ca pa-
rameters used are as follows: the ca runs for four generations; the size of the moore neighborhood
considered is 1; the threshold value for the ca rule is 5 (t = 5); and the percentage of rock cells
at the beginning of the process is 50% (for both maps). rock and wall cells are represented by
white and red color respectively. colored areas represent different tunnels (   oor clusters). images
adapted from [304].

in the dungeon generation implementation presented in [304], each room is a
50   50 grid, where each cell can be in one of two states: empty or rock. initially,
the grid is empty. the generation of a single room is as follows.

1. the grid is    sprinkled    with rocks: for each cell, there is id203 (e.g., 0.5)
that it is turned into rock. this results in a relatively uniform distribution of rock
cells.

2. a number of ca generations (iterations) are applied to this initial grid.
3. for each generation the following simple rule is applied to all cells: a cell turns
into rock in the next iteration if at least t (e.g., 5) of its neighbors are rock,
otherwise it will turn into free space.

4. for aesthetic reasons the rock cells that border on empty space are designated as

   wall    cells, which are functionally rock cells but look different.

the aforementioned simple procedure generates a surprisingly lifelike cave-
room. figure 4.6 shows a comparison between a random map (sprinkled with rocks)
and the results of a few iterations of the cellular automaton. but while this process
generates a single room, a game would normally require a number of connected
rooms. a generated room might not have any openings in the con   ning rocks, and
there is no guarantee that any exits align with entrances to the adjacent rooms.
therefore, whenever a room is generated, its immediate neighbors are also gen-
erated. if there is no connection between the largest empty spaces in the two rooms,
a tunnel is drilled between those areas at the point where they are least separated. a
few more iterations of the ca algorithm are then run on all nine neighboring rooms

168

chapter 4. generating content

fig. 4.7 cave generation: a 3    3 base grid map generated with ca. rock and wall cells are
represented by white and red color respectively; gray areas represent    oor. moore neighborhood
size is 2, t is 13, number of ca iterations is 4, and the percentage of rock cells at the initialization
phase is 50%. image adapted from [304].

together, to smooth out any sharp edges. figure 4.7 shows the result of this process,
in the form of nine rooms that seaid113ssly connect. this generation process is ex-
tremely fast, and can generate all nine rooms in less than a millisecond on a modern
computer. a similar approach to that of johnson et al. is featured in the galak-z
(17-bit, 2016) game for dungeon generation [9]. in that game cellular automata gen-
erate the individual rooms of levels and the rooms are tied together via a variation
of a hilbert curve, which is a continuous fractal space-   lling curve [261]. galak-z
(17-bit, 2016) shows an alternative way of combining ca with other methods for
achieving the desired map generation result.

in summary, ca are very fast constructive methods that can be used effectively
to generate certain kinds of content such as terrains and levels (as e.g., in [304]),
but they can also be potentially used to generate other types of content. the greatest
bene   ts a ca algorithm can offer to a game content generator is that it depends on
a small number of parameters and that it is intuitive and relatively simple to grasp
and implement. however, the algorithm   s constructive nature is the main cause for

4.3. how could we generate content?

169

its disadvantages. for both designers and programmers, it is not trivial to fully un-
derstand the impact that a single parameter may have on the generation process,
since each parameter affects multiple features of the generated output. while the
few parameters of the core algorithm allow for a certain degree of controllability,
the algorithm cannot guarantee properties such as playability or solvability of lev-
els. further, it is not possible to design content that has speci   c requirements, e.g., a
map with a certain connectivity, since gameplay features are disjoint from the con-
trol parameters of the ca. thus, any link between the ca generation method and
gameplay features would have to be created through a process of trial and error.
in other words, one would need to resort to preprocessing or a generate-and-test
approach.

4.3.5 noise and fractals

one class of algorithms that are very frequently used to generate heightmaps and
textures are noise algorithms, many of which are fractal algorithms, meaning that
they exhibit scale-invariant properties. noise algorithms are usually fast and easy to
use but lack in controllability.

both textures and many aspects of terrains can fruitfully be represented as two-
dimensional matrices of real numbers. the width and height of the matrix map to
the x and y dimensions of a rectangular surface. in the case of a texture, this is called
an intensity map, and the values of cells correspond directly to the brightness of the
associated pixels. in the case of terrains, the value of each cell corresponds to the
height of the terrain (over some baseline) at that point. this is called a heightmap. if
the resolution with which the terrain is rendered is greater than the resolution of the
heightmap, intermediate points on the ground can simply be interpolated between
points that do have speci   ed height values. thus, using this common representation,
any technique used to generate noise could also be used to generate terrains, and vice
versa   though they might not be equally suitable.

it should be noted that in the case of terrains, other representations are possible
and occasionally suitable or even necessary. for example, one could represent the
terrain in three dimensions, by dividing the space up into voxels (cubes) and comput-
ing the three-dimensional voxel grid. an example is the popular open-world game
minecraft (mojang, 2011), which uses unusually large voxels. voxel grids allow
structures that cannot be represented with heightmaps, such as caves and overhang-
ing cliffs, but they require a much larger amount of storage.

fractals [180, 500] such as midpoint displacement algorithms [39] are in com-
mon use for real-time map generation. midpoint displacement is a simple algorithm
for generating two-dimensional landscapes (seen from the side) by repeatedly sub-
dividing a line. the procedure is as follows: start with a horizontal line. find the
midpoint of that line, and move the line up or down by a random amount, thus
breaking the line in two. now do the same thing for both of the resulting lines,
and so on for as many steps as you need in order to reach suf   cient resolution. ev-

170

chapter 4. generating content

fig. 4.8 the midpoint displacement algorithm visualized.

ery time you call the algorithm recursively, lower the range of the random number
generator somewhat (see fig. 4.8 for an example).

a useful and simple way of extending the midpoint displacement idea to two di-
mensions (and thus creating two-dimensional heightmaps which can be interpreted
as three-dimensional landscapes) is the diamond-square algorithm (also known
as    the cloud fractal    or    the plasma fractal    because of its frequent use for creating
such effects) [210]. this algorithm uses a square 2d matrix with width and height
2n + 1. to run the algorithm you normally initialize the matrix by setting the values
of all cells to 0, except the four corner values which are set to random values in
some chosen range (e.g., [   1,1]). then you perform the following steps:

1. diamond step: find the midpoint of the four corners, i.e., the most central
cell in the matrix. set the value of that cell to the average value of the cor-
ners. add a random value to the middle cell.

4.3. how could we generate content?

171

2. square step: find the four cells in between the corners. set each of those to
the average value of the two corners surrounding it. add a random value to
each of these cells.

call this method recursively for each of the four subsquares of the matrix, until
you reach the resolution limit of the matrix (3     3 sub-squares). every time you
call the method, reduce the range of the random values somewhat. the process is
illustrated in fig. 4.9.

there are many more advanced methods for generating fractal noise, with differ-
ent properties. one of the most important is perlin noise, which has some bene   ts
over diamond square [529]. these algorithms are covered thoroughly in books that
focus on texturing and modeling from a graphics perspective [180].

4.3.6 machine learning

an emerging direction in pcg research is to train generators on existing content,
to be able to produce more content of the same type and style. this is inspired
by the recent results in deep neural networks, where network architectures such
as id3 [232] and id5 [342]
have attained good results in learning to produce images of e.g., bedrooms, cats or
faces, and also by earlier results where both simpler learning mechanisms such as
markov chains and more complex architectures such as recurrent neural networks
have learned to produce text and music after training on some corpus.

while these kinds of generative methods based on machine learning work well
for some types of content   most notably music and images   many types of game
content pose additional challenges. in particular, a key difference between game
content generation and procedural generation in many other domains is that most
game content has strict structural constraints to ensure playability. these constraints
differ from the structural constraints of text or music because of the need to play
games in order to experience them. a level that structurally prevents players from
   nishing it is not a good level, even if it is visually attractive; a strategy game map
with a strategy-breaking shortcut will not be played even if it has interesting fea-
tures; a game-breaking card in a collectible card game is merely a curiosity; and so
on. thus, the domain of game content generation poses different challenges from
that of other generative domains. the same methods that can produce    mostly cor-
rect    images of bedrooms and horses, that might still have a few impossible angles
or vestigial legs, are less suitable for generating mazes which must have an exit.
this is one of the reasons why machine learning-based approaches have so far only
attained limited success in pcg for games. the other main reason is that for many
types of game content, there simply isn   t enough existing content to train on. this

172

chapter 4. generating content

(a) initiate corner values

(b) perform diamond step

(c) perform square step

(d) perform diamond step

(e) perform square step

fig. 4.9 the diamond-square algorithm visualized in    ve steps. adapted from a    gure by christo-
pher ewin, licensed under cc by-sa 4.0.

is, however, an active research direction where much progress might be achieved in
the next few years.

4.3. how could we generate content?

173

(a) n = 1

(b) n = 2

(c) n = 3

fig. 4.10 mario levels reconstructed by id165s with n set to 1, 2, and 3, respectively.

the core difference between pcg via machine learning and approaches such as
search-based pcg is that the content is created directly (e.g., via sampling) from
models which have been trained on game content. while some search-based pcg
approaches use evaluation functions that have been trained on game content   for
instance, the work of shaker et al. [621] or liapis et al. [373]   the actual content
generation is still based on search. below, we present some examples of pcg via
machine learning; these particular pcg studies built on the use of id165s, markov
models and arti   cial neural networks. for more examples of early work along
these lines, see the recent survey paper [668].

4.3.6.1 id165s and markov models

for content that can be expressed as one- or two-dimensional discrete structures,
such as many game levels, methods based on markov models can be used. one par-
ticularly straightforward markov model is the id165 model, which is commonly
used for text prediction. the id165 method is very simple   essentially, you build
id155 tables from strings and sample from these tables when con-
structing new strings   and also very fast.

dahlskog et al. trained id165 models on the levels of the original super mario
bros (nintendo, 1985) game, and used these models to generate new levels [156].
as id165 models are fundamentally one-dimensional, these levels needed to be
converted to strings in order for id165s to be applicable. this was done through di-
viding the levels into vertical    slices,    where most slices recur many times through-
out the level [155]. this representational trick is dependent on there being a large

174

chapter 4. generating content

amount of redundancy in the level design, something that is true in many games.
models were trained using various levels of n, and it was observed that while n = 0
creates essentially random structures and n = 1 creates barely playable levels, n = 2
and n = 3 create rather well-shaped levels. see fig. 4.10 for examples of this.

summerville et al. [667] extended these models with the use of monte carlo
tree search to guide the generation. instead of solely relying on the learned condi-
tional probabilities, they used the learned probabilities during rollouts (generation
of whole levels) that were then scored based on an objective function speci   ed by
a designer (e.g., allowing them to bias the generation towards more or less dif   -
cult levels). the generated levels could still only come from observed con   gura-
tions, but the utilization of mcts meant that playability guarantees could be made
and allowed for more designer control than just editing of the input corpus. this
can be seen as a hybrid between a search-based method and a machine learning-
based method. in parallel, snodgrass and onta  n  on trained two-dimensional markov
chains   a more complex relative of the id165   to generate levels for both su-
per mario bros (nintendo, 1985) and other similar platform games, such as lode
runner (br  derbund, 1983) [644].

4.3.6.2 neural networks

given the many uses of neural networks in machine learning, and the many dif-
ferent neural network architectures, it is little wonder that neural networks are also
highly useful for machine learning-based pcg. following on from the super mario
bros (nintendo, 1985) examples in the previous section, hoover et al. [277] gen-
erated levels for that same game by extending a representation called functional
scaffolding for musical composition (id122c) that was originally developed to com-
pose music. the original id122c representation posits 1) music can be represented
as a function of time and 2) musical voices in a given piece are functionally re-
lated [276]. through a method for evolving neural networks called neuroevolu-
tion of augmenting topologies [655], additional musical voices are evolved to be
played simultaneously with an original human-composed voice. to extend this mu-
sical metaphor and represent super mario bros (nintendo, 1985) levels as functions
of time, each level is broken down into a sequence of tile-width columns. the height
of each column extends the height of the screen. while id122c represents a unit of
time by the length of an eighth-note, a unit of time in this approach is the width of
each column. at each unit of time, the system queries the ann to decide a height to
place a tile. id122c then inputs a musical note   s pitch and duration to the anns. this
approach translates pitch to the height at which a tile is placed and duration to the
number of times a tile-type is repeated at that height. for a given tile-type or musical
voice, this information is then fed to a neural network that is trained on two-thirds
of the existing human-authored levels to predict the value of a tile-type at each col-
umn. the idea is that the neural network will learn hidden relationships between the
tile-types in the human-authored levels that can then help humans construct entire
levels from as little starting information as the layout of a single tile-type.

4.4. roles of pcg in games

175

of course, machine learning can also be used to generate other types of game
content that are not levels. a fascinating example of this is mystical tutor, a design
assistant for magic: the gathering cards [666]. in contrast to some of the other
generators that aim to produce complete, playable levels, mystical tutor acknowl-
edges that its output is likely to be    awed in some ways and instead aims to provide
inspirational raw material for card designers.

4.4 roles of pcg in games

the generation of content algorithmically may take different roles within the do-
main of games. we can identify two axes across which pcg roles can be placed:
players and designers. we envision pcg systems that consider designers while they
generate content or they operate interdependently of designers; the same applies for
players. figure 4.11 visualizes the key roles of pcg in games across the dimensions
of designer initiative and player experience.

regardless of the generation method used, game genre or content type pcg can
act either autonomously or as a collaborator in the design process. we refer to the
former role as autonomous generation (section 4.4.2) and the latter role as mixed-
initiative (section 4.4.1) generation. further, we cover the experience-driven pcg
role by which pcg algorithms consider the player experience in whatever they try
to generate (section 4.4.3). as a result, the generated content is associated to the
player and her experience. finally, if pcg does not consider the player as part of
the generation process it becomes experience-agnostic (section 4.4.4).

pcg techniques can be used to generate content in runtime, as the player is
playing the game, allowing the generation of endless variations, making the game
in   nitely replayable and opening the possibility of generating player-adapted con-
tent, or of   ine during the development of the game or before the start of a game
session. the use of pcg for of   ine content generation is particularly useful when
generating complex content such as environments and maps; several examples of
that was discussed at the beginning of the chapter. an example of the use of run-
time content generation can be found in the game left 4 dead (valve, 2008), a
   rst-person shooter game that provides dynamic experience for each player by an-
alyzing player behavior on the    y and altering the game state accordingly using
pcg techniques [14, 60]. a trend related to runtime content generation is the cre-
ation and sharing of player-generated content. some games such as littlebigplanet
(sony computer entertainment, 2008) and spore (electronic arts, 2008) provide
a content editor (level editor in the case of littlebigplanet and the spore creature
creator) that allows the players to edit and upload complete creatures or levels to
a central online server where they can be downloaded and used by other players.
with respect to the four different roles of pcg in games, runtime generation is pos-
sible in the autonomous and experience-agnostic roles, it is always the case in the
experience-driven role whereas it is impossible in the mixed-initiative role. on the
other hand, the of   ine generation of content can occur both autonomously and in

176

chapter 4. generating content

fig. 4.11 the four key pcg roles in games across the dimensions of designer initiative and player
experience. for each combination of roles the    gure lists a number of indicative examples of tools
or studies covered in this chapter.

an experience-agnostic manner. further it is exclusively the only way to generate
content in a mixed-initiative fashion whereas it is not relevant for experience-driven
generation as this pcg role occurs in runtime by de   nition.

the following four subsections outline the characteristics of each of the four pcg
roles with a particular emphasis on the mixed-initiative and the experience-driven
roles that have not yet covered in length in this chapter.

4.4.1 mixed-initiative

ai-assisted game design refers to the use of ai-powered tools to support the game
design and development process. this is perhaps the ai research area which is most
promising for the development of better games [764]. in particular, ai can assist in
the creation of game content varying from levels and maps to game mechanics and
narratives.

4.4. roles of pcg in games

177

fig. 4.12 the mixed-initiative spectrum between human and computer initiative (or creativity)
across a number of mixed-initiative design tools discussed in this section. iconoscope is a mixed-
initiative drawing game [372], sentient sketchbook is a level editor for strategy games [379], sen-
tient world is mixed-initiative map editor [380] and spaceship design is a mixed-initiative (mostly
computer initiative) tool powered by interactive evolution [377]. adapted from [375].

we identify ai-assisted game design as the task of creating artifacts via the in-
teraction of a human initiative and a computational initiative. the computational
initiative is a pcg process and thus, we discuss this co-design approach under the
heading of procedural content generation. although the term mixed-initiative lacks
a concrete de   nition [497], in this book we de   ne it as the process that considers
both the human and the computer proactively making content contributions to the
game design task although the two initiatives do not need to contribute to the same
degree [774]. mixed-initiative pcg thus differs from other forms of co-creation,
such as the collaboration of multiple human creators or the interaction between a
human and non-proactive computer support tools (e.g., spell-checkers or image ed-
itors) or non-computer support tools (e.g., artboards or idea cards). the initiative of
the computer can be seen as a continuum between the no initiative state, leaving full
control of the design to the designer and having the computer program simply carry
out the commands of the human designer, to the full initiative state which yields an
autonomously creative system. any state between the two is also possible as we will
see in the examples below and as depicted in fig. 4.12.

4.4.1.1 game domains

while the process of ai-assisted game design is applicable to any creative facets
within game design [381] it is level design that has bene   ted the most from it.
within commercial-standard game development, we can    nd ai-based tools that
allow varying degrees of computer initiative. on one end of the scale, level editors
such as the garden of eden creation kit (bethesda, 2009) or game engines such

178

chapter 4. generating content

as the unreal development kit (epic games 2009) leave most of creative process
to the designer but they, nevertheless, boost game development through automat-
ing interpolations, path   nding and rendering [774]. on the other end of the com-
puter initiative scale, pcg tools specialized on e.g., vegetation   speedtree (idv,
2002)   or fps levels   oblige (apted, 2007)   only require the designer to set a
small amount of generation parameters and, thus, the generation process is almost
entirely autonomous.

within academia, the area of ai-assisted game design tools has seen signi   cant
research interest in recent years [785] with contributions mainly to the level de-
sign task across several game genres including platformers [641], strategy games
[380, 379, 774, 378] (see fig. 4.13(a)), open world games [634], racing games
[102], casual puzzle games [614] (see fig. 4.13(b)), horror games [394],    rst-person
shooters [501], educational games [89, 372], mobile games [482], and adventure
games [323]. the range of mixed-initiative game design tools expands to tools that
are designed to assist with the generation of complete game rulesets such as the
metagame [522], the rulearn [699] and the ludocore [639] tools to tools that are
purposed to generate narratives [480, 673] and stories within games [358].

4.4.1.2 methods

any pcg approach could potentially be utilized for mixed-initiative game design.
the dominant methods that have so far being used, however, rely on evolutionary
computation following the search-based pcg paradigm. even though evolution, at
   st sight, does not appear to be the most attractive approach for real-time processing
and generation of content, it offers great advantages associated, in particular, with
the stochasticity of arti   cial evolution, diversity maintenance and potential for bal-
ancing multiple design objectives. evolution can be constrained to the generation of
playable, usable, or, in general, content of particular qualities within desired design
speci   cations. at the same time, it can incorporate metrics such as novelty [382] or
surprise [240], for maximizing the diversity of generated content and thus enabling a
change in the creative path of the designer [774]. evolution can be computationally
costly, however, and thus, interactive evolution is a viable and popular alternative
for mixed-initiative evolutionary-based generation (e.g., see [102, 380, 377, 501]).
beyond arti   cial evolution, another class of algorithms that is relevant for mixed-
initiative content generation is constraint solvers and constraint optimization. meth-
ods such as answer set programming [383, 69] have been used in several ai-assisted
level design tools including tanagra [641] for platformers and refraction [89] for
educational puzzle games. arti   cial neural networks can also perform certain tasks
in a mixed-initiative manner, such as performing    autocomplete    or level repair
[296] through the use of deep learning approachers such as stacked autoencoders.
the goal here is to provide a tool that       lls in    parts of a level that the human de-
signer does not want or have time to create, and correcting other parts to achieve
further consistency.

4.4. roles of pcg in games

179

(a) sentient sketchbook

(b) ropossum

fig. 4.13 examples of mixed-initiative level design tools. sentient sketchbook (a) offers map
sketch suggestions to the designer via arti   cial evolution (see rightmost part of the image); the
suggestions are evolved to either maximize particular objectives of the map (e.g., balance) or are
evolved to maximize the novelty score of the map. in ropossum (b) the designer may select to
design elements of cut the rope (chillingo, 2010) game levels; the generation of the remaining
elements are left to evolutionary algorithms to design.

180

4.4.2 autonomous

chapter 4. generating content

the role of autonomous generation is arguably the most dominant pcg role in
games. the earlier parts of this chapter are already dedicated to extensive discus-
sions and studies of pcg systems that do not consider the designer in their creative
process. as a result we will not cover this pcg role in further detail here. what is
important to be discussed, however, is the fuzzy borderline between mixed-initiative
and autonomous pcg systems. it might be helpful, for instance, to consider au-
tonomous pcg as the process by which the role of the designer starts and ends
with an of   ine setup of the algorithm. for instance, the designer is only involved
in the parameterization of the algorithm as in the case of speedtree (idv, 2002).
one might wish, however, to further push the borderline between autonomous and
mixed-initiative generation and claim that generation is genuinely autonomous only
if the creative process reconsiders and adapts the utility function that drives the con-
tent generation   thereby becoming creative in its own right. a static utility function
that drives the generation is often referred to as mere generation within the compu-
tational creativity    eld [381].

while the line between autonomy and collaboration with designers is still an
open research question, for the purposes of this book, we can safely claim that the
pcg process is autonomous when the initiative of the designer is limited to algo-
rithmic parameterizations before the generation starts.

4.4.3 experience-driven

as games offer one of the most representative examples of rich and diverse content
creation applications and are elicitors of unique user experiences experience-driven
pcg (edpcg) [783, 784] views game content as the building block of games and
the generated games as the potentiators of player experience. based on the above,
edpcg is de   ned as a generic and effective approach for the optimization of user
(player) experience via the adaptation of the experienced content. according to the
experience-driven role of pcg in games player experience is the collection of af-
fective patterns elicited, cognitive processes emerged and behavioral traits observed
during gameplay [781].

by coupling player experience with procedural content generation, the experience-
driven perspective offers a new, player-centered role to pcg. since games are com-
posed by game content that, when played by a particular player, elicits experience
patterns, one needs to assess the quality of the content generated (linked to the ex-
perience of the player), search through the available content, and generate content
that optimizes the experience for the player (see fig. 4.14). in particular, the key
components of edpcg are:
    player experience modeling: player experience is modeled as a function of

game content and player.

4.4. roles of pcg in games

181

fig. 4.14 the four key components of the experience-driven pcg framework.

ef   cacy and robustness.

the modeled experience.

    content quality: the quality of the generated content is assessed and linked to
    content representation: content is represented accordingly to maximize search
    content generator: the generator searches through the generative space for con-
tent that optimizes the experience for the player according to the acquired model.
each component of edpcg has its own dedicated literature and the extensive
review of each is covered in other parts of the book. in particular, player experi-
ence modeling is covered in chapter 5 whereas the remaining three components
of the framework have already been covered in this chapter. a detailed survey and
discussion about edpcg is available in [783].

4.4.3.1 experience-driven pcg in practice

left 4 dead (valve, 2008) is an example of the use of experience-driven pcg in a
commercial game where an algorithm is used to adjust the pacing of the game on
the    y based on the player   s emotional intensity. in this case, adaptive pcg is used
to adjust the dif   culty of the game in order to keep the player engaged [60]. adap-
tive content generation can also be used with another motive such as the generation
of more content of the kind the player seems to like. this approach was followed,
for instance, in the galactic arms race [250] game where the weapons presented
to the player are evolved based on her previous weapon use and preferences. in an-
other edpcg study, el-nasr et al. implemented a direct    tness function   derived
from visual attention theory   for the procedural generation of lighting [188, 185].
the procedural zelda game engine [257], a game engine designed to emulate the

182

chapter 4. generating content

(a) human

(b) world-champion ai

fig. 4.15 example levels generated for two different mario players. the generated levels maxi-
mize the modeled fun value for each player. the level on top is generated for one of the experiment
subjects that participated in [521] while the level below is generated for the world champion agent
of the mario ai competition in 2009.

popular the legend of zelda (nintendo, 1986   2017) action-rpg game series, is
built mainly to support experience-driven pcg research. another example is the
work by pedersen et al. [521], who modi   ed an open-source clone of the classic
platform game super mario bros (nintendo, 1985) to allow for personalized level
generation. the realization of edpcg in this example is illustrated in fig. 4.16.
the    rst step was to represent the levels in a format that would yield an easily
searchable space. a level was represented as a short parameter vector describing
the number, size and placement of gaps which the player can fall through, and the
presence or absence of a switching mechanic. the next step was to create a model
of player experience based on the level played and the player   s playing style. data
was collected from hundreds of players, who played pairs of levels with different
parameters and were asked to rank which of two levels best induced each of the
following user states: fun, challenge, frustration, predictability, anxiety, boredom.
while playing, the game also recorded a number of metrics of the players    playing
styles, such as the frequency of jumping, running and shooting. this data was then
used to train neural networks to predict the examined user states using evolutionary
preference learning. finally, these player experience models were utilized to opti-
mize game levels for particular players [617]. two examples of such levels can be
seen in fig. 4.15. it is worth noting   as discussed in chapter 5   that one may wish
to further improve the models of experience of mario players by including infor-
mation about the player beyond gameplay [29] such as her head pose [610] or her
facial expressions [52].

4.4.4 experience-agnostic

with experience-agnostic pcg we refer to any pcg approach that does not con-
sider the role of the player in the generation of content. but where should we set
the boundary of involvement? when do we consider a player as part of the gener-
ation process and when don   t we? while the borderline between experience-driven
and experience-agnostic is not trivial to draw we de   ne any pcg approach whose
content quality function does not include a player (experience) model or it does not

4.4. roles of pcg in games

183

fig. 4.16 the edpcg framework in detail. the gradient grayscale-colored boxes represent a con-
tinuum of possibilities between the two ends of the box while white boxes represent discrete,
exclusive options within the box. the blue arrows illustrate the edpcg approach followed for
the super mario bros (nintendo, 1985) example study [521, 617]: content quality is assessed via
a direct, data-driven evaluation function which is based on a combination of a gameplay-based
(model-free) and a subjective (pairwise preference) player experience modeling approach; content
is represented indirectly and exhaustive search is applied to generate better content.

interact with the player in any way during generation as experience-agnostic. as
with the role of autonomous pcg, this chapter has already gone through several
examples of content generation that do not involve a player or a player experience
model. to avoid being repetitive we will refer the reader to the pcg studies covered
already that are outside the de   nition of experience-driven pcg.

184

chapter 4. generating content

4.5 what could be generated?

in this section we brie   y outline the possible content types that a pcg algorithm
can generate in a game. generally speaking liapis et al. [381] identi   ed six creative
domains (or else facets) within games that we will follow for our discussion in
this section. these include level architecture (design), audio, visuals, rules (game
design), narrative, and gameplay. in this chapter we will cover the    rst    ve facets and
we purposely exclude the gameplay facet. creative gameplay is directly associated
with play and as such is covered in the previous chapter. we conclude this section
with a discussion on complete game generation.

4.5.1 levels and maps

the generation of levels is by far the most popular use of pcg in games. levels
can be viewed as necessary content since every game has some form of spatial
representation or virtual world within which the player can perform a set of actions.
the properties of the game level, in conjunction with the game rules, frame the
ways a player can interact with the world and determine how the player can progress
from one point in the game to another. the game   s level design contributes to the
challenges a player faces during the game. while games would often have a    xed set
of mechanics throughout, the way a level is designed can in   uence the gameplay and
the degree of game challenge. for that reason, a number of researchers have argued
that levels coupled with game rules de   ne the absolutely necessary building blocks
of any game; in that regard the remaining facets covered below are optional [371].
the variations of possible level designs are endless: a level representation can vary
from simple two-dimensional illustrations of platforms and coins   as in the super
mario bros (nintendo, 1985) series   to the constrained 2d space of candy crush
saga (king, 2012), to the three-dimensional and large urban spaces of assassin   s
creed (ubisoft, 2007) and call of duty (in   nity ward, 2003), to the 2d elaborated
structures of angry birds (rovio, 2009), to the voxel-based open gameworld of
minecraft (mojang 2011).

due to their several similarities we can view the procedural generation of game
levels from the lens of procedural architecture. similarly to architecture, level design
needs to consider both the aesthetic properties and the functional requirements of
whatever is designed within the game world. depending on the game genre, func-
tional requirements may vary from a reachable end-goal for platform games, to a
challenging gameplay in driving games such as forza motorsport (turn 10 stu-
dios 2005), to waves of gameplay intensity as in pac-man (namco, 1980), left 4
dead (valve, 2008), resident evil 4 (capcom, 2005) and several other games. a
procedural level generator also needs to consider the aesthetics of the content as
the level   s aesthetic appearance may have a signi   cant impact not only on the vi-
sual stimuli it offers to the player but also on navigation. for example, a sequence
of identical rooms can easily make the player disoriented   as was intended in the

4.5. what could be generated?

185

fig. 4.17 the procedurally generated levels of diablo (blizzard entertainment, 1996): one of the
most characteristic examples of level generation in commercial games. diablo is a relatively recent
descendant of rogue (toy and wichmann, 1980) (i.e., rogue-like) role-playing game characterized
by dungeon-based procedurally generated game levels. image obtained from wikipedia (fair use).

dream sequences of max payne (remedy, 2001)   while dark areas can add to the
challenge of the game due to low visibility or augment the player   s arousal as in
the case of amnesia: the dark descent (frictional games, 2010), nevermind (fly-
ing mollusk, 2015) and sonancia [394]. when the level generator considers larger,
open levels or gameworlds then it draws inspiration from urban and city planning
[410], with edges to constrain player freedom   landmarks to orient the player and
motivate exploration [381]   as in the grand theft auto (rockstar games, 1997) se-
ries and districts and areas to break the world   s monotony   as in world of warcraft
(blizzard entertainment, 2004) which uses highly contrasting colors, vegetation and
architectural styles to split the world into districts that are suitable for characters of
different level ranges.

as already seen broadly in this chapter the generation of levels in a procedural
manner is clearly the most popular and possibly the oldest form of pcg in the game
industry. we already mentioned the early commercial use of pcg for automatic level
design in games such as rogue (toy and wichman, 1980) and the rogue-inspired
diablo (see fig. 4.17) series (blizzard entertainment, 1996), and the more recent
world generation examples of civilization iv (firaxis, 2005) and minecraft (mo-
jang, 2011). the level generation algorithms used in commercial games are usually

186

chapter 4. generating content

fig. 4.18 the caricaturized and highly-emotive visuals of the game limbo (playdead, 2010). im-
age obtained from wikipedia (fair use).

constructive, in particular, in games where players can interact with and change the
game world via play. players of spelunky (yu and hull, 2009), for instance, are al-
lowed to modify a level which is not playable (i.e., the exit cannot be reached) by
blowing up the blocking tiles with a bomb provided by the game level.

the academic interest in procedural level generation is only recent [720, 783,
616] but it has produced a substantial volume of studies already. most of the aca-
demic studies described in this chapter are focused on levels. the interested reader
may refer to those for examples of level generation across various methodologies,
pcg roles and game genres.

4.5.2 visuals

games are, by de   nition, visual media unless the game is designed explicitly to
not have visuals   e.g., the real sound: kaze no regret (sega, 1997) adventure au-
dio game. the visual information displayed on the screen conveys messages to the
player which are dependent on the graphical style, color palette and visual texture.
visuals in games can vary from simple abstract and pixelized representations as the
8-bit art of early arcade games, to caricaturized visuals as in limbo (playdead, 2010)
(see fig. 4.18), to photorealistic graphics as in the fifa series (ea sports, 1993)
[299].

within the game industry pcg has been used broadly for the generation of any
of the above visual types. arguably, the complexity of the visual generation task
increases the more the resolution and the photorealism of the desired output in-
creases. there are examples of popular generative tools such as speedtree (idv,
2002) for vegetation and facegen (singular inversions, 2001) for faces, however,
that can successfully output photorealistic 3d visuals. within academia notable ex-
amples of visual generation are the games petalz [565, 566] (   ower generation),
galactic arms race [250] (weapon generation; see also fig. 4.3) and audioinspace

4.5. what could be generated?

187

[275] (weapon generation). in all three games visuals are represented by neural
networks that are evolved via interactive evolution. within the domain of weapon
particle generation another notable example is the generation of surprising yet bal-
anced weapons for the game unreal tournament iii (midway games, 2007) using
constrained surprise search [240]; an algorithm that maximizes the surprise score
of a weapon but at the same time imposes designer constraints to it so that it is bal-
anced. other researchers have been inspired by theories about    universal    properties
of beauty [18] to generate visuals of high appeal and appreciation [377]. the pcg
algorithm in that study generates spaceships based on their size, simplicity, balance
and symmetry, and adapts its visual output to the taste of the visual   s designer via
interactive evolution. the pcg-assisted design process referred to as iterative re-
   nement [380] is another way of gradually increasing the resolution of the visuals a
designer creates by being engaged in an iterative and creative dialog with the visuals
generator. beyond the generation of in-game entities a visuals pcg algorithm may
focus on general properties of the visual output such as pixel shaders [282], lighting
[188, 185], brightness and saturation, which can all in   uence the overall appearance
of any game scene.

4.5.3 audio

even though audio can be seen as optional content it can affect the player directly
and its impact on player experience is apparent in most games [219, 221, 129]. au-
dio in games has reached a great level of maturity as demonstrated by two bafta
game awards and an mtv video music award for best video game soundtrack
[381]. the audio types one meets in games may vary from fully orchestrated sound-
track (background) music, as in skyrim (bethesda, 2011), to sound effects, as the dy-
ing or pellet-eating sounds of pac-man (namco, 1980), to the voice-acted sounds of
fallout 3 (bethesda, 2008). most notably within indie game development, proteus
(key and kanaga, 2013) features a mapping between spatial positioning, visuals
and player interaction, which collectively affect the sounds that are played. profes-
sional tools such as the sound middleware of udk (epic games, 2004) and the
popular sfxr and bfxr sound generation tools provide procedural sound components
to audio designers, demonstrating a commercial interest in and need of procedurally
generated audio.

at a    rst glance, the generation of game audio, music and sounds might not seem
to be particularly different from any other type of audio generation outside games.
games are interactive, however, and that particular feature makes the generation of
audio a rather challenging task. when it comes to the de   nition of procedural audio
in games, a progressive stance has been that its procedurality is caused by the very
interaction with the game. (for instance, game actions that cause sound effects of
music can be considered as procedural audio creation [220, 128].) ideally, the game
audio must be able to adapt to the current game state and the player behavior. as a
result adaptive audio is a grand challenge for composers since the combinations of

188

chapter 4. generating content

all possible game and player states could be largely unknown. another dif   culty for
the autonomous generation of adaptive music, in particular, is that it requires real-
time composition and production; both of which need to be embedded in a game
engine. aside from a few efforts in that direction3 the current music generation
models are not particularly designed to perform well in games. in the last decade,
however, academic work on procedural game music and sound has seen substantial
advancements in venues such as the procedural content generation and the musical
metacreation workshop series.

generally speaking, sound can be either diegetic or non-diegetic. a sound is
diegetic if its source is within the game   s world. the source of the diegetic sound
can be visible on the screen (on-screen) or can be implied to be present at the current
game state (off-screen). diegetic sounds include characters, voices, sounds made by
items on-screen or interactions of the player, or even music represented as coming
from instruments available in the game. a non-diegetic sound, on the other hand, is
any sound whose source is outside the game   s world. as such non-diegetic sounds
cannot be visible on-screen or even implied to be off-screen. examples include com-
mentaries of a narrator, sound effects which are not linked to game actions, and
background music.

a pcg algorithm can generate both diegetic and non-diegetic sounds including
music, sound effects and commentaries. examples of non-diegetic sound generation
in games include the sonancia horror sound generator that tailors the tension of the
game to the desires of the designer based on the properties of the game level [394].
the mapping between tension and sounds in sonancia has been derived through
id104 [396]. similarly to sonancia   and towards exploring the creative
space between audio and level design   audioverdrive generates levels from audio
and audio from levels [273]. notably within diegetic audio examples, scirea et al.
[606] explores the relationship between procedurally generated music and narrative.
studies have also considered the presence of game characters on-display for the
composition of game soundtracks [73] or the combination of short musical phrases
that are driven by in-game events and, in turn, create responsive background audio
for strategy games [280].

finally, it is worth mentioning that there are games featuring pcg that use music
as the input for the generation of other creative domains rather than music per se.
for example, games such as audio surf (fitterer, 2008) and vib ribbon (sony en-
tertainment, 2000) do not procedurally generate music but they instead use music
to drive the generation of levels. audioinspace [275] is another example of a side-
scrolling space shooter game that does not generate music but uses the background
music as the basis for weapon particle generation via arti   cial evolution.

3 for instance, see the upcoming melodrive app at: http://melodrive.com.

4.5. what could be generated?

4.5.4 narrative

189

many successful games are relying heavily on their narratives; the clear distinction
however, between such narratives and traditional stories is the interactivity element
that is offered by games. now, whether games can tell stories [313] or games are
instead a form of narrative [1] is still an open research question within game stud-
ies, and beyond the scope of this book. the study of computational (or procedural)
narrative focuses on the representational and generational aspects of stories as those
can be told via a game. stories can play an essential part in creating the aesthetics
of a game which, in turn, can impact affective and cognitive aspects of the playing
experience [510].

by breaking the game narrative into subareas of game content we can    nd core
game content elements such as the game   s plotline [562, 229], but also the ways a
story is represented in the game environment [730, 83]. the coupling of a game   s
representation and the story of the game is of vital importance for player experi-
ence. stories and plots are taking place in an environment and are usually told via
a virtual camera lens. the behavior of the virtual camera   viewed as a parame-
terized element of computational narrative   can drastically in   uence the player   s
experience. that can be achieved via an affect-based cinematographic representa-
tion of multiple cameras as those used in heavy rain (quantic dream, 2010) or
through an affect-based automatic camera controller as that used in the maze-ball
game [780]. choosing the best camera angle to highlight an aspect of a story can be
seen as a multi-level optimization problem, and approached with combinations of
optimization algorithms [85]. games such as world of warcraft (blizzard entertain-
ment, 2004) use cut scenes to raise the story   s climax and lead the player to partic-
ular player experience states. the creation or semi-automatic generation of stories
and narratives belongs to the area of interactive storytelling, which can be viewed
as a form of story-based pcg. the story can adjust according to the actions of the
player targeting personalized story generation (e.g., see [568, 106] among others).
ultimately, game worlds and plot point story representations can be co-generated as
demonstrated in a few recent studies (e.g., see [248]).

computational narrative methods for generating or adapting stories of exposi-
tions are typically build on planning algorithms, and planning is therefore essential
for narrative [792]. the space of stories can be represented in various ways, and the
representations in turn make use of dissimilar search/planning algorithms, includ-
ing traditional optimization and id23 approaches [483, 117, 106].
cavazza et al. [106], for instance, introduced an interactive storytelling system built
with the unreal game engine that uses hierarchical task network planning to sup-
port story generation and anytime user intervention. young et al. [792] introduced an
architecture called mimesis, primarily designed to generate intelligent, plan-based
character and system behavior at runtime with direct uses in narrative generation.
finally the idtension engine [682] dynamically generates story paths based on the

190

chapter 4. generating content

player   s choices; the engine was featured in nothing for dinner,4 a 3d interactive
story aiming to help teenagers living challenging daily life situations at home.

similarly to dominant approaches of narrative and text generation, interactive
storytelling in games relies heavily on stored knowledge about the (game) world.
games that rely on narratives   such as heavy rain (quantic dream, 2010)   may
include thousands of lines of dialog which are manually authored by several writers.
to enable interactive storytelling the game should be able to select responses (or
paths in the narrative) based on what the player will do or say, as in fac  ade [441]
(see fig. 4.19). to alleviate, in part, the burden of manually representing world
knowledge, data-driven approaches can be used. for instance, one may crowdsource
actions and utterance data from thousand of players that interact with virtual agents
of a game and then train virtual agents to respond in similar ways using id165s
[508]. or instead, one might design a system in which designers collaborate with
a computer by taking turns on adding sentences in a story; the computer is able
to provide meaningful sentences by matching the current story with similar stories
available on the cloud [673]. alternatively, a designer could use the news of the day
from sites, blogs or wikipedia and generate games that tell the news implicitly via
play [137].

research on interactive narrative and story-based pcg bene   ts from and in-
   uences the use of believable agents that interact with the player and are inter-
woven in the story plot. the narrative can yield more (or less) believability to
agents and thus the relationship between agents and the story they tell is impor-
tant [801, 401, 531, 106]. in that sense, the computational narrative of a game may
de   ne the arena for believable agent design. research on story-based pcg has also
in   uenced the design and development of games. starting from popular indepen-
dent attempts like fac  ade [441] (see fig. 4.19), prom week [448] and nothing for
dinner to the commercial success of the elder scrolls v: skyrim (bethesda soft-
works, 2011), heavy rain (quantic dream, 2010) and mass effect (bioware, 2007)
narrative has traditionally been amongst the key factors of player experience and
immersion; particularly in narrative-heavy games as the ones aforementioned.

examples of sophisticated computational narrative techniques crossing over
from academia to commercial-standard products include the storytelling system
versu [197] which was used to produce the game blood & laurels (emily short,
2014). for the interested reader the interactive    ction database5 contains a detailed
list of games built on the principles of interactive narratives and    ction, and the stoy-
gen.org6 repository, by chris martens and rogelio e. cardona-rivera, maintains
existing openly-available computational story generation systems. finally note that
the various ways ai can be used to play text-based adventure games and interactive
   ction are covered in chapter 3.

4 http://nothingfordinner.org
5 http://ifdb.tads.org/
6 http://storygen.org/

4.5. what could be generated?

191

fig. 4.19 a screenshot from the fac  ade [441] game featuring its main characters: grace and trip.
the seminal design and ai technologies of fac  ade popularized the vision of interactive narrative
and story-based pcg within games.

4.5.5 rules and mechanics

the game rules frame the playing experience by providing the conditions of play   
for instance, winning and losing conditions   and the actions available to the player
(game mechanics). rules constitute necessary content as they are in a sense the core
of any game, and a game   s rules pervade it.

for most games, the design of their ruleset largely de   nes them and contributes
to their success. it is common that the rule set follows some standard design patterns
within its genre. for example, the genre of platform games is partly de   ned by run-
ning and jumping mechanics, whereas these are rare in puzzle games. evidently, the
genre constrains the possibility (design) space of the game rules. while this prac-
tice has been bene   cial   as rule sets are built on earlier successful paradigms   it
can also be detrimental to the creativity of the designer. it is often the case that the
players themselves can create new successful game variants (or even sub-genres) by
merely altering some rules of an existing game. a popular example is the modi   -
cation of warcraft iii (blizzard, 2002) which allowed the player to control a single
   hero    unit and, in turn, gave rise to a new, popular game genre named multiplayer
online battle arenas (moba).

192

chapter 4. generating content

most existing approaches to rule generation take a search-based approach, and
are thus dependent on some way of evaluating a set of rules [711, 355]. however,
accurately estimating the quality of a set of game rules is very hard. game rules
differ from most other types of game content in that they are almost impossible to
evaluate in isolation from the rest of the game. while levels, characters, textures, and
many other types of content can to some extent be evaluated outside of the game,
looking at a set of rules generally gives very little information of how they play. for
a human, the only way to truly experience the rules of a game is to play the game.
for a computer, this would translate to simulating gameplay in some way in order
to evaluate the rules. (in this sense, rules can be said to be more similar to program
code than they are to e.g., pictures or music.)

so how can simulated playthroughs be used to judge the quality of the rulesets?
several ideas about how to judge a game depending on how agents play it have been
introduced. the    rst is balance; for symmetric two-player games in particular, bal-
ance between the winning chances of the two players is generally positive [274].
another idea is outcome uncertainty, meaning that any particular game should be
   decided    as late as possible [76]. yet another idea is learnability: a good game,
including its ruleset, is easy to learn and hard to master. in other words, it should
have a long, smooth learning curve for the player, as learning to play the game is
part of what makes it fun. this idea can be found expressed most clearly in koster   s
   theory of fun    [351], but can also be said to be implicit in schmidhuber   s the-
ory of arti   cial curiosity [602] and in theories in developmental psychology [204].
within work in game rule generation, attempts have been made to capture this idea
in different ways. one way is to use a id23 agent to try to learn to
play the game; games where the agent improves the most over a long time score the
best [716]. another way of capturing this idea is to use several agents of different
skill levels to try to play the game. games score better when they maximize the
performance difference between these agents [491]. this idea is also related to the
idea of depth in games, which can be seen as the length of the chain of heuristics
that can be acquired in a game [362].

perhaps the most successful example of game rule generation within academic
research is ludi [76]. ludi follows a search-based pcg approach and evolves gram-
mars that represent the rules of board games (see fig. 4.20). the    tness function
that drives the rule generation is composed by several metrics that estimate good
design patterns in board games, such as game depth and rule simplicity. a success-
fully designed game that came out of the ludi generator is named yavalath [75] (see
fig. 4.20). the game is played on a 5-by-5 hexagonal board by two or three players.
yavalath   s winning and losing conditions are very simple: you win if you make a
line of four tokens, whereas you lose if you make a line of three tokens; the game is
a draw if the board    lls up.

one of the earliest examples of video game rule generation is togelius and
schmidhuber   s experiment with generating simple pac-man-like games [716]. in
that study rules are evolved to maximize the learnability of player agents as mea-
sured via simulated playthroughs. another example is the work by nielsen et al. in
which game rules are represented using the video game description language [492].

4.5. what could be generated?

193

using answer set programming (a solver-based method) [69] rather than search-
based methods, rules have been generated for simple 2d games that, however, re-
spect constraints such as playability (i.e., the victory condition is attainable) [637].
it is fair to say that none of these attempts to generate video games have been able
to produce good games, i.e., games that anyone (except the creator of the system
that creates the games) would want to play. this points to the immense challenge in
accurately estimating the quality of a video game rule set. one of the reasons this
seems to be a more challenging problem than estimating the quality of a board game
rule set is the time dimension, as human reaction time and ability to estimate and
predict unfolding processes play an important role in the challenge of many video
games.

for more examples and in-depth analysis on rule and mechanics generation the
interested reader is referred to the    rules and mechanics    chapter of the pcg book
[486].

4.5.6 games

game generation refers to the use of pcg algorithms for computationally design-
ing new complete games. the vast majority of pcg studies so far, however, have
been very speci   c to a particular game facet or domain. it is, for instance, either
a level that is generated or the audio for some level but rarely both. meanwhile it
is surprising to think that the relationship between the different facets is naturally
interwoven. a characteristic example of the interwoven nature among game facets
is given in [381]: player actions   viewed as a manifestation of game rules   are
usually accompanied by corresponding sound effects such as the sound of mario
jumping in super mario bros (nintendo, 1985). now let us think of a pcg al-
gorithm that introduces a new rule to the game   hence a new player action. the
algorithm automatically constrains the sound effects that can be associated to this
new action based on a number of factors such as the action   s duration, purpose and
overall contribution to the game plot. actions and sounds appear to have a cause and
effect (or hierarchical) relationship and a pcg algorithm would naturally prioritize
the creation of the action before it generates its sound. most relationships between
facets, however, are not strictly hierarchical or unidirectional. for example, a game
level can be successful because of a memorable landmark as much as the gameplay
it affords [381]. similarly, the narrative of a game relies on a multitude of factors
including the camera placement as well as the visuals and the sounds.

the game generation topic has attracted a growing interest in recent years even
though the relationship between the different games facets is not considered largely.
most game generation projects focus on a single facet of a game and do not inves-
tigate the interaction between different facets. the rule generator for pac-man-like
games [716], for instance, evolves different rules for different colored agents but it
does not evolve the agents    color to indicate different playing strategies. similarly

194

chapter 4. generating content

(a) the ludi game rule generator

(b) a deluxe version of the yavalath game

fig. 4.20 the ludi game rule generator (a) and its game yavalath (b). image (a) is adapted from
[720]. image (b) is published with permission by cameron browne and n  estor romeral andr  es.

4.5. what could be generated?

195

to the ghosts of pac-man (namco, 1981) we could imagine that red represents an
aggressive behavior whereas orange represents a passive behavior.

among the few notable attempts of game generation, game-o-matic [723] is a
game generation system that creates games representing ideas. more speci   cally,
game-o-matic includes an authoring tool in which a user can enter entities and
their interactions via concept maps. the entities and interactions are translated, re-
spectively, into game visuals and game mechanics; the mechanics, however, do not
take into account the visuals or semantics of the game objects they are applied on.
one of the    rst preliminary discussions on how multi-facet integration might hap-
pen is offered by nelson and mateas [484]. in their paper they present a system for
matching sprites (visuals) to very simple warioware-style mechanics. their system
is somewhat similar to game-o-matic, but works a bit differently: instead of the
designer specifying verbs and nouns she wants a game to be about, she gives the
system constraints on how verbs and nouns relate in the game (for example, a chas-
ing game needs a    prey    sprite that is something that can do things like       ee    or    be
hunted    and so on). the system then uses conceptnet7 and id1388 to generate
games that    t these constraints.

arguably one of the most elaborate examples of game generation is angelina
[135, 137, 136]. angelina9 is a game generator that has seen several develop-
ments over the years and is currently capable of evolving the rules and levels of the
game, collecting and placing pieces of visuals and music (that are relevant to the
theme and the emotive mood of the game), giving names for the games it creates
and even creating simple commentaries that characterize them. angelina is able
to generate games of different genres   including platformer games (see fig. 4.21)
and 3d adventure games   some of which have even participated in game design
competitions [136].

the systems above make some initial, yet important, steps towards game gener-
ation and they attempt to interweave the different domains within games in a mean-
ingful way, mostly in a hierarchical fashion. however, pcg eventually needs to
rise to the challenge of tackling the compound generation of multiple facets in an
orchestrated manner [711, 371]. an early study on the fusion of more than one
generative facet (domain) in games is the one performed recently by karavolos et
al. [324]. the study employs machine learning-based pcg to derive the common
generative space   or the common patterns   of game levels and weapons in    rst-
person shooters. the aim of this orchestration process between level design and
game design is the generation of level-weapon couplings that are balanced. the un-
known mapping between level representations and weapon parameters is learned by
a deep convolutional neural network which predicts if a given level with a particular
set of weapons will be balanced or not. balance is measured in terms of the win-lose
ratio obtained by ai bots playing in a deathmatch scenario. figure 4.22 illustrates
the architecture used to fuse the two domains. for the interested reader in the or-

7 http://conceptnet.io/
8 https://id138.princeton.edu/
9 http://www.gamesbyangelina.org/

196

chapter 4. generating content

fig. 4.21 angelina   s puzzling present game. the game features an invert gravity mechanic that
allows a player to overcome the high obstacle on the left and complete the level. image obtained
with permission from http://www.gamesbyangelina.org/.

fig. 4.22 a convolutional neural network (id98) architecture used for fusing levels and weapons
in    rst-person shooters. the network is trained to predict whether a combination of a level and a
weapon would yield a balanced game or not. the id98 can be used to orchestrate the generation
of a balanced level given a particular weapon and vice versa. image adapted from [324].

chestration process we further elaborate on the topic in the last chapter of this book;
some early discussions on this vision can also be found in [371].

2x100x100 pixels8x98x988x49x4916x47x4716x23x23401664game levelweaponsconvolutionmax-poolingmax-pooling32convolutionconvolution32x21x2132x10x10max-poolingadvantage 1st teambalancedadvantage 2nd team4.6. evaluating content generators

197

4.6 evaluating content generators

creating a generator is one thing; evaluating it is another. regardless of the method
followed all generators shall be evaluated on their ability to achieve the desired goals
of the designer. arguably, the generation of any content is trivial; the generation of
valuable content for the task at hand, on the other hand, is a rather challenging
procedure. (one may claim, however, that the very process of generating valuable
content is also, by itself, trivial as one can design a generator that returns a random
sample of hand-crafted masterpieces.) further, it is more challenging to generate
content that is not only valuable but is also novel or even inspiring.

4.6.1 why is it dif   cult?

but what makes the evaluation of content so dif   cult? first, it is the diverse, stochas-
tic and subjective nature of the users that experience the content. whether players or
designers, content users have dissimilar personalities, gameplay aims and behavior,
emotive responses, intents, styles and goals [378]. when designing a pcg system it
is critical to remember that we can potentially generate massive amounts of content
for designers to interact with and players to experience. it is thus of utmost impor-
tance to be able to evaluate how successful the outcomes of the generator might be
across dissimilar users: players and designers. while content generation is a cheap
process relying on algorithms, design and game-play are expensive tasks relying on
humans who cannot afford the experience of bad content. second, content quality
might be affected by algorithms and their underlying stochasticity, for instance, in
evolutionary search. content generators often exhibit non-deterministic behavior,
making it very hard to predict a priori what the outcomes of a particular generative
system might be.

4.6.2 function vs. aesthetics

particular properties of content can be objectively de   ned and tested whereas other
properties of it can only be assessed subjectively. it is only natural to expect that
functional properties of content quality can be objectively de   ned whereas a large
part of its aesthetics can only be de   ned subjectively. for instance, playability of
a level is a functional characteristic that can be objectively measured   e.g., an ai
agent manages to complete the level; hence it is playable. balance and symmetry
can also be objectively de   ned to a degree through estimates of deviation from a
norm   it may be a score (balance) or a distance from a central choke point in the
map (symmetry). there are games, however, for which content balance, symmetry
and other functional properties are not trivially measurable. and of course there are
several aspects of content such as the comprehensibility of a narrative, the pleas-

198

chapter 4. generating content

antnesses of a color scheme, the preference for a room   s architectural style or the
graphics style, and the experience of sound effects and music that are not objectively
measured.

functional, objectively de   ned, content properties can be expressed either as
metrics or as constraints that a generator needs to satisfy. constraints can be spec-
i   ed by the content designers or imposed by other game content already available.
for instance, let us assume that a well-designed generated strategy game level needs
to be both balanced and playable. playability can form a simple binary constraint:
the level is playable when an ai agent manages to complete it; it is non-playable oth-
erwise. balance can form another constraint by which all items, bases and resources
are accessible to similar degrees by all players; if equal accessibility is below a
threshold value then the constraint is not satis   ed. next, let us suppose we wish to
generate a new puzzle for the map we just generated. naturally, the puzzle needs
to be compatible with our level. a pcg algorithm needs to be able to satisfy these
constraints as part of its quality evaluation. constrained satisfaction algorithms such
as the feasible-infeasible two-population genetic algorithm [379, 382], constrained
divergent search rewarding content value but also content novelty [382] or surprise
[240], and constraint solvers such as answer set programming [638] are able to
handle this. the generated results are within constraints, thereby valuable for the
designer. value, however, may have varying degrees of success and this is where
alternative methods or heuristics can help, as we cover in the section below.

4.6.3 how can we evaluate a generator?

generally speaking, a content generator can be evaluated in three ways: directly
by the designer or indirectly by either human players or ai agents. designers can
directly observe properties of the content generator and take decisions based on data
visualization methods. human players can play and test the content and/or provide
feedback about the content via subjective reporting. ai agents can do the same: play
the content or measure something about the content and report it to us in the form
of a quality metric, or metrics. clearly, machines cannot experience the content
but they can, instead, simulate it and provide us estimates of content experience.
the overall evaluation process can very well combine and bene   t from any of the
above approaches. in the remainder of this section we cover the approaches of data
visualization, ai automated playtesting and human playtesting in further detail.

4.6.3.1 visualization

the visualization approach to content quality assessment is associated with a) the
computation of meaningful metrics that can assign measurable characteristics to
content and b) ways to visualize these metrics. the task of metric design can be
viewed as the equivalent of    tness function design. as such, designing good con-

4.6. evaluating content generators

199

fig. 4.23 the expressive range of the ropossum level generator for the metrics of linearity and
density. adapted from [608].

tent generation quality metrics in an ad-hoc manner involves a degree of practical
wisdom. metrics, for instance, can be based on the expressive range of the gener-
ator under assessment, so-called expressivity metrics [640, 608]. the analysis of a
generator   s expressivity gives us access to the potential overall quality of the gen-
erator across its full range of generative space. the generative space can then be
visualized as heatmaps or alternative graphical representations such as 2d or 3d
scatter plots (see fig. 4.23 for an example). it is one thing if a level generator is
able to create only a few meaningful or playable levels and another if the genera-
tor is robust and consistent with respect to the playability of its generated levels.
it is also one thing if our generator is only able to generate levels with very spe-
ci   c characteristics within a narrow space of its expressive range and another if our
level generator is able to express a broad spectrum of level properties, yielding uni-
formly covered expressive ranges. such information can be directly visible on the
illustrated heatmaps or scatter plots. alternatively, data compression methods can
be used directly on the generated content and offer us 2d or 3d representations of
the generative space, thereby, bypassing the limitations of ad-hoc metric design. an
example of this approach is the use of autoencoders for compressing the images
produced by the delenox autonomous content generator [373].

200

4.6.3.2 ai

chapter 4. generating content

using ai to playtest our generator is a safe and relatively cheap way to rapidly
retrieve quality metrics for it without relying on human playtesting. in the same
way that a search-based pcg method would use ai to simulate the content before
generating it, ai agents can test the potential of a generator across a number of
metrics and return us values about its quality. the metrics can be in the form of
classes   for instance, test checks performed for completing an area of a level   
scalar values   e.g., a level   s balance   or even ordinal values   e.g., the rank of the
level in terms of asymmetry. the relevance of the metrics to the generator   s quality
is obviously dependent on the designer   s ad-hoc decisions. once again, designing
appropriate metrics for our ai agent to compute is comparable to the challenge of
designing any utility function. an interesting approach to ai-based testing is the
use of procedural personas [267, 269]. these are data-driven inferred models of
dissimilar play styles that potentially imitate the different styles of human play. in
a sense, procedural personas provide a more human-realistic approach to ai-based
testing of a generator. finally, by visualizing particular game artifacts or simulating
them through the use of ai agents we can have access to the information we might be
able to extract from a game, we can understand what is possible within our content
space, we can infer how rules and functions operate in whatever we generate, and
we can possibly understand how the information we are able to extract relates to
data we can extract from human playtesting [481].

4.6.3.3 human players

in addition to data visualization and ai-based simulation for the evaluation of a con-
tent generator a designer might wish to use complementary approaches that rely on
quantitative user studies and playtesting. playtesting is regarded to be an expensive
way to test a generator but it can be of immense bene   t for content quality assurance,
in particular for those aspects of content that cannot be measured objectively   e.g.,
aesthetics and playing experience. the most obvious approach to evaluate the con-
tent experienced by players is to explicitly ask them about it. a game user study can
involve a small number of dedicated players that will play through various amounts
of content or, alternatively, a id104 approach can provide suf   cient data
to machine learn content evaluation functions (see [621, 370, 121] among others).
data obtained can be in any format including classes (e.g., a binary answer about the
quality of a level), scores (e.g., the likeliness of a sound) or ranks (e.g., a preference
about a particular level). it is important to note that the playtesting of content can
be complemented by annotations coming from the designers of the game or other
experts involved in content creation. in other words, our content generator may be
labeled with both    rst-person (player) and third-person (designer) annotations. fur-
ther guidelines about which questionnaire type to use and advice about the design
of user study protocols can be found in chapter 5.

4.8. exercises

4.7 further reading

201

extensive versions of most of the material covered in this chapter can be found
in dedicated chapters of the pcg in games textbook [616]. in particular, all the
methods and types of pcg in games are covered in further detail (see chapters 1 to
9 of [616]). considering the roles of pcg, the mixed-initiative and the experience-
driven role of pcg are, respectively, detailed in chapters 11 [374] and 10 [618]
of that textbook [616]. in addition to chapter 11 of [616] the framework named
mixed-initiative co-creativity [774] provides a theoretical grounding for the impact
of mixed-initiative interaction on the creativity of both designers and computational
processes. further, the original articles about the experience-driven pcg framework
can be found in [783, 784]. finally, the topic of pcg evaluation is covered also in
the    nal chapter [615] of the pcg in games textbook [616].

4.8 exercises

pcg offers endless opportunities for generation and evaluation across the different
creativity domains in games and across combinations of those. as an initial step
we would recommend the reader to start experimenting with maze generation and
platformer level generation (as outlined below). the website of the book contains
details regarding both frameworks and potential exercises.

4.8.1 maze generation

maze generation is a very popular type of level generation and relevant for several
game genres. in the    rst exercise we recommend that you develop a maze genera-
tor using both a constructive and a search-based pcg approach and compare their
performance according to a number of meaningful criteria that you will de   ne. the
reader may use the unity 3d open-access maze generation framework which is
available at: http://catlikecoding.com/unity/tutorials/maze/. further guidelines and
exercises for maze generation can be found at the book   s website.

4.8.2 platformer level generation

the platformer level generation framework is based on the in   nite mario bros (pers-
son, 2008) framework which has been used as the main framework of the mario ai
(and later platformer ai) competition since 2010. the competition featured several
different tracks including gameplay, learning, turing test and level generation. for
the exercises of this chapter the reader is requested to download the level generation

202

chapter 4. generating content

framework (https://sites.google.com/site/platformersai/) and apply constructive and
generate-and-test methods for the generation of platformer levels. the levels need to
be evaluated using one or more of the methods covered in this book. further details
and exercises with the platformer level generation framework can be found at the
book   s website.

4.9 summary

this chapter viewed ai as a means for generating content in games. we de   ned
procedural content generation as the algorithmic process of creating content in and
for games and we explored the various bene   ts of this process. we then provided a
general taxonomy about content and its generation and explored the various ways
one can generate content including search-based, solver-based, grammar-based, ma-
chine learning-based, and constructive generation methods. the use of the pcg
method is naturally dependent on the task at hand and the type of content one wishes
to generate. it further depends on the potential role the generator might take within
games. we outlined the four possible roles a generator can take in games which
are determined by the degree to which they involve the designer (autonomous vs.
mixed-initiative) and/or the player (experience-agnostic vs. experience-driven) in
the process. the chapter ends with a discussion on the important and rather un-
explored topic of evaluation, the challenges it brings, and a number of evaluation
approaches one might consider.

we have so far covered the most traditional use of ai in games (chapter 3) and
the use of ai for generating parts of (or complete) games (this chapter). the next
and    nal chapter of this part is dedicated to the player and the ways we can use ai
to model aspects of her behavior and her experience.

chapter 5
modeling players

this chapter is dedicated to players and the use of ai for modeling them. this area
of research is often called player modeling [782, 636]. we take player modeling to
mean the detection, prediction and expression of human player characteristics that
are manifested through cognitive, affective and behavioral patterns while playing
games. in the context of this book, player modeling studies primarily the use of ai
methods for the construction of computational models of players. by model we re-
fer to a mathematical representation   it may be a rule set, a vector of parameters,
or a set of probabilities   that captures the underlying function between the charac-
teristics of the player and her interaction with the game, and the player   s response to
that interaction. given that every game features at least one player (with some no-
table exceptions [50]), and that player modeling affects work on game-playing and
content generation, we consider the modeling of player behavior and experience as
a very important use of ai in games [764, 785].

psychology has studied human behavior, cognition and emotions for a long
time. branches of computer science and human-computer interaction that attempt
to model and simulate human behavior, cognition, emotion or the feeling of emo-
tion (affect) include the    elds of affective computing and user modeling. player
modeling is related to these    elds but focuses on the domain of games. notably,
games can yield dynamic and complex emotions in the player, the manifestations
of which cannot be captured trivially by standard methods in empirical psychol-
ogy, affective computing or cognitive modeling research. the high potential that
games have in affecting players is mainly due to their ability to place the player in a
continuous mode of interaction, which, in turn, elicits complex cognitive, affective
and behavioral responses. thus, the study of the player may not only contribute to
the design of improved forms of human-computer interaction, but also advance our
knowledge of human experiences.

as mentioned earlier, every game features at least one user   the player   who
controls some aspect of the game environment. the player character could be visible
in the game as an avatar or a group of entities [94], or could be invisible as in many
puzzle games and casual games. control may vary from the relatively simple (e.g.,
limited to movement in an orthogonal grid) to the highly complex (e.g., having

203

204

chapter 5. modeling players

to decide several times per second between hundreds of different possibilities in a
highly complex 3d world). given these intricacies, understanding and modeling the
interaction between the player and the game can be seen as a holy grail of game
design and development. designing the interaction and the emergent experience
right results in a successful game that manages to elicit unique experiences.

the interaction between the player(s) and the game is dynamic, real-time and
in many cases highly complex. the interaction is also rich in the sense that many
modalities of interaction may be involved and that the information exchange be-
tween the game and the player may both be fast and entail large amounts of data for
us to process. if the game is well-designed, the interaction is also highly engaging
for the player. given the great amount of information that can be extracted through
this interaction and used for creating models of the player, the game should be able
to learn much about the person playing it, as a player and perhaps as a human in
general. in fact, there is no reason why the model should not know more about how
you play than you do.

in the remainder of this chapter we    rst attempt to de   ne the core ingredients of
player modeling (section 5.1) and then we discuss reasons why ai should be used
to model players (section 5.2). in section 5.3 we provide a high-level taxonomy of
player modeling focusing on two core approaches for constructing a player model:
top-down and bottom-up. we then detail the available types of data for the model   s
input (section 5.4), a classi   cation for the model   s output (section 5.5) and the
various ai methods that are appropriate for the player modeling task (section 5.6).
the key components of player modeling as discussed in this chapter (input, output
and model) are depicted in fig. 5.1. we conclude, in section 5.7, with a number of
concrete examples of ai being used for modeling players.

5.1 what player modeling is and what it is not

one could arguably detect behavioral, emotional or cognitive aspects of both hu-
man players and non-human players, or non-player characters (notwithstanding the
actual existence of emotions in the latter). however, in this book we focus on as-
pects that can be detected from, modeled from, and expressed in games with human
players [782]. we explicitly exclude the modeling of npcs from our discussion in
this chapter, as in our de   nition, player modeling is modeling of a human player.
modeling the experience of an npc would seem to be a futile exercise, as one can
hardly say that an npc possesses actual emotions or cognition. modeling the be-
havior of an npc is also of little interest, at least if one has access to the game   s
code: a perfect model for the npc already exists. npc modeling, however, can be a
useful testbed for player modeling techniques, for instance, by comparing the model
derived from human players with the hand-crafted one. more interestingly, it can be
an integral component of ai that adapts its behavior in response to the dynamics of
the npcs   as in [28]. nevertheless, while the challenges faced in modeling npcs

5.1. what player modeling is and what it is not

205

fig. 5.1 the key components of player modeling as discussed in this chapter. the distinction be-
tween model-based and model-free approaches is outlined in section 5.3. the various options for
the input of the model are discussed in section 5.4. the taxonomy for the model   s output is dis-
cussed in section 5.5   each box represents a dedicated subsection. finally, the various ai methods
(supervised learning, id23 and unsupervised learning) used for modeling corre-
sponding output data types are discussed thoroughly in section 5.6.

are substantial, the issues raised from the modeling of human players de   ne a far
more complex and important problem for the understanding of player experience.

sometimes the terms player modeling and opponent modeling [214, 592, 48] are
used interchangeably when a human player is modeled. however, opponent mod-
eling is a more narrow concept referring to predicting behavior of an adversarial
player when playing to win in an imperfect information game like poker [48] or
starcraft (blizzard entertainment, 1988) [504]. some aspects of modeling npcs
or simulated playthroughs for winning in a game are discussed in chapter 3.

we also make a distinction between player modeling [116, 281] and player pro-
   ling [782]. the former refers to modeling complex dynamic phenomena during
gameplay interaction, whereas the latter refers to the categorization of players based
on static information that does not alter during gameplay. information of static na-
ture includes personality, cultural background, gender and age. we put an emphasis
on the former, but will not ignore the latter, as the availability of a good player
pro   le may contribute to the construction of reliable player models.

206

chapter 5. modeling players

in summary, player modeling   as we de   ne it in this book   is the study of com-
putational means for the modeling of a player   s experience or behavior which is
based on theoretical frameworks about player experience and/or data derived from
the interaction of the player with a game [782, 764]. player models are built on dy-
namic information obtained during game-player interaction, but they could also rely
on static player pro   ling information. unlike studies focusing on taxonomies of be-
havioral player modeling   e.g., via a number of dimensions [636] or direct/indirect
measurements [623]   we view player modeling in a holistic manner including cog-
nitive, affective, personality and demographic aspects of the player. moreover, we
exclude approaches that are not directly based on human-generated data or not based
on empirically-evaluated theories of player experience, human cognition, affect or
behavior. the chapter does not intend to provide an exhaustive review of player
modeling studies under the above de   nition, but rather an introduction and a high-
level taxonomy that explores the possibilities with respect to the modeling approach,
the model   s input and the model   s output.

5.2 why model players?

the primary goal of player modeling is to understand how the interaction with a
game is experienced by individual players. thus, while games can be utilized as
an arena for eliciting, evaluating, expressing and even synthesizing experience, we
argue that the main aim of the study of players in games is the understanding of
players    cognitive, affective and behavioral patterns. indeed, by the very nature of
games, one cannot dissociate games from player experience.

there are two core reasons that drive the use of ai for modeling game play-
ers and their play, thereby serving the primary goal of player modeling as stated
above. the    rst is for understanding something about their players    experience dur-
ing play. models of player experience are often built using machine learning meth-
ods, typically supervised learning methods like support vector machines or neural
networks. the training data here consists of some aspect of the game or player-game
interaction, and the targets are labels derived from some assessment of player ex-
perience, gathered for example from physiological measurements or questionnaires
[781]. once predictors of player experience are derived they can be taken into ac-
count for designing the in-game experience. that can be achieved by adjusting the
behavior of non-player characters (see chapter 3) or by adjusting the game environ-
ment (see chapter 4).

the second reason why one would want to use ai to model players is for under-
standing players    behavior in the game. this area of player modeling is concerned
with structuring observed player behavior even when no measures of experience are
available   for instance, by identifying player types or predicting player behavior via
game and player analytics [178, 186]. a popular distinction in data derived from
games [186] is the one between player metrics and game metrics. the latter is a
superset of the former as it also includes metrics about the game software (system

5.3. a high-level taxonomy of approaches

207

metrics) and the game development process as a whole (process metrics). system
metrics and process metrics are important aspects of modern game development that
in   uence decision making with respect to procedures, business models, and market-
ing. in this book, however, we focus on player metrics. the interested reader may
refer to [186] for alternative uses of metrics in games and the application of analytics
to game development and research   i.e., game analytics.

once aspects of player behavior are identi   ed a number of actions can be taken
to improve the game such as the personalization of content, the adjustment of npcs
or, ultimately, the redesign of (parts of) the game. derived knowledge about the
in-game behavior of the player can lead to improved game testing and game design
procedures, and better monetization and marketing strategies [186]. within behavior
modeling we identify four main player modeling subtasks that are particularly rel-
evant for game ai: imitation and prediction   achieved via supervised learning or
id23   and id91 and association mining   achieved via un-
supervised learning. the two main purposes of player imitation is the development
of non-player characters with believable, human-like behavioral characteristics, and
the understanding of human play per se through creating generative models of it.
the prediction of aspects of player behavior, instead, may provide answers to ques-
tions such as    when will this player stop playing?    or    how often will that player
get stuck in that area of the level?    or    which item type will this player pick in the
next room?   . the aim of id91 is the classi   cation of player behaviors within a
number of clusters depending of their behavioral attributes. id91 is important
for both the personalization of the game and the understanding of playing behavior
in association with the game design [178]. finally, association mining is useful in
instances where frequent patterns or sequences of actions (or in-game events) are
important for determining how a player behaves in a game.

while player behavior and player experience are interwoven notions there is a
subtle difference between them. player behavior points to what a player does in
a game whereas player experience refers to how a player feels during play. the
feeling of one   s gameplay experience is clearly associated with what one does in
the game; player experience, however, is primarily concerned with affective and
cognitive aspects of play as opposed to mere reactions of gameplay which refer to
player behavior.

given the above aims, core tasks and sub-tasks of player modeling in the next

section we discuss the various available options for constructing a player model.

5.3 a high-level taxonomy of approaches

irrespective of the application domain, computational models are characterized by
three core components: the input the model will consider, the computational model
per se, and the output of the model (see fig. 5.1). the model itself is a mapping
between the input and the output. the mapping is either hand-crafted or derived
from data, or a mix of the two. in this section we will    rst go through the most

208

chapter 5. modeling players

common approaches for constructing a computational model of players, then we
will go through a taxonomy of possible inputs for a player model (section 5.4)
and    nally we will examine aspects of player experience and behavior that a player
model can represent as its output (section 5.5).

a high-level classi   cation of the available approaches for player modeling can
be made between model-based (or top-down) and model-free (or bottom-up) ap-
proaches [782, 783]. the above de   nitions are inspired by the analogous classi-
   cation in rl by which a world model is available (i.e., model-based) or not (i.e.,
model-free). given the two ends of this continuum hybrid approaches between them
can naturally exist. the gradient red color of the player model box in fig. 5.1 illus-
trates the continuum between top-down and bottom-up approaches. the remainder
of this section presents the key elements of and core differences among the various
approaches for modeling of players.

5.3.1 model-based (top-down) approaches

in a model-based or top-down [782] approach a player model is built on a theoret-
ical framework. as such, researchers follow the modus operandi of the humanities
and social sciences, which hypothesize models to explain phenomena. such hy-
potheses are usually followed by an empirical phase in which it is experimentally
determined to what extent the hypothesized models    t observations; however, such
a practice is not the norm within player experience research. while user experience
has been studied extensively across several disciplines, in this book we identify three
main disciplines we can borrow theoretical frameworks from and build models of
player experience: psychology and affective sciences, neuroscience, and    nally,
game studies and game research.

5.3.1.1 psychology and affective sciences

top-down approaches to player modeling may refer to models derived from popu-
lar theories about emotion [364] such as the cognitive appraisal theory [212, 601].
further, the player model may rely on well established affect representations such
as the emotional dimensions of arousal and valence [200] that de   ne the circumplex
model of affect of russell [539] (see fig. 5.2(a)). valence refers to how pleasur-
able (positive) or unpleasurable (negative) the emotion is whereas arousal refers to
how intense (active) or lethargic (inactive) that emotion is. following a theoretical
model, emotional manifestations of players are often mapped directly to speci   c
player states. for instance, by viewing player experience as a psychophysiological
phenomenon [779] a player   s increased heart rate may correspond to high arousal
and, in turn, to high levels of excitement or frustration.

beyond established theories of emotion, model-based approaches can also be in-
spired by a general cognitive-behavioral theoretical framework such as the theory

5.3. a high-level taxonomy of approaches

209

of mind [540] for modeling aspects of social interactions in games. popular ex-
ample frameworks for deriving user models in games include the usability theory
[489, 290], the belief-desire-intention (bdi) model [66, 224], the cognitive model
by ortony, clore, and collins [512] and skinner   s behavioristic approach [633] with
its links to reward systems in games. further we can draw inspiration from social
sciences and linguistics in order to model lexical aspects of gameplay interaction
(e.g., chatting). natural language processing, opinion mining and id31
are normally relying on theoretical models that build on affective and sociological
aspects of textual communication [517, 514].

of particular importance is the concept of    ow by csikszentmihalyi [151, 149,
150] which has been a popular psychological construct for modeling player experi-
ence in a top-down fashion. when in a state of    ow (or else, state of    happiness   )
during an activity we tend to concentrate on the present moment, we lose our ability
of re   ective self-consciousness, we feel a sense of personal control over the sit-
uation or activity, our perception of time is altered, and we experience the activity
as intrinsically rewarding. analogously the optimal experience during play has been
associated with a    ne balance between boredom and anxiety, also known as the    ow
channel (see fig. 5.2(b)). given its direct relevance to player experience,    ow has
been adapted and incorporated for use in game design and for the understanding of
player experience [678, 675, 473].

5.3.1.2 neuroscience

a number of studies have relied on the working hypothesis of an underlying map-
ping between the brain, its neural activity and player experience. however, this re-
lationship is not well explored and the presumptive mapping is largely unknown.
for example, interest has been associated with activity in the visual cortex and
the release of endomorphin whereas the sense of achievement has been linked to
dopamine levels [35]. according to [35], neuroscienti   c evidence suggests that the
reward systems of games are directly associated with the dopamine-based reward
structures in the brain and that dopamine is released during gameplay [346]. fur-
ther, pleasure has been associated with areas in the brain responsible for decision
making, thereby revealing the direct links between gameplay experience and deci-
sion making [575]. pleasure has also been associated with uncertain outcomes or
uncertain rewards [625] as well as with interest and curiosity [43], which are all key
elements of successful game design. stress is also tightly coupled with player expe-
rience given its clear association with anxiety and fear; stress can be both monitored
via physiology and regulated via game design. the testosterone levels of players
have also been measured in association to digital game activities [444] and    ndings
reveal particular patters of competition in games as testosterone factors. finally, it
appears that trust between players in a social gaming setup could be measured indi-
rectly via oxytocin levels [350].

the degree to which current    ndings from neuroscience are applicable to player
experience research is largely unknown since access to neural activity and brain hor-

210

chapter 5. modeling players

(a) russell   s two-dimensional circumplex model of affect. the    gure contains a small number
of representative affective states (black circles).

(b) an illustration of the    ow channel.

fig. 5.2 two popular frameworks used for modeling users and their experience in games: (a) the
arousal-valence circumplex model of affect and (b) the    ow channel concept.

5.3. a high-level taxonomy of approaches

211

mone levels remains a rather intrusive process at the time of writing. manifestations
of brain activity such as the brain   s electrical waves   measured through electroen-
cephalography on our scalp   or more indirect manifestations such as stress and
anxiety   measured through skin conductance   can give us access to approximates
of brain activity. these approximates can be used for modeling the experience of
play as discussed later in this chapter.

5.3.1.3 game studies and game research

theoretical models of user experience in games are often driven by work in game
studies and game research. examples of models that have been used extensively in
the literature include malone   s core design dimensions that collectively contribute
to    fun    games [419] de   ned as challenge, curiosity and fantasy. in particular,
challenge refers to the uncertainty of achieving a goal due to e.g., variable dif   culty
level, multiple level goals, hidden information, and randomness. curiosity refers to
the player   s feeling of uncertainty with respect to what will happen next. finally,
fantasy is the ability of the game to show (or evoke) situations or contexts that are
not actually present. these three dimensions have been quanti   ed, operationalized
and successfully evaluated in prey-predator games [766], physical games [769, 775],
preschooler games [320] and racing games [703].

bartle   s [33] classi   cation of player types within games as a form of general
player pro   les can be used indirectly for modeling players. bartle identi   es four
archetypes of players he names killers (i.e., players that focus on winning and are
engaged by ranks and leaderboards), achievers (i.e., players that focus on achieving
goals quickly and are engaged by achievements), socializers (i.e., players that focus
on social aspects of games such as developing a network of friends) and explorers
(i.e., players who focus on the exploration of the unknown). various other method-
ologies have also been followed to derive speci   c player experience archetypes for
particular classes of games [34, 787].

other popular and interconnected views of player experience from a game design
perspective include the theory of    fun    by koster [351], the notion of the    magic
circle    in games [587] and the four    fun    factor model of lazzaro [365]. indicatively,
koster   s theory relates the concept of fun with learning in games: the more you learn
the more you tend to play a game. according to his theory you stop playing a game
that is way too easy (no learning of new skills) or way too hard (no learning either).
lazzaro   s four fun factors are named hard fun (e.g., playing to win and see how
good i am at it), easy fun (e.g., playing to explore new worlds and game spaces),
serious fun (e.g., playing to feel better about myself or get better at something that
matters to me) and people fun (e.g., playing as an excuse to invite friends over,
or having fun merely by watching them play). within game studies, the theoretical
model of incorporation [94] is a notable multifaceted approach for capturing player
immersion. the model is composed of six types of player involvement: affective,
kinaesthetic, spatial, shared, ludic, and narrative.

212

chapter 5. modeling players

with a careful analysis of the models proposed and their subcomponents one
could coherently argue that there is one underlying theoretical model of player ex-
perience after all. while it is not the intention of this book to thoroughly discuss the
interconnections between the aforementioned models it is worth pointing out a num-
ber of indicative examples of our envisaged overarching player experience model.
an explorer (bartle), for instance, can be associated with the easy fun factor of laz-
zaro and the curiosity dimension of malone. further, the achiever archetype (bartle)
can be linked to the serious fun factor (lazzaro). accordingly, a killer archetype
(bartle) maps to the hard fun factor (lazzaro), the challenge dimension of malone   s
model, and a number of    ow aspects. finally, a socializer player pro   le (bartle)
could be associated to people fun (lazzaro) and, in turn, to the shared involvement
facet of calleja [94].

even though the literature on theoretical models of experience is rather rich, one
needs to be cautious with the application of such theories to games (and game play-
ers) as the majority of the models have not been derived from or tested on interactive
media such as games. calleja [94], for instance, re   ects on the inappropriateness of
the concepts of    fun    and    magic circle    (among others) for games. at this point it
is worth noting that while ad-hoc designed models can be an extremely powerful
and expressive they need to be cross-validated empirically to be of practical use for
computational player modeling; however, such practices are not as common within
the broader area of game studies and game design.

5.3.2 model-free (bottom-up) approaches

model-free approaches refer to the data-driven construction of an unknown map-
ping (model) between a player input and a player state. any manifestation of
player affect or behavioral pattern could de   ne the input of the model (see more
in section 5.4 below). a player state, on the other hand, is any representation of the
player   s experience or current emotional, cognitive, or behavioral state; this is es-
sentially the output of the computational model (see more in section 5.5). evidently,
model-free approaches follow the modus operandi of the exact sciences, in which
observations are collected and analyzed to generate models without a strong initial
assumption on what the model looks like or even what it captures. player data and
labels of player states are collected and used to derive the model.

classi   cation, regression and preference learning techniques adopted from ma-
chine learning   see chapter 2   or statistical approaches are commonly used for the
construction of the mapping between the input and the output. examples include
studies in which player actions, goals and intentions are modeled and predicted for
the purpose of believable gameplay, adaptive gameplay, interactive storytelling or
even the improvement of a game   s monetization strategy [511, 800, 414, 693, 592].
in contrast to supervised learning, id23 can be applied when a re-
ward function, instead, can characterize aspects of playing behavior or experience.
unsupervised learning is applicable when target outputs are not available for pre-

5.4. what is the model   s input like?

213

dictive purposes but, alternatively, data is used for the analysis of playing behavior
(see fig. 5.1).

we meet bottom-up player modeling attempts since the early years of the game
ai    eld in    rst-person shooters [695, 696], racing games [703] and variants of pac-
man (namco, 1980) [776]. recently, the availability of large sets of game and player
data has opened up the horizons of behavioral data mining in games   i.e., game
data mining [178]. studies that attempt to identify different behavioral, playing
and action patterns within a game are well summarized in [186] and include [36,
176, 687, 690, 750], among many others.

5.3.3 hybrids

the space between a completely model-based and a completely model-free ap-
proach can be viewed as a continuum along which any player modeling approach
might be placed. while a completely model-based approach relies solely on a the-
oretical framework that maps a player   s responses to game stimuli, a completely
model-free approach assumes there is an unknown function between modalities of
user input and player states that a machine learner (or a statistical model) may dis-
cover, but does not assume anything about the structure of this function. relative
to these extremes, the vast majority of studies in player modeling may be viewed
as hybrids that synergistically combine elements of the two approaches. the con-
tinuum between top-down and bottom-up player modeling approaches is illustrated
with a gradient color in fig. 5.1.

5.4 what is the model   s input like?

by now we have covered the various approaches available for modeling players
and we will, in this section, focus on what the input of such a model might be
like. the model   s input can be of three main types: (1) anything that a player is
doing in a game environment gathered from gameplay data   i.e., behavioral data
of any type such as user interface selections, preferences, or in-game actions; (2)
objective data collected as responses to game stimuli such as physiology, speech
and body movements; and (3) the game context which comprises of any player-
agent interactions but also any type of game content viewed, played, and/or created.
the three input types are detailed in the remainder of this section. at the end of the
section we also discuss static pro   le information on the player (such as personality)
as well as web data beyond games that could feed and enhance the capacity of a
player model.

214

5.4.1 gameplay

chapter 5. modeling players

given that games may affect the player   s cognitive processing patterns and cogni-
tive focus we assume that a player   s actions and preferences are linked directly to
her experience. consequently, one may infer the player   s current experience by an-
alyzing patterns of her interaction with the game, and by associating her experience
with game context variables [132, 239]. any element derived from the direct inter-
action between the player and the game can be classi   ed as gameplay input. these
interpretable measures of gameplay have also been de   ned as player metrics [186].
player metrics include detailed attributes of the player   s behavior derived from re-
sponses to game elements such as npcs, game levels, user menus, or embodied
conversational agents. popular examples of data attributes include detailed spatial
locations of players viewed as heatmaps [177], statistics on the use of in-game
menus, as well as descriptive statistics about gameplay, and communication with
other players. figure 5.3 shows examples of heatmaps in the minidungeons1 puzzle
game. both general measures (such as performance and time spent on a task) and
game-speci   c measures (such as the weapons selected in a shooter game [250]) are
relevant and appropriate player metrics.

a major limitation with the gameplay input is that the actual player experience
is only indirectly observed. for instance, a player who has little interaction with a
game might be thoughtful and captivated, or just bored and busy doing something
else. gameplay metrics can only be used to approach the likelihood of the presence
of certain player experiences. such statistics may hold for player populations, but
may provide little information for individual players. therefore, when one attempts
to use pure player metrics to make estimates of player experiences and make the
game respond in an appropriate manner to these perceived experiences, it is advis-
able to keep track of the feedback of the player to the game responses, and adapt
when the feedback indicates that the player experience was gauged incorrectly.

5.4.2 objective

computer game players are presented with a wide palette of affective stimuli dur-
ing game play. those stimuli vary from simple auditory and visual events (such
as sound effects and textures) to complex narrative structures, virtual cinemato-
graphic views of the game world and emotively expressive game agents. player
emotional responses may, in turn, cause changes in the player   s physiology, re   ect
on the player   s facial expression, posture and speech, and alter the player   s attention
and focus level. monitoring such bodily alterations may assist in recognizing and
constructing the player   s model. as such, the objective approach to player model-
ing incorporates access to multiple modalities of player input.

1 http://minidungeons.com/

5.4. what is the model   s input like?

215

(a) in this example the player acts as a com-
pletionist: succeeding in killing all monsters,
drinking all potions and collecting all treasure.

(b) in this example the player prioritizes reach-
ing the exit, avoiding any monsters and only
collecting potions and treasures that are near
the path to the exit.

fig. 5.3 two example heatmaps (human playtraces) in the minidungeons game. minidungeons is
a simple turn-based rogue-like puzzle game, implemented as a benchmark problem for modeling
the decision-making styles of human players [267].

the relationship between psychology and its physiological manifestations has
been studied extensively ([17, 95, 779, 558] among many others). what is widely
evidenced is that the sympathetic and the parasympathetic components of the au-
tonomic nervous system are involuntary affected by affective stimuli. in general,
arousal-intense events cause dynamic changes in both nervous systems: an increase
and a decrease of activity, respectively, in the sympathetic and the parasympathetic
nervous system. alternatively, activity at the parasympathetic nervous system is
high during relaxing or resting states. as mentioned above, such nervous system
activities cause alterations in one   s facial expression, head pose, electrodermal ac-
tivity, heart rate variability, blood pressure, pupil dilation [91, 624] and so on.

recent years have seen a signi   cant volume of studies that explore the interplay
between physiology and gameplay by investigating the impact of different game-
play stimuli on dissimilar physiological signals ([697, 473, 421, 420, 556, 721, 175,
451] among others). such signals are usually obtained through electrocardiogra-
phy (ecg) [780], photoplethysmography [780, 721], galvanic skin response (gsr)
[421, 271, 270, 272], respiration [721], electroencephalography (eeg) [493] and
electromyography (emg).

in addition to physiology one may track the player   s bodily expressions (mo-
tion tracking) at different levels of detail and infer the real-time affective responses
from the gameplay stimuli. the core assumption of such input modalities is that
particular bodily expressions are linked to expressed emotions and cognitive pro-
cesses. objective input modalities, beyond physiology, that have been explored ex-

216

chapter 5. modeling players

tensively include facial expressions [321, 19, 236, 88, 794], muscle activation (typ-
ically face) [133, 164], body movement and posture [23, 731, 321, 172, 47], speech
[741, 319, 308, 306, 30], text [517, 137, 391], haptics [509], gestures [283], brain
waves [559, 13], and eye movement [23, 469].

while objective measurements can be a very informative way of assessing the
player   s state during the game a major limitation with most of them is that they can
be invasive, thus affecting the player   s experience with the game. in fact, some types
of objective measures appear to be implausible within commercial-standard game
development. pupillometry and gaze tracking, for instance, are very sensitive to
distance from screen, and variations in light and screen luminance, which collec-
tively make them rather impractical for use in a game application. the recent rebirth
of virtual reality (vr), however, gives eye gaze sensing technologies entirely new
opportunities and use within games [628]; a notable example of a vr headset that
features eye-tracking is fove.2 other visual cues obtained through a camera (facial
expressions, body posture and eye movement) require a well-lit environment which
is often not present in home settings (e.g., when playing video-games) and they can
be seen by some players as privacy hazards (as the user is continuously recorded).
even though highly unobtrusive, the majority of the vision-based affect-detection
systems currently available have additional limitations when asked to operate in
real-time [794]. we argue that an exception to this rule is body posture, which can
both be effectively detected nowadays and provide us with meaningful estimates
of player experience [343]. aside from the potential they might have, however, the
appropriateness of camera-based input modalities for games is questionable since
experienced players tend to stay still while playing games [22].

as a response to the limitations of camera-based measurements, speech and text
(e.g., chat) offer two highly accessible, real-time ef   cient and unobtrusive modali-
ties with great potential for gaming applications; however, they are only applicable
to games where speech (or text) forms a control modality (as e.g., in conversational
games for children [320, 789]), collaborative games that naturally rely on speech
or text for communication across players (e.g., in collaborative    rst-person shoot-
ers), or games that rely on natural language processing such as text-based adventure
games or interactive    ction (see discussion of chapter 4).

within players    physiology, existing hardware for eeg, respiration and emg
require the placement of body parts such as the head, the chest or parts of the face
on the sensors, making those physiological signals rather impractical and highly in-
trusive for most games. on the contrary, recent sensor technology advancements for
the measurement of electrodermal activity (skin conductivity), photoplethysmogra-
phy (blood volume pulse), heart rate variability and skin temperature have made
those physiological signals more attractive for the study of affect in games. real-
time recordings of these can nowadays be obtained via comfortable wristbands and
stored in a personal computer or a mobile device via a wireless connection [779].

at the moment of writing there are a few examples of commercial games that
utilize physiological input from players. one particularly interesting example is

2 https://www.getfove.com/

5.4. what is the model   s input like?

217

fig. 5.4 a screenshot from nevermind (flying mollusk, 2015). the game supports several off-
the-shelf sensors that allow the audiovisual content of the game to adapt to the stress levels of the
player. image obtained from erin reynolds with permission.

nevermind (flying mollusk, 2015), a biofeedback-enhanced adventure horror game
that adapts to the player   s stress levels by increasing the level of challenge it pro-
vides: the higher the stress the more the challenge for the player (see fig. 5.4). a
number of sensors which detect heart activity are available for affective interac-
tion with nevermind. the journey of wild divine (wild divine, 2001) is another
biofeedback-based game designed to teach relaxation exercises via the player   s
blood volume pulse and skin conductance. it is also worth noting that aaa game
developers such as valve have experimented with the player   s physiological input
for the personalization of games such as left 4 dead (valve, 2008) [14].

5.4.3 game context

in addition to gameplay and objective input, the game   s context is a necessary input
for player modeling. game context refers to the momentanous state of the game
during play and excludes any gameplay elements; those are already discussed in
the gameplay input section. clearly, our gameplay affects some aspects of the game
context and vice versa but the two can be viewed as separate entities. viewing this
relationship from an analytics lens, the game context can be seen as a form of game
metrics, opposed to gameplay which is a form of player metrics.

the importance of the game context for modeling players is obvious. in fact, we
could argue that the context of the game during the interaction is a necessary input
for detecting reliably any cognitive and affective responses of players. it could also

218

chapter 5. modeling players

be argued that the game context is necessary as a guide during the annotation of the
player experience; but more of that we will discuss in section 5.5. the same way
that we require the current social and cultural context to better detect the under-
lying emotional state of a particular facial expression of our discussant any player
reactions cannot be dissociated from the stimulus (or the game context) that elicited
them. naturally, player states are always linked to game context. as a result, player
models that do not take context into account run a risk of inferring erroneous states
for the player. for example, an increase in galvanic skin response can be linked to
different high-arousal affective states such as frustration and excitement. it is very
hard to tell however, what the heightened galvanic skin response    means    without
knowing what is happening in the game at the moment. in another example, a partic-
ular facial expression of the player, recorded though a camera, could be associated
with either an achievement in the game or a challenging moment, and needs to be
triangulated with the current game state to be understood. evidently, such dualities
of the underlying player state may be detrimental for the design of the player model.
while a few studies have investigated physiological reactions of players in isola-
tion, good practice in player modeling commands that any reactions of the play-
ers is triangulated with information about the current game state. for instance,
the model needs to know if the gsr increases because the player died or com-
pleted the level. the game context   naturally combined (or fused) with other in-
put modalities from the player   has been used extensively in the literature for the
prediction of different affective and cognitive states relevant to playing experience
[451, 434, 521, 617, 572, 133, 254, 558, 452, 433].

5.4.4 player pro   le

a player pro   le includes all the information about the player which is static and it
is not directly (nor necessarily) linked to gameplay. this may include information
on player personality (such as expressed by the five factor model of personality
[140, 449]), culture dependent factors, and general demographics such as gender
and age. a player   s pro   le may be used as input to the player model to comple-
ment the captured in-game behavior with general attributes about the player. such
information may lead to more precise predictive models about players.

while gender, age [787, 686], nationality [46] and player expertise level [96]
have already proven important factors for pro   ling players the role of personality
remains somewhat contentious. on the one hand, the    ndings of van lankveld et al.
[736, 737], for instance, reveal that gameplay behavior does not necessarily corre-
spond to a player   s behavior beyond the game. on the other hand, yee et al. have
identi   ed strong correlations between player choices in world of warcraft (blizzard
entertainment, 2004) and the personalities of its players [788]. strong correlations
have also been found between the playing style and personality in the    rst-person
shooter battle   eld 3 (electronic arts, 2011) [687]. in general, we need to acknowl-
edge that there is no guaranteed one-to-one mapping between a player   s in-game

5.5. what is the model   s output like?

219

behavior and personality, and that a player   s personality pro   le does not necessarily
indicate what the player would prefer or like in a game [782].

5.4.5 linked data

somewhere between the highly dynamic in-game behavior and the static pro   le in-
formation about the player we may also consider linked data retrieved from web
services that are not associated with gameplay per se. this data, for instance, may
include our social media posts, emoticons, emojis [199], tags used, places visited,
game reviews written, or any relevant semantic information extracted from diverse
web content. the bene   t of adding such information to player models is many-
fold but it has so far seen limited use in games [32]. in contrast to current player
modeling approaches the use of massive amounts and dissimilar types of content
across linked online sources would enable the design of player models which are
based on user information stored across various online datasets, thereby realizing
semantically-enriched game experiences. for example, both scores and sentiment-
analyzed textual reviews [517, 514] from game review sites such as metacritic3 or
gamerankings4 can be used as input to a model. this model can then be used to
create game content which is expected to appeal to the speci   c parts of the com-
munity, based, for instance, on demographics, skill or interests collected from the
user   s in-game achievements or favored games [585].

5.5 what is the model   s output like?

the model   s output, i.e., that which we wish to model, is usually a representation of
the player   s state. in this section we explore three options for the output of the model
that serve different purposes in player modeling. if we wish to model the experi-
ence of the player the output is provided predominately through manual annotation.
if instead we wish to model aspects of player behavior the output is predominately
based on in-game actions (see fig. 5.1). finally, it may very well be that the model
has no output. section 5.5.1 and section 5.5.2 discuss the particularities of the out-
put, respectively, for the purpose of behavioral modeling and experience modeling
whereas section 5.5.3 explores the condition where the model has no outputs.

3 http://www.metacritic.com
4 http://www.gamerankings.com/

220

chapter 5. modeling players

5.5.1 modeling behavior

the task of modeling player behavior refers to the prediction or imitation of a partic-
ular behavioral state or a set of states. note that if no target outputs are available then
we are faced with either an unsupervised learning problem or a reinforcement learn-
ing problem which we discuss in section 5.5.3. the output we must learn to predict
(or imitate) in a supervised learning manner can be of two major types of game-
play data: either micro-actions or macro-actions (see fig. 5.1). the    rst machine
learning problem considers the moment-to-moment game state and player action
space that are available at a frequency of frame rates. for example, we can learn
to imitate the moves of a player on a frame-to-frame basis by comparing the play
traces of an ai agent and a human as e.g., done for super mario bros (nintendo,
1985) [511, 469]. when macro-actions are considered instead, the target output is
normally an aggregated feature of player behavior over time, or a behavioral pat-
tern. examples of such outputs include game completion times, win rates, churn,
trajectories, and game balance.

5.5.2 modeling experience

to model the experience of the player one needs to have access to labels of that
experience. those labels ideally need to be as close to the ground truth of expe-
rience as possible. the ground truth (or gold standard) in affective sciences refers
to a hypothesized and unknown label, value, or function, that best characterizes and
represents an affective construct or an experience. labels are normally provided
through manual annotation which is a rather laborious process. manual annotation
is however necessary given that we require some estimate of the ground truth for
subjective notions such as the emotional states of the player. the accuracy of that
estimation is regularly questioned as there are numerous factors contributing to a
deviation between a label and the actual underlying player experience.

manually annotating players and their gameplay is a challenge in its own right
with respect to both the human annotators involved and the annotation protocol cho-
sen [455, 777]. on one hand, the annotators need to be skilled enough to be able to
approximate the actual experience well. on the other hand, there are still many open
questions left for us to address when it comes to the annotation tools and protocols
used. such questions include: who will do the labeling: the person experiencing
the gameplay or others? will the labeling of player experience involve states (dis-
crete representation) or instead involve the use of intensity or experience dimensions
(continuous representation)? when it comes to time, should it be done in real-time
or of   ine, in discrete time periods or continuously? should the annotators be asked
to rate the affect in an absolute fashion or, instead, rank it in a relative fashion?
answers to the above questions yield different data annotation protocols and, in-
evitably, varying degrees of data quality, validity and reliability. in the following

5.5. what is the model   s output like?

221

sections we attempt to address a number of such critical questions that are usually
raised in subjective annotations of player states.

5.5.2.1 free response or forced response?

subjective player state annotations can be based either on a player   s free response   
retrieved via e.g., a think-aloud protocol [555]   or on forced responses retrieved
through questionnaires or annotation tools. free response naturally contains richer
information about the player   s state, but it is often unstructured, even chaotic, and
thus hard to analyze appropriately. on the other hand, forcing players to self-report
their experiences using directed questions or tasks constrains them to speci   c ques-
tionnaire items which could vary from simple tick boxes to multiple choice items.
both the questions and the answers we provide to annotators may vary from single
words to sentences. questionnaires can contain elements of player experience (e.g.,
the game experience questionnaire [286]), demographic data and/or personality
traits (e.g., a validated psychological pro   ling questionnaire such as the neo-pi-r
[140]). in the remainder of this section we will focus on forced responses as these
are easier to analyze and are far more appropriate for data analysis and player mod-
eling (as de   ned in this book).

5.5.2.2 who annotates?

given the subjective nature of player experience the    rst natural question that comes
in mind is who annotates players? in other words, who has the right authority and
the best capacity to provide us with reliable tags of player experience? we dis-
tinguish two main categories: annotations can either be self-reports or reports ex-
pressed indirectly by experts or external observers [783].

in the    rst category the player states are provided by the players themselves and
we call that    rst-person annotation. for example, a player is asked to rate the level
of engagement while watching her playthrough video. first-person is clearly the
most direct way to annotate a player state and build a model based on the solicited
annotations. we can only assume there is disparity between the true (inner) expe-
rience of each player and the experience as felt by herself or perceived by others.
based on this assumption the player   s annotations should normally be closer to her
inner experience (ground truth) compared to third-person annotation. first-person
annotation, however, may suffer from self-deception and memory limitations [778].
these limitations have been attributed mainly to the discrepancies between    the ex-
periencing self    and    the remembering self    of a person [318] which is also known
as the memory-experience gap [462].

expert annotators   as a response to the above limitations   may instead be able
to surpass the perception of experience and reach out to the inner experience of
the player. in this second annotation category, named third-person annotation, an
expert   such as a game designer   or an external observer provides the player state

222

chapter 5. modeling players

in a more objective manner, thereby reducing the subjective biases of    rst-person
perceptions. for instance, a user experience analyst may provide particular player
state tags while observing a    rst-person shooter deathmatch game. the bene   t of
third-person annotation is that multiple annotators can be used for a particular game-
play experience. in fact, the availability of several such subjective perceptions of
experience may allow us to approximate the ground truth better as the agreement
between many annotators enhances the validity of our data directly. a potential
disagreement, on the other hand, might suggest that the gameplay experience we
examine is non-trivial or may indicate that some of our annotators are untrained or
inexperienced.

5.5.2.3 how is player experience represented?

another key question is how player experience is best represented: as a number of
different states (discrete) or, alternatively, as a set of dimensions (continuous)? on
one hand, discrete labeling is practical as a means of representing player experience
since the labels can easily form individual items (e.g.,    excited   ,    annoyed    etc.) in
an experience questionnaire, making it easy to ask the annotator/player to pick one
(e.g., in [621]). continuous labeling, on the other hand, appears to be advantageous
for two key reasons. first, experiential states such as immersion are hard to capture
with words or linguistic expressions that have fuzzy boundaries. second, states do
not allow for variations in experience intensity over time since they are binary: ei-
ther the state is present or not. for example, the complex notions of fun, or even
engagement, cannot be easily captured by their corresponding linguistic represen-
tation in a questionnaire or de   ne well a particular state of a playing experience.
instead it seems natural to represent them as a continuum of experience intensity
that may vary over time. for these reasons we often observe low agreement among
the annotators [143] when we represent playing experience via discrete states.

as discussed earlier, the dominant approach in continuous annotation is the use
of russell   s two-dimensional (arousal-valence) circumplex model of affect [581]
(see fig. 5.2(a)). figure 5.5 illustrates two different annotation tools (feeltrace and
affectrank) that are based on the arousal-valence circumplex model of affect. figure
5.6 depicts the ranktrace continuous annotation tool which can be used for the
annotation of a single dimension of affect (i.e., tension in this example). all three
tools are accessible and of direct use for annotating playing experience.

5.5.2.4 how often to annotate?

annotation can happen either within particular time intervals or continuously. time-
continuous annotation has been popularized due to the existence of freely available
tools such as feeltrace [144] (see fig. 5.5(c)) and gtrace [145], which allows for
continuous annotation of content (mostly videos and speech) across the dimensions
of arousal and valence. in addition to feeltrace there are annotation tools like the

5.5. what is the model   s output like?

223

continuous measurement system [454] and emujoy [474], where the latter is de-
signed for the annotation of music content. user interfaces such as wheels and
knobs linked to the above annotation tools show further promise for the continu-
ous annotation of experience in games [125, 397, 97] (see fig. 5.6). the continuous
annotation process, however, appears to require a higher amount of cognitive load
compared to a time-discrete annotation protocol. higher cognitive loads often result
in lower levels of agreement between different annotators and yield unreliable data
for modeling player experience [166, 418].

as a response to the above limitations, time-discrete annotation provides data at
particular intervals when the annotator feels there is a change in the player   s state.
and changes are best indicated relatively rather than absolutely. affectrank, for
instance (see fig. 5.5(b)), is a discrete, rank-based annotation tool that can be used
for the annotation of any type of content including images, video, text or speech and
it provides annotations that are signi   cantly more reliable (with respect to inter-rater
agreement) than the annotations obtained from continuous annotation tools such as
feeltrace [777]. the rank-based design of affectrank is motivated by observations
of recent studies in third-person video annotation indicating that    . . . humans are
better at rating emotions in relative rather than absolute terms.    [455, 777]. further,
affectrank is grounded in numerous    ndings showcasing the supremacy of ranks
over ratings for obtaining annotations of lower inconsistency and order effects [777,
773, 778, 436, 455, 761].

a recent tool that builds on the relative-based annotation of affectrank and al-
lows for the annotation of affect in a continuous yet unbounded fashion is ranktrace
(see fig. 5.6). the core idea behind ranktrace is introduced in [125]: the tool asks
participants to watch the recorded playthrough of a play session and annotate in
real-time the perceived intensity of a single emotional dimension. the annotation
process in ranktrace is controlled through a    wheel-like    hardware, allowing par-
ticipants to meticulously increase or decrease emotional intensity by turning the
wheel, similarly to how volume is controlled in a stereo system. further, the general
interfacing design of ranktrace builds on the one-dimensional gtrace annotation
tool [145]. unlike other continuous annotation tools, however, annotation in rank-
trace is unbounded: participants can continuously increase or decrease the intensity
as desired without constraining themselves to an absolute scale. this design deci-
sion is built on the anchor [607] and adaptation level [258] psychology theories by
which affect is a temporal notion based on earlier experience that is best expressed
in relative terms [765, 777, 397]. the use of ranktrace has revealed the bene   ts
of relative and unbounded annotation for modeling affect more reliably [397] and
has also showed promise for the construction of general models of player emotion
across games [97].

5.5.2.5 when to annotate?

when is it best to annotate experience: before, during or after play (see fig. 5.1)?
in a pre-experience questionnaire we usually ask annotators to set the baseline of

224

chapter 5. modeling players

(a) annotating facial expressions of players during play. the annotation is context-dependent as
the video includes the gameplay of the player (see top left corner).

(b) affectrank: a time-discrete annotation tool
for arousal and valence.

(c) feeltrace. a time-continuous annotation
tool for arousal and valence.

fig. 5.5 an example of third-person annotation based on videos of players and their gameplay
using either (a) the affectrank (b) or the feeltrace (c) annotation tool. affectrank is freely avail-
able at: https://github.com/taperi/affectrank. feeltrace is freely available at: http://emotion-
research.net/download/feeltrace%20package.zip.

a player   s state prior to playing a game. this state can be in   uenced by a number
of factors such as the mood of the day, the social network activity, the caffeine
consumption, earlier playing activity and so on. this is a wealth of information that
can be used to enrich our models. again, what is worth detecting is the relative
change [765] from the baseline state of the user prior playing to the game.

5.5. what is the model   s output like?

225

fig. 5.6 the ranktrace annotation tool. in this example the tool is used for the annotation of
tension in horror games. participants play a game and then they annotate the level of tension by
watching a video-recorded playthrough of their game session (top of image). the annotation trace
is controlled via a wheel-like user interface. the entire annotation trace is shown for the partici-
pant   s own reference (bottom of image). image adapted from [397]. the ranktrace tool is available
at: http://www.autogamedesign.eu/software.

a during-experience protocol, on the other hand, may involve the player in a
   rst-person think-aloud setup [555] or a third-person annotation design. for the
latter protocol you may think of user experience experts that observe and annotate
player experience during the beta release of a game, for example. as mentioned
earlier,    rst-person annotation during play is a rather intrusive process that disrupts
the gameplay and risks adding experimental noise to annotation data. in contrast,
third-person annotation is not intrusive; however, there are expected deviations from
the actual    rst-person experience, which is inaccessible to the observer.

the most popular approach for the annotation of player experience is after a game
(or a series of games) has been played, in a post-experience fashion. post-experience
annotation is unobtrusive for the player and it is usually performed by the players
themselves. self-reports, however, are memory-dependent by nature and memory is,
in turn, time-dependent. thus, one needs to consider carefully the time window be-
tween the experience and its corresponding report. for the reported post-experience
to be a good approximation of the actual experience the playing time window needs
to be small in order to minimize memory biases, yet suf   ciently large to elicit par-
ticular experiences to the player. the higher the cognitive load required to retrieve
the gameplay context is, the more the reports are memory-biased and not relevant to
the actual experience. further, the longer the time window between the real experi-
ence and the self-report the more the annotator activates aspects of episodic memory
associated with the gameplay [571]. episodic memory traces that form the basis of

annotation timelinecontrollable referencevideoplayback226

chapter 5. modeling players

self-reports fade over time, but the precise rate at which this memory decay occurs
is unknown and most likely individual [571]. ideally, memory decay is so slow that
the annotator will have a clear feeling of the gameplay session when annotating it.
now, if the time window becomes substantial   on the scale of hours and days   the
annotator has to activate aspects of semantic memory such as general beliefs about
a game. in summary, the more the episodic memory, and even more so the seman-
tic memory, are activated during annotation, the more systematic errors are induced
within the annotation data.

as a general rule of thumb the longer it takes for us to evaluate an experience
of ours the larger the discrepancy between the true experience and the evaluation of
the experience, which is usually more intense than the true experience. it also seems
that this gap between our memory of experience and our real experience is more
prominent when we report unpleasant emotions such as anger, sadness and tension
rather than positive emotions [462]. another bias that affects how we report our
experience is the experience felt near the end of a session, a game level or a game;
this effect has been named peak-end rule [462].

an effective way to assist episodic memory and minimize post-experience cogni-
tive load is to show annotators replay videos of their gameplay (or the gameplay of
others) and ask them to annotate those. this can be achieved via id104 [96]
in a third-person manner or on a    rst-person annotation basis [125, 271, 397, 97].
another notable approach in this direction is the data-driven retrospective inter-
viewing method [187]. according to that method player behavioral data is collected
and is analyzed to drive the construction of interview questions. these questions are
then used in retrospect (post-experience) to re   ect on the annotator   s behavior.

5.5.2.6 which annotation type?

we often are uncertain about the type of labels we wish to assign to a player state or
a player experience. in particular, we can select from three data types for our annota-
tion: ratings, classes, and ranks (see fig. 5.1). the rating-based format represents a
player   s state with a scalar value or a vector of values. ratings are arguably the dom-
inant practice for quantitatively assessing aspects of a user   s behavior, experience,
opinion or emotion. in fact, the vast majority of user and psychometric studies have
adopted rating questionnaires to capture the opinions, preferences and perceived ex-
periences of experiment participants   see [78, 442, 119] among many. the most
popular rating-based questionnaire follows the principles of a likert scale [384] in
which users are asked to specify their level of agreement with (or disagreement
against) a given statement   see fig. 5.7(a) for an example. other popular rating-
based questionnaires for user and player experience annotation include the geneva
wheel model [600], the self-assessment manikin [468], the positive and negative
affect schedule [646], the game experience questionnaire [286], the flow state
scale [293] and the player experience of need satisfaction (pens) survey [583],
which was developed based on self-determination theory [162].

5.5. what is the model   s output like?

227

rating-based reporting has notable inherent limitations that are often over-
looked, resulting in fundamentally    awed analyses [778, 298]. first, ratings are
analyzed traditionally by comparing their values across participants; see [233, 427]
among many. while this is a generally accepted and dominant practice it neglects
the existence of inter-personal differences as the meaning of each level on a rat-
ing scale may differ across experiment participants. for example, two participants
assessing the dif   culty of a level may assess it as exactly the same dif   culty, but
then one rates it as    very easy to play    and the other as    extremely easy to play   .
it turns out that there are numerous factors that contribute to the different internal
rating scales existent across participants [455] such as differences in personality,
culture [643], temperament and interests [740]. further, a large volume of studies
has also identi   ed the presence of primacy and recency order effects in rating-based
questionnaires (e.g., [113, 773]), systematic biases towards parts of the scale [388]
(e.g., right-handed participants may tend to use the right side of the scale) or a
   xed tendency over time (e.g., on a series of experimental conditions, the last ones
are rated higher). indicatively, the comparative study of [773] between ratings and
ranks showcases higher inconsistency effects and signi   cant order (recency) effects
existent in ratings.

in addition to inter-personal differences, a critical limitation arises when ratings
are treated as interval values since ratings are by nature ordinal values [657, 298].
strictly speaking, any approach or method that treats ratings as numbers by, for
instance, averaging their ordinal labels is fundamentally    awed. in most question-
naires likert items are represented as pictures (e.g., different representations of
arousal in the self-assessment manikin [468]) or as adjectives (e.g.,    moderately   ,
   fairly    and    extremely   ). these labels (images or adjectives) are often erroneously
converted to integer numbers, violating basic axioms of statistics which suggest that
ordinal values cannot be treated as interval values [657] since the underlying nu-
merical scale is unknown. note that even when a questionnaire features ratings as
numbers (e.g., see fig. 5.7(a)), the scale is still ordinal as the numbers in the in-
strument represent labels. thus, the underlying numerical scale is still unknown and
dependent on the participant [657, 515, 361]. treating ratings as interval values is
grounded in the assumption that the difference between consecutive ratings is    xed
and equal. however, there is no valid assumption suggesting that a subjective rating
scale is linear [298]. for instance, the difference between    fairly (4)     and    ex-
tremely (5)    may be larger than the distance between    moderately (3)    and    fairly
(4)    as some experiment participants rarely use the extremes of the scale or tend to
use one extreme more than the other [361]. if, instead, ratings are treated naturally
as ordinal data no assumptions are made about the distance between rating labels,
which eliminates introducing data noise to the analysis.

the second data type for the annotation of players is the class-based format.
classes allow annotators to select from a    nite and non-structured set of options
and, thus, a class-based questionnaire provides nominal data among two (binary) or
more options. the questionnaire asks subjects to pick a player state from a particu-
lar representation which could vary from a simple boolean question (was that game
level frustrating or not? is this a sad facial expression? which level was the most

228

chapter 5. modeling players

stressful?) to a player state selection from, for instance, the circumplex model of
affect (is this a high- or a low-arousal game state for the player?). the limitations
of ratings are mitigated, in part, via the use of class-based questionnaires. by not
providing information about the intensity of each player state, however, classes do
not have the level of granularity ratings naturally have. a class-based questionnaire
might also yield annotations with an unbalanced number of samples per class. a
common practice in psychometrics consists of transforming sets of consecutive rat-
ings into separate classes (e.g., see [226, 260] among many). in an example study
[255], arousal ratings on a 7-point scale are transformed into high, neutral and low
arousal classes using 7-5, 4 and 3-1 ratings, respectively. while doing so might seem
appropriate, the ordinal relation among classes is not being taken into account. more
importantly, the transformation process adds a new set of bias to the subjectivity bias
of ratings, namely class splitting criteria [436].

finally, rank-based questionnaires ask the annotator to rank a preference among
options such as two or more sessions of the game [763]. in its simplest form, the
annotator compares two options and speci   es which one is preferred under a given
statement (pairwise preference). with more than two options, the participants are
asked to provide a ranking of some or all the options. examples of rank-based ques-
tions include: was that level more engaging than this level? which facial expres-
sion looks happier?). another example of a rank-based questionnaire (4-alternative
forced choice) is illustrated in fig. 5.7(b). being a form of subjective reporting,
rank-based questionnaires (as much as rating-based and class-based questionnaires)
are associated with the well known limitations of memory biases and self-deception.
reporting about subjective constructs such as experience, preference or emotion via
rank-based questionnaires, however, has recently attracted the interest of researchers
in marketing [167], psychology [72], user modeling [761, 37] and affective com-
puting [765, 721, 436, 455, 773] among other    elds. this gradual paradigm shift is
driven by both the reported bene   ts of ranks minimizing the effects of self-reporting
subjectivity biases and recent    ndings demonstrating the advantages of ordinal an-
notation [765, 773, 455].

5.5.2.7 what is the value of player experience?

describing, labeling and assigning values to subjective notions, such as player ex-
perience, is a non-trivial task as evidenced by a number of disciplines including
neuroscience [607], psychology [258], economics [630], and arti   cial intelligence
[315]. annotators can attempt to assign numbers to such notions in an absolute
manner, using for instance a rating scale. annotators can alternatively assign val-
ues in a relative fashion, using for instance a ranking. there are, however, a mul-
titude of theoretical and practical reasons to doubt that subjective notions can be
encoded as numbers in the    rst place [765]. for instance, according to kahneman
[317], co-founder of behavioral economics,    ...it is safe to assume that changes are
more accessible than absolute values   ; his theory about judgment heuristics is built
on herbert simon   s psychology of bounded rationality [630]. further, an important

5.5. what is the model   s output like?

229

(a) rating: a 5-point likert item example

(b) rank: a 4-alternative forced choice exam-
ple

fig. 5.7 examples of rating-based (a) vs. rank-based (b) questionnaires.

thesis in psychology, named adaptation level theory [258], suggests that humans
lack the ability to maintain a constant value about subjective notions and their pref-
erences about options are, instead, made on a pairwise comparison basis using an
internal ordinal scale [460]. the thesis claims that while we are ef   cient at discrimi-
nating among options, we are not good at assigning accurate absolute values for the
intensity of what we perceive. for example, we are particularly bad at assigning ab-
solute values to tension, frequency and loudness of sounds, the brightness of an im-
age, or the arousal level of a video. the above theories have also been supported by
neuroscienti   c evidence suggesting that experience with stimuli gradually creates
our own internal context, or anchor [607], against which we rank any forthcoming
stimulus or perceived experience. thus, our choice about an option is driven by our
internal ordinal representation of that particular option within a sample of options;
not by any absolute value of that option [658].

as a remote observation, one may argue that the relative assessment provides
less information than the absolute assessment since it does not express a quantity
explicitly and only provides ordinal relations. as argued earlier, however, any addi-
tional information obtained in an absolute fashion (e.g., when ratings are treated as
numbers) violates basic axioms of applied statistics. thus the value of the additional
information obtained (if any) is questioned directly [765].

in summary, results across different domains investigating subjective assessment
suggest that relative (rank-based) annotations minimize the assumptions made about
experiment participants    notions of highly subjective constructs such as player ex-
perience. further, annotating experience in a relative fashion, instead of an absolute
fashion, leads to the construction of more generalizable and accurate computational
models of experience [765, 436].

5.5.3 no output

very often we are faced with datasets where target outputs about player behavioral
or experience states are not available. in such instances modeling of players must
rely on unsupervised learning [176, 244, 178] (see fig. 5.1). unsupervised learning,

230

chapter 5. modeling players

as discussed in chapter 2, focuses on    tting a model to observations by discovering
associations of the input and without having access to a target output. the input is
generally treated as a set of random variables and a model is built through the obser-
vations of associations among the input vectors. unsupervised learning as applied to
modeling players involves tasks such as id91 and association mining which
are described in section 5.6.3.

it may also be the case that we do not have target outputs available but, neverthe-
less, we can design a reward function that characterizes behavioral or experiential
patterns of play. in such instances we can use id23 approaches
to discover policies about player behavior or player experience based on in-game
play traces or other state-action representations (see section 5.6.2). in the following
section we detail the approaches used for modeling players in a supervised learning,
id23 and unsupervised learning fashion.

5.6 how can we model players?

in this section we build upon the data-driven approach of player modeling and dis-
cuss the application of supervised, reinforcement and unsupervised learning to
model players, their behavior and their experience. to showcase the difference be-
tween the three learning approaches let us suppose we wish to classify player be-
havior. we can only use unsupervised learning if no behavioral classes have been
de   ned a priori [176]. we can instead use supervised learning if, for example, we
have already obtained an initial classi   cation of players (either manually or via clus-
tering) and we wish to    t new players into these prede   ned classes [178]. finally,
we can use id23 to derive policies that imitate different types
of playing behavior or style. in section 5.6.1 we focus on the supervised learning
paradigm whereas in section 5.6.2 and section 5.6.3 we outline, respectively, the re-
inforcement learning and the unsupervised learning approach for modeling players.
all three machine learning approaches are discussed in chapter 2.

5.6.1 supervised learning

player modeling consists of    nding a function that maps a set of measurable at-
tributes of the player to a particular player state. following the supervised learning
approach this is achieved by machine learning, or automatically adjusting, the pa-
rameters of a model to    t a dataset that contains a set of input samples, each one
paired with target outputs. the input samples correspond to the list of measurable
attributes (or features) while the target outputs correspond to the annotations of the
player   s states for each of the input samples that we are interested to learn to pre-
dict. as mentioned already, the annotations may vary from behavioral characteris-

5.6. how can we model players?

231

tics, such as completion times of a level or player archetypes, to estimates of player
experience, such as player frustration.

as we saw in chapter 2 popular supervised learning techniques, including arti-
   cial neural networks (shallow or deep architectures), id90, and support
vector machines, can be used in games for the analysis, the imitation and the pre-
diction of player behavior, and the modeling of playing experience. the data type
of the annotation determines the output of the model and, in turn, the type of the
machine learning approach that can be applied. the three supervised learning alter-
natives for learning from numerical (or interval), nominal and ordinal annotations   
respectively, regression, classi   cation and preference learning   are discussed in
this section.

5.6.1.1 regression

when the outputs that a player model needs to approximate are interval values, the
modeling problem is known as metric or standard regression. any regression algo-
rithm is applicable to the task, including linear or polynomial regression, arti   cial
neural networks and support vector machines. we refer the reader to chapter 2 for
details on a number of popular regression algorithms.

regression algorithms are appropriate for imitation and prediction tasks of
player behavior. when the task, however, is modeling of player experience cau-
tion needs to be put on the data analysis. while it is possible, for instance, to use
regression algorithms to learn the exact numeric ratings of experience, in general it
should be avoided because regression methods assume that the target values follow
an interval (numerical) scale. ratings naturally de   ne an ordinal scale [765, 773] in-
stead. as mentioned already, ordinal scales such as ratings should not be converted
to numerical values due to the subjectivity inherent to reports, which imposes a
non-uniform and varying distance among questionnaire items [778, 657]. prediction
models trained to approximate a real-value representation of a rating   even though
they may achieve high prediction accuracies   do not necessarily capture the true
reported playing experience because the ground truth used for training and valida-
tion of the model has been undermined by the numerous effects discussed above.
we argue that the known fundamental pitfalls of self-reporting outlined above pro-
vide suf   cient evidence against the use of regression for player experience modeling
[765, 515, 455, 361]. thus, we leave the evaluation of regression methods on expe-
rience annotations outside the scope of this book.

5.6.1.2 classi   cation

classi   cation is the appropriate form of supervised learning for player modeling
when the annotation values represent a    nite and non-structured set of classes.
classi   cation methods can infer a mapping between those classes and player at-
tributes. available algorithms include arti   cial neural networks, id90, ran-

232

chapter 5. modeling players

dom forests, support vector machines, k-nearest neighbors, and id108
among many others. further details about some of these algorithms can be found in
chapter 2.

classes can represent playing behavior which needs to be imitated or predicted,
such as completion times (e.g., expressed as low, average or high completion time)
or user retention in a free-to-play game (e.g., expressed as weak, mild or strong
retention). classes can alternatively represent player experience such as an excited
versus a frustrated player as manifested from facial expressions or low, neutral and
high arousal states for a player.

classi   cation is perfectly suited for the task of modeling player experience if
discrete annotations of experience are selected from a list of possibilities and pro-
vided as target outputs [153, 344]. in other words, annotations of player experience
need to be nominal for classi   cation to be applied. a common practice, however, as
already mentioned in section 5.5.2.6, is to treat ratings of experience as classes and
transform the ordinal scale   that de   nes ratings   into a nominal scale of separate
classes. for example, ratings of arousal that lie between    1 and 1 are transformed
into low, neutral and high arousal classes. by classifying ratings not only the ordinal
relation among the introduced classes is ignored but, most importantly, the transfor-
mation process induces several biases to the data (see section 5.5.2.6). these biases
appear to be detrimental and mislead the search towards the ground truth of player
experience [765, 436].

5.6.1.3 preference learning

as an alternative to regression and classi   cation methods, preference learning
[215] methods are designed to learn from ordinal data such as ranks or preferences.
it is important to note that the training signal in the preference learning paradigm
merely provides information for the relative relation between instances of the phe-
nomenon we attempt to approximate. target outputs that follow an ordinal scale do
not provide information about the intensity (regression) or the clusters (classi   ca-
tion) of the phenomenon.

generally we could construct a player model based on in-game behavioral pref-
erences. the information that this player, for example, prefers the mini-gun over a
number of other weapons could form a set of pairwise preferences we could learn
from. alternatively we can build a model based on experience preferences. a player,
for instance, reported that area x of the level is more challenging than area y of the
same level. based on a set of such pairwise preferences we can derive a global func-
tion of challenge for that player.

as outlined in chapter 2 a large palette of algorithms is available for the task
of preference learning. many popular classi   cation and regression techniques have
been adapted to tackle preference learning tasks, including linear statistical models
such as id156 and large margins, and non-linear approaches
such as gaussian processes [122], deep and shallow arti   cial neural networks [430],
and support vector machines [302].

5.6. how can we model players?

233

preference learning has already been extensively applied to modeling aspects of
players. for example, mart    nez et al. [430, 431] and yannakakis et al. [780, 771]
have explored several arti   cial neural network approaches to learn to predict af-
fective and cognitive states of players reported as pairwise preferences. similarly,
garbarino et al. [217] have used id156 to learn pairwise en-
joyment predictors in racing games. to facilitate the use of proper machine learning
methods on preference learning problems, a number of such preference learning
methods as well as id174 and feature selection algorithms have been
made available as part of the preference learning toolbox (plt) [198]. plt is an
open-access, user-friendly and accessible toolkit5 built and constantly updated for
the purpose of easing the processing of (and promoting the use of) ranks.

as ratings, by de   nition, express ordinal scales they can directly be transposed to
any ordinal representation (e.g., pairwise preferences). for instance, given an anno-
tator   s rating indicating that a condition a felt    slightly frustrating    and a condition b
felt    very frustrating   , a preference learning method can train a model that predicts a
higher level of frustration for b than for a. in this way the modeling approach avoids
introducing artifacts of what is the actual difference between    very    and    slightly    or
the usage of the scale for this particular annotator. further, the limitation of different
subjective scales across users can be safely bypassed by transforming rating reports
into ordinal relations on a per-annotator basis. finally, the problem of the scale
varying across time due to episodic memory still persists but can be minimized by
transforming only consecutive reports, i.e., given a report for three conditions a, b
and c, the player model can be trained using only the relation between a and b, and
b and c (dropping the comparison between a and c).

5.6.1.4 summary: the good, the bad and the ugly

the last section on supervised learning is dedicated to the comparison among the
three methods   regression, classi   cation and preference learning   for modeling
players. arguably the discussion is limited when the in-game behavior of players
is imitated or predicted. if behavioral data about players follows interval, nomi-
nal or ordinal scales then naturally, regression, classi   cation and preference learn-
ing should be applied, respectively. behavioral data have an objective nature which
makes the task of learning less challenging. given the subjective notion of player ex-
perience, however, there are a number of caveats and limitations of each algorithm
that need to be taken into account. below we discuss the comparative advantages
of each and we summarize the key outcomes of supervised learning as applied to
modeling the experience of players.

regression vs. preference learning: motivated by psychological studies sug-
gesting that interval ratings misrepresent experience [515, 455, 361], we will not
dedicate ourselves an extensive comparison between preference learning and regres-
sion methods. the performance comparison between a regression and preference-

5 http://sourceforge.net/projects/pl-toolbox/

234

chapter 5. modeling players

learned model is also irrelevant as the former is arguably a priori incapable of cap-
turing the underlying experience phenomenon as precisely as the latter. such de-
viations from the ground truth, however, are not trivial to illustrate through a data
modeling approach and thus the comparison is not straightforward. the main rea-
son is that the objective ground truth is fundamentally ill-de   ned when numbers are
used to characterize subjective notions such as player experience.

regression vs. classi   cation: classes are easy to analyze and create player
models from. further, their use eliminates part of the inter-personal biases intro-
duced with ratings. for these reasons classi   cation should be preferred to regres-
sion for player experience modeling. we already saw that classi   cation, instead of
regression, is applied when ratings are available to overcome part of the limitations
inherent in rating-based annotation. for instance, this can be achieved by transform-
ing arousal ratings to high, neutral and low arousal classes [255]. while this com-
mon practice in psychometrics eliminates part of the rating subjectivity it adds new
forms of data biases inherent in the ad-hoc decisions to split the classes. further,
the analysis of player models across several case studies in the literature has already
shown that transforming ratings into classes creates a more complicated machine
learning problem [765, 436].

classi   cation vs. preference learning: preference learning is the supreme
method for modeling experience when ranks or pairwise preferences are available.
even when ratings or classes are available comparisons between classi   cation and
preference learning player models in the literature suggest that preference learn-
ing methods lead to more ef   cient, generic and robust models which capture more
information about the ground truth [765]. indicatively, crammer and signer [147]
compare classi   cation, regression and preference learning training algorithms in a
task to learn ratings. they report the supremacy of preference learning over the
other methods based on several synthetic datasets and a movie-ratings dataset. in
addition, extensive evidence already shows that preference learning better approxi-
mates the underlying function between input (e.g., experience manifestations such
as gameplay) and output (e.g., annotations) [436]. figure 5.8 showcases how much
closer a preference learned model can reach a hypothesized (arti   cial) ground truth,
compared to a classi   cation model trained on an arti   cial dataset. in summary, pref-
erence learning via rank-based annotation controls for reporting memory effects,
eliminates subjectivity biases and builds models that are closer to the ground truth
of player experience [778, 777].

grounded in extensive evidence our    nal note for the selection of a supervised
learning approach for modeling player experience is clear: independently of how
experience is annotated we argue that preference learning (the good) is a superior
supervised learning method for the task at hand, classi   cation (the ugly) provides a
good balance between simplicity and approximation of the ground truth of player
experience whereas regression (the bad) is based on rating annotations which are of
questionable quality with respect to their relevance to the true experience.

5.6. how can we model players?

235

(a) ground truth

(b) classi   cation

(c) preference learning

fig. 5.8 a hypothesized (arti   cial) ground truth function (z-axis) which is dependent on two player
attributes, x1 and x2 (fig. 5.8(a)), the best classi   cation model (fig. 5.8(b)) and the best preference
learned model (fig. 5.8(c)). all images are retrieved from [436].

5.6.2 id23

while it is possible to use id23 to model aspects of users dur-
ing their interaction the rl approach for modeling players has been tried mostly in
comparatively simplistic and abstract games [195] and has not seen much applica-

236

chapter 5. modeling players

tion in computer games. the key motivation for the use of rl for modeling players
is that it can capture the relative valuation of game states as encoded internally by
humans during play [685]. at    rst glance, player modeling with rl may seem to be
an application of rl for game playing, and we discuss this in chapter 3 as part of
the play for experience aim. in this section, we instead discuss this approach from
the perspective that a policy learned via rl can capture internal player states with
no corresponding absolute target values such as decision making, learnability, cog-
nitive skills or emotive patterns. further, those policies can be trained on player data
such as play traces. the derived player model depicts psychometrically-valid, ab-
stract simulations of a human player   s internal cognitive or affective processes. the
model can be used directly to interpret human play, or indirectly, it can be featured
in ai agents which can be used as playtesting bots during the game design process,
as baselines for adapting agents to mimic classes of human players, or as believable,
human-like opponents [268].

using the rl paradigm, we can construct player models via rl if a reward sig-
nal can adjust a set of parameters that characterize the player. the reward signal
can be based either directly on the in-game behavior of the player   for instance, the
decision taken at a particular game state   or indirectly on player annotations (e.g.,
annotated excitement throughout the level) or objective data (e.g., physiological in-
dexes showing player stress). in other words, the immediate reward function can be
based on gameplay data if the model wishes to predict the behavior of the player or,
instead, be based on any objective measure or subjective report if the model attempts
to predict the experience of the player. the representation of the rl approach can
be anything from a standard q table that, for instance, models the decision making
behavior of a player (e.g., as in [268, 685]) to an ann that e.g., models in-game
behavior (as in [267]), to a set of behavior scripts [650] that are adjusted to imitate
gameplay behavior via rl, to a deep q network.

we can view two ways of constructing models of players via rl: models can
be built of   ine (i.e., before gameplay starts) or at runtime (i.e., during play). we
can also envision hybrid approaches by which models are    rst built of   ine and then
are polished at runtime. of   ine rl-based modeling adds value to our playtesting
capacity via, for instance, procedural personas (see section 5.7.1.3) whereas run-
time rl-based player modeling offers dynamicity to the model with respect to time.
runtime player modeling further adds on the capacity of the model to adapt to the
particular characteristics of the player, thereby increasing the degree of personaliza-
tion. we can think of models of players, for instance, that are continuously tailored
to the current player by using the player   s in-game annotations, behavioral deci-
sions, or even physiological responses during the game.

this way of modeling players is still in its infancy with only a few studies existent
on player behavioral modeling in educational games [488], in roguelike adventure
games [268, 267] via td learning or evolutionary id23, and in
   rst-person shooter games [685] via inverse rl. however, the application of rl
for modeling users beyond games has been quite active for the purposes of model-
ing web-usage data and interactions on the web [684] or modeling user simulations
in id71 [114, 225, 595]. normally in such systems a statistical model is

5.6. how can we model players?

237

   rst trained on a corpus of human-computer interaction data for simulating (imitat-
ing) user behavior. then id23 is used to tailor the model towards
an optimal dialog strategy which can be found through trial and error interactions
between the user and the simulated user.

5.6.3 unsupervised learning

the aim of unsupervised learning (see chapter 2) is to derive a model given a
number of observations. unlike in supervised learning, there is no speci   ed target
output. unlike in id23 there is no reward signal. (in short, there
is no training signal of any kind.) in unsupervised learning, the signal is hidden in-
ternally in the interconnections among data attributes. so far, unsupervised learning
has mainly been applied to two core player modeling tasks: id91 behaviors
and mining associations between player attributes. while chapter 2 provides the
general description of these unsupervised learning algorithms, in this section we
focus on their speci   c application for modeling players.

5.6.3.1 id91

as discussed in chapter 2, id91 is a form unsupervised learning aiming to
   nd clusters in datasets so that data within a cluster is similar to each other and
dissimilar to data in other clusters. when it comes to the analysis of user behavior
in games, id91 offers a means for reducing the dimensionality of a dataset,
thereby yielding a manageable number of critical features that represent user behav-
ior. relevant data for id91 in games include player behavior, navigation pat-
terns, assets bought, items used, game genres played and so on. id91 can be
used to group players into archetypical playing patterns in an effort to evaluate how
people play a particular game and as part of a user-oriented testing process [176].
further, one of the key questions of user testing in games is whether people play the
game as intended. id91 can be utilized to derive a number of different playing
or behavioral styles directly addressing this question. arguably, the key challenge
in successfully applying id91 in games is that the derived clusters should have
an intelligible meaning with respect to the game in question. thus, clusters should
be clearly interpretable and labeled in a language that is meaningful to the involved
stakeholders (such as designers, artists and managers) [176, 178]. in the case studies
of section 5.7.1 we meet the above challenges and demonstrate the use of id91
in the popular tomb raider: underworld (eidos interactive, 2008) game.

238

chapter 5. modeling players

5.6.3.2 frequent pattern mining

in chapter 2 we de   ned frequent pattern mining as the set of problems and tech-
niques related to    nding patterns and structures in data. patterns include sequences
and itemsets. both frequent itemset mining (e.g., apriori [6]) and frequent se-
quence mining (e.g., gsp [652]) are relevant and useful for player modeling. the
key motivation for applying frequent pattern mining on game data is to    nd inherent
and hidden regularities in the data. in that regard, key player modeling problems,
such as player type identi   cation and detection of player behavior patterns, can be
viewed as frequent pattern mining problems. frequent pattern mining can for ex-
ample be used to to discover what game content is often purchased together   e.g.,
players that buy x tend to buy y too   or what are the subsequent actions after dying
in a level   e.g., players that die often in the tutorial level pick up more health packs
in level 1 [120, 621].

5.7 what can we model?

as already outlined at the beginning of this chapter, modeling of users in games can
be classi   ed into two main tasks: modeling of the behavior of players and modeling
of their experience. it is important to remember that modeling of player behavior
is (mostly) a task of objective nature whereas the modeling of player experience is
subjective given the idiosyncratic nature of playing experience. the examples we
present in the remainder of this chapter highlight the various uses of ai for modeling
players.

5.7.1 player behavior

in this section, we exemplify player behavior modeling via three representative use
cases. the two    rst examples are based on a series of studies on player modeling by
drachen et al. in 2009 [176] and later on by mahlmann et al. in 2010 [414] in the
tomb raider: underworld (eidos interactive, 2008) game. the analysis includes
both the id91 of players [176] and the prediction [414] of their behavior,
which make it an ideal case study for the purposes of this book. the third study
presented in this section focuses on the use of play traces for the procedural creation
of player models. that case study explores the creation of procedural personas in
the minidungeons puzzle roguelike game.

5.7. what can we model?

239

fig. 5.9 a screenshot from the tomb raider: underworld (eidos interactive, 2008) game fea-
turing the player character, lara croft. the game is used as one of the player behavior modeling
case studies presented in this book. image obtained from wikipedia (fair use).

5.7.1.1 id91 players in tomb raider: underworld

tomb raider: underworld (tru) is a third-person perspective, advanced platform-
puzzle game, where the player has to combine strategic thinking in planning the
3d-movements of lara croft (the game   s player character) and problem solving in
order to go through a series of puzzles and navigate through a number of levels (see
fig. 5.9).

the dataset used for this study includes entries from 25,240 players. the 1,365
of those that completed the game were selected and used for the analysis presented
below. note that tru consists of seven main levels plus a tutorial level. six features
of gameplay behavior were extracted from the data and are as follows: number of
deaths by opponents, number of deaths by the environment (e.g.,    re, traps, etc.),
number of deaths by falling (e.g., from ledges), total number of deaths, game com-
pletion time, and the times help was requested. all six features were calculated on
the basis of completed tru games. the selection of these particular features was
based on the core game design of the tru game and their potential impact on the
process of distinguishing among dissimilar patterns of play.

three different id91 techniques were applied to the task of identifying the
number of meaningful and interpretable clusters of players in the data: id116,
hierarchical id91 and self-organizing maps. while the    rst two have been cov-
ered in chapter 2 we will brie   y outline the third method here.

a self-organizing map (som) [347] creates and iteratively adjusts a low-
dimensional projection of the input space via vector quantization. in particular, a
type of large som called an emergent self-organizing map [727] was used in con-
junction with reliable visualization techniques to help us identify clusters. a som
consists of neurons organized in a low-dimensional grid. each neuron in the grid

240

chapter 5. modeling players

(map) is connected to the input vector through a connection weight vector. in ad-
dition to the input vector, the neurons are connected to neighbor neurons of the
map through neighborhood interconnections which generate the structure of the
map: rectangular and hexagonal lattices organized in a two-dimensional sheet or a
three-dimensional toroid shape are some of the most popular topologies used. som
training can be viewed as a vector quantization algorithm which resembles the
id116 algorithm. what differentiates som, however, is the update of the topo-
logical neighbors of the best-matching neuron   a best-matching neuron is a neuron
for which there exists at least one input vector for which the euclidean distance to
the weight vector of this neuron is minimal. as a result, the whole neuron neighbor-
hood is stretched towards the presented input vector. the outcome of som training
is that neighboring neurons have similar weight vectors which can be used for pro-
jecting the input data to the two-dimensional space and thereby id91 a set of
data through observation on a 2d plane. for a more detailed description of soms,
the reader is referred to [347].

to get some insight into the possible number of clusters existent in the data, k-
means was applied for all k values less than or equal to 20. the sum of the euclidean
distances between each player instance and its corresponding cluster centroid (i.e.,
quantization error) is calculated for all 20 trials of id116. the analysis reveals
that the percent decrease of the mean quantization error due to the increase of k is
notably high when k = 3 and k = 4. for k = 3 and k = 4 this value equals 19%
and 13% respectively while it lies between 7% and 2% for k > 4. thus, the id116
id91 analysis provides the    rst indication of the existence of three or four main
player behavioral clusters within the data.

as an alternative approach to id116, hierarchical id91 is also applied to
the dataset. this approach seeks to build a hierarchy of clusters existent in the data.
the ward   s id91 method [747] is used to specify the clusters in the data by
which the squared euclidean distance is used as a measure of dissimilarity between
data vector pairs. the resulting dendrogram is depicted in fig. 5.10(a). as noted
in chapter 2 a dendrogram is a treelike diagram that illustrates the merging of data
into clusters as a result of hierarchical id91. it consists of many u-shaped
lines connecting the clusters. the height of each u represents the squared euclidean
distance between the two clusters being connected. depending on where the data
analyst sets the squared euclidean distance threshold a dissimilar number of clusters
can be observed.

both id116 and hierarchical id91 already demonstrate that the 1,365
players can be clustered in a low number of different player types. id116 in-
dicates there are for three or four clusters while the ward   s dendrogram reveals the
existence of two populated and two smaller clusters, respectively, in the middle and
at the edges of the tree.

applying som, as the third alternative approach, allows us to cluster the tru
data by observation on a two-dimensional plane. the u-matrix depicted in fig.
5.10(b) is a visualization of the local distance structure in the data placed onto a
two-dimensional map. the average distance value between each neuron   s weight
vector and the weight vectors of its immediate neighbors corresponds to the height

5.7. what can we model?

241

(a) dendrogram of tru data using ward hierarchical id91. a squared euclidean distance of
4.5 (illustrated with a horizontal black line) reveals four clusters. image adapted from [176].

(b) u-matrix visualization of a self-organizing map depicting the four player clusters identi   ed in a
population of 1,365 tru players (shown as small colored squares). different square colors depict
different player clusters. valleys represent clusters whereas mountains represent cluster borders.
image adopted from [176].

fig. 5.10 detecting player types from tru data using hierarchical (a) and som (b) id91
methods.

of that neuron in the u-matrix (positioned at the map coordinates of the neuron).

242

chapter 5. modeling players

thus, u-matrix values are large in areas where no or few data points reside, creating
mountain ranges for cluster boundaries. on the other hand, visualized valleys indi-
cate clusters of data as small u-matrix values are observed in areas where the data
space distances of neurons are small.

the som analysis reveals four main classes of behavior (player types) as de-
picted in fig. 5.10(b). the different colors of the u-matrix correspond to the four
different clusters of players. in particular, cluster 1 (8.68% of the tru players)
corresponds to players that die very few times, their death is caused mainly by the
environment, they do not request help from the game frequently and they complete
the game very quickly. given such game skills these players were labeled as vet-
erans. cluster 2 (22.12%) corresponds to players that die quite often (mainly due
to falling), they take a long time to complete the game   indicating a slow-moving,
careful style of play   and prefer to solve most puzzles in the game by themselves.
players of this cluster were labeled as solvers, because they excel particularly at
solving the puzzles of the game. players of cluster 3 form the largest group of tru
players (46.18%) and are labeled as paci   sts as they die primarily from active op-
ponents. finally, the group of players corresponding to cluster 4 (16.56% of tru
players), namely the runners, is characterized by low completion times and frequent
deaths by opponents and the environment.

the results showcase how id91 of player behavior can be useful to evalu-
ate game designs. speci   cally, tru players seem to not merely follow a speci   c
strategy to complete the game but rather they fully explore the affordances provided
by the game in dissimilar ways. the    ndings are directly applicable to tru game
design as id91 provides answers to the critical question of whether people play
the game as intended. the main limitation of id91, however, is that the derived
clusters are not intuitively interpretable and that clusters need to be represented into
meaningful behavioral patterns to be useful for game design. collaborations be-
tween the data analyst and the designers of the game   as was performed in this
study   is essential for meaningful interpretations of the derived clusters. the ben-
e   t of such a collaboration is both the enhancement of game design features and
the effective phenomenological debugging of the game [176]. in other words, we
make sure both that no feature of the game is underused or misused and that the
playing experience and the game balance are debugged.

5.7.1.2 predicting player behavior in tomb raider: underworld

building on the same set of tru player data, a second study examined the possi-
bilities of predicting particular aspects of playing behavior via supervised learning
[414]. an aspect of player behavior that is particularly important for game design
is to predict when a player will stop playing. as one of the perennial challenges of
game design is to ensure that as many different types of players are facilitated in the
design, being able to predict when players will stop playing a game is of interest
because it assists with locating potentially problematic aspects of game design. fur-

5.7. what can we model?

243

ther, such information helps toward the redesign of a game   s monetization strategy
for maximizing user retention.

data was drawn from the square enix europe metrics suite and was collected
during a two month period (1st dec 2008     31st jan 2009), providing records from
approximately 203,000 players. for the player behavior prediction task it was de-
cided to extract a subsample of 10,000 players which provides a large enough and
representative dataset for the aims of the study, while at the same time is manage-
able in terms of computational effort. a careful data-preprocessing approach yielded
6,430 players that were considered for the prediction task   these players had com-
pleted the    rst level of the game.

as in the tru cluster analysis the features extracted from the data relate to the
core mechanics of the game. in addition to the six features investigated in the cluster-
ing study of tru the extracted features for this study include the number of times
the adrenalin feature of the game was used, the number of rewards collected, the
number of treasures found, and the number of times the player changes settings in
the game (including player ammunition, enemy hit points, player hit points, and re-
covery time when performing platform jumps). further details about these features
can be found in [414].

to test the possibility of predicting the tru level the player completed last a
number of classi   cation algorithms are tested on the data using the weka machine
learning software [243]. the approach followed was to experiment with at least one
algorithm from each of the algorithm families existent in weka and to put additional
effort on those classi   cation algorithms that were included in a recent list of the most
important algorithms in data mining: decision tree induction, id26 and
simple regression [759]. the resulting set of algorithms chosen for classi   cation
are as follows: id28, multi-layer id88 id26, variants
of id90, id110s, and support vector machines. in the following
section, we only outline the most interesting results from those reported in [414]. for
all tested algorithms, the reported classi   cation prediction accuracy was achieved
through 10-fold cross validation.

most of the tested algorithms had similar levels of performance, and were able
to predict when a player will stop playing substantially better than the baseline. in
particular, considering only gameplay of level 1 classi   cation algorithms reach an
accuracy between 45% and 48%, which is substantially higher than the baseline per-
formance (39.8%). when using additional features from level 2, the predictions are
much more accurate   between 50% and 78%   compared to the baseline (45.3%).
in particular, id90 and id28 manage to reach accuracies of
almost 78% in predicting on what level a player will stop playing. the difference in
the predictive strength of using level 1 and 2 data as compared to only level 1 data
is partly due to increased amount of features used in the latter case.

beyond accuracy an important feature of machine learning algorithms is their
transparency and their expressiveness. the models are more useful to a data analyst
and a game designer if they can be expressed in a form which is easy to visualize and
comprehend. id90   of the form constructed by the   algorithm [544]
and its many derivatives   are excellent from this perspective, especially if pruned to

244

chapter 5. modeling players

fig. 5.11 a decision tree trained by the   algorithm [544] to predict when tru players will
stop playing the game. the leaves of the tree (ovals) indicate the number of the level (2, 3 or 7)
the player is expected to complete. note that the tru game has seven levels in total. the tree is
constrained to tree depth 2 and achieves a classi   cation accuracy of 76.7%.

a small size. for instance, the extremely small decision tree depicted in fig. 5.11 is
constrained to tree depth 2 and was derived on the set of players who completed both
levels 1 and 2 with a classi   cation accuracy of 76.7%. the predictive capacity of
the decision tree illustrated in fig. 5.11 is impressive given how extremely simple it
is. the fact that we can predict the    nal played level   with a high accuracy   based
only on the amount of time spent in the room named flush tunnel of level 2 and
the total rewards collected in level 2 is very appealing for game design. what this
decision tree indicates is that the amount of time players spend within a given area
early in the game and how well they perform are important for determining if they
continue playing the game. time spent on a task or in an area of the game can indeed
be indicative of challenges with progressing through the game, which can result in
a frustrating experience.

5.7.1.3 procedural personas in minidungeons

procedural personas are generative models of player behavior, meaning that they
can replicate in-game behavior and be used for playing games in the same role
as players; additionally, procedural personas are meant to represent archetypical
players rather than individual players [268, 267, 269]. a procedural persona can
be de   ned as the parameters of a utility vector that describe the preferences of a

5.7. what can we model?

245

player. for example, a player might allocate different weight to    nishing a game
fast, exploring dialog options, getting a high score, etc.; these preferences can be
numerically encoded in a utility vector where each parameter corresponds to the
persona   s interest in a particular activity or outcome. once these utilities are de-
   ned, id23 via td learning or neuroevolution can be used to    nd
a policy that re   ects these utilities, or a tree search algorithm such as mcts can be
used with these utilities as evaluation functions. approaches similar to the proce-
dural persona concept have also been used for modeling the learning process of the
player in educational games via id23 [488].

as outlined in section 5.4.1, minidungeons is a simple rogue-like game which
features turn-based discrete movement, deterministic mechanics and full informa-
tion. the player avatar must reach the exit of each level to win it. monsters block
the way and can be destroyed, at the cost of decreasing the player character   s health;
health can be restored by collecting potions. additionally, treasures are distributed
throughout levels. in many levels, potions and treasures are placed behind monsters,
and monsters block the shortest path from the entrance to the exit. like many games,
it is therefore possible to play minidungeons with different goals, such as reaching
the exit in the shortest possible time, collecting as much treasure as possible or
killing all the monsters (see figs. 5.3 and 5.12).

these different playing styles can be formalized as procedural personas by at-
taching differing utilities to measures such as the number of treasures collected, the
number of monsters killed or the number of turns taken to reach the exit. id24
can be used to learn policies that implement the appropriate persona in single lev-
els [268], and evolutionary algorithms can be used to train neural networks that
implement a procedural persona across multiple levels [267]. these personas can
be compared with the play traces of human players by placing the persona in ev-
ery situation that the human encountered in the play trace and comparing the action
chosen by the procedural persona with the action chosen by the human (as you
are comparing human actions with those of a q function, you might say that you
are asking    what would q do?   ). it is also possible to learn the utility values for a
procedural persona clone of a particular human player by evolutionary search for
those values that make the persona best match a particular play trace (see fig. 5.12).
however, it appears that these    clones    of human players generalize less well than
designer-speci   ed personas [269].

5.7.2 player experience

the modeling of player experience involves learning a set of target outputs that ap-
proximate the experience (as opposed of the behavior) of the player. by de   nition,
that which is being modeled (experience) is of subjective nature and the model-
ing therefore requires target outputs that somehow approximate the ground truth of
experience. a model of player experience predicts some aspect of the experience a
player would have in some game situation, and learning such models is naturally a

246

chapter 5. modeling players

(a) an arti   cial neural network mapping between a game state
(input) and plans (output). the input contains blue circles rep-
resenting distances to various important elements of the game
and a red circle representing hit points of the player character.

(b) a level of minidungeons 2
depicting the current state of the
game.

fig. 5.12 a example of a procedural persona: in this example we evolve the weights of arti   cial
neural networks   an ann per persona. the ann takes observations of the player character and
its environment and uses these to choose from a selection of possible plans. during evolution the
utility function of each persona is used as the    tness function for adjusting its network weights.
each individual of each generation is evaluated by simulating a full game. a utility function allows
us to evolve a network to pursue multiple goals across a range of different situations. the method
depends on the designer providing carefully chosen observations, appropriate planning algorithms,
and well-constructed utility functions. in this example the player opts to move towards a safe
treasure. this is illustrated with a green output neuron and highlighted corresponding weights (a)
and a green path on the game level (b).

supervised learning problems. as mentioned, there are many ways this can be done,
with approaches to player experience modeling varying regarding the inputs (from
what the experience is predicted, e.g., physiology, level design parameters, playing
style or game speed), the outputs (what sort of experience is predicted, e.g., fun,
frustration, attention or immersion) and the modeling methodology.

in this section we will outline a few examples of supervised learning for model-
ing the experience of players. to best cover the material (methods, algorithms, uses
of models) we rely on studies which have been thoroughly examined in the litera-
ture. in particular, in the remainder of this section we outline the various approaches
and extensive methodology for modeling experience in two games: a variant of the
popular super mario bros (nintendo, 1985) game and a 3d prey-predator game
named maze-ball.

5.7.2.1 modeling player experience in super mario bros

our    rst example builds upon the work of pedersen et al. [521, 520] who modi   ed
an open-source clone of the classic platform game super mario bros (nintendo,
1985) to allow for personalized level generation. that work is important in that it
set the foundations for the development of the experience-driven procedural content

5.7. what can we model?

247

generation framework [783] which constitutes a core research trend within proce-
dural content generation (see also chapter 4).

the game used in this example is a modi   ed version of markus persson   s in   -
nite mario bros which is a public domain clone of nintendo   s classic platform game
super mario bros (nintendo, 1985). all experiments reported in this example rely
on a model-free approach for the modeling of player experience. models of player
experience are based on both the level played (game context) and the player   s play-
ing style. while playing, the game recorded a number of behavioral metrics of the
players, such as the frequency of jumping, running and shooting, that are taken into
consideration for modeling player experience. further, in a follow-up experiment
[610], the videos of players playing the game were also recorded and used to extract
a number of useful visual cues such as the average head movement during play. the
output (ground truth of experience) for all experiments is provided as    rst-person,
rank-based reports obtained via id104. data was crowdsourced from hun-
dreds of players, who played pairs of levels with different level parameters (e.g.,
dissimilar numbers, sizes and placements of gaps) and were asked to rank which
of two levels best induced a number of player states. across the several studies of
player experience modeling for this variant of super mario bros (nintendo, 1985)
collectively players have been asked to annotate fun, engagement, challenge, frus-
tration, predictability, anxiety, and boredom. these are the target outputs the player
model needs to predict based on the input parameters discussed above.

given the rank-based nature of the annotations the use of preference learning is
necessary for the construction of the player model. the collected data is used to train
arti   cial neural networks that predict the players    experiential states, given a player   s
behavior (and/or affective manifestations) and a particular game context, using evo-
lutionary preference learning. in neuroevolutionary preference learning [763], a
genetic algorithm evolves an arti   cial neural network so that its output matches the
pairwise preferences in the data set. the input of the arti   cial neural network is
a set of features that have been extracted from the data set   as mentioned earlier,
the input may include gameplay and/or objective data in this example. it is worth
noting that automatic feature selection is applied to pick the set of features (model
input) that are relevant for predicting variant aspects of player experience. the ge-
netic algorithm implemented uses a    tness function that measures the difference
between the reported preferences and the relative magnitude of the model output.
neuroevolutionary preference learning has been used broadly in the player model-
ing literature and the interested reader may refer to the following studies (among
many): [432, 610, 763, 521, 520, 772].

the id104 experiment of pedersen et al. [521, 520] resulted in data
(gameplay and subjective reports of experience) from 181 players. the best pre-
dictor of reported fun reached an accuracy of around 70% on unseen subjective
reports of fun. the input of the neural network fun-model is obtained through au-
tomatic feature selection consists of the time mario spent moving left, the number
of opponents mario killed from stomping, and the percentage of level played in
the left direction. all three playing features appear to contribute positively for the
prediction of reported fun in the game. the best-performing model for challenge

248

chapter 5. modeling players

fig. 5.13 facial feature tracking for head movement. image adapted from [610].

prediction had an accuracy of approximately 78%. it is more complex than the best
fun predictor, using    ve features: time mario spends standing still, jump dif   culty,
coin blocks mario pressed, number of cannonballs mario killed, and mario kills by
stomping. finally, the best predictor for frustration reaches an accuracy of 89%. it
is indeed an impressive    nding that a player experience model can predict (with
near-certainty) whether the player is frustrated by the current game by merely cal-
culating the time mario spent standing still, the time mario spent on its last life, the
jump dif   culty, and the deaths mario had from falling in gaps. the general    ndings
of pedersen et al. [520] suggest that good predictors for experience can be found
if a preference learning approach is applied on crowdsourced reports of experience
and gameplay data. the prediction accuracies, however, depend on the complexity
of the reported state   arguably fun is a much more complicated and fuzzier notion
to report compared to challenge or frustration. in a follow up study by pedersen
et al. [521] the additional player states of predictability, anxiety and boredom were
predicted with accuracies of approximately 77%, 70% and 61%, respectively. the
same player experience methodology was tested on an even larger scale, soliciting
data from a total number of 780 players of the game [621]. frequent pattern mining
algorithms were applied to the data to derive frequent sequences of player actions.
using sequential features of gameplay the models reach accuracies of up to 84% for
engagement, 83% for frustration and 79% for challenge.

in addition to the behavioral characteristics the visual cues of the player can be
taken into account as objective input to the player model. in [610] visual features
were extracted from videos of 58 players, both throughout whole game sessions and
during small periods of critical events such as when a player completes a level or
when the player loses a life (see figs. 5.13 and 5.14). the visual cues enhance the
quality of the information we have about a player   s affective state which, in turn,
allows us to better approximate player experience. speci   cally, fusing the game-
play and the visual reaction features as inputs to the arti   cial neural network we
achieve average accuracies of up to 84%, 86% and 84% for predicting reported en-
gagement, frustration and challenge, respectively. the key    ndings of [610] suggest

5.7. what can we model?

249

(a) winning

(b) losing

(c) experiencing challenge

(d) experiencing challenge

fig. 5.14 examples of facial expressions of super mario bros (nintendo, 1985) players for differ-
ent game states. all images are retrieved from the platformer experience dataset [326].

that players    visual reactions can provide a rich source of information for modeling
experience preferences and lead to more accurate models of player experience.

5.7.2.2 modeling player experience in maze-ball

our second example for modeling player experience builds largely upon the exten-
sive studies of mart    nez et al. [434, 430, 435] who analyzed player experience us-
ing a simple 3d prey-predator game named maze-ball towards achieving affective-
driven camera control in games. while the game is rather simple, the work on maze-
ball offers a thorough analysis of player experience via a set of sophisticated tech-
niques for capturing the psychophysiological patterns of players including prefer-
ence learning, frequent pattern mining and deep convolutional neural networks. in
addition the dataset that resulted from these studies is publicly available for further
experimentation and forms a number of suggested exercises for this book.

maze-ball is a three-dimensional prey-predator game (see fig. 5.15); similar to
a 3d version of pac-man (namco,1981). the player (prey) controls a ball which

250

chapter 5. modeling players

(a) maze-ball

(b) space-maze

fig. 5.15 early maze-ball prototype (a) and a polished variant of
that
features real-time camera adaptation [345]. the games can be found and played at
http://www.hectorpmartinez.com/.

the game (b)

moves inside a maze hunted by 10 opponents (predators) moving around the maze.
the goal of the player is to maximize her score by gathering as many tokens, scat-
tered in the maze, as possible while avoiding being touched by the opponents in a
prede   ned time window of 90 seconds. a detailed description of maze-ball game-
play can be found in [780].

gameplay attributes and physiological signals (skin conductance and heart rate
variability) were acquired from 36 players of maze-ball. each subject played a pre-
de   ned set of eight games for 90 seconds, thus the total number of game sessions
available is 288. gameplay and physiological signals de   ne the input of the player
experience model. to obtain the ground truth of experience players self-reported
their preference about game pairs they played using a rank-based questionnaire, in
particular a 4-alternative forced choice (4-afc) protocol [780]. they were asked to
rank the two games of each game pair with respect to fun, challenge, boredom, frus-
tration, excitement, anxiety and relaxation. these annotations are the target outputs
the player model will attempt to predict based on the input parameters discussed
above.

several features were extracted from the gameplay and physiological signals ob-
tained. these included features related to kills and deaths in the game as well as
features associated with the coverage of the level. for extracting features from the
physiological signals the study considered their average, standard deviation, and
maximum and minimum values. the complete feature list and the experimental pro-
tocol followed can be found in [780].

as in the example with the game variant of super mario bros (nintendo, 1985)
the rank-based nature of the annotations requires the use of preference learning for
the construction of the player experience model. thus, the collected data is used to
train neural networks that predict the player states, given a player   s gameplay be-
havior and its physiological manifestations, using evolutionary preference learning.
the architecture of the neural network can be either shallow using a simple multi-
layered id88 or deep (using convolutional neural networks [430, 435]). figure
5.16 shows the different ways information from gameplay and physiology can been

5.7. what can we model?

251

fig. 5.16 three dissimilar approaches to deep multimodal fusion via convolutional neural net-
works. gameplay events are fused with skin conductance in this example. the networks illustrated
present two layers with one neuron each. the    rst convolutional layer receives as input a contin-
uous signal at a high time resolution, which is further reduced by a pooling layer. the resulting
signal (feature map) presents a lower time resolution. the second convolutional layer can combine
this feature map with additional modalities at the same low resolution. in the convolution fusion
network (left    gure), the two events are introduced at this level as a pulse signal. in the pooling
fusion network (middle    gure), the events are introduced as part of the    rst pooling layer, resulting
in a    ltered feature map. finally, in the training fusion network (right    gure), the events affect
the training process of the    rst convolutional layer, leading to an alternative feature map. image
adapted from [435].

fused on a deep convolutional neural network which is trained via preference
learning to predict player experience in any game experience dataset that contains
discrete in-game events and continuous signals (e.g., the player   s skin conductance).
predictors of the player experience states can reach accuracies that vary from
72% for challenge up to 86% for frustration using a shallow multi-layer percep-
tron player model [780]. signi   cant improvements are observed in those accuracies
when the input space of the model is augmented with frequent sequences of in-game
and physiological events (i.e., fusion on the input space). as in [621], mart    nez et
al. used gsp to extract those frequent patterns that were subsequently used as in-
puts of the player model [434]. further accuracy improvements can be observed
when physiology is fused with physiological signals on deep architectures of con-
volutional neural networks [435]. using deep fusion (see fig. 5.16) accuracies of
predicting player experience may surpass 82% for all player experience states con-
sidered. further information about the results obtained in the maze-ball game can
be found in the following studies: [780, 434, 430, 435, 436].

252

5.8 further reading

chapter 5. modeling players

for an extensive reading on game and player analytics (including visualization,
id174, data modeling and game domain-dependent tasks) we refer the
reader to the edited book by el-nasr et al. [186]. when it comes to player modeling
two papers offer complementary perspectives and taxonomies of player modeling
and a thorough discussion on what aspects of players can be modeled and the ways
players can be modeled: the survey papers of smith et al. [636] and yannakakis et
al. [782].

5.9 exercises

in this section we propose a set of exercises for modeling both the behavior and the
experience of game players. for that purpose, we outline a number of datasets that
can be used directly for analysis. please note, however, that the book   s website will
remain up to date with more datasets and corresponding exercises beyond the ones
covered below.

5.9.1 player behavior

a proposed semester-long game data mining project is as follows. you have to
choose a dataset containing player behavioral attributes to apply the necessary pre-
processing on the data such as extracting features and selecting features. then you
must apply a relevant unsupervised learning technique for compressing, analyz-
ing, or reducing the dimensionality of your dataset. based on the outcome of unsu-
pervised learning you will need to implement a number of appropriate supervised
learning techniques that learn to predict a data attribute (or a set of attributes). we
leave the selection of algorithms to the reader or the course instructor. below we dis-
cuss a number of example datasets one might wish to start from; the reader, however,
may refer to the book   s website for more options on game data mining projects.

5.9.1.1 steamspy dataset

steamspy (http://steamspy.com/) is a rich dataset of thousands of games released on
steam6 containing several attributes each. while strictly not a dataset focused on
player modeling, steamspy offers an accessible and large dataset for game analyt-
ics. the data attributes of each game include the game   s name, the developer, the
publisher, the score rank of the game based on user reviews, the number of owners

6 http://store.steampowered.com/

5.9. exercises

253

of the game on steam, the people that have played this game since 2009, the people
that have played this game in the last two weeks, the average and median playtime,
the game   s price and the game   s tags. the reader may use an api7 to download all
data attributes from all games contained in the dataset. then one might wish to apply
supervised learning to be able to predict an attribute (e.g., the game   s price) based
on other game features such as the game   s score, release date and tags. or alterna-
tively, one might wish to construct a score predictor of a new game. the selection
of the modeling task and the ai methods is left to the reader.

5.9.1.2 starcraft: brood war repository

the starcraft: brood war repository contains a number of datasets that include
thousands of professional starcraft replays. the various data mining papers, datasets
as well as replay websites, crawlers, packages and analyzers have been compiled by
alberto uriarte at drexel university.8 in this exercise you are faced with the chal-
lenge of mining game replays with the aim to predict a player   s strategy. some
results on the starcraft: brood war datasets can be found in [750, 728, 570] among
others.

5.9.2 player experience

as a semester project on player experience modeling it is suggested you choose
a game, one or more affective or cognitive states to model (model   s output) and
one or more input modalities. you are expected to collect empirical data using your
selected game and build models for the selected psychological state of the players
that rely on the chosen input modalities.

as a smaller project that does not involve data collection you may opt to choose
one of the following datasets and implement a number of ai methods that will de-
rive accurate player experience models. the models should be compared in terms of
a performance measure. the two datasets accompanying this book and outlined be-
low are the platformer experience dataset and the maze-ball dataset. the book   s
website will be up to date with more datasets and exercises beyond the ones covered
below.

5.9.2.1 platformer experience dataset

the extensive analysis of player experience in super mario bros (nintendo, 1985)
and our wish to further advance our knowledge and understanding on player expe-

7 http://steamspy.com/api.php
8 available at: http://nova.wolfwork.com/datamining.html

254

chapter 5. modeling players

rience had led to the construction of the platformer experience dataset [326]. this
is the    rst open-access game experience corpus that contains multiple modalities of
data from players of in   nite mario bros, a variant of super mario bros (nintendo,
1985). the open-access database can be used to capture aspects of player experi-
ence based on behavioral and visual recordings of platform game players. in addi-
tion, the database contains aspects of the game context   such as level attributes   
demographic data of the players and self-reported annotations of experience in two
forms: ratings and ranks.

here are a number of questions you might wish to consider when attempting to
build player experience models that are as accurate as possible: which ai methods
should i use? how should i treat my output values? which feature extraction and
selection mechanism should i consider? the detailed description of the dataset can
be found here: http://www.game.edu.mt/ped/. the book website contains further
details and a set of exercises based on this dataset.

5.9.2.2 maze-ball dataset

as in the case of the platformer experience dataset the maze-ball dataset is also
publicly available for further experimentation. this open-access game experience
corpus contains two modalities of data obtained from maze-ball players: their
gameplay attributes and three physiological signals: blood volume pulse, heart rate
and skin conductance. in addition, the database contains aspects of the game such as
features of the virtual camera placement. finally the dataset contains demographic
data of the players and self-reported annotations of experience in two forms: ratings
and ranks.

the aim, once again, is to construct the most accurate models of experience for
the players of maze-ball. so, which modalities of input will you consider? which
annotations are more reliable for predicting player experience? how will your sig-
nals be processed? these are only a few of the possible questions you will en-
counter during your efforts. the detailed description of the dataset can be found
here: http://www.hectorpmartinez.com/. the book website contains further details
about this dataset.

5.10 summary

this chapter focused on the use of ai for modeling players. the core reasons why
ai should be used for that purpose is either to derive something about the players   
experience (how they feel in a game) or for us to understand something about their
behavior (what they do in a game). in general we can model player behavior and
player experience by following a top-down or a bottom-up approach (or a mix of
the two). top-down (or model-based) approaches have the advantage of solid the-
oretical frameworks usually derived from other disciplines or other domains than

5.10. summary

255

games. bottom-up (or model-free) instead rely on data from players and have the
advantage of not assuming anything about players other than that player experience
and behavior are associated with data traces left by the player and that these data
traces are representative of the phenomenon we wish to explain. while a hybrid
between model-based and model-free approaches is in many ways a desirable ap-
proach to player modeling, we focus on bottom-up approaches, where we provide
a detailed taxonomy for the options available regarding the input and the output of
the model, and the modeling mechanism per se. the chapter ends with a number
of player modeling examples, for modeling both the behavior of players and their
experience.

the player modeling chapter is the last chapter of the second part of this book,
which covered the core uses of ai in games. the next chapter introduces the third
and last part of the book, which focuses on the holistic synthesis of the various ai
areas, the various methods and the various users of games under a common game
ai framework.

part iii
the road ahead

chapter 6
game ai panorama

this chapter attempts to give a high-level overview of the    eld of game ai, with
particular reference to how the different core research areas within this    eld inform
and interact with each other, both actually and potentially. for that purpose we    rst
identify the main research areas and their sub-areas within the game ai    eld. we
then view and analyze the areas from three key perspectives: (1) the dominant ai
method(s) used under each area; (2) the relation of each area with respect to the end
(human) user; and (3) the placement of each area within a human-computer (player-
game) interaction perspective. in addition, for each of these areas we consider how
it could inform or interact with each of the other areas; in those cases where we    nd
that meaningful interaction either exists or is possible, we describe the character of
that interaction and provide references to published studies, if any.

the main motivations for us writing this chapter is to help the reader understand
how a particular area relates to other areas within this increasingly growing    eld,
how the reader can bene   t from knowledge created in other areas and how the reader
can make her own research more relevant to other areas. to facilitate and foster
synergies across active research areas we place all key studies into a taxonomy with
the hope of developing a common understanding and vocabulary within the    eld of
ai and games. the structure of this chapter is based on the    rst holistic overview of
the game ai    eld presented in [785]. the book takes a new perspective on the key
game ai areas given its educational and research focus.

the main game ai areas and core subareas already identi   ed in this book and

covered in this chapter are as follows:
    play games (see chapter 3) which includes the subareas of playing to win and
playing for the experience. independently of the purpose (winning or experi-
ence) ai can control either the player character or the non-player character.
    generate content (see chapter 4) which includes the subareas of autonomous
(procedural) content generation and assisted content generation. please note that
the terms assisted (procedural) content generation and mixed-initiative (proce-
dural) content generation (as de   ned in chapter 4) are used interchangeably in
this chapter.

259

chapter 6. game ai panorama
260
    model players (see chapter 5) which includes the subareas of player experience

modeling and player behavior modeling, or else, game data mining [178].

the scope of this chapter is not to provide an inclusive survey of all game ai
areas   the details of each area have been covered in preceding chapters of the
book   but rather a roadmap of interconnections between them via representative
examples. as research progresses in this    eld, new research questions will pop up
and new methods be invented, and other questions and methods recede in impor-
tance. we believe that all taxonomies of research    elds are by necessity tentative.
consequently, the list of areas de   ned in this chapter should not be regarded as    xed
and    nal.

the structure of the chapter is as follows: in section 6.1, we start by holistically
analyzing the game ai areas within the game ai    eld and we provide three alter-
native views over game ai: one with respect to the methods used, one with respect
to the end users within game research and development and one where we outline
how each of the research areas    ts within the player-game interaction loop of digital
games. then, section 6.2, digs deeper into the research areas and describes each
one of them in detail. with the subsection describing each area, there is a short de-
scription of the area and a paragraph on the possible interactions with each of the
other areas for which we have been able to identify strong or weak in   uences . the
chapter ends with a section containing our key conclusions and vision for the future
of the    eld.

6.1 panoramic views of game ai

analyzing any research    eld as a composition of various subareas with intercon-
nections and interdependencies can be achieved in several different ways. in this
section we view game ai research from three high-level perspectives that focus on
the computer (i.e., the ai methods), the human (i.e., the potential end user of game
ai) and the interaction between the key end user (i.e., player) and the game. in-
stead in section 6.2 we outline each game ai area and present the interconnections
between the areas.

game ai is composed of (a set of) methods, processes and algorithms in arti   cial
intelligence as those are applied to, or inform the development of, games. naturally,
game ai can be analyzed through the method used by identifying the dominant ai
approaches under each game ai area (see section 6.1.1). alternatively, game ai
can be viewed from the game domain perspective with a focus on the end users
of each game ai area (see section 6.1.2). finally game ai is, by nature, realized
through systems that entail rich human-computer interaction (i.e., games) and, thus,
the different areas can be mapped to the interaction framework between the player
and the game (see section 6.1.3).

6.1. panoramic views of game ai

261

table 6.1 dominant (   ) and secondary (   ) ai methods for each of the core ai areas we cover in
this book. the total number of methods used for each area appears at the bottom row of the table.

play games

generate content

model players

winning experience autonomously assisted experience behavior

behavior authoring
tree search
evolutionary computation
supervised learning
id23
unsupervised learning
total (dominant)

   
   
   
   
   

   
   
   
   
   

5 (4)

5 (2)

2 (1)

   
   

   
   

   
3 (1)

   
   
   
3 (2)

   
   
2 (2)

6.1.1 methods (computer) perspective

the    rst panoramic view of game ai we present is centered around the ai meth-
ods used in the    eld. as the basis of this analysis we    rst list the core ai methods
mostly used in the game ai    eld. the key methodology areas identi   ed in chapter
2 include ad-hoc behavior authoring, tree search, evolutionary computation, rein-
forcement learning, supervised learning, and unsupervised learning. for each of the
game ai areas investigated we have identi   ed the ai methods that are dominant
or secondary in the area. while the dominant methods represent the most popular
techniques used in the literature, secondary methods represent techniques that have
been considered from a substantial volume of studies but are not dominant.

we have chosen to group methods according to what we perceive as a received
taxonomy and following the structure of chapter 2. while it would certainly be pos-
sible to classify the various methods differently, we argue that the proposed classi-
   cation is compact (containing solely key methodology areas) and it follows stan-
dard method classi   cations in ai. while this taxonomy is commonly accepted, the
lines can be blurred. in particular evolutionary computation, being a very general
optimization method, can be used to perform supervised, unsupervised or reinforce-
ment learning (more or less pro   ciently). the model-building aspect of reinforce-
ment learning can be seen as a supervised learning problem (mapping from action
sequences to rewards), and the commonly used tree search method monte carlo tree
search can be seen as a form of td learning. the result of any tree search algorithm
can be seen as a plan, though it is often not guaranteed to lead to the desired end
state. that the various methods have important commonalities and some overlap
does not detract from the fact that each of them is clearly de   ned.

table 6.1 illustrates the relationship between game ai areas and correspond-
ing methods. it is evident that evolutionary computation and supervised learning
appear to be of dominant or secondary use in most game ai areas. evolutionary
computation is a dominant method for playing to win, for generating content (in an
assisted/mixed-initiative fashion or autonomously), and for modeling players; it has
also been considered for the design of believable play (play for experience) research.
supervised learning is of substantial use across the game ai areas and appears to be

262

chapter 6. game ai panorama

dominant in player experience and behavioral modeling, as well as in the area of ai
that plays for experience. behavior authoring, on the other hand, is useful solely for
game-playing. id23 and unsupervised learning    nd limited use
across the game ai areas, respectively, being dominant only on ai that plays to win
and player behavior modeling. finally, tree search    nds use primarily in playing
to win and it is also considered   as a form of planning   for controlling play for
experience and in computational narrative (as part of autonomous or assisted pcg).
viewing table 6.1 from the game ai areas    perspective (columns) it seems that
ai that plays games (either for wining or for the experience) de   nes the game ai
area with the most diverse and richest palette of ai methods. on the contrary, proce-
dural content generation is solely dominated by evolutionary computation and tree
search to a secondary degree. it is important to state that the popularity of any ai
method within a particular area is closely tied to the task performed or the goal in
mind. for example, evolutionary computation is largely regarded as a computation-
ally heavy process which is mostly used in tasks associated with of   ine training. as
pcg so far mainly relies on content that is generated of   ine, evolutionary compu-
tation offers a good candidate method and the core approach behind search-based
pcg [720]. if online learning is a requirement for the task at hand, however, other
methods (such as id23 or pruned tree-search) tend to be preferred.
clearly the possibility space for future implementations of ai methods under
particular game ai areas seems rather large. while particular methods have been
traditionally dominant in speci   c areas for good reasons (e.g., planning in compu-
tational narrative) there are equally good reasons to believe that the research in a
game ai area itself has been heavily in   uenced by (and limited to) its correspond-
ing dominant ai methods. the empty cells of table 6.1 indicate potential areas for
exploration and offer us an alternative view of promising new intersections between
game ai areas and methods.

6.1.2 end user (human) perspective

the second panoramic view of the game ai    eld puts an emphasis on the end user
of the ai technology or general outcome (product or solution). towards that aim we
investigate three core dimensions of the game ai    eld and classify all game ai areas
with respect to the process ai follows, the game context under which algorithms
operate and,    nally, the end user that bene   ts most from the resulting outcome. the
classes identi   ed under the above dimensions are used as the basis of the taxonomy
we propose.

the    rst dimension (phrased as a question) refers to the ai process: in general,
what can ai do within games? we identify two potential classes in this dimension:
ai can model or generate. for instance, an arti   cial neural network can model
a playing pattern, or a genetic algorithm can generate game assets. given that ai
can model or generate the second dimension refers to the context: what can ai
methods model or generate in a game? the two possible classes here are content

6.1. panoramic views of game ai

263

fig. 6.1 the end user perspective of the identi   ed game ai areas. each ai area follows a process
(model or generate) under a context (content or behavior) for a particular end user (designer,
player, ai researcher or game producer/publisher). blue and red arrows represent the processes of
modeling and generation, respectively. modi   ed graph from [785].

and behavior. for example, ai can model a players    affective state, or generate a
level. finally, the third dimension is the end user: ai can model, or generate, either
content or behavior; but, for whom? the classes under the third dimension are the
designer, the player, the ai researcher, and the producer/publisher.

note that the above taxonomy serves as a framework for classifying the game
ai areas according to the end user and is, by no means, inclusive of all potential
processes, contexts, and end users. for instance, one could claim that the producer   s
role should be distinct from the publisher   s role and that a developer should also be
included in that class. moreover, game content could be further split into smaller
sub-classes such as narrative, levels, etc. nevertheless, the proposed taxonomy pro-
vides distinct roles for the ai process (model vs. generate vs. evaluate), clear-cut
classi   cation for the context (content vs. behavior) and a high-level classi   cation of
the available stakeholders in game research and development (designer vs. player
vs. ai researcher vs. producer/publisher). the taxonomy presented here is a modi-
   ed version of the one introduced in [785] and it does not consider evaluation as a
process for ai since it is out of the primary scope of this book.

figure 6.1 depicts the relationship between the game ai core areas, the subareas
and the end users in game research and development. assisted, or mixed-initiative,
content generation is useful for the designer and entails all possible combinations of
processes and context as both content and behavior can be either modeled or gener-
ated for the designer. compared to the other stakeholders the player bene   ts directly
from more game ai research areas. in particular the player and her experience are
affected by research on player modeling, which results from the modeling of ex-
perience and behavior; research on autonomous procedural content generation, as

264

chapter 6. game ai panorama

a result of generation of content; and studies on npc playing (for wining or expe-
rience) resulting from the generation of behavior. the player character (pc)-based
game playing (for winning or experience) areas provide input to the ai researcher
primarily. finally, the game producer/publisher is primarily affected by results on
behavioral player modeling, game analytics and game data mining as a result of
behavior modeling.

6.1.3 player-game interaction perspective

the third and    nal panoramic perspective of game ai presented in this section
couples the computational processes with the end user within a game and views
all game ai areas through a human-computer interaction   or, more accurately, a
player-game interaction   lens. the analysis builds on the    ndings of section 6.1.2
and places the    ve game ai areas that concern the player as an end user on a player-
game interaction framework as depicted in fig. 6.2. putting an emphasis on player
experience and behavior, player modeling directly focuses on the interaction be-
tween a player and the game context. game content is in   uenced primarily by re-
search on autonomous procedural content generation. in addition to other types of
content, most games feature npcs, the behavior of which is controlled by some
form of ai. npc behavior is informed by research in npcs that play the game to
win or any other playing-experience purpose such as believability.

looking at the player-game interaction perspective of game ai it is obvious that
the player modeling area has the most immediate and direct impact on the player
experience as it is the only area linked to the player-game interaction directly. from
the remaining areas, pcg in   uences player experience the most as all games have
some form of environment representation and mechanics. finally, ai that plays as
an npc (either to win or for the experience of play) is constrained to games that
include agents or non-player characters.

the areas not considered directly in this game ai perspective affect the player
rather remotely. research on ai tools that assist the generative process of content
improves the game   s quality as a whole and in retrospect the player experience since
designers tend to maintain a second-order player model [378] while designing. fi-
nally, ai that plays the game as a player character can be offered for testing both the
content and the npc behaviors of a game, but also the interaction between the player
and the game (via e.g., player experience competitions), but is mainly directed to ai
researchers (see fig. 6.1).

6.2 how game ai areas inform each other

in this section, we outline the core game ai areas and discuss how they inform or
in   uence (the terms are used interchangeably) each other. all research areas could

6.2. how game ai areas inform each other

265

fig. 6.2 game ai areas and sub-areas viewed from a player-game interaction perspective.

be seen as potentially in   uencing each other to some degree; however, making a list
of all such in   uences would be impractical and the result would be uninteresting.
therefore we only describe direct in   uences. direct in   uences can be either strong
(represented by a     as the bullet point style next to the corresponding in   uence in
the following lists) or weak (represented by a    ). we do not list in   uences we do
not consider potentially important for the informed research area, or which only go
through a third research area.

the sections below list outgoing in   uence. therefore, to know how area a in-
   uences area b you should look in the section describing area a. some in   uences
are mutual, some not. the notation a     b in the headings of this section denotes
that    a in   uences b   . in addition to the text description each section provides a    g-
ure representing all outgoing in   uences of the area as arrows. dark and light gray
colored areas represent, respectively, strong and weak in   uence. areas with white
background are not in   uenced by the area under consideration. the    gures also de-
pict the incoming in   uences from other areas. incoming strong and weak in   uences
are represented, respectively, with a solid line and a dashed line around the game
ai areas that in   uence the area under consideration. note that the description of the

266

chapter 6. game ai panorama

incoming in   uence from an area is presented in the corresponding section of that
area.

6.2.1 play games

the key area in which ai plays a game (as covered in chapter 3) involves the sub-
areas of playing to win and playing for experience. as mentioned earlier in the
chapter the ai can control either player or non-player characters of the game. we
cover the in   uences to (and from) these subareas of game ai in this section.

6.2.1.1 playing to win (as a player or as a non-player)

as already seen in chapter 3 research in ai that learns to play (and win) a game
focuses on using id23 techniques such as temporal difference
learning or evolutionary algorithms to learn policies/behaviors that play games
well   whether it is a pc or an npc playing the game. from the very beginning of ai
research, id23 techniques have been applied to learn how to play
board games (see for example samuel   s checkers player [591]). basically, playing
the game is seen as a id23 problem, with the reinforcement tied
to some measure of success in the game (e.g., the score, or length of time survived).
as with all id23 problems, different methods can be used to solve
the problem (   nd a good policy) [715] including td learning [689], evolutionary
computation [406], competitive co-evolution [24, 538, 589, 580], simulated anneal-
ing [42], other optimization algorithms and a large number of combinations between
such algorithms [339]. in recent years a large number of papers that describe the
application of various learning methods to different types of video games have ap-
peared in the literature (including several overviews [470, 406, 632, 457]). finally,
using games to develop arti   cial general intelligence builds on the idea that games
can be useful environments for algorithms to learn complex and useful behaviors;
thus research in algorithms that learn to win is essential.

it is also worth noting that most existing game-based benchmarks measure how
well an agent plays a game   see for example [322, 404, 504]. methods for learning
to play a game are vital for such benchmarks, as the benchmarks are only meaningful
in the context of the algorithms. when algorithms are developed that    beat    existing
benchmarks, new benchmarks need to be developed. for example, the success of an
early planning agent in the    rst mario ai competition necessitated that the software
be augmented with a better level generator for the next competition [322], and for
the simulated car racing competition, the performance of the best agents on the
original competition game spurred the change to a new more sophisticated racing
game [710, 392].

6.2. how game ai areas inform each other

267

fig. 6.3 playing to win: in   uence on (and from) other game ai research areas. outgoing in-
   uence (represented by arrows): black and dark gray colored areas reached by arrows represent,
respectively, strong and weak in   uence. incoming in   uence is represented by red lines around
the areas that in   uence the area under investigation (i.e., ai that plays to win in this    gure): strong
and weak in   uences are represented, respectively, by a solid and a dashed line.

research in this area impacts game ai at large as three game ai subareas are
directly affected; in turn, one subarea is directly affecting ai that plays to win (see
fig. 6.3).
    playing to win     playing for the experience: an agent cannot be believable
or existent to augment the game   s experience if it is not pro   cient. being able
to play a game well is in several ways a precondition for playing games in a be-
lievable manner though well playing agents can be developed without learning
(e.g., via top-down approaches). in recent years, successful entries to competi-
tions focused on believable agents, such as the 2k botprize and the mario ai
championship turing test track, have included a healthy dose of learning algo-
rithms [719, 603].
    playing to win     generate content (autonomously): having an agent that
is capable of playing a game pro   ciently is useful for simulation-based testing
in procedural content generation, i.e., the testing of newly generated game con-
tent by playing through that content with an agent. for example, in a program
generating levels for the platform game super mario bros (nintendo, 1985), the
levels can be tested by allowing a trained agent to play them; those that the agent
cannot complete can be discarded [335]. browne   s ludi system, which generates
complete board games, evaluates these games through simulated playthrough and
uses learning algorithms to adapt the strategy to each game [74].
    playing to win     generate content (assisted): just as with autonomous pro-
cedural content generation, many tools for ai-assisted game design rely on being
able to simulate playthroughs of some aspect of the game. for instance, the sen-
tient sketchbook tool for level design uses simple simulations of game-playing
agents to evaluate aspects of levels as they are being edited by a human de-

268

chapter 6. game ai panorama

signer [379]. another example is the automated playtesting framework named
restricted play [295] which aims mostly at assisting designers on aspects of
game balance during game design. a form of restricted play is featured in the
ludocore game engine [639].

6.2.1.2 playing for the experience (as a player or as a non-player)

research on ai that plays a game for a purpose other than winning is central to
studies where playing the game well is not the primary research aim. ai can play
the game as a player character attempting to maximize the believability value of
play as, for instance, in [719, 619, 96]. it can alternatively play the game in a role of
an npc for the same purpose [268]. work under this research subarea involves the
study of believability, interestingness or playing experience in games and the inves-
tigations of mechanisms for the construction of agent architectures that appear to
have e.g., believable or human-like characteristics. the approaches for developing
such architectures can be either top-down behavior authoring (such as the fatima
model used in my dream theatre [100] and the mind module model [191] used in
the pataphysic institute) or bottom-up attempting to imitate believable gameplay
from human players such as the early work of thurau et al. in quake ii (activision,
1997) bots [696], the human imitation attempts in super mario bros (nintendo,
1985) [511], the unreal tournament 2004 (epic games, 2004) believable bots of
schrum et al. [603] and the id104 studies of the restaurant game [508].
evidently, commercial games have for long bene   ted from agent believability re-
search. examples of this include popular games such as the sims (electronic arts,
2000) series. the industry puts a strong emphasis on the design of believability in
games as this contributes to more immersive game environments. the funding of
believability research through game ai competitions such as the 2k botprize is one
of the many clear indicators of the commercial value of agent believability.

over the last few years there has been a growing academic (and commercial)
interest in the establishment of competitions that can be used as assessment tools
for agent believability [719]. agent believability research has provided input and
given substance to those game benchmarks. a number of game turing competitions
have been introduced to the bene   t of agent believability research, including the
2k botprize on the unreal tournament 2004 (epic games, 2004) [647, 264] game
and the mario ai championship: turing test track [619] on the super mario bros
(nintendo, 1985) game. recently, the community saw ai agents passing the turing
test in the 2k botprize [603].

the study of ai that plays games not for winning, but for other purposes, affects
research on three other game ai areas as illustrated in fig. 6.4, whereas it is affected
by four other game ai areas.
    playing for the experience     model players (experience and behavior):
there is a direct link between player modeling and believable agents as research
carried out for the modeling of human, human-like, and supposedly believable
playing behavior can inform the construction of more appropriate models for

6.2. how game ai areas inform each other

269

fig. 6.4 playing for the experience: in   uence on (and from) other game ai research areas.

players. examples include the imitation of human play styles in super mario
bros (nintendo, 1985) [511] and quake ii (activision, 1997) [696]. though
computational player modeling uses learning algorithms, it is only in some cases
that it is the behavior of an npc that is modeled. in particular, this is true when
the in-game behavior of one or several players is modeled. this can be done using
either id23 techniques, or supervised learning techniques such
as id26 or id90. in either case, the intended outcome for the
learning algorithm is not necessarily an npc that plays as well as possible, but
one that plays in the style of the modeled player [735, 511].
    playing for the experience     generate content (autonomously): believ-
able characters may contribute to better levels [96], more believable stories
[801, 401, 531] and, generally, better game representations [563]. a typical ex-
ample of the integration of characters in the narrative and the drive of the lat-
ter based on the former includes the fatima agents in fearnot! [516] and my
dream theater [100]. another example is the generation of super mario bros
(nintendo, 1985) levels that maximize the believability of any mario player [96].

6.2.2 generate content

as covered in detail in chapter 4 ai can be used to design whole (or parts of) games
in an autonomous or in an assisted fashion. this core game ai area includes the
subareas of autonomous (procedural) content generation and assisted or mixed-
initiative (procedural) content generation. the interactions of these subareas with
the remaining areas of game ai are covered in this section.

270

chapter 6. game ai panorama

fig. 6.5 generate content (autonomously): in   uence on (and from) other game ai research areas.

6.2.2.1 generate content (autonomously)

as stated in chapter 4 procedural content generation has been included in limited
roles in some commercial games since the early 1980s; however, recent years have
seen an expansion of research on more controllable pcg for multiple types of game
content [764], using techniques such as evolutionary search [720] and constraint
solving [638]. the in   uence of pcg research beyond games is already evident in
areas such as computational creativity [381] and interaction design (among others).
there are several surveys of pcg available, including a recent book [616] and vision
paper [702], as well as surveys of frameworks [783], sub-areas of pcg [554, 732]
and methods [720, 638].

autonomous content generation is one of the areas of recent academic research
on ai in games which bears most promise for incorporation into commercial
games. a number of recent games have been based heavily on pcg, including
independent (   indie   ) game production successes such as spelunky (mossmouth,
2009) and minecraft (mojang, 2011), and mainstream aaa games such as diablo
iii (blizzard entertainment, 2012) and civilization v (2k games, 2010). a notable
example, as mentioned in chapter 4 is no man   s sky (hello games, 2016) with its
quintillion different procedurally generated planets. some games heavily based on
pcg and developed by researchers have been released as commercial games on plat-
forms such as steam and facebook; two good examples of this are petalz [565, 566]
and galactic arms race [249].

figure 6.5 depicts the three (and    ve) areas that are in   uenced by (and in   uence)

autonomous pcg.
    generate content (autonomously)     play to win: if an agent is trained to
perform well in only a single game environment, it is easy to overspecialize the

6.2. how game ai areas inform each other

271

training and arrive at a policy/behavior that will not generalize to other levels.
therefore, it is important to have a large number of environments available for
training. pcg can help with this, potentially providing an in   nite supply of test
environments. for example, when training players for the mario ai champi-
onship it is common practice to test each agent on a large set of freshly generated
levels, to avoid overtraining [322]. there has also been research on adapting
npc behavior speci   cally to generated content [332]. finally, one approach to
arti   cial general intelligence is to train agents to be good at playing games in
general, and test them on a large variety of games drawn from some genre or dis-
tribution. to avoid over   tting, this requires games to be generated automatically,
a form of pcg [598]. the generation of new environments is very important
for npc behavior learning, and this extends to benchmarks that measure some
aspect of npc behavior. apart from the mario ai championship, competitions
such as the simulated car racing championship use freshly generated tracks,
unseen by the participants, to test submitted controllers [102]. but there is also
scope for benchmarks and competitions focused on measuring the capabilities of
pcg systems themselves, such as the level generation track of the mario ai
championship [620].
    generate content (autonomously)     play for the experience: research on
autonomous pcg naturally in   uences research on agent (pc or npc) control for
believability, interestingness or other aims aside from winning given that these
agents are performing in a particular environment and under a speci   c game
context. this in   uence is still in its infancy and the only study we can point the
reader to is the one by camilleri et al. [96] where the impact of level design on
player character believability is examined in super mario bros (nintendo, 1985).
further, research on interactive narrative bene   ts from and in   uences the use of
believable agents that interact with the player and are interwoven in the story
plot. the narrative can yield more (or less) believability to agents and thus the
relationship between the behavior of the agents and the emergent story is strong
[801, 401, 531]. in that sense, the computational narrative of a game may de   ne
the arena for believable agent design.
    generate content (autonomously)     generate content (assisted): as con-
tent design is a central part of game design, many ai-assisted design tools incor-
porate some form of assisted content design. examples include tanagra, which
helps designers create complete platform game levels which ensure playabil-
ity through the use of constraint solvers [641], and sketchaworld [634]. an-
other example is sentient sketchbook, which assists humans in designing strategy
game levels through giving immediate feedback on properties of levels and au-
tonomously suggesting modi   cations [379].

6.2.2.2 generate content (assisted)

assisted content generation refers to the development of ai-powered tools that sup-
port the game design and development process. this is perhaps the ai research area

272

chapter 6. game ai panorama

fig. 6.6 generate content (assisted): in   uence on (and from) other game ai research areas.

which is most promising for the development of better games [764]. in particu-
lar, ai can assist in the creation of game content varying from levels and maps to
game mechanics and narratives. the impact of ai-enabled authoring tools on design
and development in   uences the study of ai that plays games for believability, in-
terestingness or player experience, and research in autonomous procedural content
generation (see fig. 6.6). ai-assisted game design tools range from those designed
to assist with generation of complete game rulesets such as metagame [522] or
rulearn [699] to those focused on more speci   c domains such as strategy game
levels [379], platform game levels [642], horror games [394] or physics-based puz-
zles [613].

it is worth noting that ai tools have been used extensively for supporting design
and commercial game development. examples such as the speedtree (interactive
data visualization inc., 2013) generator for trees and other plants [287] have seen
uses in several game productions. the mixed-initiative pcg tools mentioned above
have a great potential in the near future as most of these are already tested on com-
mercial games or developed with game industrial partners. furthermore, there are
tools designed for interactive modeling and analysis of game rules and mechanics,
which are not focused on generating complete games but on prototyping and un-
derstanding aspects of complex games; such systems could be applied to existing
commercial games [639].
    generate content (assisted)     play for the experience: authoring tools in
forms of open-world sandboxes could potentially be used for the creation of more
believable behaviors. while this is largely still an unexplored area of research
and development, notable attempts include the nero game ai platform where
players can train game agents for ef   cient and believable    rst-person shooter
bot behaviors [654]. an open version of this platform focused on id104
behaviors has been released recently [327]. a similar line of research is the gen-

6.2. how game ai areas inform each other

273

eration of super mario bros (nintendo, 1985) players by means of interactive
evolution [648].
    generate content (assisted)     generate content (autonomously): re-
search on methods of mixed-initiative co-creation [774] and design can feed
input to and spur discussion on central topics in procedural content genera-
tion. given the importance of content design in the development process as
a whole, any form of mixed-initiative ai assistance in the generation process
can support and augment procedural content generation. notable examples of
mixed-initiative pcg include the tanagra platform game level design ai assis-
tant [641], and the sketchaworld [634], the sentient world [380], the sentient
sketchbook [379, 774] and the sonancia [394] systems which generate game
maps and worlds in a mixed-initiative design fashion following different ap-
proaches and levels of human computation. further, tools can assist the author-
ing of narrative in games. in particular, drama management tools have long
been investigated within the game ai community. an academic example is abl
which has allowed the authoring of narrative in fac  ade [441]. among the few
available and well-functional authoring tools the most notable is the versu [197]
storytelling system which was used in the game blood & laurels (emily short,
2014) and the inform 7 [480] software package that led to the design of mystery
house possessed (emily short, 2005). more story generation tools as such can
be found at the http://storygen.org/ repository, by chris martens and rogelio e.
cardona-rivera.

6.2.3 model players

as already explored in chapter 5, modeling players involves the subtasks of mod-
eling their behavior or their experience. given the interwoven nature of these two
tasks we present their in   uences to (and from) other game ai areas under one com-
mon section. in player modeling [782, 636], computational models are created for
detecting how the player perceives and reacts to gameplay. as stated in chapter
5 such models are often built using machine learning methods where data con-
sisting of some aspect of the game or player-game interaction is associated with
labels derived from some assessment of player experience, gathered for example
from questionnaires [781]. however, the area of player modeling is also concerned
with structuring observed player behavior even when no correlates to experience
are available   e.g., for identifying player types or predicting player behavior.

research and development in player modeling can inform attempts for player ex-
perience in commercial-standard games. player experience detection methods and
algorithms can advance the study of user experience in commercial games. in addi-
tion, the appropriateness of sensor technology, the technical plausibility of biofeed-
back sensors, and the suitability of various modalities of human input can inform in-
dustrial developments. quantitative testing via game metrics   varying from behav-
ioral data mining to in-depth low scale studies   is also improved [764, 178, 186].

274

chapter 6. game ai panorama

fig. 6.7 model players: in   uence on (and from) other game ai research areas.

by now, a considerable number of academic studies use directly datasets from com-
mercial games to induce models of players that could inform further development of
the game. for example, we refer the reader to the experiments in id91 players
of tomb raider: underworld (square enix, 2008) into archetypes [176] and pre-
dicting their late-game performance based on early-game behavior [414]. examples
of player modeling components within high-pro   le commercial games include the
arousal-driven appearance of npcs in left 4 dead 2 (valve corporation, 2009), the
fearful combat skills of the opponent npcs in f.e.a.r. (monolith, 2005), and the
avatars    emotion expression in the sims series (maxis, 2000) and black and white
(lionhead studios, 2001). a notable example of a game that is based on player expe-
rience modeling is nevermind (flying mollusk, 2016); the game adapts its content
based on the stress of the player, which is manifested via a number of physiological
sensors.

player modeling is considered to be one of the core non-traditional uses of ai
in games [764] and affects research in ai-assisted game design, believable agents,
computational narrative and procedural content generation (see fig. 6.7).
    model players     play for the experience: player models can inform and up-
date believable agent architectures. models of behavioral, affective and cognitive
aspects of gameplay can improve the human-likeness and believability of any
agent controller   whether it is ad-hoc designed or built on data derived from
gameplay. while the link between player modeling and believable agent design
is obvious and direct, research efforts towards this integration within games are
still sparse. however, the few efforts made on the imitation of human game play-
ing for the construction of believable architectures have resulted in successful
outcomes. for example, human behavior imitation in platform [511] and racing
games [735, 307] has provided human-like and believable agents while similar
approaches for developing unreal tournament 2004 (epic games, 2004) bots
(e.g., in [328]) recently managed to pass the turing test in the 2k botprize com-

6.3. the road ahead

275

petition. notably, one of the two agents that passed the turing test in 2k botprize
managed to do so by imitating (mirroring) aspects of human play [535]. a line
of work that stands in between player modeling and playing games for the ex-
perience is the study on procedural personas [268, 267, 269]. as introduced in
chapter 5 procedural personas are npcs that are trained to imitate realistically
the decision making process of humans during play. their study both in   uences
our understanding about the internal (cognitive) processes of playing behavior
and advances our knowledge on how to build believable characters in games.
    model players     generate content (autonomously): there is an obvious
link between computational models of players and pcg as player models can
drive the generation of new personalized content for the player. the experience-
driven role of pcg [783], as covered in chapter 4, views game content as an
indirect building block of a player   s affective, cognitive and behavioral state and
proposes adaptive mechanisms for synthesizing personalized game experiences.
the    core loop    of an experience-driven pcg solution involves learning a model
that can predict player experience, and then using this model as part of an evalua-
tion function for evolving (or otherwise optimizing) game content; game content
is evaluated based on how well it elicits a particular player experience, accord-
ing to the model. examples of pcg that are driven by player models include
the generation of game rules [716], camera pro   les [780, 85] and platform game
levels [617]. most work that goes under the label    game adaptation    can be said
to implement the experience-driven architecture; this includes work on adapting
the game content to the player using id23 [28] or semantic
constraint solving [398] rather than evolution. player models may also inform
the generation of computational narrative. predictive models of playing experi-
ence can drive the generation of individualized scenarios in a game. examples of
the coupling between player modeling and computational narrative include the
affect-driven narrative systems met in fac  ade [441] and fearnot! [26], and the
affect-centered game narratives such as the one of final fantasy vii (square,
1997).
    model players     generate content (assisted): user models can enhance au-
thoring tools that, in turn, can assist the design process. the research area that
bridges user modeling and ai-assisted design is in its infancy and only a few ex-
ample studies can be identi   ed. indicatively, designer models [378] have been
employed to personalize mixed-initiative design processes [774, 377, 379]. such
models may drive the procedural generation of designer-tailored content.

6.3 the road ahead

this chapter has initially identi   ed the currently most active areas and subareas
within game ai and placed them on three holistic frameworks: an ai method map-
ping, a game stakeholder (end user) taxonomy and the player-game interaction loop.
this analysis revealed dominant ai algorithms within particular areas as well as

276

chapter 6. game ai panorama

room for exploration of new methods within areas. in addition, it revealed the dis-
similar impact of different areas on different end users such as the ai researcher and
the designer and,    nally, outlined the in   uence of the different game ai areas on the
player, the game and their interaction. from the high-level analysis of the game ai
   eld we moved on to the detailed analysis of the game ai areas that compose it and
thoroughly surveyed the meaningful interconnections between the different areas.

the total number of strong and weak in   uences is rather small compared to all
possible interconnections between the areas, which clearly signals the research ca-
pacity of the game ai    eld for further explorations. we can distinguish a number of
connections which are currently very active, meaning that much work currently goes
on in one area that draws on work in another area. here we see, for example, the
connection between ai that plays to win in a general fashion in conjunction with the
use of tree search algorithms: the mcts algorithm was invented in the context of
board game-playing, proved to be really useful in the general game playing compe-
tition, and is being investigated for use in games as different as starcraft (blizzard
entertainment, 1998) and super mario bros (nintendo, 1985). improvements and
modi   cations to the algorithm have been    owing back and forth between the vari-
ous areas. another indicative connection that is alive and strong is between player
modeling and procedural content generation, where it is now common for newly
devised pcg algorithms and experimental studies to include player behavioral or
player experience models.

one can also study the currently strong areas by trying to cluster the trending
topics in recent iterations of the ieee cig and aiide conferences. such studies
always include some form of selection bias, as papers can usually be counted into
more than one area (e.g., depending on if you group by method or domain), but if
you start from the session groupings made by the program chairs of each conference
you achieve at least some inter-subjective validity. according to such a id91,
the most active topics over the last few years have been player (or emotion) model-
ing, game analytics, general game ai, real-time strategy game playing   especially
starcraft (blizzard entertainment, 1998)   and pcg (in general). another perspec-
tive of the trend in game ai research is the varying percentage of studies on npc
(or game agent) behavior learning over other uses of ai in games at the two key
conferences in the    eld (ieee cig and aiide). our preliminary calculations sug-
gest that while, initially, ai was mainly applied for npc control and for playing
board/card games well   more than 75% of cig and aiide papers were linked to
npc behavior and agent game playing in 2005   that trend has drastically changed
as entirely new (non-traditional) uses of ai became more common over the years   
e.g., roughly 52% of the papers in cig and aiide in 2011 did not involve game
agents and npc behavior. these facts indicate a shift in the use of ai in and for
games towards multiple non-traditional applications   which tend to be traditional
by now   for the development of better games [764].

but it is maybe even more interesting to look at all those connections that are
unexploited or underexploited or potentially strong. for example, player modeling
is potentially very important in the development of ai that controls believable, in-
teresting or curious agents, but this has not been explored in enough depth yet; the

6.4. summary

277

same holds for the application of user (or else, designer) modeling principles to-
wards the personalization of ai-assisted game design. believable agents have, in
turn, not been used enough in content generation (either autonomous or assisted).
a grand vision of game ai for the years to come is to let it identify its own role
within game design and development as it sees    t. in the last chapter of this book
we discuss frontier research topics as such and identify unexplored roles of ai in
games.

6.4 summary

we hope that with this chapter of this book, we have been able to give our readers
a sense of how this   by now rather large and multifaceted   research    eld hangs
together, and what could be done to integrate it further. we realize that this is only
our view of its dynamics and interconnections, and that there are (or could be) many
competing views. we look forward to seeing those in upcoming studies in the    eld.
finally, it is important to note that it would have been impossible to provide a
complete survey of all the areas as,    rst, the game ai    eld is growing rapidly and,
second, it is not the core objective of the book. this means that the bibliography
is indicative rather than exhaustive and serves as a general guideline for the reader.
the website of the book, instead of the book per se, will be kept up to date regarding
important new readings for each area.

the next and    nal chapter of the book is dedicated to a few long-standing, yet
rather unexplored, research frontiers of game ai. we believe that any advances made
in these directions will lead to scienti   c breakthroughs not merely within game ai
but largely in both games (their design, technology and analysis) and ai per se.

chapter 7
frontiers of game ai research

in this    nal chapter of the book we discuss a number of long-term visionary goals
of game ai, putting an emphasis on the generality of ai and the extensibility of its
roles within games. in particular, in section 7.1 we discuss our vision for general
behavior for each one of the three main uses of ai in games. play needs to be-
come general; generators are required to have general generative capacities across
games, content types, designers and players; models of players also need to show-
case general modeling abilities. in section 7.2 we also discuss roles of ai that are
still unexplored and certainly worth investigating in the future. the book ends with
a discussion dedicated to general ethical considerations of game ai (section 7.3).

7.1 general general game ai

as evidenced from the large volume of studies the game ai research area has been
supported by an active and healthy research community for more than a decade   
at least since the start of the ieee cig and the aiide conference series in 2005.
before then, research had been conducted on ai in board games since the dawn
of automatic computing. initially, most of the work published at ieee cig or ai-
ide was concerned with learning to play a particular game as well as possible, or
using search/planning algorithms to play a game as well as possible without learn-
ing. gradually, a number of new applications for ai in games and for games in ai
have come to complement the original focus on ai for playing games [764]. papers
on procedural content generation, player modeling, game data mining, human-like
playing behavior, automatic game testing and so on have become commonplace
within the community. as we saw in the previous chapter there is also a recogni-
tion that all these research endeavors depend on each other [785]. however, almost
all research projects in the game ai    eld are very speci   c. most published papers
describe a particular method   or a comparison of two or more methods   for per-
forming a single task (playing, modeling, generating, etc.) in a single game. this is
problematic in several ways, both for the scienti   c value and for the practical appli-

279

280

chapter 7. frontiers of game ai research

cability of the methods developed and studies made in the    eld. if an ai approach
is only tested on a single task for a single game, how can we argue that is an ad-
vance in the scienti   c study of arti   cial intelligence? and how can we argue that
it is a useful method for a game designer or developer, who is likely working on a
completely different game than the one the method was tested on?

as discussed in several parts of this book general game playing is an area that
has already been studied extensively and constitutes one of the key areas of game ai
[785]. the focus of generality solely on play, however, is very narrow as the possible
roles of ai and general intelligence in games are many, including game design,
content design and player experience design. the richness of the cognitive skills
and affective processes required to successfully complete these tasks has so far been
largely ignored by game ai research. we thus argue, that while the focus on general
ai needs to be retained, research on general game ai needs to expand beyond mere
game playing. the new scope for general general game ai beyond game-playing
broadens the applicability and capacity of ai algorithms and our understanding of
intelligence as tested in a creative domain that interweaves problem solving, art, and
engineering.

for general game ai to eventually be truly general, we argue that we need to
extend the generality of general game playing to all other ways in which ai is (or can
be) applied to games. more speci   cally we argue that the    eld should move towards
methods, systems and studies that incorporate three different types of generality:
1. game generality. we should develop ai methods that work with not just one

game, but with any game (within a given range) that the method is applied to.

2. task generality. we should develop methods that can do not only one task (play-

ing, modeling, testing, etc) but a number of different, related tasks.

3. user/designer/player generality. we should develop methods that can model,
respond to and/or reproduce the very large variability among humans in design
style, playing style, preferences and abilities.
we further argue that all of this generality can be embodied into the concept of
general game design, which can be thought of as a    nal frontier of ai research
within games. further details about the notion of general general game ai can be
found in the vision paper we co-authored about this frontier research area [718]. it
is important to note that we are not arguing that more focused investigations into
methods for single tasks in single games are useless; these are often important as
proofs-of-concept or industrial applications and they will continue to be important
in the future, but there will be an increasing need to validate such case studies in a
more general context. we are also not envisioning that everyone will suddenly start
working on general methods. rather, we are positing generalizations as a long-term
goal for our entire research community. finally, the general systems of game ai that
we envision ought to have a real-world use. there is a risk that by making systems
too general we might end up not    nding applications of these general systems to any
speci   c real-world problem. thus, the system   s applicability (or usefulness) sets our
core constraint towards this vision of general game ai. more speci   cally, we envi-

7.1. general general game ai

281

sion general general game ai systems that are nevertheless integrated successfully
within speci   c game platforms or game engines.

7.1.1 general play

the problem of playing games is the one that has been most generalized so far. there
already exist at least three serious benchmarks or competitions attempting to pose
the problem of playing games in general, each in its own imperfect way. the gen-
eral game playing competition, often abbreviated ggp [223], the arcade learning
environment [40] and the general video game ai competition [528]; all three have
been discussed in various places in this book. the results from these competitions
so far indicate that general purpose search and learning algorithms by far outper-
form more domain-speci   c solutions and    clever hacks   . somewhat simpli   ed, we
can say that variations of id169 perform best on gvgai and
ggp [202], and for ale (where no forward model is available so learning a policy
for each game is necessary) id23 with deep networks [464] and
search-based iterative width [389, 301, 390] perform best. this is a very marked
difference from the results of the game-speci   c competitions, indicating the lack of
domain-independent solutions.

while these are each laudable initiatives and currently the focus of much re-
search, in the future we will need to expand the scope of these competitions and
benchmarks considerably, including expanding the range of games available to play
and the conditions under which gameplay happens. we need game playing bench-
marks and competitions capable of expressing any kind of game, including puzzle
games, 2d arcade games, text adventures, 3d action-adventures and so on; this is the
best way to test general ai capacities and reasoning skills. we also need a number of
different ways of interfacing with these games   there is room for both benchmarks
that give agents no information beyond the raw screen data but give them hours to
learn how to play the game, and those that give agents access to a forward model
and perhaps the game code itself, but expect them to play any game presented to
them with no time to learn. these different modes test different ai capabilities and
tend to privilege different types of algorithms. it is worth noting that the gvgai
competition is currently expanding to different types of playing modes, and has a
long-term goal to include many more types of games [527].

we also need to differentiate away from just measuring how to play games op-
timally. in the past, several competitions have focused on agents that play games
in a human-like manner; these competitions have been organized similarly to the
classic turing test [263, 619]. playing games in a human-like manner is important
for a number of reasons, such as being able to test levels and other game content
as part of search-based generation, and to demonstrate new content to players. so
far, the question of how to play games in a human-like manner in general is mostly
unexplored; some preliminary work is reported in [337]. making progress here will
likely involve modeling how humans play games in general, including characteris-

282

chapter 7. frontiers of game ai research

tics such as short-term memory, reaction time and perceptual capabilities, and then
translating these characteristics to playing style in individual games.

7.1.2 general game generation and orchestration

the study of pcg [616] for the design of game levels has reached a certain matu-
rity and is, by far, the most popular domain for the application of pcg algorithms
and approaches (e.g., see [720, 785, 783] among many). what is common in most
of the content generation studies covered in this book, however, is their speci   city
and strong dependency of the representation chosen on the game genre examined.
for the mario ai framework, for instance, the focus on a single level generation
problem has been very much a mixed blessing: it has allowed for the proliferation
and simple comparison of multiple approaches to solving the same problem, but has
also led to a clear over   tting of methods. even though some limited generalization
is expected within game levels of the same genre, the level generators that have been
explored so far clearly do not have the capacity of general level design. we argue
that there needs to be a shift in how level generation is viewed. the obvious change
of perspective is to create general level generators   level generators with general
intelligence that can generate levels for any game (within a speci   ed range). that
would mean that levels are generated successfully across game genres and players
and that the output of the generation process is meaningful and playable as well as
entertaining for the player. further, a general level generator should be able to coor-
dinate the generative process with the other computational game designers who are
responsible for the other parts of the game design.

to achieve general level design intelligence algorithms are required to capture
as much of the level design space as possible at different representation resolutions.
we can think of representation learning approaches such as deep autoencoders [739]
capturing core elements of the level design space and fusing various game genres
within a sole representation   as already showcased by a few methods, such as the
deep learning novelty explorer [373]. the    rst attempt to create a benchmark for
general level generation has recently been launched in the form of the level genera-
tion track of the gvgai competition. in this competition track, competitors submit
level generators capable of generating levels for unseen games. the generators are
then supplied with the description of several games, and produce levels which are
judged by human judges [338]. initial results suggest that constructing competent
level generators that can produce levels for any game is much more challenging
than constructing competent level generators for a single game. a related effort is
the video game level corpus [669] which aims to provide a set of game levels
across multiple games and genres which can be used for training level generators
for data-driven procedural content generation.

while level generation, as discussed above, is one of the main examples of proce-
dural content generation, there are many other aspects (or facets) of games that can
be generated. these include visuals, such as textures and images; narrative, such

7.1. general general game ai

283

as quests and backstories; audio, such as sound effects and music; and of course
all kinds of things that go into game levels, such as items, weapons, enemies and
personalities [381, 616]. however, an even greater challenge is the generation of
complete games, including some or all of these facets together with the rules of the
game. while, as covered in chapter 4, there have been several attempts to gener-
ate games (including their rules) we are not aware of any approach to generating
games that tries to generate more than two of the facets of games listed above. we
are also not aware of any game generation system that even tries to generate games
of more than one genre. multi-faceted generation systems like sonancia [394, 395]
co-generate horror game levels with corresponding soundscapes but do not cater to
the generation of rules. it is clear that the very domain-limited and facet-limited as-
pects of current game generation systems result from intentionally limiting design
choices in order to make the very dif   cult problem of generating complete games
tractable. yet, in order to move beyond what could be argued to be toy domains and
start to ful   ll the promise of game generation, we need systems that can generate
multiple facets of games at the same time, and that can generate games of different
kinds.

this process has been de   ned as facet (domain) orchestration in games [371,
324]. orchestration refers to the process of harmonizing game generation. evi-
dently, orchestration is a necessary process when we consider the output of two
or more content type generators   such as visuals and audio   for the generation of
a complete game. drawing inspiration from music, orchestration may vary from a
top-down, conductor-driven process to a bottom-up, free-from generation process
[371]. a few years ago, something very much like general game generation and or-
chestration was outlined as the challenges of    multi-content, multi-domain pcg   
and    generating complete games    [702]. it is interesting to note that there has not
seemingly been any attempt to create more general game generators since then, per-
haps due to the complexity of the task. a recent study by karavolos et al. [324]
moves towards the orchestration direction as it fuses level and game design param-
eters in    rst-person shooters via deep convolutional neural networks. the trained
networks can be used to generate balanced games. currently the only genre for
which generators have been built that can generate high-quality (complete) games
is abstract board games. once more genres have been    conquered   , we hope that
the task of building more general level generators can begin.

linked to the tasks of orchestration and general game generation there are im-
portant questions with respect to the creative capacity of the generation process that
remain largely unanswered. for example, how creative can a generator be and how
can we assess it? is it, for instance, deemed to have appreciation, skill, and imagina-
tion [130]? when it comes to the evaluation of the creative capacity of current pcg
algorithms a case can be made that most of them possess only skill. does the creator
manage to explore novel combinations within a constrained space, thereby resulting
in exploratory game design creativity [53]; or, is on the other hand trying to break
existing boundaries and constraints within game design to come up with entirely
new designs, demonstrating transformational creativity [53]? if used in a mixed-
initiative fashion, does it enhance the designer   s creativity by boosting the possi-

284

chapter 7. frontiers of game ai research

bility space for her? arguably, the appropriateness of various evaluation methods
for autonomous pcg creation or mixed-initiative co-creation [774] remains largely
unexplored within both human and computational creativity research.

7.1.3 general game affective loop

it stands to reason that general intelligence implies (and is tightly coupled with)
general emotional intelligence [443]. the ability to recognize human behavior and
emotion is a complex yet critical task for human communication that acts as a fa-
cilitator of general intelligence [157]. throughout evolution, we have developed
particular forms of advanced cognitive, emotive and social skills to address this
challenge. beyond these skills, we also have the capacity to detect affective patterns
across people with different moods, cultural backgrounds and personalities. this
generalization ability also extends, to a degree, across contexts and social settings.
despite their importance, the characteristics of social intelligence have not yet been
transferred to ai in the form of general emotive, cognitive or behavioral models.
while research in affective computing [530] has reached important milestones such
as the capacity for real-time emotion recognition [794]   which can be faster than
humans under particular conditions   all key    ndings suggest that any success of
affective computing is heavily dependent on the domain, the task at hand, and the
context in general. this speci   city limitation is particularly evident in the domain
of games [781] as most work in modeling player experience focuses on particu-
lar games, under well-controlled conditions with particular, small sets of players
(see [783, 609, 610, 435] among many). in this section we identify and discuss two
core unexplored and interwoven aspects of modeling players that are both important
and necessary steps towards the long-term aim of game ai to realize truly adaptive
games. the    rst aspect is the closure of the affective loop in games; the second as-
pect is the construction of general models capable of capturing experience across
players and games.

as stated at the start of this book, affective computing is best realized within
games in what we name the game affective loop. while the phases of emotion elic-
itation, affect modeling and affect expression have offered some robust solutions by
now, the very loop of affective-based interaction has not been closed yet. aside from
a few studies demonstrating some affect-enabled adaptation of the game [772, 617]
the area remains largely unexplored. it is not only the complexity of modeling play-
ers and their experience that is the main hurdle against any advancement. what is
also far from trivial is the appropriate and meaningful integration of any of these
models in a game. the questions of how often the system should adapt, what it
should alter and by what degree are not easy to answer. as most of the questions are
still open to the research community the only way to move forward is to do more
research in adaptive games involving affective aspects of the experience. existing
commercial-standard games that already realize the affective loop such as never-
mind (flying mollusk, 2016) are the ambassadors for further work in this area.

7.2. ai in other roles in games

285

once the game affective loop is successfully realized within particular games the
next goal for game ai is the generality of affect-based interaction across games.
the game affective loop should not only be operational; it should ideally be general
too. for ai in games to be general beyond game-playing it needs to be able to recog-
nize general emotional and cognitive-behavioral patterns. this is essentially ai that
can detect context-free emotive and cognitive reactions and expressions across con-
texts and builds general computational models of human behavior and experience
which are grounded in a general gold standard of human behavior. so far we have
only seen a few proof-of-concept studies in this direction. early work within the
game ai    eld focused on the ad-hoc design of general metrics of player interest that
were tested across different prey-predator games [768, 767]. in other, more recent,
studies predictors of player experience were tested for their ability to capture player
experience across dissimilar games [431, 612, 97]. another study on deep multi-
modal fusion can be seen as an embryo for further research in this direction [435],
in which various modalities of player input such as player metrics, skin conductance
and heart activity have been fused using stacked autoencoders. discovering entirely
new representations of player behavior and emotive manifestations across games,
modalities of data, and player types is a    rst step towards achieving general player
modeling. such representations can, in turn, be used as the basis for approximating
the ground truth of user experience in games.

7.2 ai in other roles in games

the structure of this book re   ects our belief that playing games, generating content
and modeling players are the central applications of ai methods in games. how-
ever, there are many variants and use cases of game playing, player modeling or
content generation that we have not had time to explore properly in the book, and
which in some cases not have been explored in the literature at all. further, there are
some applications of ai in games that cannot be really classi   ed as special cases
of our    big three    ai applications in games, despite our best efforts. this section
brie   y sketches some of these applications, some of which may be important future
research directions.

playtesting: one of the many use cases for ai for playing games is to test the
games. testing games for bugs, balancing player experience and behavior, and other
issues is important in game development, and one of the areas where game devel-
opers are looking for ai assistance. while playtesting is one of the ai capabilities
within many of the mixed-initiative tools discussed in chapter 4, there has also been
work on ai-based playtesting outside of that context. for example, denzinger et al.
evolved action sequences to    nd exploits in sports games, with discouragingly good
results [165]. for the particular case of    nding bugs and exploits in games, one of
the research challenges is to    nd a good and representative coverage of problems,
so as to deliver an accurate picture to the development team of how many problems

286

chapter 7. frontiers of game ai research

there are and how easy they are to run into, and allow prioritization of which prob-
lems to    x.

critiquing games: can ai methods meaningfully judge and critique games? game
criticism is hard and generally depends on deep understanding of not only games but
also the surrounding cultural context. still, there might be automated metrics that are
useful for game criticism, and can provide information to help reviewers, game cu-
rators and others in selecting which games to consider for reviewing for inclusion
in app stores. the angelina game generation system is one of the few examples
towards this direction [136] in which ai generates the overview of the game to be
played.

hyper-formalist game studies: ai methods can be applied to corpora of games
in order to understand distributions of game characteristics. for example, decision
trees can be used to visualize patterns of resource systems in games [312]. there
are likely many other ways of using game ai for game studies that are still to be
discovered.

game directing: the outstanding feature of left 4 dead (valve corporation, 2008)
was its ai director, which adjusted the onslaught of zombies to provide a dramatic
curve of challenge for players. while simple and literally one-dimensional (only a
single dimension of player experience was tracked), the ai director proved highly
effective. there is much room for creating more sophisticated ai directors; the
experience-driven pcg framework [783] is one potential way within which to work
towards this.

creative inspiration: while designing a complete game that actually works likely
requires a very complex generator, it can be simpler to generate an idea for new
games, that are then designed by humans. creative ideation tools range from sim-
ple word-recombination-based tools implemented as card games or twitter bots, to
elaborate computational creativity systems such as the what if-machine [391].

chat monitoring: in-game chats are important in many online multi-player games,
as they allow people to collaborate within games and socialize through them. un-
fortunately, such chats can also be used to threaten or abuse other players. given
the very large volume of chat messages sent through a successful online game, it
becomes impossible for the game developers to curate chats manually. in the efforts
to combat toxic behavior, some game developers have therefore turned to machine
learning. notably, riot games have trained algorithms to recognize and remove
toxic behavior in the moba league of legends (riot games, 2009) [413]. even
worse, sexual predation can be seen in some games, where pedophiles use game
chats to reach children; there have been attempts to use machine learning to detect
sexual predators in game chats too [241].

ai-based game design: throughout most of the book, we have assumed the ex-

7.3. ethical considerations

287

istence of a game or at least a game design, and discussed how ai can be used to
play that game, generate content for it or model its players. however, one could also
start from some ai method or capability and try to design a game that builds on that
method or capability. this could be seen as an opportunity to showcase ai methods
in the context of games, but it could also be seen as a way of advancing game de-
sign. most classic game designs originate in an era where there were few effective
ai algorithms, there was little knowledge among game designers about those ai
algorithms that existed, and cpu and memory capacity of home computers was too
limited to allow anything beyond simple heuristic ai and some best-   rst search to
be used. one could even say that many classic video game designs are an attempt
to design around the lack of ai   for example, the lack of good dialog ai for npcs
led to the use of dialog trees, the lack of ais that could play fps games believably
and competently led to fps game designs where most enemies are only on-screen
for a few seconds so that you do not notice their lack of smarts, and the lack of
level generation methods that guaranteed balance and playability led to game de-
signs where levels did not need to be completable. the persistence of such design
patterns may be responsible for the relatively low utilization of interesting ai meth-
ods within commercial game development. by starting with the ai and designing
a game around it, new design patterns that actually exploit some of the recent ai
advances can be found.

several games have been developed within the game ai research community
speci   cally to showcase ai capabilities, some of which have been discussed in this
book. three of the more prominent examples are based on stanley et al.   s work
on neuroevolution and the neat algorithm: nero, which is an rts-like game
where the player trains an army through building a training environment rather
than controlling it directly [654]; galactic arms race, in which weapons con-
trolled through neural networks are indirectly collectively evolved by thousands of
players [250, 249]; and petalz, which is a facebook game about collecting    ow-
ers based on a similar idea of selection-based collective neuroevolution [565, 566].
other games have been built to demonstrate various adaptation mechanisms, such
as in   nite tower defense [25] and maze-ball [780]. within interactive narrative it is
relatively common to build games that showcase speci   c theories and methods; a fa-
mous example is fac  ade [441] and another prominent example is prom week [447].
treanor et al. have attempted to identify ai-based game design patterns, and found
a diverse array of roles in which ai can be or has been used in games, and a number
of avenues for future ai-based game design [724].

7.3 ethical considerations

like all technologies, arti   cial intelligence, including game ai, can be used for
many purposes, some of them nefarious. perhaps even more importantly, technol-
ogy can have ethically negative or at least questionable effects even when there is no
malicious intent. the ethical effects of using ai with and in games are not always

288

chapter 7. frontiers of game ai research

obvious, and the topic is not receiving the attention it should. this short section
looks at some of the ways in which game ai intersects with ethical questions. for
general ai research issues, ethics and values we refer the interested reader to the
asilomar ai principles1 developed in conjunction with the 2017 asilomar confer-
ence.

player modeling is perhaps the part of game ai where the ethical questions are
most direct, and perhaps most urgent. there is now a vigorous debate about the
mass collection of data about us both by government entities (such as the us na-
tional security agency or the united kingdom   s gchq) and private entities (such
as google, amazon, facebook and microsoft) [64, 502]. with methodological ad-
vances in data mining, it is becoming possible to learn more and more about in-
dividual people from their digital traces, including inferring sensitive information
and predicting behavior. given that player modeling involves large-scale data col-
lection and mining, many of the same ethical challenges exist in player modeling as
in the mining of data about humans in general. mikkelsen et al. present an overview
of ethical challenges for player modeling [458]. below we give some examples of
such challenges.

privacy: it is becoming increasingly possible and even practicable to infer vari-
ous real-life traits and properties of people from their in-game behavior. this can
be done without the consent or even knowledge of the subject, and some of the in-
formation can be of a private and sensitive nature. for example, yee and colleagues
investigated how player choices in world of warcraft (blizzard entertainment, 2004)
correlated with the personalities of players. they used data about players    characters
from the armory database of world of warcraft (blizzard entertainment, 2004) and
correlated this information with personality tests administered to players; multiple
strong correlations were found [788]. in a similar vein, a study investigated how
players    life motives correlated with their minecraft (mojang, 2011) log    les [101].
that research used the life motivation questionnaires of steven reiss, and found
that players    self-reported life motives (independence, family, etc.) were expressed
in a multitude of ways inside constructed minecraft (mojang, 2011) worlds. using
a very different type of game strong correlations have been found between play-
ing style in the    rst-person shooter battle   eld 3 (electronic arts, 2011) and player
characteristics such as personality [687], age [686] and nationality [46]. it is en-
tirely plausible that similar methods could be used to infer sexual preferences, po-
litical views, health status and religious beliefs. such information could be used by
advertising networks to serve targeted ads, by criminals looking to blackmail the
player, by insurance companies looking to differentiate premiums, or by malevolent
political regimes for various forms of suppression. we do not know yet what can be
predicted and with what accuracy, but it is imperative that more research be done on
this within the publicly available literature; it is clear that this kind of research will
also be carried out behind locked doors.

1 https://futureo   ife.org/ai-principles/

7.3. ethical considerations

289

ownership of data: some player data can be used to recreate aspects of the player   s
behavior; this is the case for e.g., the drivatars in microsoft   s forza motorsport
series, and more generally for agents created according to the procedural persona
concept [267]. it is currently not clear who owns this data, and if the game devel-
oper/publisher owns the data, what they can do with it. will the game allow other
people to play against a model of you, i.e., how you would have played the game?
if so, can it identify you to other players as the origin of this data? does it have to
be faithful to the behavioral model of you, or can it add or distort aspects of your
playing behavior?

adaptation: much of the research within game ai is concerned with adaptation
of games, with the experience-driven pcg framework being the perhaps most com-
plete account on how to combine player modeling with procedural content gener-
ation to create personalized game experiences [783]. however, it is not clear that
it is always a good thing to adapt games to players. the       lter bubble    is a con-
cept within discussion of social networks which refers to the phenomenon where
collaborative    ltering ensures that users are only provided with content that is al-
ready in line with their political, ethical, or aesthetic preferences, leading to a lack
of healthy engagement with other perspectives. excessive adaptation and personal-
ization might have a similar effect, where players are funneled into a narrow set of
game experiences.

stereotypes: anytime we train a model using some dataset, we run the risk of
reproducing stereotypes within that dataset. for example, it has been shown that
id27s trained on standard datasets of the english language reproduce
gender-based stereotypes [93]. the same effects could be present when modeling
player preferences and behavior, and the model might learn to reproduce prejudiced
conceptions regarding gender, race, etc. such problems can be exacerbated or ame-
liorated by the tools made available to players for expressing themselves in-game.
for example, lim and harrell have developed quantitative methods for measuring
and addressing bias in character creation tools [386].

censorship: of course, it is entirely possible, and advisable, to use ai methods to
promote ethical behavior and uphold ethical values. earlier, section 7.2 discussed
the examples of ai for    ltering player chats in online multi-player games, and for
detecting sexual predators. while such technologies are generally welcome, there
are important ethical considerations in how they should be deployed. for example,
a model that has been trained to recognize hate speech might also react to normal
in-game jargon; setting the right decision threshold might involve a delicate tradeoff
between ensuring a welcoming game environment and not restricting communica-
tions unduly.

ai beyond games: finally, a somewhat more far-fetched concern, but one we be-
lieve still merits discussion is the following. games are frequently used to train and
test ai algorithms   this is the main aim of, for example, the general video game

290

chapter 7. frontiers of game ai research

ai competition and the arcade learning environment. however, given how many
games are focused on violent competition, does this mean that we focus unduly on
the development of violence in arti   cial intelligence? what effects could this have
on ai that is trained on games but employed in other domains, such as transport or
health care?

7.4 summary

in this last chapter of this book we went through directions that we view as criti-
cal and important for the advancement of the game ai    eld. initially we have ar-
gued that the general intelligence capacity of machines needs to be both explored
and exploited to its full potential (1) across the different tasks that exist within the
game design and development process, including but absolutely no longer limited
to game playing; (2) across different games within the game design space; and (3)
across different users (players or designers) of ai. we claim that, thus far, we have
underestimated the potential for general ai within games. we also claim that the
currently dominant practice of only designing ai for a speci   c task within a speci   c
domain will eventually be detrimental to game ai research as algorithms, methods
and epistemological procedures will remain speci   c to the task at hand. as a result,
we will not manage to push the boundaries of ai and exploit its full capacity for
game design. we are inspired by the general game-playing paradigm and the recent
successes of ai algorithms in that domain and suggest that we become less speci   c
about all subareas of the game ai    eld including player modeling and game gener-
ation. doing so would allow us to detect and mimic different general cognitive and
emotive skills of humans when designing games. it is worth noting, again, that we
are not advocating that all research within the game ai    eld focuses on generality
right now; studies on particular games and particular tasks are still valuable, given
how little we still understand and can do. but over time, we predict that more and
more research will focus on generality across tasks, games and users, because it is
in the general problems that the interesting research questions of the future lie. it
seems that we are not alone in seeing this need as other researchers have argued for
the use of various game-related tasks (not just game playing) to be used in arti   cial
general intelligence research [799].

the path towards achieving general game arti   cial intelligence is still largely un-
explored. for ai to become less speci   c   yet remain relevant and useful for game
design   we envision a number of immediate steps that could be taken:    rst and fore-
most, the game ai community needs to adopt an open-source accessible strategy so
that methods and algorithms developed across the different tasks are shared among
researchers for the advancement of this research area. venues such as the current
game ai research portal2 could be expanded and used to host successful methods
and algorithms. for the algorithms and methods to be of direct use particular tech-

2 http://www.aigameresearch.org/

7.4. summary

291

nical speci   cations need to be established   e.g., such as those established within
game-based ai benchmarks   which will maximize the interoperability among the
various tools and elements submitted. examples of benchmarked speci   cations for
the purpose of general game ai research include the general video game description
language and the puzzle game engine puzzlescript.3 finally, following the gvgai
competition paradigm, we envision a new set of competitions rewarding general
player models, ai-assisted tools and game generation techniques. these competi-
tions would further motivate researchers to work in this exciting research area and
enrich the database of open-access interoperable methods and algorithms, directly
contributing to the state of the art in computational general game design.

beyond generality we also put a focus on the extensibility of ai roles within
games. in that regard, we outlined a number of ai roles that are underrepresented
currently but nevertheless de   ne very promising research frontiers for game ai.
these include the roles of ai as playtester, game critic, game studies formalist, di-
rector, creative designer, and gameplay ethics judge. further, we view the placement
of ai at the very center of the design process (ai-based game design) as another
critical research frontier.

this chapter, and the book itself, concluded with a discussion on the ethical im-
plications of whatever we do in game ai research. in particular, we discussed as-
pects such as the privacy and ownership of data, the considerations about game
adaptation, the emergence of stereotypes through computational models of players,
the risks of ai acting as a censor, and    nally the ethical constraints imposed on ai
by    unethical    aspects of the very nature of games.

3 http://www.puzzlescript.net/

references

1. espen aarseth. genre trouble. electronic book review, 3, 2004.
2. mart    n abadi, ashish agarwal, paul barham, eugene brevdo, zhifeng chen, craig citro,
greg s. corrado, andy davis, jeffrey dean, matthieu devin, et al. tensorflow: large-scale
machine learning on heterogeneous distributed systems. arxiv preprint arxiv:1603.04467,
2016.

3. ryan abela, antonios liapis, and georgios n. yannakakis. a constructive approach for the
generation of underwater environments. in proceedings of the fdg workshop on procedural
content generation in games, 2015.

4. david h. ackley, geoffrey e. hinton, and terrence j. sejnowski. a learning algorithm for

id82s. cognitive science, 9(1):147   169, 1985.

5. alexandros agapitos, julian togelius, simon m. lucas, j  urgen schmidhuber, and andreas
konstantinidis. generating diverse opponents with multiobjective evolution. in computa-
tional intelligence and games, 2008. cig   08. ieee symposium on, pages 135   142. ieee,
2008.

6. rakesh agrawal, tomasz imieli  nski, and arun swami. mining association rules between

sets of items in large databases. in acm sigmod record, pages 207   216. acm, 1993.

7. rakesh agrawal and ramakrishnan srikant. fast algorithms for mining association rules. in
proceedings of the 20th international conference on very large data bases, vldb, pages
487   499, 1994.

8. john b. ahlquist and jeannie novak. game development essentials: game arti   cial intelli-

9. zach aikman. galak-z: forever: building space-dungeons organically. in game develop-

10. bob alexander. the beauty of response curves. ai game programming wisdom, page 78,

11. krishna aluru, stefanie tellex, john oberlin, and james macglashan. minecraft as an ex-

perimental world for ai in robotics. in aaai fall symposium, 2015.

12. samuel alvernaz and julian togelius. autoencoder-augmented neuroevolution for visual
doom playing. in ieee conference on computational intelligence and games. ieee, 2017.
13. omar alzoubi, rafael a. calvo, and ronald h. stevens. classi   cation of eeg for affect
recognition: an adaptive approach. in ai 2009: advances in arti   cial intelligence, pages
52   61. springer, 2009.

14. mike ambinder. biofeedback in gameplay: how valve measures physiology to enhance
gaming experience. in game developers conference, san francisco, california, us, 2011.
15. dan amerson, shaun kime, and r. michael young. real-time cinematic camera control for
interactive narratives. in proceedings of the 2005 acm sigchi international conference
on advances in computer entertainment technology, pages 369   369. acm, 2005.

gence. delmar pub, 2008.

ers conference, 2015.

2002.

293

294

references

16. elisabeth andr  e, martin klesen, patrick gebhard, steve allen, and thomas rist. integrating
models of personality and emotions into lifelike characters. in affective interactions, pages
150   165. springer, 2000.

17. john l. andreassi. psychophysiology: human behavior and physiological response. psy-

18. rudolf arnheim. art and visual perception: a psychology of the creative eye. university of

chology press, 2000.

california press, 1956.

19. ivon arroyo, david g. cooper, winslow burleson, beverly park woolf, kasia muldner, and
in proceedings of conference on

robert christopherson. emotion sensors go to school.
arti   cial intelligence in education (aied), pages 17   24. ios press, 2009.

20. w. ross ashby. principles of the self-organizing system. in facets of systems science, pages

521   536. springer, 1991.

21. daniel ashlock. evolutionary computation for modeling and optimization. springer, 2006.
22. stylianos asteriadis, kostas karpouzis, noor shaker, and georgios n. yannakakis. does
your pro   le say it all? using demographics to predict expressive head movement during
gameplay. in proceedings of umap workshops, 2012.

23. stylianos asteriadis, paraskevi tzouveli, kostas karpouzis, and stefanos kollias. estima-
tion of behavioral user state based on eye gaze and head pose   application in an e-learning
environment. multimedia tools and applications, 41(3):469   493, 2009.

24. phillipa avery, sushil louis, and benjamin avery. evolving coordinated spatial tactics for
autonomous entities using in   uence maps. in computational intelligence and games, 2009.
cig 2009. ieee symposium on, pages 341   348. ieee, 2009.

25. phillipa avery, julian togelius, elvis alistar, and robert pieter van leeuwen. computational
in evolutionary computation (cec), 2011 ieee

intelligence and tower defence games.
congress on, pages 1084   1091. ieee, 2011.

26. ruth aylett, sandy louchart, joao dias, ana paiva, and marco vala. fearnot!   an experi-

ment in emergent narrative. in intelligent virtual agents, pages 305   316. springer, 2005.

27. simon e. ortiz b., koichi moriyama, ken-ichi fukui, satoshi kurihara, and masayuki nu-
mao. three-subagent adapting architecture for    ghting videogames. in paci   c rim interna-
tional conference on arti   cial intelligence, pages 649   654. springer, 2010.

28. sander bakkes, pieter spronck, and jaap van den herik. rapid and reliable adaptation of
video game ai. ieee transactions on computational intelligence and ai in games, 1(2):93   
104, 2009.

29. sander bakkes, shimon whiteson, guangliang li, george viorel vis  niuc, efstathios char-
itos, norbert heijne, and arjen swellengrebel. challenge balancing for personalised game
spaces. in games media entertainment (gem), 2014 ieee, pages 1   8. ieee, 2014.

30. rainer banse and klaus r. scherer. acoustic pro   les in vocal emotion expression. journal

of personality and social psychology, 70(3):614, 1996.

31. ray barrera, aung sithu kyaw, clifford peters, and thet naing swe. unity ai game pro-

gramming. packt publishing ltd, 2015.

32. gabriella a. b. barros, antonios liapis, and julian togelius. data adventures. in proceed-

ings of the fdg workshop on procedural content generation in games, 2015.

33. richard a. bartle. designing virtual worlds. new riders, 2004.
34. chris bateman and richard boon. 21st century game design (game development series).

charles river media, inc., 2005.

35. chris bateman and lennart e. nacke. the neurobiology of play.

in proceedings of the
international academic conference on the future of game design and technology, pages
1   8. acm, 2010.

36. christian bauckhage, anders drachen, and rafet sifa. id91 game behavior data. ieee

transactions on computational intelligence and ai in games, 7(3):266   278, 2015.

37. yoann baveye, jean-no  el bettinelli, emmanuel dellandrea, liming chen, and christel
chamaret. a large video database for computational models of induced emotion. in pro-
ceedings of affective computing and intelligent interaction, pages 13   18, 2013.

38. jessica d. bayliss. teaching game ai through minecraft mods. in 2012 ieee international

games innovation conference (igic), pages 1   4. ieee, 2012.

references

295

39. far`es belhadj. terrain modeling: a constrained fractal model.

in proceedings of the 5th
international conference on computer graphics, virtual reality, visualisation and interaction
in africa, pages 197   204. acm, 2007.

40. marc g. bellemare, yavar naddaf, joel veness, and michael bowling. the arcade learning
environment: an evaluation platform for general agents. arxiv preprint arxiv:1207.4708,
2012.

41. yoshua bengio. learning deep architectures for ai. foundations and trends in machine

learning, 2(1):1   127, 2009.

42. jos  e luis bernier, c. ilia herr  aiz, j. j. merelo, s. olmeda, and alberto prieto. solving
mastermind using gas and simulated annealing: a case of dynamic constraint optimization.
in parallel problem solving from nature (ppsn) iv, pages 553   563. springer, 1996.
43. kent c. berridge. pleasures of the brain. brain and cognition, 52(1):106   128, 2003.
44. dimitri p. bertsekas. id145 and optimal control. athena scienti   c belmont,

ma, 1995.

45. nadav bhonker, shai rozenberg, and itay hubara. playing snes in the retro learning

environment. arxiv preprint arxiv:1611.02205, 2016.

46. mateusz bialas, shoshannah tekofsky, and pieter spronck. cultural in   uences on play style.
in computational intelligence and games (cig), 2014 ieee conference on, pages 1   7.
ieee, 2014.

47. nadia bianchi-berthouze and christine l. lisetti. modeling multimodal expression of user   s
affective subjective experience. user modeling and user-adapted interaction, 12(1):49   84,
2002.

48. darse billings, denis papp, jonathan schaeffer, and duane szafron. opponent modeling in

poker. in aaai/iaai, pages 493   499, 1998.

49. christopher m. bishop. pattern recognition and machine learning. 2006.
50. staffan bj  ork and jesper juul. zero-player games. in philosophy of computer games con-

51. vikki blake. minecraft has 55 million monthly players, 122 million sales. imagine games

ference, madrid, 2012.

network, february 2017.

52. paris mavromoustakos blom, sander bakkes, chek tien tan, shimon whiteson,
diederik m. roijers, roberto valenti, and theo gevers. towards personalised gaming via
facial expression recognition. in proceedings of aiide, 2014.

53. margaret a. boden. what is creativity. dimensions of creativity, pages 75   117, 1994.
54. margaret a. boden. creativity and arti   cial intelligence. arti   cial intelligence, 103(1):347   

356, 1998.

55. margaret a. boden. the creative mind: myths and mechanisms. psychology press, 2004.
56. slawomir bojarski and clare bates congdon. realm: a rule-based evolutionary computa-
tion agent that learns to play mario. in computational intelligence and games (cig), 2010
ieee symposium on, pages 83   90. ieee, 2010.

57. luuk bom, ruud henken, and marco wiering. id23 to train ms. pac-man
using higher-order action-relative inputs. in adaptive id145 and reinforce-
ment learning (adprl), 2013 ieee symposium on, pages 156   163. ieee, 2013.

58. blai bonet and h  ector geffner. planning as heuristic search. arti   cial intelligence, 129(1-

2):5   33, 2001.

59. philip bontrager, ahmed khalifa, andre mendes, and julian togelius. matching games and
algorithms for general video game playing. in twelfth arti   cial intelligence and interactive
digital entertainment conference, 2016.

60. michael booth. the ai systems of left 4 dead. in fifth arti   cial intelligence and interactive

digital entertainment conference (keynote), 2009.

61. adi botea, martin m  uller, and jonathan schaeffer. near optimal hierarchical path-   nding.

journal of game development, 1(1):7   28, 2004.

62. david m. bourg and glenn seemann. ai for game developers. o   reilly media, inc., 2004.
63. michael bowling, neil burch, michael johanson, and oskari tammelin. heads-up limit

holdem poker is solved. science, 347(6218):145   149, 2015.

296

references

64. danah boyd and kate crawford. six provocations for big data. in a decade in internet time:
symposium on the dynamics of the internet and society. oxford internet institute, oxford,
2011.

65. s. r. k. branavan, david silver, and regina barzilay. learning to win by reading manuals
in a monte-carlo framework. journal of arti   cial intelligence research, 43:661   704, 2012.
66. michael e. bratman, david j. israel, and martha e. pollack. plans and resource-bounded

practical reasoning. computational intelligence, 4(3):349   355, 1988.

67. leo breiman, jerome friedman, charles j. stone, and richard a. olshen. classi   cation and

68. daniel brewer. tactical path   nding on a navmesh. game ai pro: collected wisdom of game

regression trees. crc press, 1984.

ai professionals, page 361, 2013.

69. gerhard brewka, thomas eiter, and miros  aw truszczy  nski. answer set programming at a

glance. communications of the acm, 54(12):92   103, 2011.

70. rodney brooks. a robust layered control system for a mobile robot.

ieee journal on

robotics and automation, 2(1):14   23, 1986.

71. david s. broomhead and david lowe. radial basis functions, multi-variable functional

interpolation and adaptive networks. royals signals & radar establishment, 1988.

72. anna brown and alberto maydeu-olivares. how irt can solve problems of ipsative data in

forced-choice questionnaires. psychological methods, 18(1):36, 2013.

73. daniel lankford brown. mezzo: an adaptive, real-time composition program for game
soundtracks. in eighth arti   cial intelligence and interactive digital entertainment confer-
ence, 2012.

74. cameron browne. automatic generation and evaluation of recombination games. phd the-

sis, queensland university of technology, 2008.

75. cameron browne. yavalath. in evolutionary game design, pages 75   85. springer, 2011.
76. cameron browne and frederic maire. evolutionary game design. ieee transactions on

computational intelligence and ai in games, 2(1):1   16, 2010.

77. cameron b. browne, edward powley, daniel whitehouse, simon m. lucas, peter i. cowl-
ing, philipp rohlfshagen, stephen tavener, diego perez, spyridon samothrakis, and simon
colton. a survey of id169 methods. computational intelligence and ai in
games, ieee transactions on, 4(1):1   43, 2012.

78. nicholas j. bryan, gautham j. mysore, and ge wang. isse: an interactive source sepa-
ration editor. in proceedings of the sigchi conference on human factors in computing
systems, pages 257   266, 2014.

79. bobby d. bryant and risto miikkulainen. evolving stochastic controller networks for in-
telligent game agents. in evolutionary computation, 2006. cec 2006. ieee congress on,
pages 1007   1014. ieee, 2006.

80. mat buckland. programming game ai by example. jones & bartlett learning, 2005.
81. mat buckland and mark collins. ai techniques for game programming. premier press, 2002.
82. vadim bulitko, yngvi bj  ornsson, nathan r. sturtevant, and ramon lawrence. real-time
in arti   cial intelligence for computer

heuristic search for path   nding in video games.
games, pages 1   30. springer, 2011.

83. vadim bulitko, greg lee, sergio poo hernandez, alejandro ramirez, and david thue. tech-
niques for ai-driven experience management in interactive narratives. in game ai pro 2:
collected wisdom of game ai professionals, pages 523   534. ak peters/crc press, 2015.
84. paolo burelli. virtual cinematography in games: investigating the impact on player experi-

ence. foundations of digital games, 2013.

85. paolo burelli and georgios n. yannakakis. combining local and global optimisation for
virtual camera control. in proceedings of the 2010 ieee conference on computational
intelligence and games, copenhagen, denmark, august 2010. ieee.

86. christopher j. c. burges. a tutorial on support vector machines for pattern recognition. data

mining and knowledge discovery, 2(2):121   167, 1998.

87. michael buro and david churchill. real-time strategy game competitions. ai magazine,

33(3):106, 2012.

references

297

88. carlos busso, zhigang deng, serdar yildirim, murtaza bulut, chul min lee, abe
kazemzadeh, sungbok lee, ulrich neumann, and shrikanth narayanan. analysis of emo-
in pro-
tion recognition using facial expressions, speech and multimodal information.
ceedings of the international conference on multimodal interfaces (icmi), pages 205   211.
acm, 2004.

89. eric butler, adam m. smith, yun-en liu, and zoran popovic. a mixed-initiative tool for
designing level progressions in games. in proceedings of the 26th annual acm symposium
on user interface software and technology, pages 377   386. acm, 2013.

90. martin v. butz and thies d. lonneker. optimized sensory-motor couplings plus strategy
in ieee symposium on computational

extensions for the torcs car racing challenge.
intelligence and games, pages 317   324. ieee, 2009.

91. john t. cacioppo, gary g. berntson, jeff t. larsen, kirsten m. poehlmann, and tiffany a.

ito. the psychophysiology of emotion. handbook of emotions, 2:173   191, 2000.

92. francesco calimeri, michael fink, stefano germano, andreas humenberger, giovambattista
ianni, christoph redl, daria stepanova, andrea tucci, and anton wimmer. angry-hex: an
arti   cial player for angry birds based on declarative knowledge bases. ieee transactions
on computational intelligence and ai in games, 8(2):128   139, 2016.

93. aylin caliskan, joanna j. bryson, and arvind narayanan. semantics derived automatically

from language corpora contain human-like biases. science, 356(6334):183   186, 2017.

94. gordon calleja. in-game: from immersion to incorporation. mit press, 2011.
95. rafael calvo, iain brown, and steve scheding. effect of experimental factors on the recog-
nition of affective mental states through physiological measures. in ai 2009: advances in
arti   cial intelligence, pages 62   70. springer, 2009.

96. elizabeth camilleri, georgios n. yannakakis, and alexiei dingli. platformer level design
for player believability. in ieee computational intelligence and games conference. ieee,
2016.

97. elizabeth camilleri, georgios n. yannakakis, and antonios liapis. towards general models
of player affect. in affective computing and intelligent interaction (acii), 2017 interna-
tional conference on, 2017.

98. murray campbell, a. joseph hoane, and feng-hsiung hsu. deep blue. arti   cial intelligence,

134(1-2):57   83, 2002.

99. henrique campos, joana campos, jo  ao cabral, carlos martinho, jeppe herlev nielsen, and
ana paiva. my dream theatre. in proceedings of the 2013 international conference on
autonomous agents and multi-agent systems, pages 1357   1358. international foundation
for autonomous agents and multiagent systems, 2013.

100. joana campos, carlos martinho, gordon ingram, asimina vasalou, and ana paiva. my

dream theatre: putting con   ict on center stage. in fdg, pages 283   290, 2013.

101. alessandro canossa, josep b. martinez, and julian togelius. give me a reason to dig
minecraft and psychology of motivation. in computational intelligence in games (cig),
2013 ieee conference on. ieee, 2013.

102. luigi cardamone, daniele loiacono, and pier luca lanzi.

interactive evolution for the
procedural generation of tracks in a high-end racing game. in proceedings of the 13th annual
conference on genetic and evolutionary computation, pages 395   402. acm, 2011.

103. luigi cardamone, georgios n. yannakakis, julian togelius, and pier luca lanzi. evolving
in applications of evolutionary computation,

interesting maps for a    rst person shooter.
pages 63   72. springer, 2011.

104. justine cassell. embodied conversational agents. mit press, 2000.
105. justine cassell, timothy bickmore, mark billinghurst, lee campbell, kenny chang, hannes
vilhj  almsson, and hao yan. embodiment in conversational interfaces: rea. in proceedings
of the sigchi conference on human factors in computing systems, pages 520   527. acm,
1999.

106. marc cavazza, fred charles, and steven j. mead. character-based interactive storytelling.

ieee intelligent systems, 17(4):17   24, 2002.

298

references

107. marc cavazza, fred charles, and steven j. mead. interacting with virtual characters in inter-
active storytelling. in proceedings of the first international joint conference on autonomous
agents and multiagent systems: part 1, pages 318   325. acm, 2002.

108. georgios chalkiadakis, edith elkind, and michael wooldridge. computational aspects of
cooperative game theory. synthesis lectures on arti   cial intelligence and machine learning,
5(6):1   168, 2011.

109. alex j. champandard. ai game development: synthetic creatures with learning and reactive

110. alex j. champandard. behavior trees for next-gen game ai. in game developers confer-

behaviors. new riders, 2003.

ence, audio lecture, 2007.

111. alex j. champandard. understanding behavior trees. aigamedev. com, 2007.
112. alex j. champandard. getting started with decision making and control systems. ai game

113. jason c. chan. response-order effects in likert-type scales. educational and psychological

programming wisdom, 4:257   264, 2008.

measurement, 51(3):531   540, 1991.

114. senthilkumar chandramohan, matthieu geist, fabrice lefevre, and olivier pietquin. user
simulation in dialogue systems using inverse id23. in interspeech 2011,
pages 1025   1028, 2011.

115. devendra singh chaplot and guillaume lample. arnold: an autonomous agent to play fps

games. in thirty-first aaai conference on arti   cial intelligence, 2017.

116. darryl charles and michaela black. dynamic player modelling: a framework for player-
centric digital games. in proceedings of the international conference on computer games:
arti   cial intelligence, design and education, pages 29   35, 2004.

117. fred charles, miguel lozano, steven j. mead, alicia fornes bisquerra, and marc cavazza.
in proceedings of tidse,

planning formalisms and authoring in interactive storytelling.
2003.

118. guillaume m. j. b. chaslot, mark h. m. winands, h. jaap van den herik, jos w. h. m.
uiterwijk, and bruno bouzy. progressive strategies for monte-carlo tree search. new math-
ematics and natural computation, 4(03):343   357, 2008.

119. xiang    anthony    chen, tovi grossman, daniel j. wigdor, and george fitzmaurice. duet:
in proceedings of the

exploring joint interactions on a smart phone and a smart watch.
sigchi conference on human factors in computing systems, pages 159   168, 2014.

120. zhengxing chen, magy seif el-nasr, alessandro canossa, jeremy badler, stefanie tignor,
and randy colvin. modeling individual differences through frequent pattern mining on
role-playing game actions. in eleventh arti   cial intelligence and interactive digital enter-
tainment conference, aiide, 2015.

121. sonia chernova, jeff orkin, and cynthia breazeal. id104 hri through online mul-

tiplayer games. in aaai fall symposium: dialog with robots, pages 14   19, 2010.

122. wei chu and zoubin ghahramani. preference learning with gaussian processes. in proceed-

ings of the international conference on machine learning (icml), pages 137   144, 2005.

123. david churchill and michael buro. portfolio greedy search and simulation for large-scale
combat in starcraft. in computational intelligence in games (cig), 2013 ieee conference
on. ieee, 2013.

124. david churchill, mike preuss, florian richoux, gabriel synnaeve, alberto uriarte, santi-
ago onta  n  on, and michal certick`y. starcraft bots and competitions. in encyclopedia of
computer graphics and games. springer, 2016.

125. andrea clerico, cindy chamberland, mark parent, pierre-emmanuel michon, sebastien
tremblay, tiago h. falk, jean-christophe gagnon, and philip jackson. biometrics and clas-
si   er fusion to predict the fun-factor in video gaming. in ieee computational intelligence
and games conference. ieee, 2016.

126. carlos a. coello coello, gary b. lamont, and david a. van veldhuizen. evolutionary

algorithms for solving multi-objective problems. springer, 2007.

127. nicholas cole, sushil j. louis, and chris miles. using a genetic algorithm to tune    rst-
in congress on evolutionary computation (cec), pages 139   145.

person shooter bots.
ieee, 2004.

references

299

128. karen collins. an introduction to procedural music in video games. contemporary music

129. karen collins. playing with sound: a theory of interacting with sound and music in video

review, 28(1):5   15, 2009.

games. mit press, 2013.

130. simon colton. creativity versus the perception of creativity in computational systems. in

aaai spring symposium: creative intelligent systems, 2008.

131. cristina conati. intelligent tutoring systems: new challenges and directions. in ijcai, pages

2   7, 2009.

132. cristina conati, abigail gertner, and kurt vanlehn. using id110s to manage
uncertainty in student modeling. user modeling and user-adapted interaction, 12(4):371   
417, 2002.

133. cristina conati and heather maclaren. modeling user affect from causes and effects. user

modeling, adaptation, and personalization, pages 4   15, 2009.

134. john conway. the game of life. scienti   c american, 223(4):4, 1970.
135. michael cook and simon colton. multi-faceted evolution of simple arcade games. in ieee

computational intelligence and games, pages 289   296, 2011.

136. michael cook and simon colton. ludus ex machina: building a 3d game designer that
competes alongside humans. in proceedings of the 5th international conference on compu-
tational creativity, 2014.

137. michael cook, simon colton, and alison pease. aesthetic considerations for automated

platformer design. in aiide, 2012.

138. seth cooper, firas khatib, adrien treuille, janos barbero, jeehyung lee, michael beenen,
andrew leaver-fay, david baker, zoran popovi  c, et al. predicting protein structures with a
multiplayer online game. nature, 466(7307):756   760, 2010.

139. corinna cortes and vladimir vapnik.

support-vector networks. machine learning,

20(3):273   297, 1995.

140. paul t. costa and robert r. maccrae. revised neo personality inventory (neo pi-r)
and neo    ve-factor inventory (neo-ffi): professional manual. psychological assessment
resources, incorporated, 1992.

141. r  emi coulom. ef   cient selectivity and backup operators in monte-carlo tree search.

in

international conference on computers and games, pages 72   83. springer, 2006.

142. r  emi coulom. computing elo ratings of move patterns in the game of go. in computer

games workshop, 2007.

143. roddy cowie and randolph r. cornelius. describing the emotional states that are expressed

in speech. speech communication, 40(1):5   32, 2003.

144. roddy cowie, ellen douglas-cowie, susie savvidou, edelle mcmahon, martin sawey, and
marc schr  oder.    feeltrace   : an instrument for recording perceived emotion in real time.
in isca tutorial and research workshop (itrw) on speech and emotion, 2000.

145. roddy cowie and martin sawey. gtrace-general trace program from queen   s university,

belfast, 2011.

146. peter i. cowling, edward j. powley, and daniel whitehouse. information set monte carlo
tree search. ieee transactions on computational intelligence and ai in games, 4(2):120   
143, 2012.

147. koby crammer and yoram singer. pranking with ranking. advances in neural information

processing systems, 14:641   647, 2002.

148. chris crawford. chris crawford on interactive storytelling. new riders, 2012.
149. mihaly csikszentmihalyi. creativity: flow and the psychology of discovery and invention.

new york: harper collins, 1996.

150. mihaly csikszentmihalyi. beyond boredom and anxiety. jossey-bass, 2000.
151. mihaly csikszentmihalyi. toward a psychology of optimal experience. springer, 2014.
152. george cybenko. approximation by superpositions of a sigmoidal function. mathematics

of control, signals and systems, 2(4):303   314, 1989.

153. ryan s. j. d. baker, gregory r. moore, angela z. wagner, jessica kalka, aatish salvi,
michael karabinos, colin a. ashe, and david yaron. the dynamics between student af-
fect and behavior occurring outside of educational software. in affective computing and
intelligent interaction, pages 14   24. springer, 2011.

300

references

154. anders dahlbom and lars niklasson. goal-directed hierarchical dynamic scripting for

rts games. in aiide, pages 21   28, 2006.

155. steve dahlskog and julian togelius. patterns as objectives for level generation. in proceed-

ings of the international conference on the foundations of digital games. acm, 2013.

156. steve dahlskog, julian togelius, and mark j. nelson. linear levels through id165s. in pro-
ceedings of the 18th international academic mindtrek conference: media business, man-
agement, content & services, pages 200   206. acm, 2014.

157. antonio r. damasio, barry j. everitt, and dorothy bishop. the somatic marker hypothesis
and the possible functions of the prefrontal cortex [and discussion]. philosophical transac-
tions of the royal society b: biological sciences, 351(1346):1413   1420, 1996.

158. gustavo danzi, andrade hugo pimentel santana, andr  e wilson brotto furtado,
andr  e roberto gouveia, amaral leitao, and geber lisboa ramalho. online adaptation
of computer games agents: a id23 approach. in ii workshop de jogos e
entretenimento digital, pages 105   112, 2003.

159. isaac m. dart, gabriele de rossi, and julian togelius. speedrock: procedural rocks through
grammars and evolution. in proceedings of the 2nd international workshop on procedural
content generation in games. acm, 2011.

160. fernando de mesentier silva, scott lee, julian togelius, and andy nealen. ai-based
playtesting of contemporary board games. in proceedings of foundations of digital games
(fdg), 2017.

161. maarten de waard, diederik m. roijers, and sander bakkes. id169 with
options for general video game playing. in computational intelligence and games (cig),
2016 ieee conference on. ieee, 2016.

162. edward l. deci and richard m. ryan. intrinsic motivation. wiley online library, 1975.
super mario bros.
163. erik d. demaine, giovanni viglietta, and aaron williams.

is
in proceedings of the 8th international conference on
harder/easier than we thought.
fun with algorithms (fun 2016), pages 13:1   13:14, la maddalena, italy, june 8   10 2016.
164. jack dennerlein, theodore becker, peter johnson, carson reynolds, and rosalind w. picard.
in proceedings of the

frustrating computer users increases exposure to physical factors.
international ergonomics association (iea), 2003.

165. j  org denzinger, kevin loose, darryl gates, and john w. buchanan. dealing with parame-
terized actions in behavior testing of commercial computer games. in ieee symposium
on computational intelligence and games, 2005.

166. l. devillers, r. cowie, j. c. martin, e. douglas-cowie, s. abrilian, and m. mcrorie. real
life emotions in french and english tv video clips: an integrated annotation protocol com-
bining continuous and discrete approaches. in proceedings of the 5th international confer-
ence on language resources and evaluation (lrec 2006), genoa, italy, page 22, 2006.

167. ravi dhar and itamar simonson. the effect of forced choice on choice. journal of marketing

research, 40(2), 2003.

168. joao dias, samuel mascarenhas, and ana paiva. fatima modular: towards an agent archi-
tecture with a generic appraisal framework. in emotion modeling, pages 44   56. springer,
2014.

169. kevin dill. a pattern-based approach to modular ai for games. game programming gems,

8:232   243, 2010.

170. kevin dill.

introducing gaia: a reusable, extensible architecture for ai behavior.

in

proceedings of the 2012 spring simulation interoperability workshop, 2012.

171. kevin dill and l. martin. a game ai approach to autonomous control of virtual characters.

in interservice/industry training, simulation, and education conference (i/itsec), 2011.

172. sidney d   mello and art graesser. automatic detection of learner   s affect from gross body

language. applied arti   cial intelligence, 23(2):123   150, 2009.

173. joris dormans. adventures in level design: generating missions and spaces for action ad-
venture games. in proceedings of the 2010 workshop on procedural content generation in
games. acm, 2010.

references

301

174. joris dormans and sander bakkes. generating missions and spaces for adaptable play expe-
riences. ieee transactions on computational intelligence and ai in games, 3(3):216   228,
2011.

175. aanders drachen, lennart nacke, georgios n. yannakakis, and anja lee pedersen. corre-
lation between heart rate, electrodermal activity and player experience in    rst-person shooter
games. in proceedings of the siggraph symposium on video games. acm-siggraph
publishers, 2010.

176. anders drachen, alessandro canossa, and georgios n. yannakakis. player modeling using
self-organization in tomb raider: underworld. in proceedings of the 2009 ieee symposium
on computational intelligence and games, pages 1   8. ieee, 2009.

177. anders drachen and matthias schubert. spatial game analytics. in game analytics, pages

365   402. springer, 2013.

178. anders drachen, christian thurau, julian togelius, georgios n. yannakakis, and christian

bauckhage. game data mining. in game analytics, pages 205   253. springer, 2013.

179. h. drucker, c.j. c. burges, l. kaufman, a. smola, and v. vapnik. support vector regression
machines. in advances in neural information processing systems (nips), pages 155   161.
morgan kaufmann publishers, 1997.

180. david s. ebert. texturing & modeling: a procedural approach. morgan kaufmann, 2003.
181. marc ebner, john levine, simon m. lucas, tom schaul, tommy thompson, and julian

togelius. towards a video game description language. dagstuhl follow-ups, 6, 2013.

182. arthur s. eddington. the constants of nature. in the world of mathematics 2, pages 1074   

1093. simon & schuster, 1956.

183. arjan egges, sumedha kshirsagar, and nadia magnenat-thalmann. generic personality
and emotion simulation for conversational agents. computer animation and virtual worlds,
15(1):1   13, 2004.

184. agoston e. eiben and james e. smith. introduction to evolutionary computing. springer,

185. magy seif el-nasr. intelligent lighting for game environments. journal of game develop-

2003.

ment, 2005.

186. magy seif el-nasr, anders drachen, and alessandro canossa. game analytics: maximizing

the value of player data. springer, 2013.

187. magy seif el-nasr, shree durga, mariya shiyko, and carmen sceppa. data-driven retro-
spective interviewing (ddri): a proposed methodology for formative evaluation of pervasive
games. entertainment computing, 11:1   19, 2015.

188. magy seif el-nasr, athanasios vasilakos, chinmay rao, and joseph zupko. dynamic intel-
ligent lighting for directing visual attention in interactive 3-d scenes. computational intelli-
gence and ai in games, ieee transactions on, 1(2):145   153, 2009.

189. magy seif el-nasr, john yen, and thomas r. ioerger. flame   fuzzy logic adaptive model

of emotions. autonomous agents and multi-agent systems, 3(3):219   257, 2000.

190. mirjam palosaari eladhari and michael mateas. semi-autonomous avatars in world of
minds: a case study of ai-based game design. in proceedings of the 2008 international
conference on advances in computer entertainment technology, pages 201   208. acm,
2008.

191. mirjam palosaari eladhari and michael sellers. good moods: outlook, affect and mood in
dynemotion and the mind module. in proceedings of the 2008 conference on future play:
research, play, share, pages 1   8. acm, 2008.

192. george skaff elias, richard gar   eld, k. robert gutschera, and peter whitley. characteris-

tics of games. mit press, 2012.

193. david k. elson and mark o. riedl. a lightweight intelligent virtual cinematography system

for machinima production. in aiide, pages 8   13, 2007.

194. nathan ensmenger. is chess the drosophila of ai? a social history of an algorithm. social

studies of science, 42(1):5   30, 2012.

195. ido erev and alvin e. roth. predicting how people play games: id23
in experimental games with unique, mixed strategy equilibria. american economic review,
pages 848   881, 1998.

302

references

196. martin ester, hans-peter kriegel, j  org sander, and xiaowei xu. a density-based algorithm
for discovering clusters in large spatial databases with noise. in proceedings of the interna-
tional conference on knowledge discovery and data mining (kdd), pages 226   231, 1996.
197. richard evans and emily short. versu   a simulationist storytelling system. ieee transac-

tions on computational intelligence and ai in games, 6(2):113   130, 2014.

198. vincent e. farrugia, h  ector p. mart    nez, and georgios n. yannakakis. the preference learn-

ing toolbox. arxiv preprint arxiv:1506.01709, 2015.

199. bjarke felbo, alan mislove, anders s  gaard, iyad rahwan, and sune lehmann. using
millions of emoji occurrences to learn any-domain representations for detecting sentiment,
emotion and sarcasm. arxiv preprint arxiv:1708.00524, 2017.

200. lisa a. feldman. valence focus and arousal focus: individual differences in the structure of

affective experience. journal of personality and social psychology, 69(1):153, 1995.

201. david ferrucci, eric brown, jennifer chu-carroll, james fan, david gondek, aditya a.
kalyanpur, adam lally, j. william murdock, eric nyberg, john prager, nico schlaefer, and
chris welty. building watson: an overview of the deepqa project. ai magazine, 31(3):59   
79, 2010.

202. hilmar finnsson and yngvi bj  ornsson. learning simulation control in general game-playing

agents. in aaai, pages 954   959, 2010.

203. jacob fischer, nikolaj falsted, mathias vielwerth, julian togelius, and sebastian risi.

monte-carlo tree search for simulated car racing. in proceedings of fdg, 2015.
204. john h. flavell. the developmental psychology of jean piaget. ardent media, 1963.
205. dario floreano, peter d  urr, and claudio mattiussi. neuroevolution: from architectures to

learning. evolutionary intelligence, 1(1):47   62, 2008.

206. dario floreano, toshifumi kato, davide marocco, and eric sauser. coevolution of active

vision and feature selection. biological cybernetics, 90(3):218   228, 2004.

207. david b. fogel. blondie24: playing at the edge of ai. morgan kaufmann, 2001.
208. david b. fogel, timothy j. hays, sarah l. hahn, and james quon. the blondie25 chess
program competes against fritz 8.0 and a human chess master. in computational intelligence
and games, 2006 ieee symposium on, pages 230   235. ieee, 2006.

209. tom forsyth. cellular automata for physical modelling. game programming gems, 3:200   

214, 2002.

210. alain fournier, don fussell, and loren carpenter. computer rendering of stochastic models.

communications of the acm, 25(6):371   384, 1982.

211. michael freed, travis bear, herrick goldman, geoffrey hyatt, paul reber, a. sylvan, and
in working notes of the
joshua tauber. towards more human-like computer opponents.
aaai spring symposium on arti   cial intelligence and interactive entertainment, pages 22   
26, 2000.

212. nico frijda. the emotions. cambridge university press, englewood cliffs, nj, 1986.
213. frederik frydenberg, kasper r. andersen, sebastian risi, and julian togelius. investigating
in computational intelligence and

mcts modi   cations in general video game playing.
games (cig), 2015 ieee conference on, pages 107   113. ieee, 2015.

214. drew fudenberg and david k. levine. the theory of learning in games. mit press, 1998.
215. j. f  urnkranz and e. h  ullermeier. preference learning. springer, 2010.
216. raluca d. gaina, jialin liu, simon m. lucas, and diego p  erez-li  ebana. analysis of vanilla
rolling horizon evolution parameters in general video game playing. in european con-
ference on the applications of evolutionary computation, pages 418   434. springer, 2017.

217. maurizio garbarino, simone tognetti, matteo matteucci, and andrea bonarini. learning
general preference models from physiological responses in video games: how complex is it?
in affective computing and intelligent interaction, pages 517   526. springer, 2011.

218. pablo garc    a-s  anchez, alberto tonda, giovanni squillero, antonio mora, and juan j.
in computational intelligence and

merelo. evolutionary deckbuilding in hearthstone.
games (cig), 2016 ieee conference on. ieee, 2016.

219. tom a. garner. from sinewaves to physiologically-adaptive soundscapes: the evolving
relationship between sound and emotion in video games. in emotion in games: theory
and praxis, pages 197   214. springer, 2016.

references

303

220. tom a. garner and mark grimshaw. sonic virtuality: understanding audio in a virtual world.

the oxford handbook of virtuality, 2014.

221. h. p. gasselseder. re-scoring the games score: dynamic music and immersion in the
ludonarrative. in proceedings of the intelligent human computer interaction conference,
2014.

222. jakub gemrot, rudolf kadlec, michal b    da, ond  rej burkert, radek p    bil, jan havl      cek,
luk  a  s zem  c  ak, juraj   simlovi  c, radim vansa, michal   stolba, tom  a  s plch, and cyril brom.
pogamut 3 can assist developers in building ai (not only) for their videogame agents. in
agents for games and simulations, pages 1   15. springer, 2009.

223. michael genesereth, nathaniel love, and barney pell. general game playing: overview of

the aaai competition. ai magazine, 26(2):62, 2005.

224. michael georgeff, barney pell, martha pollack, milind tambe, and michael wooldridge.
the belief-desire-intention model of agency. in international workshop on agent theories,
architectures, and languages, pages 1   10. springer, 1998.

225. kallirroi georgila, james henderson, and oliver lemon. learning user simulations for in-

formation state update dialogue systems. in interspeech, pages 893   896, 2005.

226. panayiotis g. georgiou, matthew p. black, adam c. lammert, brian r. baucom, and
shrikanth s. narayanan.    that   s aggravating, very aggravating   : is it possible to clas-
sify behaviors in couple interactions using automatically derived lexical features? in
affective computing and intelligent interaction, pages 87   96. springer, 2011.

227. maryrose gerardi, barbara olasov rothbaum, kerry ressler, mary heekin, and albert
rizzo. virtual reality exposure therapy using a virtual iraq: case report. journal of trau-
matic stress, 21(2):209   213, 2008.

228. malik ghallab, dana nau, and paolo traverso. automated planning: theory and practice.

elsevier, 2004.

229. spyridon giannatos, yun-gyung cheong, mark j. nelson, and georgios n. yannakakis.
generating narrative action schemas for suspense. in eighth arti   cial intelligence and in-
teractive digital entertainment conference, 2012.

230. arthur gill. introduction to the theory of id122. mcgraw-hill, 1962.
231. ian goodfellow, yoshua bengio, and aaron courville. deep learning. mit press, 2016.
232. ian goodfellow, jean pouget-abadie, mehdi mirza, bing xu, david warde-farley, sherjil
ozair, aaron courville, and yoshua bengio. generative adversarial nets. in advances in
neural information processing systems, pages 2672   2680, 2014.

233. nitesh goyal, gilly leshed, dan cosley, and susan r. fussell. effects of implicit sharing
in collaborative analysis. in proceedings of the sigchi conference on human factors in
computing systems, pages 129   138, 2014.

234. katja grace, john salvatier, allan dafoe, baobao zhang, and owain evans. when will ai
exceed human performance? evidence from ai experts. arxiv preprint arxiv:1705.08807,
2017.

235. thore graepel, ralf herbrich, and julian gold. learning to    ght. in proceedings of the in-
ternational conference on computer games: arti   cial intelligence, design and education,
pages 193   200, 2004.

236. joseph f. grafsgaard, kristy elizabeth boyer, and james c. lester. predicting facial indica-
tors of confusion with id48. in proceedings of international conference
on affective computing and intelligent interaction (acii), pages 97   106. springer, 2011.

237. jonathan gratch. emile: marshalling passions in training and education. in proceedings of

the fourth international conference on autonomous agents, pages 325   332. acm, 2000.

238. jonathan gratch and stacy marsella. a domain-independent framework for modeling emo-

tion. cognitive systems research, 5(4):269   306, 2004.

239. jonathan gratch and stacy marsella. evaluating a computational model of emotion. au-

tonomous agents and multi-agent systems, 11(1):23   43, 2005.

240. daniele gravina, antonios liapis, and georgios n. yannakakis. constrained surprise search
for content generation. in computational intelligence and games (cig), 2016 ieee con-
ference on. ieee, 2016.

304

references

241. elin rut gudnadottir, alaina k. jensen, yun-gyung cheong, julian togelius, byung chull
bae, and christoffer holmg  ard pedersen. detecting predatory behaviour in online game
chats. in the 2nd workshop on games and nlp, 2014.

242. johan hagelbck. potential-   eld based navigation in starcraft. in ieee conference on com-

putational intelligence and games (cig). ieee, 2012.

243. mark hall, eibe frank, geoffrey holmes, bernhard pfahringer, peter reutemann, and ian h.
witten. the weka data mining software: an update. acm sigkdd explorations newsletter,
11(1):10   18, 2009.

244. jiawei han and micheline kamber. data mining: concepts and techniques. morgan kauf-

mann, 2006.

245. nikolaus hansen and andreas ostermeier. completely derandomized self-adaptation in evo-

lution strategies. evolutionary computation, 9(2):159   195, 2001.

246. daniel damir harabor and alban grastien. online graph pruning for path   nding on grid

maps. in aaai, 2011.

247. peter e. hart, nils j. nilsson, and bertram raphael. correction to a formal basis for the

heuristic determination of minimum cost paths. acm sigart bulletin, (37):28   29, 1972.

248. ken hartsook, alexander zook, sauvik das, and mark o. riedl. toward supporting stories
with procedurally generated game worlds. in computational intelligence and games (cig),
2011 ieee conference on, pages 297   304. ieee, 2011.

249. erin j. hastings, ratan k. guha, and kenneth o. stanley. automatic content generation in
the galactic arms race video game. ieee transactions on computational intelligence and
ai in games, 1(4):245   263, 2009.

250. erin j. hastings, ratan k. guha, and kenneth o. stanley. evolving content in the galactic
in ieee symposium on computational intelligence and games,

arms race video game.
pages 241   248. ieee, 2009.

251. matthew hausknecht, joel lehman, risto miikkulainen, and peter stone. a neuroevolution
approach to general atari game playing. ieee transactions on computational intelligence
and ai in games, 6(4):355   366, 2014.

252. brian hawkins. real-time cinematography for games (game development series). charles

river media, inc., 2004.

253. simon haykin. neural networks: a comprehensive foundation. macmillian college pub-

lishing company inc., upper saddle river, nj, usa, 1998.

254. richard l. hazlett. measuring emotional valence during interactive experiences: boys at
video game play. in proceedings of sigchi conference on human factors in computing
systems (chi), pages 1023   1026. acm, 2006.

255. jennifer healey. recording affect in the    eld: towards methods and metrics for improv-
ing ground truth labels. in affective computing and intelligent interaction, pages 107   116.
springer, 2011.

256. d. o. hebb. the organization of behavior. wiley, new york, 1949.
257. norbert heijne and sander bakkes. procedural zelda: a pcg environment for player ex-
perience research. in proceedings of the international conference on the foundations of
digital games. acm, 2017.

258. harry helson. adaptation-level theory. harper & row, 1964.
259. ralf herbrich, michael e. tipping, and mark hatton. personalized behavior of computer

controlled avatars in a virtual reality environment, august 15 2006. us patent 7,090,576.

260. javier hernandez, rob r. morris, and rosalind w. picard. call center stress recognition with
person-speci   c models. in affective computing and intelligent interaction, pages 125   134.
springer, 2011.

261. david hilbert.   uber die stetige abbildung einer linie auf ein fl  achenst  uck. mathematische

annalen, 38(3):459   460, 1891.

262. philip hingston. a turing test for computer game bots. ieee transactions on computational

intelligence and ai in games, 1(3):169   186, 2009.

263. philip hingston. a new design for a turing test for bots. in computational intelligence and

games (cig), 2010 ieee symposium on, pages 345   350. ieee, 2010.

references

305

264. philip hingston. believable bots: can computers play like people? springer, 2012.
265. philip hingston, clare bates congdon, and graham kendall. mobile games with intelli-
gence: a killer application? in computational intelligence in games (cig), 2013 ieee
conference on, pages 1   7. ieee, 2013.

266. sepp hochreiter and j  urgen schmidhuber. long short-term memory. neural computation,

9(8):1735   1780, 1997.

267. christoffer holmg  ard, antonios liapis, julian togelius, and georgios n. yannakakis. evolv-
ing personas for player decision modeling. in computational intelligence and games (cig),
2014 ieee conference on. ieee, 2014.

268. christoffer holmg  ard, antonios liapis, julian togelius, and georgios n. yannakakis. gen-

erative agents for player decision modeling in games. in fdg, 2014.

269. christoffer holmg  ard, antonios liapis, julian togelius, and georgios n. yannakakis. per-
sonas versus clones for player decision modeling. in international conference on entertain-
ment computing, pages 159   166. springer, 2014.

270. christoffer holmg  ard, georgios n. yannakakis, karen-inge karstoft, and henrik steen an-
dersen. stress detection for ptsd via the startlemart game. in affective computing and
intelligent interaction (acii), 2013 humaine association conference on, pages 523   528.
ieee, 2013.

271. christoffer holmg  ard, georgios n. yannakakis, h  ector p. mart    nez, and karen-inge
in affec-
karstoft. to rank or to classify? annotating stress for reliable ptsd pro   ling.
tive computing and intelligent interaction (acii), 2015 international conference on, pages
719   725. ieee, 2015.

272. christoffer holmg  ard, georgios n. yannakakis, h  ector p. mart    nez, karen-inge karstoft,
and henrik steen andersen. multimodal ptsd characterization via the startlemart game.
journal on multimodal user interfaces, 9(1):3   15, 2015.

273. nils iver holtar, mark j. nelson, and julian togelius. audioverdrive: exploring bidirectional
in proceedings of the 2013 international

communication between music and gameplay.
computer music conference, pages 124   131, 2013.

274. vincent hom and joe marks. automatic design of balanced board games. in proceedings
of the aaai conference on arti   cial intelligence and interactive digital entertainment (ai-
ide), pages 25   30, 2007.

275. amy k. hoover, william cachia, antonios liapis, and georgios n. yannakakis. au-
dioinspace: exploring the creative fusion of generative audio, visuals and gameplay.
in evolutionary and biologically inspired music, sound, art and design, pages 101   112.
springer, 2015.

276. amy k. hoover, paul a. szerlip, and kenneth o. stanley. functional scaffolding for com-

posing additional musical voices. computer music journal, 2014.

277. amy k. hoover, julian togelius, and georgios n. yannakakis. composing video game levels
with music metaphors through functional scaffolding. in first computational creativity and
games workshop, iccc, 2015.

278. john j. hop   eld. neural networks and physical systems with emergent collective computa-
tional abilities. proceedings of the national academy of sciences, 79(8):2554   2558, 1982.
279. kurt hornik, maxwell stinchcombe, and halbert white. multilayer feedforward networks

are universal approximators. neural networks, 2(5):359   366, 1989.

280. ben houge. cell-based music organization in tom clancy   s endwar. in demo at the aiide

2012 workshop on musical metacreation, 2012.

281. ryan houlette. player modeling for adaptive games. ai game programming wisdom ii,

pages 557   566. charles river media, inc., 2004.

282. andrew howlett, simon colton, and cameron browne. evolving pixel shaders for the pro-
totype video game subversion. in the thirty sixth annual convention of the society for the
study of arti   cial intelligence and simulation of behaviour (aisb10), de montfort univer-
sity, leicester, uk, 30th march, 2010.

283. johanna h  oysniemi, perttu h  am  al  ainen, laura turkki, and teppo rouvi. children   s intuitive

gestures in vision-based action games. communications of the acm, 48(1):44   50, 2005.

306

references

284. chih-wei hsu and chih-jen lin. a comparison of methods for multiclass support vector

machines. ieee transactions on neural networks, 13(2):415   425, 2002.

285. feng-hsiung hsu. behind deep blue: building the computer that defeated the world chess

champion. princeton university press, 2002.

286. wijnand ijsselsteijn, karolien poels, and y. a. w. de kort. the game experience question-
naire: development of a self-report measure to assess player experiences of digital games.
tu eindhoven, eindhoven, the netherlands, 2008.

287. interactive data visualization. speedtree, 2010. http://www.speedtree.com/.
288. aaron isaksen, dan gopstein, julian togelius, and andy nealen. discovering unique game
variants. in computational creativity and games workshop at the 2015 international con-
ference on computational creativity, 2015.

289. aaron isaksen, daniel gopstein, and andrew nealen. exploring game space using survival

analysis. in proceedings of foundations of digital games (fdg), 2015.

290. katherine isbister and noah schaffer. game usability: advancing the player experience.

crc press, 2015.

291. damian isla. handling complexity in the halo 2 ai. in game developers conference, 2005.
292. damian isla and bruce blumberg. new challenges for character-based ai for games.
in
proceedings of the aaai spring symposium on ai and interactive entertainment, pages 41   
45. aaai press, 2002.

293. susan a. jackson and robert c. eklund. assessing    ow in physical activity: the    ow state
scale-2 and dispositional    ow scale-2. journal of sport & exercise psychology, 24(2), 2002.
294. emil juul jacobsen, rasmus greve, and julian togelius. monte mario: platforming with
mcts. in proceedings of the 2014 annual conference on genetic and evolutionary com-
putation, pages 293   300. acm, 2014.

295. alexander jaffe, alex miller, erik andersen, yun-en liu, anna karlin, and zoran popovic.

evaluating competitive game balance with restricted play. in aiide, 2012.

296. rishabh jain, aaron isaksen, christoffer holmg  ard, and julian togelius. autoencoders for
level generation, repair, and recognition. in iccc workshop on computational creativity
and games, 2016.

297. daniel jallov, sebastian risi, and julian togelius. evocommander: a novel game based
on evolving and switching between arti   cial brains. ieee transactions on computational
intelligence and ai in games, 9(2):181   191, 2017.

298. susan jamieson. likert scales: how to (ab) use them. medical education, 38(12):1217   1218,

2004.

299. aki j  arvinen. gran stylissimo: the audiovisual elements and styles in computer and video

games. in proceedings of computer games and digital cultures conference, 2002.

300. arnav jhala and r. michael young. cinematic visual discourse: representation, genera-
tion, and evaluation. computational intelligence and ai in games, ieee transactions on,
2(2):69   81, 2010.

301. yuu jinnai and alex s. fukunaga. learning to prune dominated action sequences in online

black-box planning. in aaai, pages 839   845, 2017.

302. thorsten joachims. text categorization with support vector machines: learning with many

relevant features. machine learning: ecml-98, pages 137   142, 1998.

303. thorsten joachims. optimizing search engines using clickthrough data.

in proceedings
of the acm sigkdd international conference on knowledge discovery in data mining
(kdd), pages 133   142. acm, 2002.

304. lawrence johnson, georgios n. yannakakis, and julian togelius. cellular automata for real-
time generation of in   nite cave levels. in proceedings of the 2010 workshop on procedural
content generation in games. acm, 2010.

305. matthew johnson, katja hofmann, tim hutton, and david bignell. the malmo platform for

arti   cial intelligence experimentation. in ijcai, pages 4246   4247, 2016.

306. tom johnstone and klaus r. scherer. vocal communication of emotion. in handbook of

emotions, pages 220   235. guilford press, new york, 2000.

references

307

307. german gutierrez jorge munoz and araceli sanchis. towards imitation of human driving
style in car racing games. in philip hingston, editor, believable bots: can computers play
like people? springer, 2012.

308. patrik n. juslin and klaus r. scherer. vocal expression of affect. oxford university press,

oxford, uk, 2005.

309. niels justesen, tobias mahlmann, and julian togelius. online evolution for multi-action ad-
versarial games. in european conference on the applications of evolutionary computation,
pages 590   603. springer, 2016.

310. niels justesen and sebastian risi. continual online evolutionary planning for in-game
in proceedings of the conference on genetic and

build order adaptation in starcraft.
evolutionary computation (gecco), 2017.

311. niels justesen, b  alint tillman, julian togelius, and sebastian risi. script-and cluster-based
uct for starcraft. in computational intelligence and games (cig), 2014 ieee conference
on. ieee, 2014.

312. tr  ondur justinussen, peter hald rasmussen, alessandro canossa, and julian togelius. re-
source systems in games: an analytical approach. in computational intelligence and games
(cig), 2012 ieee conference on, pages 171   178. ieee, 2012.
313. jesper juul. games telling stories. game studies, 1(1):45, 2001.
314. jesper juul. a casual revolution: reinventing video games and their players. mit press,

2010.

315. souhila kaci. working with preferences: less is more. springer, 2011.
316. leslie pack kaelbling, michael l. littman, and andrew w. moore. id23:

a survey. journal of arti   cial intelligence research, 4:237   285, 1996.

317. daniel kahneman. a perspective on judgment and choice: mapping bounded rationality.

american psychologist, 58(9):697, 2003.

318. daniel kahneman and jason riis. living, and thinking about it: two perspectives on life.

the science of well-being, pages 285   304, 2005.

319. theofanis kannetis and alexandros potamianos. towards adapting fantasy, curiosity and
challenge in multimodal dialogue systems for preschoolers. in proceedings of international
conference on multimodal interfaces (icmi), pages 39   46. acm, 2009.

320. theofanis kannetis, alexandros potamianos, and georgios n. yannakakis. fantasy, curiosity
and challenge as adaptation indicators in multimodal dialogue systems for preschoolers. in
proceedings of the 2nd workshop on child, computer and interaction. acm, 2009.

321. ashish kapoor, winslow burleson, and rosalind w. picard. automatic prediction of frus-

tration. international journal of human-computer studies, 65(8):724   736, 2007.

322. sergey karakovskiy and julian togelius. the mario ai benchmark and competitions. ieee

transactions on computational intelligence and ai in games, 4(1):55   67, 2012.

323. dani  el karavolos, anders bouwer, and rafael bidarra. mixed-initiative design of game
levels: integrating mission and space into level generation. in proceedings of the 10th inter-
national conference on the foundations of digital games, 2015.

324. daniel karavolos, antonios liapis, and georgios n. yannakakis. learning the patterns of
balance in a multi-player shooter game. in proceedings of the fdg workshop on procedural
content generation in games, 2017.

325. kostas karpouzis and georgios n. yannakakis. emotion in games: theory and praxis.

springer, 2016.

326. kostas karpouzis, georgios n. yannakakis, noor shaker, and stylianos asteriadis. the
platformer experience dataset. in affective computing and intelligent interaction (acii),
2015 international conference on, pages 712   718. ieee, 2015.

327. igor v. karpov, leif johnson, and risto miikkulainen. evaluation methods for active human-
guided neuroevolution in games. in 2012 aaai fall symposium on robots learning inter-
actively from human teachers (rliht), 2012.

328. igor v. karpov, jacob schrum, and risto miikkulainen. believable bot navigation via play-
back of human traces. in philip hingston, editor, believable bots: can computers play like
people? springer, 2012.

308

references

329. leonard kaufman and peter j. rousseeuw. id91 by means of medoids. north-holland,

330. leonard kaufman and peter j. rousseeuw. finding groups in data: an introduction to cluster

analysis. john wiley & sons, 2009.

331. richard kaye. minesweeper is np-complete. the mathematical intelligencer, 22(2):9   15,

1987.

2000.

332. markus kemmerling and mike preuss. automatic adaptation to generated content via car
setup optimization in torcs. in computational intelligence and games (cig), 2010 ieee
symposium on, pages 131   138. ieee, 2010.

333. micha   kempka, marek wydmuch, grzegorz runc, jakub toczek, and wojciech ja  skowski.
vizdoom: a doom-based ai research platform for visual id23. arxiv
preprint arxiv:1605.02097, 2016.

334. graham kendall, andrew j. parkes, and kristian spoerer. a survey of np-complete puzzles.

icga journal, 31(1):13   34, 2008.

335. manuel kerssemakers, jeppe tuxen, julian togelius, and georgios n. yannakakis. a proce-
dural procedural level generator generator. in computational intelligence and games (cig),
2012 ieee conference on, pages 335   341. ieee, 2012.

336. rilla khaled and georgios n. yannakakis. village voices: an adaptive game for con   ict

resolution. in proceedings of fdg, pages 425   426, 2013.

337. ahmed khalifa, aaron isaksen, julian togelius, and andy nealen. modifying mcts for

human-like general video game playing. in proceedings of ijcai, 2016.

338. ahmed khalifa, diego perez-liebana, simon m. lucas, and julian togelius. general video

game level generation. in proceedings of ijcai, 2016.

339. k-j kim, heejin choi, and sung-bae cho. hybrid of evolution and reinforcement learn-
ing for othello players. in computational intelligence and games, 2007. cig 2007. ieee
symposium on, pages 203   209. ieee, 2007.

340. kyung-min kim, chang-jun nan, jung-woo ha, yu-jung heo, and byoung-tak zhang.
pororobot: a deep learning robot that plays video q&a games. in aaai 2015 fall sympo-
sium on ai for id176 (ai-hri 2015), 2015.

341. steven orla kimbrough, gary j. koehler, ming lu, and david harlan wood. on a feasible   
infeasible two-population (fi-2pop) genetic algorithm for constrained optimization: dis-
tance tracing and no free lunch. european journal of operational research, 190(2):310   327,
2008.

342. diederik p. kingma and max welling. auto-encoding id58. arxiv preprint

arxiv:1312.6114, 2013.

343. a. kleinsmith and n. bianchi-berthouze. affective body expression perception and recog-

nition: a survey. ieee transactions on affective computing, 2012.

344. andrea kleinsmith and nadia bianchi-berthouze. form as a cue in the automatic recognition
of non-acted affective body expressions. in affective computing and intelligent interaction,
pages 155   164. springer, 2011.

345. yana knight, h  ector perez mart    nez, and georgios n. yannakakis. space maze: experience-

driven game camera control. in fdg, pages 427   428, 2013.

346. matthias j. koepp, roger n. gunn, andrew d. lawrence, vincent j. cunningham, alain
dagher, tasmin jones, david j. brooks, c. j. bench, and p. m. grasby. evidence for striatal
dopamine release during a video game. nature, 393(6682):266   268, 1998.

347. teuvo kohonen. self-organizing maps. springer, secaucus, nj, usa, 3rd edition, 2001.
348. andrey n. kolmogorov. on the representation of continuous functions of several variables by
superposition of continuous functions of one variable and addition. russian, american math-
ematical society translation 28 (1963) 55-59. doklady akademiia nauk ssr, 14(5):953   
956, 1957.

349. richard kone  cn`y. modeling of    ghting game players. master   s thesis, institute of digital

games, university of malta, 2016.

350. michael kosfeld, markus heinrichs, paul j. zak, urs fischbacher, and ernst fehr. oxytocin

increases trust in humans. nature, 435(7042):673   676, 2005.

references

309

351. raph koster. theory of fun for game design. o   reilly media, inc., 2013.
352. bartosz kostka, jaroslaw kwiecien, jakub kowalski, and pawel rychlikowski. text-based

adventures of the golovin ai agent. arxiv preprint arxiv:1705.05637, 2017.

353. jan koutn    k, giuseppe cuccu, j  urgen schmidhuber, and faustino gomez. evolving large-
scale neural networks for vision-based id23. in proceedings of the 15th
annual conference on genetic and evolutionary computation, pages 1061   1068. acm,
2013.

354. jakub kowalski and andrzej kisielewicz. towards a real-time game description language.

in icaart (2), pages 494   499, 2016.

355. jakub kowalski and marek szyku  a. evolving chess-like games using relative algorithm
performance pro   les. in european conference on the applications of evolutionary compu-
tation, pages 574   589. springer, 2016.

356. john r. koza. genetic programming: on the programming of computers by means of natural

selection. mit press, 1992.

357. teofebano kristo and nur ulfa maulidevi. deduction of    ghting game countermeasures
in data and software engineering

using neuroevolution of augmenting topologies.
(icodse), 2016 international conference on. ieee, 2016.

358. ben kybartas and rafael bidarra. a semantic foundation for mixed-initiative computational

storytelling. in interactive storytelling, pages 162   169. springer, 2015.

359. alexandros labrinidis and hosagrahar v. jagadish. challenges and opportunities with big

data. proceedings of the vldb endowment, 5(12):2032   2033, 2012.

360. john laird and michael van lent. human-level ai   s killer application: interactive computer

games. ai magazine, 22(2):15, 2001.

361. g. b. langley and h. sheppeard. the visual analogue scale: its use in pain measurement.

rheumatology international, 5(4):145   148, 1985.

362. frank lantz, aaron isaksen, alexander jaffe, andy nealen, and julian togelius. depth in

strategic games. in proceedings of the aaai wnaig workshop, 2017.

363. pier luca lanzi, wolfgang stolzmann, and stewart w. wilson. learning classi   er systems:

from foundations to applications. springer, 2003.

364. richard s. lazarus. emotion and adaptation. oxford university press, 1991.
365. nicole lazzaro. why we play games: four keys to more emotion without story. technical

366. yann lecun, yoshua bengio, and geoffrey hinton. deep learning. nature, 521(7553):436   

report, xeo design inc., 2004.

444, 2015.

367. david lee and mihalis yannakakis. principles and methods of testing    nite state machines   

a survey. proceedings of the ieee, 84(8):1090   1123, 1996.

368. alan levinovitz. the mystery of go, the ancient game that computers still can   t win. wired

magazine, 2014.

369. mike lewis and kevin dill. game ai appreciation, revisited. in game ai pro 2: collected

wisdom of game ai professionals, pages 3   18. ak peters/crc press, 2015.

370. boyang li, stephen lee-urban, darren scott appling, and mark o. riedl. id104

narrative intelligence. advances in cognitive systems, 2(1), 2012.

371. antonios liapis. creativity facet orchestration: the whys and the hows. arti   cial and com-

putational intelligence in games: integration; dagstuhl follow-ups, 2015.

372. antonios liapis. mixed-initiative creative drawing with webiconoscope. in proceedings
of the 6th international conference on computational intelligence in music, sound, art and
design. (evomusart). springer, 2017.

373. antonios liapis, h  ector p. mart  nez, julian togelius, and georgios n. yannakakis. trans-
forming exploratory creativity with delenox. in proceedings of the fourth international
conference on computational creativity, pages 56   63, 2013.

374. antonios liapis, gillian smith, and noor shaker. mixed-initiative content creation.

in

procedural content generation in games, pages 195   214. springer, 2016.

375. antonios liapis and georgios n. yannakakis. boosting computational creativity with human
interaction in mixed-initiative co-creation tasks. in proceedings of the iccc workshop on
computational creativity and games, 2016.

310

references

376. antonios liapis, georgios n. yannakakis, and julian togelius. neuroevolutionary con-
strained optimization for content creation. in computational intelligence and games (cig),
2011 ieee conference on, pages 71   78. ieee, 2011.

377. antonios liapis, georgios n. yannakakis, and julian togelius. adapting models of visual
aesthetics for personalized content creation. ieee transactions on computational intelli-
gence and ai in games, 4(3):213   228, 2012.

378. antonios liapis, georgios n. yannakakis, and julian togelius. designer modeling for per-
sonalized game content creation tools. in proceedings of the aiide workshop on arti   cial
intelligence & game aesthetics, 2013.

379. antonios liapis, georgios n. yannakakis, and julian togelius.

sentient sketchbook:
computer-aided game level authoring. in proceedings of acm conference on foundations
of digital games, pages 213   220, 2013.

380. antonios liapis, georgios n. yannakakis, and julian togelius. sentient world: human-
based procedural cartography. in evolutionary and biologically inspired music, sound, art
and design, pages 180   191. springer, 2013.

381. antonios liapis, georgios n. yannakakis, and julian togelius. computational game cre-
ativity. in proceedings of the fifth international conference on computational creativity,
pages 285   292, 2014.

382. antonios liapis, georgios n. yannakakis, and julian togelius. constrained novelty search:

a study on game content generation. evolutionary computation, 23(1):101   129, 2015.

383. vladimir lifschitz. answer set programming and plan generation. arti   cial intelligence,

384. rensis likert. a technique for the measurement of attitudes. archives of psychology, 140:1   

138(1-2):39   54, 2002.

55, 1932.

385. chong-u lim, robin baumgarten, and simon colton. evolving behaviour trees for the
commercial game defcon. in european conference on the applications of evolutionary
computation, pages 100   110. springer, 2010.

386. chong-u lim and d. fox harrell. revealing social identity phenomena in videogames with
in proceedings of the 6th international aisb symposium on ai and

archetypal analysis.
games, 2015.

387. aristid lindenmayer. mathematical models for cellular interactions in development i. fila-

ments with one-sided inputs. journal of theoretical biology, 18(3):280   299, 1968.

388. r. l. linn and n. e. gronlund. measurement and assessment in teaching. prentice-hall,

2000.

389. nir lipovetzky and hector geffner. width-based algorithms for classical planning: new
results. in proceedings of the twenty-   rst european conference on arti   cial intelligence,
pages 1059   1060. ios press, 2014.

390. nir lipovetzky, miquel ramirez, and hector geffner. classical planning with simulators:

results on the atari video games. in proceedings of ijcai, pages 1610   1616, 2015.

391. maria teresa llano, michael cook, christian guckelsberger, simon colton, and rose hep-
worth. towards the automatic generation of    ctional ideas for games. in experimental ai
in games (exag14), a workshop collocated with the tenth annual aaai conference on
arti   cial intelligence and interactive digital entertainment (aiide14). aaai publications,
2014.

392. daniele loiacono, pier luca lanzi, julian togelius, enrique onieva, david a. pelta, mar-
tin v. butz, thies d. l  onneker, luigi cardamone, diego perez, yago s  aez, mike preuss, and
jan quad   ieg. the 2009 simulated car racing championship. computational intelligence and
ai in games, ieee transactions on, 2(2):131   147, 2010.

393. daniele loiacono, julian togelius, pier luca lanzi, leonard kinnaird-heether, simon m.
lucas, matt simmerson, diego perez, robert g. reynolds, and yago saez. the wcci 2008
simulated car racing competition. in ieee symposium on computational intelligence and
games, pages 119   126. ieee, 2008.

394. phil lopes, antonios liapis, and georgios n. yannakakis. sonancia: soni   cation of pro-
cedurally generated game levels. in proceedings of the iccc workshop on computational
creativity & games, 2015.

references

311

395. phil lopes, antonios liapis, and georgios n. yannakakis. framing tension for game gener-
ation. in proceedings of the seventh international conference on computational creativity,
2016.

396. phil lopes, antonios liapis, and georgios n. yannakakis. modelling affect for horror sound-

scapes. ieee transactions on affective computing, 2017.

397. phil lopes, georgios n. yannakakis, and antonios liapis. ranktrace: relative and un-
bounded affect annotation. in affective computing and intelligent interaction (acii), 2017
international conference on, 2017.

398. ricardo lopes and rafael bidarra. adaptivity challenges in games and simulations: a survey.

computational intelligence and ai in games, ieee transactions on, 3(2):85   99, 2011.

399. sandy louchart, ruth aylett, joao dias, and ana paiva. unscripted narrative for affectively

driven characters. in aiide, pages 81   86, 2005.

400. nathaniel love, timothy hinrichs, david haley, eric schkufza, and michael genesereth.
general game playing: game description language speci   cation. technical report lg-2006-
01, stanford logic group, computer science department, stanford university, 2008.

401. a. bryan loyall and joseph bates. personality-rich believable agents that use language. in
proceedings of the first international conference on autonomous agents, pages 106   113.
acm, 1997.

402. feiyu lu, kaito yamamoto, luis h. nomura, syunsuke mizuno, youngmin lee, and ruck
thawonmas. fighting game arti   cial intelligence competition platform. in consumer elec-
tronics (gcce), 2013 ieee 2nd global conference on, pages 320   323. ieee, 2013.

403. simon m. lucas. evolving a neural network location evaluator to play ms. pac-man.
in proceedings of the ieee symposium on computational intelligence and games, pages
203   210, 2005.

404. simon m. lucas. ms pac-man competition. acm sigevolution, 2(4):37   38, 2007.
405. simon m. lucas. computational intelligence and games: challenges and opportunities. in-

ternational journal of automation and computing, 5(1):45   57, 2008.

406. simon m. lucas and graham kendall. evolutionary computation and games. computational

intelligence magazine, ieee, 1(1):10   18, 2006.

407. simon m. lucas, michael mateas, mike preuss, pieter spronck, and julian togelius. arti   -
cial and computational intelligence in games (dagstuhl seminar 12191). dagstuhl reports,
2(5):43   70, 2012.

408. simon m. lucas and t. jeff reynolds. learning    nite-state transducers: evolution versus
heuristic state merging. ieee transactions on evolutionary computation, 11(3):308   325,
2007.

409. jeremy ludwig and art farley. a learning infrastructure for improving agent performance
and game balance. in georgios n. yannakakis and john hallam, editors, proceedings of the
aiide   07 workshop on optimizing player satisfaction, technical report ws-07-01, pages
7   12. aaai press, 2007.

410. kevin lynch. the image of the city. mit press, 1960.
411. james macqueen. some methods for classi   cation and analysis of multivariate observations.
in proceedings of the fifth berkeley symposium on mathematical statistics and id203,
number 14, pages 281   297. oakland, ca, usa, 1967.

412. brian magerko. story representation and interactive drama. in aiide, pages 87   92, 2005.
413. brendan maher. can a video game company tame toxic behaviour? nature, 531(7596):568   

571, 2016.

414. tobias mahlmann, anders drachen, julian togelius, alessandro canossa, and georgios n.
yannakakis. predicting player behavior in tomb raider: underworld. in proceedings of the
2010 ieee conference on computational intelligence and games, pages 178   185. ieee,
2010.

415. tobias mahlmann, julian togelius, and georgios n. yannakakis. modelling and evalua-
tion of complex scenarios with the strategy game description language. in computational
intelligence and games (cig), 2011 ieee conference on, pages 174   181. ieee, 2011.

312

references

416. tobias mahlmann, julian togelius, and georgios n. yannakakis. evolving card sets towards
balancing dominion. in proceedings of the ieee congress on evolutionary computation
(cec). ieee, 2012.

417. kevin majchrzak, jan quad   ieg, and g  unter rudolph. advanced dynamic scripting for
   ghting game ai. in international conference on entertainment computing, pages 86   99.
springer, 2015.

418. nikos malandrakis, alexandros potamianos, georgios evangelopoulos, and athanasia zlat-
intsi. a supervised approach to movie emotion tracking. in acoustics, speech and signal
processing (icassp), 2011 ieee international conference on, pages 2376   2379. ieee,
2011.

419. thomas w. malone. what makes computer games fun? byte, 6:258   277, 1981.
420. regan l. mandryk and m. stella atkins. a fuzzy physiological approach for continu-
international journal

ously modeling emotion during interaction with play technologies.
of human-computer studies, 65(4):329   347, 2007.

421. regan l. mandryk, kori m. inkpen, and thomas w. calvert. using psychophysiological
techniques to measure user experience with entertainment technologies. behaviour & infor-
mation technology, 25(2):141   158, 2006.

422. jacek mandziuk. computational intelligence in mind games. challenges for computational

423. jacek mandziuk. knowledge-free and learning-based methods in intelligent game playing.

intelligence, 63:407   442, 2007.

springer, 2010.

424. benjamin mark, tudor berechet, tobias mahlmann, and julian togelius. procedural gener-
ation of 3d caves for games on the gpu. in proceedings of the conference on the founda-
tions of digital games (fdg), 2015.

425. dave mark. behavioral mathematics for game ai. charles river media, 2009.
426. dave mark and kevin dill. improving ai decision modeling through utility theory. in game

developers conference, 2010.

427. gloria mark, yiran wang, and melissa niiya. stress and multitasking in everyday college
in proceedings of the sigchi conference on

life: an empirical study of online activity.
human factors in computing systems, pages 41   50, 2014.

428. stacy marsella, jonathan gratch, and paolo petta. computational models of emotion. a

blueprint for affective computing   a sourcebook and manual, 11(1):21   46, 2010.

429. chris martens. ceptre: a language for modeling generative interactive systems. in eleventh

arti   cial intelligence and interactive digital entertainment conference, 2015.

430. h  ector p. mart    nez, yoshua bengio, and georgios n. yannakakis. learning deep physiolog-

ical models of affect. computational intelligence magazine, ieee, 9(1):20   33, 2013.

431. h  ector p. mart    nez, maurizio garbarino, and georgios n. yannakakis. generic physiological
features as predictors of player experience. in affective computing and intelligent interac-
tion, pages 267   276. springer, 2011.

432. h  ector p. mart    nez, kenneth hullett, and georgios n. yannakakis. extending neuro-
evolutionary preference learning through player modeling. in proceedings of the 2010 ieee
conference on computational intelligence and games, pages 313   320. ieee, 2010.

433. h  ector p. mart    nez and georgios n. yannakakis. genetic search feature selection for affec-
tive modeling: a case study on reported preferences. in proceedings of the 3rd international
workshop on affective interaction in natural environments, pages 15   20. acm, 2010.

434. h  ector p. mart    nez and georgios n. yannakakis. mining multimodal sequential patterns: a
case study on affect detection. in proceedings of international conference on multimodal
interfaces (icmi), pages 3   10. acm, 2011.

435. h  ector p. mart    nez and georgios n. yannakakis. deep multimodal fusion: combining dis-
crete events and continuous signals. in proceedings of the 16th international conference on
multimodal interaction, pages 34   41. acm, 2014.

436. h  ector p. mart    nez, georgios n. yannakakis, and john hallam. don   t classify ratings of

affect; rank them! ieee transactions on affective computing, 5(3):314   326, 2014.

references

313

437. giovanna martinez-arellano, richard cant, and david woods. creating ai characters for
fighting games using genetic programming. ieee transactions on computational intelli-
gence and ai in games, 2016.

438. michael mateas. interactive drama, art and arti   cial intelligence. phd thesis, carnegie

mellon university, pittsburgh, pa, usa, 2002.

439. michael mateas. expressive ai: games and arti   cial intelligence. in digra conference,

2003.

440. michael mateas and andrew stern. a behavior language for story-based believable agents.

ieee intelligent systems, 17(4):39   47, 2002.

441. michael mateas and andrew stern. fac  ade: an experiment in building a fully-realized in-

teractive drama. in game developers conference, 2003.

442. michael mauderer, simone conte, miguel a. nacenta, and dhanraj vishwanath. depth
perception with gaze-contingent depth of    eld. in proceedings of the sigchi conference
on human factors in computing systems, pages 217   226, 2014.

443. john d. mayer and peter salovey. the intelligence of emotional intelligence. intelligence,

17(4):433   442, 1993.

444. allan mazur, elizabeth j. susman, and sandy edelbrock. sex difference in testosterone

response to a video game contest. evolution and human behavior, 18(5):317   326, 1997.

445. andrew mcafee, erik brynjolfsson, thomas h. davenport, d. j. patil, and dominic barton.

big data. the management revolution. harvard bus rev, 90(10):61   67, 2012.

446. john mccarthy. partial formalizations and the lemmings game. technical report, stanford

university, 1998.

447. josh mccoy, mike treanor, ben samuel, michael mateas, and noah wardrip-fruin. prom
week: social physics as gameplay. in proceedings of the 6th international conference on
foundations of digital games, pages 319   321. acm, 2011.

448. josh mccoy, mike treanor, ben samuel, aaron a. reed, noah wardrip-fruin, and michael
mateas. prom week. in proceedings of the international conference on the foundations of
digital games, pages 235   237. acm, 2012.

449. robert r. mccrae and paul t. costa jr. a    ve-factor theory of personality. handbook of

personality: theory and research, 2:139   153, 1999.

450. warren s. mcculloch and walter pitts. a logical calculus of the ideas immanent in nervous

activity. bulletin of mathematical biophysics, 5(4):115   133, 1943.

451. scott w. mcquiggan, sunyoung lee, and james c. lester. early prediction of student frus-
tration. in proceedings of international conference on affective computing and intelligent
interaction, pages 698   709. springer, 2007.

452. scott w. mcquiggan, bradford w. mott, and james c. lester. modeling self-ef   cacy in
intelligent tutoring systems: an inductive approach. user modeling and user-adapted in-
teraction, 18(1):81   123, 2008.

453. andre mendes, julian togelius, and andy nealen. hyper-heuristic general video game play-
in computational intelligence and games (cig), 2016 ieee conference on. ieee,

ing.
2016.

454. daniel s. messinger, tricia d. cassel, susan i. acosta, zara ambadar, and jeffrey f. cohn.
infant smiling dynamics and perceived positive emotion. journal of nonverbal behavior,
32(3):133   155, 2008.

455. angeliki metallinou and shrikanth narayanan. annotation and processing of continuous
emotional attributes: challenges and opportunities. in 10th ieee international conference
and workshops on automatic face and gesture recognition (fg). ieee, 2013.

456. zbigniew michalewicz. do not kill unfeasible individuals.

in proceedings of the fourth

intelligent information systems workshop, pages 110   123, 1995.

457. risto miikkulainen, bobby d. bryant, ryan cornelius, igor v. karpov, kenneth o. stanley,
and chern han yong. computational intelligence in games. computational intelligence:
principles and practice, pages 155   191, 2006.

458. benedikte mikkelsen, christoffer holmg  ard, and julian togelius. ethical considerations for

player modeling. in proceedings of the aaai wnaig workshop, 2017.

314

references

459. tomas mikolov, kai chen, greg corrado, and jeffrey dean. ef   cient estimation of word

representations in vector space. arxiv preprint arxiv:1301.3781, 2013.

460. george a. miller. the magical number seven, plus or minus two: some limits on our capacity

for processing information. psychological review, 63(2):81, 1956.

461. ian millington and john funge. arti   cial intelligence for games. crc press, 2009.
462. talya miron-shatz, arthur stone, and daniel kahneman. memories of yesterday   s emotions:
does the valence of experience affect the memory-experience gap? emotion, 9(6):885, 2009.
463. volodymyr mnih, adria puigdomenech badia, mehdi mirza, alex graves, timothy lilli-
crap, tim harley, david silver, and koray kavukcuoglu. asynchronous methods for deep
in international conference on machine learning, pages 1928   
id23.
1937, 2016.

464. volodymyr mnih, koray kavukcuoglu, david silver, andrei a. rusu, joel veness, marc g.
bellemare, alex graves, martin riedmiller, andreas k. fidjeland, georg ostrovski, stig pe-
tersen, charles beattie, amir sadik, ioannis antonoglou, helen king, dharshan kumaran,
daan wierstra, shane legg, and demis hassabis. human-level control through deep rein-
forcement learning. nature, 518(7540):529   533, 2015.

465. mathew monfort, matthew johnson, aude oliva, and katja hofmann. asynchronous data
in proceedings of the 16th
aggregation for training end to end visual control networks.
conference on autonomous agents and multi-agent systems, pages 530   537. international
foundation for autonomous agents and multiagent systems, may 2017.

466. nick montfort and ian bogost. racing the beam: the atari video computer system. mit

press, 2009.

467. matej morav  c    k, martin schmid, neil burch, viliam lis`y, dustin morrill, nolan bard,
trevor davis, kevin waugh, michael johanson, and michael bowling. deepstack: expert-
level arti   cial intelligence in no-limit poker. arxiv preprint arxiv:1701.01724, 2017.

468. jon d. morris. observations: sam: the self-assessment manikin   an ef   cient cross-
cultural measurement of emotional response. journal of advertising research, 35(6):63   68,
1995.

469. jorge munoz, georgios n. yannakakis, fiona mulvey, dan witzner hansen, german gutier-
rez, and araceli sanchis. towards gaze-controlled platform games. in computational intel-
ligence and games (cig), 2011 ieee conference on, pages 47   54. ieee, 2011.

470. hector munoz-avila, christian bauckhage, michal bida, clare bates congdon, and graham

kendall. learning and game ai. dagstuhl follow-ups, 6, 2013.

471. roger b. myerson. game theory: analysis of con   ict. 1991. cambridge: mass, harvard

university.

472. roger b. myerson. game theory. harvard university press, 2013.
473. lennart nacke and craig a. lindley. flow and immersion in    rst-person shooters: measuring
the player   s gameplay experience. in proceedings of the 2008 conference on future play:
research, play, share, pages 81   88. acm, 2008.

474. frederik nagel, reinhard kopiez, oliver grewe, and eckart altenm  uller. emujoy: software
for continuous measurement of perceived emotions in music. behavior research methods,
39(2):283   290, 2007.

475. karthik narasimhan, tejas kulkarni, and regina barzilay. language understanding for text-

based games using deep id23. arxiv preprint arxiv:1506.08941, 2015.

476. alexander nareyek. intelligent agents for computer games. in t.a. marsland and i. frank,
editors, computers and games, second international conference, cg 2002, pages 414   422,
2002.

477. alexander nareyek. game ai is dead. long live game ai! ieee intelligent systems, (1):9   

11, 2007.

478. john f. nash. equilibrium points in n-person games. in proceedings of the national academy

of sciences, number 1, pages 48   49, 1950.

479. steve nebel, sascha schneider, and g  unter daniel rey. mining learning and crafting sci-
enti   c experiments: a literature review on the use of minecraft in education and research.
journal of educational technology & society, 19(2):355, 2016.

references

315

if theory

480. graham nelson. natural language, semantic analysis, and interactive    ction.

reader, 141, 2006.

481. mark j. nelson. game metrics without players: strategies for understanding game arti-

facts. in aiide workshop on arti   cial intelligence in the game design process, 2011.

482. mark j. nelson, simon colton, edward j. powley, swen e. gaudl, peter ivey, rob saunders,
blanca p  erez ferrer, and michael cook. mixed-initiative approaches to on-device mobile
game design. in proceedings of the chi workshop on mixed-initiative creative interfaces,
2017.

483. mark j. nelson and michael mateas. search-based drama management in the interactive
fiction anchorhead. in proceedings of the first arti   cial intelligence and interactive digital
entertainment conference, pages 99   104, 2005.

484. mark j. nelson and michael mateas. an interactive game-design assistant. in proceedings

of the 13th international conference on intelligent user interfaces, pages 90   98, 2008.

485. mark j. nelson and adam m. smith. asp with applications to mazes and levels. in proce-

dural content generation in games, pages 143   157. springer, 2016.

486. mark j. nelson, julian togelius, cameron browne, and michael cook. rules and mechanics.

in procedural content generation in games, pages 99   121. springer, 2016.

487. john von neumann. theory of self-reproducing automata. university of illinois press,

champaign, il, usa, 1966.

488. truong-huy d. nguyen, shree subramanian, magy seif el-nasr, and alessandro canossa.
strategy detection in wuzzit: a decision theoretic approach. in international conference
on learning science   workshop on learning analytics for learning and becoming a prac-
tice, 2014.

489. jakob nielsen.

usability 101:

introduction to usability, 2003.

available at

http://www.useit.com/alertbox/20030825.html.

490. jon lau nielsen, benjamin fedder jensen, tobias mahlmann, julian togelius, and geor-
gios n. yannakakis. ai for general strategy game playing. handbook of digital games,
pages 274   304, 2014.

491. thorbj  rn s. nielsen, gabriella a. b. barros, julian togelius, and mark j. nelson. general
video game evaluation using relative algorithm performance pro   les. in applications of
evolutionary computation, pages 369   380. springer, 2015.

492. thorbj  rn s. nielsen, gabriella a. b. barros, julian togelius, and mark j. nelson. towards
generating arcade game rules with vgdl. in proceedings of the 2015 ieee conference on
computational intelligence and games, 2015.

493. anton nijholt. bci for games: a state of the art survey. in entertainment computing-icec

2008, pages 225   228. springer, 2009.

494. nils j. nilsson. shakey the robot. technical report, dtic document, 1984.
495. kai ninomiya, mubbasir kapadia, alexander shoulson, francisco garcia, and norman
badler. planning approaches to constraint-aware navigation in dynamic environments. com-
puter animation and virtual worlds, 26(2):119   139, 2015.

496. stefano nol    and dario floreano. evolutionary robotics: the biology, intelligence, and

technology of self-organizing machines. mit press, 2000.

497. david g. novick and stephen sutton. what is mixed-initiative interaction. in proceedings
of the aaai spring symposium on computational models for mixed initiative interaction,
pages 114   116, 1997.

498. gabriela ochoa. on id107 and lindenmayer systems.

in parallel problem

solving from nature   ppsn v, pages 335   344. springer, 1998.

499. jacob kaae olesen, georgios n. yannakakis, and john hallam. real-time challenge balance
in an rts game using rtneat. in computational intelligence and games, 2008. cig   08.
ieee symposium on, pages 87   94. ieee, 2008.

500. jacob olsen. realtime procedural terrain generation. 2004.
501. peter thorup   lsted, benjamin ma, and sebastian risi. interactive evolution of levels for a
competitive multiplayer fps. in evolutionary computation (cec), 2015 ieee congress on,
pages 1527   1534. ieee, 2015.

316

references

502. cathy o   neil. weapons of math destruction: how big data increases inequality and threatens

democracy. crown publishing group (ny), 2016.

503. santiago onta  n  on. the combinatorial multi-armed bandit problem and its application to real-
time strategy games. in ninth arti   cial intelligence and interactive digital entertainment
conference, 2013.

504. santiago onta  n  on, gabriel synnaeve, alberto uriarte, florian richoux, david churchill, and
mike preuss. a survey of real-time strategy game ai research and competition in starcraft.
ieee transactions on computational intelligence and ai in games, 5(4):293   311, 2013.

505. santiago onta  n  on, gabriel synnaeve, alberto uriarte, florian richoux, david churchill, and
mike preuss. rts ai: problems and techniques. in encyclopedia of computer graphics
and games. springer, 2015.

506. jeff orkin. applying goal-oriented action planning to games. ai game programming wisdom,

507. jeff orkin. three states and a plan: the ai of f.e.a.r. in game developers conference,

2:217   228, 2003.

2006.

508. jeff orkin and deb roy. the restaurant game: learning social behavior and language from

thousands of players online. journal of game development, 3(1):39   60, 2007.

509. mauricio orozco, juan silva, abdulmotaleb el saddik, and emil petriu. the role of haptics

in games. in haptics rendering and applications. intech, 2012.

510. brian o   neill and mark riedl. emotion-driven narrative generation. in emotion in games:

theory and praxis, pages 167   180. springer, 2016.

511. juan ortega, noor shaker, julian togelius, and georgios n. yannakakis. imitating human

playing styles in super mario bros. entertainment computing, 4(2):93   104, 2013.

512. andrew ortony, gerald l. clore, and allan collins. the cognitive structure of emotions.

cambridge university press, 1990.

513. martin j. osborne. an introduction to game theory. oxford university press, 2004.
514. alexander osherenko. opinion mining and lexical affect sensing. computer-aided analysis

of opinions and emotions in texts. phd thesis, university of augsburg, 2010.

515. seth ovadia. ratings and rankings: reconsidering the structure of values and their measure-

ment. international journal of social research methodology, 7(5):403   414, 2004.

516. ana paiva, joao dias, daniel sobral, ruth aylett, polly sobreperez, sarah woods, carsten
zoll, and lynne hall. caring for agents and agents that care: building empathic relations with
synthetic agents. in proceedings of the third international joint conference on autonomous
agents and multiagent systems, pages 194   201. ieee computer society, 2004.

517. bo pang and lillian lee. opinion mining and id31. foundations and trends

in information retrieval, 2(1   2):1   135, 2008.

518. matt parker and bobby d. bryant. visual control in quake ii with a cyclic controller. in
computational intelligence and games, 2008. cig   08. ieee symposium on, pages 151   
158. ieee, 2008.

519. matt parker and bobby d. bryant. neurovisual control in the quake ii environment. ieee

transactions on computational intelligence and ai in games, 4(1):44   54, 2012.

520. chris pedersen, julian togelius, and georgios n. yannakakis. modeling player experience
in super mario bros. in proceedings of the ieee symposium on computational intelligence
and games, pages 132   139. ieee, 2009.

521. chris pedersen, julian togelius, and georgios n. yannakakis. modeling player experience
for content creation. ieee transactions on computational intelligence and ai in games,
2(1):54   67, 2010.

522. barney pell. strategy generation and evaluation for meta-game playing. phd thesis, uni-

versity of cambridge, 1993.

523. peng peng, quan yuan, ying wen, yaodong yang, zhenkun tang, haitao long, and jun
wang. multiagent bidirectionally-coordinated nets for learning to play starcraft combat
games. arxiv preprint arxiv:1703.10069, 2017.

524. tom pepels, mark h. m. winands, and marc lanctot. real-time id169 in
ms pac-man. ieee transactions on computational intelligence and ai in games, 6(3):245   
257, 2014.

references

317

525. diego perez, edward j. powley, daniel whitehouse, philipp rohlfshagen, spyridon samoth-
rakis, peter i. cowling, and simon m. lucas. solving the physical traveling salesman prob-
lem: tree search and macro actions. ieee transactions on computational intelligence and
ai in games, 6(1):31   45, 2014.

526. diego perez, spyridon samothrakis, simon lucas, and philipp rohlfshagen. rolling horizon
evolution versus tree search for navigation in single-player real-time games. in proceedings
of the 15th annual conference on genetic and evolutionary computation, pages 351   358.
acm, 2013.

527. diego perez-liebana, spyridon samothrakis, julian togelius, tom schaul, and simon m.
lucas. general video game ai: competition, challenges and opportunities. in proceedings
of the thirtieth aaai conference on arti   cial intelligence, 2016.

528. diego perez-liebana, spyridon samothrakis, julian togelius, tom schaul, simon m. lucas,
adrien cou  etoux, jerry lee, chong-u lim, and tommy thompson. the 2014 general video
ieee transactions on computational intelligence and ai in
game playing competition.
games, 8(3):229   243, 2016.

529. ken perlin. an image synthesizer. acm siggraph computer graphics, 19(3):287   296,

1985.

530. rosalind w. picard. affective computing. mit press, cambridge, ma, 1997.
531. grant pickett, foaad khosmood, and allan fowler. automated generation of conversational
non player characters. in eleventh arti   cial intelligence and interactive digital entertain-
ment conference, 2015.

532. michele pirovano. the use of fuzzy logic for arti   cial intelligence in games. technical

report, university of milano, milano, 2012.

533. jacques pitrat. realization of a general game-playing program. in ifip congress (2), pages

1570   1574, 1968.

534. isabella poggi, catherine pelachaud, fiorella de rosis, valeria caro   glio, and berardina
de carolis. greta. a believable embodied conversational agent. in multimodal intelligent
information presentation, pages 3   25. springer, 2005.

535. mihai polceanu. mirrorbot: using human-inspired mirroring behavior to pass a turing test.

in computational intelligence in games (cig), 2013 ieee conference on. ieee, 2013.

536. riccardo poli, william b. langdon, and nicholas f. mcphee. a    eld guide to genetic pro-
gramming. 2008. published via http://lulu.com and freely available at http://www.gp-   eld-
guide.org.uk (with contributions by j. r. koza).

537. jordan b. pollack and alan d. blair. co-evolution in the successful learning of backgammon

strategy. machine learning, 32(3):225   240, 1998.

538. jordan b. pollack, alan d. blair, and mark land. coevolution of a backgammon player.
in arti   cial life v: proceedings of the fifth international workshop on the synthesis and
simulation of living systems, pages 92   98. cambridge, ma: the mit press, 1997.

539. jonathan posner, james a. russell, and bradley s. peterson. the circumplex model of affect:
an integrative approach to affective neuroscience, cognitive development, and psychopathol-
ogy. development and psychopathology, 17(03):715   734, 2005.

540. david premack and guy woodruff. does the chimpanzee have a theory of mind? behavioral

and brain sciences, 1(04):515   526, 1978.

541. mike preuss, daniel kozakowski, johan hagelb  ack, and heike trautmann. reactive strategy
in computational intelligence in games

choice in starcraft by means of fuzzy control.
(cig), 2013 ieee conference on. ieee, 2013.

542. przemyslaw prusinkiewicz and aristid lindenmayer. the algorithmic beauty of plants.

springer, 1990.

543. jan quad   ieg, mike preuss, and g  unter rudolph. driving as a human: a track learning
based adaptable architecture for a car racing controller. genetic programming and evolvable
machines, 15(4):433   476, 2014.

544. j. ross quinlan. induction of id90. machine learning, 1(1):81   106, 1986.
545. j. ross quinlan. c4. 5: programs for machine learning. elsevier, 2014.
546. steve rabin. ai game programming wisdom. charles river media, inc., 2002.

318

references

547. steve rabin. ai game programming wisdom 2. charles river media, inc., 2003.
548. steve rabin. ai game programming wisdom 3. charles river media, inc., 2006.
549. steve rabin. ai game programming wisdom 4. nelson education, 2014.
550. steve rabin and nathan sturtevant. path   nding architecture optimizations. in game ai

pro: collected wisdom of game ai professionals. crc press, 2013.

551. steve rabin and nathan sturtevant. combining bounding boxes and jps to prune grid

path   nding. in aaai conference on arti   cial intelligence, 2016.

552. steven rabin. game ai pro: collected wisdom of game ai professionals. crc press, 2013.
553. steven rabin. game ai pro 2: collected wisdom of game ai professionals. crc press,

2015.

554. william l. raffe, fabio zambetta, and xiaodong li. a survey of procedural terrain gener-
ation techniques using evolutionary algorithms. in ieee congress on evolutionary compu-
tation (cec). ieee, 2012.

555. judith ramey, ted boren, elisabeth cuddihy, joe dumas, zhiwei guan, maaike j. van den
haak, and menno d. t. de jong. does think aloud work? how do we know? in chi   06
extended abstracts on human factors in computing systems, pages 45   48. acm, 2006.

556. pramila rani, nilanjan sarkar, and changchun liu. maintaining optimal challenge in com-
puter games through real-time physiological feedback. in proceedings of the 11th interna-
tional conference on human computer interaction, pages 184   192, 2005.

557. jakob rasmussen. are behavior trees a thing of the past? gamasutra, 2016.
558. niklas ravaja, timo saari, mikko salminen, jari laarni, and kari kallinen. phasic emo-
tional reactions to video game events: a psychophysiological investigation. media psychol-
ogy, 8(4):343   367, 2006.

559. genaro rebolledo-mendez, ian dunwell, erika mart    nez-mir  on, maria dolores vargas-
cerd  an, sara de freitas, fotis liarokapis, and alma r. garc    a-gaona. assessing neurosky   s
usability to detect attention levels in an assessment exercise. human-computer interaction.
new trends, pages 149   158, 2009.

560. jochen renz, xiaoyu ge, stephen gould, and peng zhang. the angry birds ai competition.

561. antonio ricciardi and patrick thill. adaptive ai for fighting games. technical report,

562. mark o. riedl and vadim bulitko. interactive narrative: an intelligent systems approach. ai

ai magazine, 36(2):85   87, 2015.

stanford university, 2008.

magazine, 34(1):67, 2012.

563. mark o. riedl and andrew stern. believable agents and intelligent story adaptation for
interactive storytelling. technologies for interactive digital storytelling and entertainment,
pages 1   12, 2006.

564. mark o. riedl and alexander zook. ai for game production.

in ieee conference on

computational intelligence in games (cig). ieee, 2013.

565. sebastian risi, joel lehman, david b. d   ambrosio, ryan hall, and kenneth o. stanley.
combining search-based procedural content generation and social gaming in the petalz
video game. in proceedings of aiide, 2012.

566. sebastian risi, joel lehman, david b. d   ambrosio, ryan hall, and kenneth o. stanley.
petalz: search-based procedural content generation for the casual gamer. ieee transactions
on computational intelligence and ai in games, 8(3):244   255, 2016.

567. sebastian risi and julian togelius. neuroevolution in games: state of the art and open
challenges. ieee transactions on computational intelligence and ai in games, 9(1):25   41,
2017.

568. david l. roberts, harikrishna narayanan, and charles l. isbell. learning to in   uence emo-
tional responses for interactive storytelling. in proceedings of the 2009 aaai symposium on
intelligent narrative technologies ii, 2009.

569. glen robertson and ian d. watson. a review of real-time strategy game ai. ai magazine,

35(4):75   104, 2014.

570. glen robertson and ian d. watson. an improved dataset and extraction process for star-

craft ai. in flairs conference, 2014.

references

319

571. michael d. robinson and gerald l. clore. belief and feeling: evidence for an accessibility

model of emotional self-report. psychological bulletin, 128(6):934, 2002.

572. jennifer robison, scott mcquiggan, and james lester. evaluating the consequences of af-
fective feedback in intelligent tutoring systems. in proceedings of international conference
on affective computing and intelligent interaction (acii). ieee, 2009.

573. philipp rohlfshagen, jialin liu, diego perez-liebana, and simon m. lucas. pac-man con-
quers academia: two decades of research using a classic arcade game. ieee transac-
tions on computational intelligence and ai in games, 2017.

574. philipp rohlfshagen and simon m. lucas. ms pac-man versus ghost team cec 2011 com-
petition. in ieee congress on evolutionary computation (cec), pages 70   77. ieee, 2011.
575. edmund t. rolls. the orbitofrontal cortex and reward. cerebral cortex, 10(3):284   294,

2000.

576. frank rosenblatt. the id88: a probabilistic model for information storage and organi-

zation in the brain. psychological review, 65(6):386, 1958.

577. jonathan rowe, bradford mott, scott mcquiggan, jennifer robison, sunyoung lee, and
james lester. crystal island: a narrative-centered learning environment for eighth grade
microbiology. in workshop on intelligent educational games at the 14th international con-
ference on arti   cial intelligence in education, brighton, uk, pages 11   20, 2009.

578. jonathan p. rowe, lucy r. shores, bradford w. mott, and james c. lester.

integrating
learning, problem solving, and engagement in narrative-centered learning environments. in-
ternational journal of arti   cial intelligence in education, 21(1-2):115   133, 2011.

579. david e. rumelhart, geoffrey e. hinton, and ronald j. williams. learning representations

by back-propagating errors. nature, 323(6088):533   536, 1986.

580. thomas philip runarsson and simon m. lucas. coevolution versus self-play temporal dif-
ference learning for acquiring position evaluation in small-board go. ieee transactions on
evolutionary computation, 9(6):628   640, 2005.

581. james a. russell. a circumplex model of affect. journal of personality and social psychol-

582. stuart russell and peter norvig. arti   cial intelligence: a modern approach. prentice-hall,

ogy, 39(6):1161, 1980.

englewood cliffs, 1995.

583. richard m. ryan, c. scott rigby, and andrew przybylski. the motivational pull of video
games: a self-determination theory approach. motivation and emotion, 30(4):344   360,
2006.

584. jennifer l. sabourin and james c. lester. affect and engagement in game-based learning

environments. ieee transactions on affective computing, 5(1):45   56, 2014.

585. owen sacco, antonios liapis, and georgios n. yannakakis. a holistic approach for
in computational intelligence and games (cig), 2016

semantic-based game generation.
ieee conference on. ieee, 2016.

586. frantisek sailer, michael buro, and marc lanctot. adversarial planning through strategy
simulation. in computational intelligence and games, 2007. cig 2007. ieee symposium
on, pages 80   87. ieee, 2007.

587. katie salen and eric zimmerman. rules of play: game design fundamentals. mit press,

2004.

588. christoph salge, christian lipski, tobias mahlmann, and brigitte mathiak. using geneti-
cally optimized arti   cial intelligence to improve gameplaying fun for strategical games. in
sandbox    08: proceedings of the 2008 acm siggraph symposium on video games, pages
7   14, new york, ny, usa, 2008. acm.

589. spyridon samothrakis, simon m. lucas, thomas philip runarsson, and david robles. co-
evolving game-playing agents: measuring performance and intransitivities. evolutionary
computation, ieee transactions on, 17(2):213   226, 2013.

590. spyridon samothrakis, david robles, and simon m. lucas. fast approximate max-n monte
carlo tree search for ms pac-man. ieee transactions on computational intelligence and ai
in games, 3(2):142   154, 2011.

591. arthur l. samuel. some studies in machine learning using the game of checkers.

ibm

journal of research and development, 3(3):210   229, 1959.

320

references

592. frederik schadd, sander bakkes, and pieter spronck. opponent modeling in real-time strat-

egy games. in gameon, pages 61   70, 2007.

593. jonathan schaeffer, neil burch, yngvi bj  ornsson, akihiro kishimoto, martin m  uller, robert
lake, paul lu, and steve sutphen. checkers is solved. science, 317(5844):1518   1522, 2007.
594. jonathan schaeffer, robert lake, paul lu, and martin bryant. chinook: the world man-

machine checkers champion. ai magazine, 17(1):21, 1996.

595. jost schatzmann, karl weilhammer, matt stuttle, and steve young. a survey of statistical
user simulation techniques for reinforcement-learning of dialogue management strategies.
knowledge engineering review, 21(2):97   126, 2006.

596. tom schaul. a video game description language for model-based or interactive learning. in

computational intelligence in games (cig), 2013 ieee conference on. ieee, 2013.

597. tom schaul. an extensible description language for video games. ieee transactions on

computational intelligence and ai in games, 6(4):325   331, 2014.

598. tom schaul, julian togelius, and j  urgen schmidhuber. measuring intelligence through

games. arxiv preprint arxiv:1109.1314, 2011.

599. jesse schell. the art of game design: a book of lenses. crc press, 2014.
600. klaus r. scherer. what are emotions? and how can they be measured? social science

information, 44(4):695   729, 2005.

601. klaus r. scherer, angela schorr, and tom johnstone. appraisal processes in emotion: the-

ory, methods, research. oxford university press, 2001.

602. j  urgen schmidhuber. developmental robotics, optimal arti   cial curiosity, creativity, music,

and the    ne arts. connection science, 18(2):173   187, 2006.

603. jacob schrum, igor v. karpov, and risto miikkulainen. ut  2: human-like behavior via neu-
roevolution of combat behavior and replay of human traces. in computational intelligence
and games (cig), 2011 ieee conference on, pages 329   336. ieee, 2011.

604. brian schwab. ai game engine programming. nelson education, 2009.
605. brian schwab, dave mark, kevin dill, mike lewis, and richard evans. gdc: turing

tantrums: ai developers rant, 2011.

606. marco scirea, yun-gyung cheong, mark j. nelson, and byung-chull bae. evaluating mu-
sical foreshadowing of videogame narrative experiences. in proceedings of the 9th audio
mostly: a conference on interaction with sound. acm, 2014.

607. ben seymour and samuel m. mcclure. anchors, scales and the relative coding of value in

the brain. current opinion in neurobiology, 18(2):173   178, 2008.

608. mohammad shaker, mhd hasan sarhan, ola al naameh, noor shaker, and julian togelius.
automatic generation and analysis of physics-based puzzle games. in computational intel-
ligence in games (cig), 2013 ieee conference on. ieee, 2013.

609. noor shaker, stylianos asteriadis, georgios n. yannakakis, and kostas karpouzis. a game-
based corpus for analysing the interplay between game context and player experience. in
affective computing and intelligent interaction, pages 547   556. springer, 2011.

610. noor shaker, stylianos asteriadis, georgios n. yannakakis, and kostas karpouzis. fus-
ing visual and behavioral cues for modeling user experience in games. cybernetics, ieee
transactions on, 43(6):1519   1531, 2013.

611. noor shaker, miguel nicolau, georgios n. yannakakis, julian togelius, and michael o   neil.
evolving levels for super mario bros using grammatical evolution. in ieee conference on
computational intelligence and games, pages 304   311. ieee, 2012.

612. noor shaker, mohammad shaker, and mohamed abou-zleikha. towards generic models of
player experience. in proceedings, the eleventh aaai conference on arti   cial intelligence
and interactive digital entertainment. aaai press, 2015.

613. noor shaker, mohammad shaker, and julian togelius. evolving playable content for cut

the rope through a simulation-based approach. in aiide, 2013.

614. noor shaker, mohammad shaker, and julian togelius. ropossum: an authoring tool for

designing, optimizing and solving cut the rope levels. in aiide, 2013.

615. noor shaker, gillian smith, and georgios n. yannakakis. evaluating content generators. in

procedural content generation in games, pages 215   224. springer, 2016.

references

321

616. noor shaker, julian togelius, and mark j. nelson, editors. procedural content generation

in games. springer, 2016.

617. noor shaker, julian togelius, and georgios n. yannakakis. towards automatic personalized
content generation for platform games. in proceedings of the aaai conference on arti   cial
intelligence and interactive digital entertainment (aiide). aaai press, october 2010.

618. noor shaker, julian togelius, and georgios n. yannakakis. the experience-driven perspec-

tive. in procedural content generation in games, pages 181   194. springer, 2016.

619. noor shaker, julian togelius, georgios n. yannakakis, likith poovanna, vinay s. ethiraj,
stefan j. johansson, robert g. reynolds, leonard k. heether, tom schumann, and marcus
gallagher. the turing test track of the 2012 mario ai championship: entries and evaluation.
in computational intelligence in games (cig), 2013 ieee conference on. ieee, 2013.

620. noor shaker, julian togelius, georgios n. yannakakis, ben weber, tomoyuki shimizu,
tomonori hashiyama, nathan sorenson, philippe pasquier, peter mawhorter, glen taka-
hashi, gillian smith, and robin baumgarten. the 2010 mario ai championship: level gen-
eration track. computational intelligence and ai in games, ieee transactions on, 3(4):332   
347, 2011.

621. noor shaker, georgios n. yannakakis, and julian togelius. id104 the aesthetics
of platform games. computational intelligence and ai in games, ieee transactions on,
5(3):276   290, 2013.

622. amirhosein shantia, eric begue, and marco wiering. connectionist id23
for intelligent unit micro management in starcraft. in neural networks (ijid98), the 2011
international joint conference on, pages 1794   1801. ieee, 2011.

623. manu sharma, manish mehta, santiago onta  n  on, and ashwin ram. player modeling eval-
uation for interactive    ction. in proceedings of the aiide 2007 workshop on optimizing
player satisfaction, pages 19   24, 2007.

624. nandita sharma and tom gedeon. objective measures, sensors and computational tech-
niques for stress recognition and classi   cation: a survey. computer methods and programs
in biomedicine, 108(3):1287   1301, 2012.

625. peter shizgal and andreas arvanitogiannis.

gambling on dopamine.

science,

299(5614):1856   1858, 2003.

626. yoav shoham and kevin leyton-brown. multiagent systems: algorithmic, game-theoretic,

and logical foundations. cambridge university press, 2008.

627. alexander shoulson, francisco m. garcia, matthew jones, robert mead, and norman i.
badler. parameterizing behavior trees. in international conference on motion in games,
pages 144   155. springer, 2011.

628. nikolaos sidorakis, george alex koulieris, and katerina mania. binocular eye-tracking
for the control of a 3d immersive multimedia user interface. in everyday virtual reality
(wevr), 2015 ieee 1st workshop on, pages 15   18. ieee, 2015.

629. david silver, aja huang, chris j. maddison, arthur guez, laurent sifre, george van
den driessche, julian schrittwieser, ioannis antonoglou, veda panneershelvam, marc lanc-
tot, et al. mastering the game of go with deep neural networks and tree search. nature,
529(7587):484   489, 2016.

630. herbert a. simon. a behavioral model of rational choice. the quarterly journal of eco-

nomics, 69(1):99   118, 1955.

631. shawn singh, mubbasir kapadia, glenn reinman, and petros faloutsos. footstep navigation

for dynamic crowds. computer animation and virtual worlds, 22(2-3):151   158, 2011.

632. moshe sipper. evolved to win. lulu.com, 2011.
633. burrhus frederic skinner. the behavior of organisms: an experimental analysis. bf skinner

foundation, 1990.

634. ruben m. smelik, tim tutenel, klaas jan de kraker, and rafael bidarra. interactive creation

of virtual worlds using procedural sketching. in proceedings of eurographics, 2010.

635. adam m. smith, erik andersen, michael mateas, and zoran popovi  c. a case study of
expressively constrainable level design automation tools for a puzzle game. in proceedings
of the international conference on the foundations of digital games, pages 156   163. acm,
2012.

322

references

636. adam m. smith, chris lewis, kenneth hullett, gillian smith, and anne sullivan. an in-
clusive taxonomy of player modeling. technical report ucsc-soe-11-13, university of
california, santa cruz, 2011.

637. adam m. smith and michael mateas. variations forever: flexibly generating rulesets from
a sculptable design space of mini-games. in computational intelligence and games (cig),
2010 ieee symposium on, pages 273   280. ieee, 2010.

638. adam m. smith and michael mateas. answer set programming for procedural content gen-
eration: a design space approach. computational intelligence and ai in games, ieee trans-
actions on, 3(3):187   200, 2011.

639. adam m. smith, mark j. nelson, and michael mateas. ludocore: a logical game engine
in computational intelligence and games (cig), 2010 ieee

for modeling videogames.
symposium on, pages 91   98. ieee, 2010.

640. gillian smith and jim whitehead. analyzing the expressive range of a level generator.
in proceedings of the 2010 workshop on procedural content generation in games. acm,
2010.

641. gillian smith, jim whitehead, and michael mateas. tanagra: a mixed-initiative level design
in proceedings of the fifth international conference on the foundations of digital

tool.
games, pages 209   216. acm, 2010.

642. gillian smith, jim whitehead, and michael mateas. tanagra: reactive planning and con-
straint solving for mixed-initiative level design. computational intelligence and ai in games,
ieee transactions on, 3(3):201   215, 2011.

643. ian sneddon, gary mckeown, margaret mcrorie, and tijana vukicevic. cross-cultural
patterns in dynamic ratings of positive and negative natural emotional behaviour. plos one,
6(2), 2011.

644. sam snodgrass and santiago onta  n  on. a hierarchical mdmc approach to 2d video game
map generation. in eleventh arti   cial intelligence and interactive digital entertainment
conference, 2015.

645. dennis soemers. tactical planning using mcts in the game of starcraft, 2014. bachelor

thesis, department of knowledge engineering, maastricht university.

646. andreas sonderegger, andreas uebelbacher, manuela pugliese, and juergen sauer. the
in   uence of aesthetics in usability testing: the case of dual-domain products. in proceedings
of the conference on human factors in computing systems, pages 21   30, 2014.

647. bhuman soni and philip hingston. bots trained to play like a human are more fun.

in
ieee international joint conference on neural networks (ijid98); ieee world congress
on computational intelligence, pages 363   369. ieee, 2008.
648. patrikk d. s  rensen, jeppeh m. olsen, and sebastian risi.

interactive super mario bros
evolution. in proceedings of the 2016 genetic and evolutionary computation conference,
pages 41   42. acm, 2016.

649. nathan sorenson and philippe pasquier. towards a generic framework for automated video

game level creation. applications of evolutionary computation, pages 131   140, 2010.

650. pieter spronck, marc ponsen, ida sprinkhuizen-kuyper, and eric postma. adaptive game

ai with dynamic scripting. machine learning, 63(3):217   248, 2006.

651. pieter spronck, ida sprinkhuizen-kuyper, and eric postma. dif   culty scaling of game ai.
in proceedings of the 5th international conference on intelligent games and simulation
(game-on 2004), pages 33   37, 2004.

652. ramakrishnan srikant and rakesh agrawal. mining sequential patterns: generalizations and
performance improvements. in international conference on extending database technol-
ogy, pages 1   17. springer, 1996.

653. kenneth o. stanley. compositional pattern producing networks: a novel abstraction of

development. genetic programming and evolvable machines, 8(2):131   162, 2007.

654. kenneth o. stanley, bobby d. bryant, and risto miikkulainen. real-time neuroevolution
in the nero video game. evolutionary computation, ieee transactions on, 9(6):653   668,
2005.

655. kenneth o. stanley and risto miikkulainen. evolving neural networks through augmenting

topologies. evolutionary computation, 10(2):99   127, 2002.

references

323

656. kenneth o. stanley and risto miikkulainen. evolving a roving eye for go. in genetic and

evolutionary computation conference, pages 1226   1238. springer, 2004.

657. stanley smith stevens. on the theory of scales of measurement. science, 103(2684):677   

680, 1946.

658. neil stewart, gordon d. a. brown, and nick chater. absolute identi   cation by relative

judgment. psychological review, 112(4):881, 2005.

659. andreas stiegler, keshav dahal, johannes maucher, and daniel livingstone. symbolic rea-
soning for hearthstone. ieee transactions on computational intelligence and ai in games,
2017.

660. jeff stuckman and guo-qiang zhang. mastermind is np-complete.

arxiv preprint

661. nathan sturtevant. memory-ef   cient path   nding abstractions. in ai programming wisdom

cs/0512049, 2005.

4. charles river media, 2008.

662. nathan sturtevant and steve rabin. canonical orderings on grids. in proceedings of the

international joint conference on arti   cial intelligence, pages 683   689, 2016.

663. nathan r. sturtevant. benchmarks for grid-based path   nding. ieee transactions on com-

putational intelligence and ai in games, 4(2):144   148, 2012.

664. nathan r. sturtevant and richard e. korf. on pruning techniques for multi-player games.
proceedings of the national conference on arti   cial intelligence (aaai), pages 201   208,
2000.

665. nathan r. sturtevant, jason traish, james tulip, tansel uras, sven koenig, ben strasser,
adi botea, daniel harabor, and steve rabin. the grid-based path planning competition:
in eighth annual symposium on combinatorial search, pages
2014 entries and results.
241   251, 2015.

666. adam james summerville and michael mateas. mystical tutor: a magic: the gathering
design assistant via denoising sequence-to-sequence learning. in twelfth arti   cial intel-
ligence and interactive digital entertainment conference, 2016.

667. adam james summerville, shweta philip, and michael mateas. mcmcts pcg 4 smb:
id169 to guide platformer level generation. in eleventh arti   cial intel-
ligence and interactive digital entertainment conference, 2015.

668. adam james summerville, sam snodgrass, matthew guzdial, christoffer holmg  ard,
amy k. hoover, aaron isaksen, andy nealen, and julian togelius. procedural content
generation via machine learning (pcgml). arxiv preprint arxiv:1702.00539, 2017.

669. adam james summerville, sam snodgrass, michael mateas, and santiago onta  n  on villar.

the vglc: the video game level corpus. arxiv preprint arxiv:1606.07487, 2016.

670. petra sundstr  om. exploring the affective loop. phd thesis, stockholm university, 2005.
671. ben sunshine-hill, michael robbins, and chris jurney. off the beaten path: non-traditional

uses of ai. in game developers conference, ai summit, 2012.

672. richard s. sutton and andrew g. barto. id23: an introduction. mit

press, 1998.

673. reid swanson and andrew s. gordon. say anything: using textual case-based reasoning
to enable open-domain interactive storytelling. acm transactions on interactive intelligent
systems (tiis), 2(3):16, 2012.

674. william r. swartout, jonathan gratch, randall w. hill jr, eduard hovy, stacy marsella, jeff

rickel, and david traum. toward virtual humans. ai magazine, 27(2):96, 2006.

675. penelope sweetser, daniel m. johnson, and peta wyeth. revisiting the gameflow model

with detailed heuristics. journal: creative technologies, 2012(3), 2012.

676. penelope sweetser and janet wiles. scripting versus emergence: issues for game developers
international journal of intelligent games and

and players in game environment design.
simulations, 4(1):1   9, 2005.

677. penelope sweetser and janet wiles. using cellular automata to facilitate emergence in game
environments. in proceedings of the 4th international conference on entertainment com-
puting (icec05), 2005.

678. penelope sweetser and peta wyeth. gameflow: a model for evaluating player enjoyment in

games. computers in entertainment (cie), 3(3):3   3, 2005.

324

references

679. maciej   swiechowski and jacek ma  ndziuk. self-adaptation of playing strategies in general
game playing. ieee transactions on computational intelligence and ai in games, 6(4):367   
381, 2014.

680. gabriel synnaeve and pierre bessi`ere. multiscale bayesian modeling for rts games: an
ieee transactions on computational intelligence and ai in

application to starcraft ai.
games, 8(4):338   350, 2016.

681. gabriel synnaeve, nantas nardelli, alex auvolat, soumith chintala, timoth  ee lacroix,
zeming lin, florian richoux, and nicolas usunier. torchcraft: a library for machine
learning research on real-time strategy games. arxiv preprint arxiv:1611.00625, 2016.
682. nicolas szilas. idtension: a narrative engine for interactive drama. in proceedings of the
technologies for interactive digital storytelling and entertainment (tidse) conference,
pages 1   11, 2003.

683. niels a. taatgen, marcia van oploo, jos braaksma, and jelle niemantsverdriet. how to
construct a believable opponent using cognitive modeling in the game of set. in proceedings
of the fifth international conference on cognitive modeling, pages 201   206, 2003.

684. nima taghipour, ahmad kardan, and saeed shiry ghidary. usage-based web recommenda-
tions: a id23 approach. in proceedings of the 2007 acm conference on
recommender systems, pages 113   120. acm, 2007.

685. bulent tastan and gita reese sukthankar. learning policies for    rst person shooter games
using inverse id23. in seventh arti   cial intelligence and interactive digi-
tal entertainment conference, 2011.

686. shoshannah tekofsky, pieter spronck, aske plaat, jaap van den herik, and jan broersen.
play style: showing your age. in computational intelligence in games (cig), 2013 ieee
conference on. ieee, 2013.

687. shoshannah tekofsky, pieter spronck, aske plaat, jaap van den herik, and jan broersen.
psyops: personality assessment through gaming behavior. in bnaic 2013: proceedings of
the 25th benelux conference on arti   cial intelligence, delft, the netherlands, november
7-8, 2013, 2013.

688. gerald tesauro. practical issues in temporal difference learning. machine learning, 8(3-

689. gerald tesauro. temporal difference learning and td-gammon. communications of the

4):257   277, 1992.

acm, 38(3):58   68, 1995.

690. ruck thawonmas, yoshitaka kashifuji, and kuan-ta chen. detection of mmorpg bots
in proceedings of the 2008 international conference on ad-

based on behavior analysis.
vances in computer entertainment technology, pages 91   94. acm, 2008.

691. michael thielscher. a general game description language for incomplete information

games. in aaai, pages 994   999, 2010.

692. william r. thompson. on the likelihood that one unknown id203 exceeds another in

view of the evidence of two samples. biometrika, 25(3/4):285   294, 1933.

693. david thue, vadim bulitko, marcia spetch, and eric wasylishen. interactive storytelling:

a player modelling approach. in aiide, pages 43   48, 2007.

694. christian thurau, christian bauckhage, and gerhard sagerer. learning human-like opponent
behavior for interactive computer games. pattern recognition, lecture notes in computer
science 2781, pages 148   155, 2003.

695. christian thurau, christian bauckhage, and gerhard sagerer. imitation learning at all levels
of game ai. in proceedings of the international conference on computer games, arti   cial
intelligence, design and education, 2004.

696. christian thurau, christian bauckhage, and gerhard sagerer. learning human-like move-
ment behavior for computer games.
in s. schaal, a. ijspeert, a. billard, s. vijayaku-
mar, j. hallam, and j.-a. meyer, editors, from animals to animats 8: proceedings of the
eighth international conference on simulation of adaptive behavior (sab-04), pages 315   
323, santa monica, ca, july 2004. the mit press.

697. tim j. w. tijs, dirk brokken, and wijnand a. ijsselsteijn. dynamic game balancing by
recognizing affect. in proceedings of international conference on fun and games, pages
88   93. springer, 2008.

references

325

698. julian togelius. evolution of a subsumption architecture neurocontroller. journal of intelli-

gent & fuzzy systems, 15(1):15   20, 2004.

699. julian togelius. a procedural critique of deontological reasoning. in proceedings of digra,

2011.

700. julian togelius. ai researchers, video games are your friends! in computational intelli-

gence, pages 3   18. springer, 2015.

701. julian togelius. how to run a successful game-based ai competition. ieee transactions on

computational intelligence and ai in games, 8(1):95   100, 2016.

702. julian togelius, alex j. champandard, pier luca lanzi, michael mateas, ana paiva, mike
preuss, and kenneth o. stanley. procedural content generation in games: goals, challenges
and actionable steps. dagstuhl follow-ups, 6, 2013.

703. julian togelius, renzo de nardi, and simon m. lucas. making racing fun through player
in proceedings of the sab   06 workshop on adaptive ap-

modeling and track evolution.
proaches for optimizing player satisfaction in computer and physical games, 2006.

704. julian togelius, renzo de nardi, and simon m. lucas. towards automatic personalised
in computational intelligence and games, 2007. cig

content creation for racing games.
2007. ieee symposium on, pages 252   259. ieee, 2007.

705. julian togelius, sergey karakovskiy, and robin baumgarten. the 2009 mario ai competi-

tion. in evolutionary computation (cec), 2010 ieee congress on. ieee, 2010.

706. julian togelius, sergey karakovskiy, jan koutn    k, and j  urgen schmidhuber. super mario
evolution. in computational intelligence and games, 2009. cig 2009. ieee symposium on,
pages 156   161. ieee, 2009.

707. julian togelius and simon m. lucas. evolving controllers for simulated car racing. in ieee

congress on evolutionary computation, pages 1906   1913. ieee, 2005.

708. julian togelius and simon m. lucas. arms races and car races. in parallel problem solving

from nature-ppsn ix, pages 613   622. springer, 2006.

709. julian togelius and simon m. lucas. evolving robust and specialized car racing skills. in

ieee congress on evolutionary computation (cec), pages 1187   1194. ieee, 2006.

710. julian togelius, simon m. lucas, ho duc thang, jonathan m. garibaldi, tomoharu
nakashima, chin hiong tan, itamar elhanany, shay berant, philip hingston, robert m.
maccallum, thomas haferlach, aravind gowrisankar, and pete burrow. the 2007 ieee
cec simulated car racing competition. genetic programming and evolvable machines,
9(4):295   329, 2008.

711. julian togelius, mark j. nelson, and antonios liapis. characteristics of generatable games.

in proceedings of the fifth workshop on procedural content generation in games, 2014.

712. julian togelius, mike preuss, nicola beume, simon wessing, johan hagelb  ack, and geor-
gios n. yannakakis. multiobjective exploration of the starcraft map space. in computational
intelligence and games (cig), 2010 ieee symposium on, pages 265   272. ieee, 2010.

713. julian togelius, mike preuss, and georgios n. yannakakis. towards multiobjective procedu-
ral map generation. in proceedings of the 2010 workshop on procedural content generation
in games. acm, 2010.

714. julian togelius, tom schaul, j  urgen schmidhuber, and faustino gomez. countering poi-
sonous inputs with memetic neuroevolution. in international conference on parallel prob-
lem solving from nature, pages 610   619. springer, 2008.

715. julian togelius, tom schaul, daan wierstra, christian igel, faustino gomez, and j  urgen
schmidhuber. ontogenetic and phylogenetic id23. k  unstliche intelligenz,
23(3):30   33, 2009.

716. julian togelius and j  urgen schmidhuber. an experiment in automatic game design.

in
computational intelligence and games, 2008. cig   08. ieee symposium on, pages 111   
118. ieee, 2008.

717. julian togelius, noor shaker, sergey karakovskiy, and georgios n. yannakakis. the mario

ai championship 2009-2012. ai magazine, 34(3):89   92, 2013.

718. julian togelius and georgios n. yannakakis. general general game ai.
conference on computational intelligence and games (cig). ieee, 2016.

in 2016 ieee

326

references

719. julian togelius, georgios n. yannakakis, sergey karakovskiy, and noor shaker. assessing

believability. in philip hingston, editor, believable bots, pages 215   230. springer, 2012.

720. julian togelius, georgios n. yannakakis, kenneth o. stanley, and cameron browne. search-
based procedural content generation: a taxonomy and survey. computational intelligence
and ai in games, ieee transactions on, 3(3):172   186, 2011.

721. simone tognetti, maurizio garbarino, andrea bonarini, and matteo matteucci. modeling
enjoyment preference from physiological responses in a car racing game. in computational
intelligence and games (cig), 2010 ieee symposium on, pages 321   328. ieee, 2010.

722. paul tozour and i. s. austin. building a near-optimal navigation mesh. ai game program-

ming wisdom, 1:298   304, 2002.

723. mike treanor, bryan blackford, michael mateas, and ian bogost. game-o-matic: gener-
ating videogames that represent ideas. in procedural content generation workshop at the
foundations of digital games conference. acm, 2012.

724. mike treanor, alexander zook, mirjam p. eladhari, julian togelius, gillian smith, michael
cook, tommy thompson, brian magerko, john levine, and adam smith. ai-based game
design patterns. 2015.

725. alan m. turing. digital computers applied to games. faster than thought, 101, 1953.
726. hiroto udagawa, tarun narasimhan, and shim-young lee. fighting zombies in minecraft

with deep id23. technical report, stanford university, 2016.

727. alfred ultsch. data mining and knowledge discovery with emergent self-organizing feature

maps for multivariate time series. kohonen maps, 46:33   46, 1999.

728. alberto uriarte and santiago onta  n  on. automatic learning of combat models for rts games.
in eleventh arti   cial intelligence and interactive digital entertainment conference, 2015.
729. nicolas usunier, gabriel synnaeve, zeming lin, and soumith chintala. episodic ex-
ploration for deep deterministic policies: an application to starcraft micromanagement
tasks. arxiv preprint arxiv:1609.02993, 2016.

730. josep valls-vargas, santiago onta  n  on, and jichen zhu. towards story-based content gener-
ation: from plot-points to maps. in computational intelligence in games (cig), 2013 ieee
conference on. ieee, 2013.

731. wouter van den hoogen, wijnand a. ijsselsteijn, and yvonne de kort. exploring behavioral
expressions of player experience in digital games. in proceedings of the workshop on facial
and bodily expression for control and adaptation of games (ecag), pages 11   19, 2008.

732. roland van der linden, ricardo lopes, and rafael bidarra. procedural generation of dun-
geons. computational intelligence and ai in games, ieee transactions on, 6(1):78   89,
2014.

733. pascal van hentenryck. id124 in logic programming. mit press, cam-

bridge, 1989.

734. niels van hoorn, julian togelius, and j  urgen schmidhuber. hierarchical controller learning
in a    rst-person shooter. in computational intelligence and games, 2009. cig 2009. ieee
symposium on, pages 294   301. ieee, 2009.

735. niels van hoorn, julian togelius, daan wierstra, and j  urgen schmidhuber. robust player
imitation using multiobjective evolution. in ieee congress on evolutionary computation
(cec), pages 652   659. ieee, 2009.

736. giel van lankveld, sonny schreurs, pieter spronck, and jaap van den herik. extraversion
in games. in international conference on computers and games, pages 263   275. springer,
2010.

737. giel van lankveld, pieter spronck, jaap van den herik, and arnoud arntz. games as person-
ality pro   ling tools. in computational intelligence and games (cig), 2011 ieee conference
on, pages 197   202. ieee, 2011.

738. harm van seijen, mehdi fatemi, joshua romoff, romain laroche, tavian barnes, and
jeffrey tsang. hybrid reward architecture for id23. arxiv preprint
arxiv:1706.04208, 2017.

739. pascal vincent, hugo larochelle, yoshua bengio, and pierre-antoine manzagol. extracting
in proceedings of the 25th

and composing robust features with denoising autoencoders.
international conference on machine learning (icml), pages 1096   1103. acm, 2008.

references

327

740. madhubalan viswanathan. measurement of individual differences in preference for numeri-

cal information. journal of applied psychology, 78(5):741   752, 1993.

741. thurid vogt and elisabeth andr  e. comparing feature sets for acted and spontaneous speech
in view of automatic emotion recognition. in proceedings of ieee international conference
on multimedia and expo (icme), pages 474   477. ieee, 2005.

742. john von neumann. the general and logical theory of automata. cerebral mechanisms in

743. john von neumann and oskar morgenstern. theory of games and economic behavior.

behavior, 1(41):1   2, 1951.

princeton university press, 1944.

744. karol wal  edzik and jacek ma  ndziuk. an automatically generated evaluation function in
general game playing. ieee transactions on computational intelligence and ai in games,
6(3):258   270, 2014.

745. che wang, pan chen, yuanda li, christoffer holmg  ard, and julian togelius. portfolio on-
line evolution in starcraft. in twelfth arti   cial intelligence and interactive digital enter-
tainment conference, 2016.

746. colin d. ward and peter i. cowling. monte carlo search applied to card selection in magic:
the gathering. in ieee symposium on computational intelligence and games (cig), pages
9   16. ieee, 2009.

747. joe h. ward jr. hierarchical grouping to optimize an objective function. journal of the

american statistical association, 58(301):236   244, 1963.

748. christopher j. c. h. watkins and peter dayan. id24. machine learning, 8(3-4):279   

292, 1992.

749. ben g. weber. abl versus behavior trees. gamasutra, 2012.
750. ben g. weber and michael mateas. a data mining approach to strategy prediction. in 2009

ieee symposium on computational intelligence and games, pages 140   147. ieee, 2009.

751. joseph weizenbaum. eliza   a computer program for the study of natural language com-

munication between man and machine. communications of the acm, 9(1):36   45, 1966.

752. paul john werbos. beyond regression: new tools for prediction and analysis in the behavioral

sciences. phd thesis, harvard university, 1974.

753. daan wierstra, tom schaul, jan peters, and juergen schmidhuber. natural evolution strate-
gies. in ieee congress on evolutionary computation (cec) 2008. (ieee world congress
on computational intelligence)., pages 3381   3387. ieee, 2008.

754. geraint a. wiggins. a preliminary framework for description, analysis and comparison of

creative systems. knowledge-based systems, 19(7):449   458, 2006.
755. minecraft wiki. minecraft. mojang ab, stockholm, sweden, 2013.
756. david h. wolpert and william g. macready. no free lunch theorems for optimization. ieee

transactions on evolutionary computation, 1(1):67   82, 1997.

757. robert f. woodbury. searching for designs: paradigm and practice. building and environ-

ment, 26(1):61   73, 1991.

758. steven woodcock. game ai: the state of the industry 2000-2001: it   s not just art, it   s

engineering. game developer magazine, 2001.

759. xindong wu, vipin kumar, j. ross quinlan, joydeep ghosh, qiang yang, hiroshi motoda,
geoffrey j. mclachlan, angus ng, bing liu, s. yu philip, zhi-hua zhou, michael stein-
bach, david j. hand, and dan steinberg. top 10 algorithms in data mining. knowledge and
information systems, 14(1):1   37, 2008.

760. kaito yamamoto, syunsuke mizuno, chun yin chu, and ruck thawonmas. deduction of
   ghting-game countermeasures using the k-nearest neighbor algorithm and a game simulator.
in computational intelligence and games (cig), 2014 ieee conference on. ieee, 2014.

761. yi-hsuan yang and homer h. chen. ranking-based emotion recognition for music orga-
nization and retrieval. audio, speech, and language processing, ieee transactions on,
19(4):762   774, 2011.

762. georgios n. yannakakis. ai in computer games: generating interesting interactive oppo-
nents by the use of evolutionary computation. phd thesis, university of edinburgh, novem-
ber 2005.

328

references

763. georgios n. yannakakis. preference learning for affective modeling. in affective computing
and intelligent interaction and workshops, 2009. acii 2009. 3rd international conference
on, pages 1   6. ieee, 2009.

764. georgios n. yannakakis. game ai revisited. in proceedings of the 9th conference on com-

puting frontiers, pages 285   292. acm, 2012.

765. georgios n. yannakakis, roddy cowie, and carlos busso. the ordinal nature of emotions.
in affective computing and intelligent interaction (acii), 2017 international conference on,
2017.

766. georgios n. yannakakis and john hallam. evolving opponents for interesting interactive
computer games. in s. schaal, a. ijspeert, a. billard, s. vijayakumar, j. hallam, and j.-a.
meyer, editors, from animals to animats 8: proceedings of the 8th international conference
on simulation of adaptive behavior (sab-04), pages 499   508, santa monica, ca, july 2004.
the mit press.

767. georgios n. yannakakis and john hallam. a generic approach for generating interesting
interactive pac-man opponents. in proceedings of the ieee symposium on computational
intelligence and games, 2005.

768. georgios n. yannakakis and john hallam. a generic approach for obtaining higher en-
tertainment in predator/prey computer games. journal of game development, 1(3):23   50,
december 2005.

769. georgios n. yannakakis and john hallam. modeling and augmenting game entertain-
ment through challenge and curiosity. international journal on arti   cial intelligence tools,
16(06):981   999, 2007.

770. georgios n. yannakakis and john hallam. towards optimizing entertainment in computer

games. applied arti   cial intelligence, 21(10):933   971, 2007.

771. georgios n. yannakakis and john hallam. entertainment modeling through physiology in

physical play. international journal of human-computer studies, 66(10):741   755, 2008.

772. georgios n. yannakakis and john hallam. real-time game adaptation for optimizing player
satisfaction. ieee transactions on computational intelligence and ai in games, 1(2):121   
133, 2009.

773. georgios n. yannakakis and john hallam. rating vs. preference: a comparative study of
self-reporting. in affective computing and intelligent interaction, pages 437   446. springer,
2011.

774. georgios n. yannakakis, antonios liapis, and constantine alexopoulos. mixed-initiative
co-creativity. in proceedings of the 9th conference on the foundations of digital games,
2014.

775. georgios n. yannakakis, henrik hautop lund, and john hallam. modeling children   s en-
tertainment in the playware playground. in 2006 ieee symposium on computational intel-
ligence and games, pages 134   141. ieee, 2006.

776. georgios n. yannakakis and manolis maragoudakis. player modeling impact on player   s
entertainment in computer games. in proceedings of international conference on user mod-
eling (um). springer, 2005.

777. georgios n. yannakakis and h  ector p. mart    nez. grounding truth via ordinal annotation. in
affective computing and intelligent interaction (acii), 2015 international conference on,
pages 574   580. ieee, 2015.

778. georgios n. yannakakis and h  ector p. mart    nez. ratings are overrated! frontiers in ict,

2:13, 2015.

779. georgios n. yannakakis, h  ector p. mart    nez, and maurizio garbarino. psychophysiology in

games. in emotion in games: theory and praxis, pages 119   137. springer, 2016.

780. georgios n. yannakakis, h  ector p. mart    nez, and arnav jhala. towards affective camera

control in games. user modeling and user-adapted interaction, 20(4):313   340, 2010.

781. georgios n. yannakakis and ana paiva. emotion in games. handbook on affective comput-

ing, pages 459   471, 2014.

782. georgios n. yannakakis, pieter spronck, daniele loiacono, and elisabeth andr  e. player

modeling. dagstuhl follow-ups, 6, 2013.

references

329

783. georgios n. yannakakis and julian togelius. experience-driven procedural content genera-

tion. affective computing, ieee transactions on, 2(3):147   161, 2011.

784. georgios n. yannakakis and julian togelius. experience-driven procedural content genera-
tion. in affective computing and intelligent interaction (acii), 2015 international confer-
ence on, pages 519   525. ieee, 2015.

785. georgios n. yannakakis and julian togelius. a panorama of arti   cial and computational
intelligence in games. ieee transactions on computational intelligence and ai in games,
7(4):317   335, 2015.

786. xin yao. evolving arti   cial neural networks. proceedings of the ieee, 87(9):1423   1447,

1999.

787. nick yee. the demographics, motivations, and derived experiences of users of massively
multi-user online graphical environments. presence: teleoperators and virtual environments,
15(3):309   329, 2006.

788. nick yee, nicolas ducheneaut, les nelson, and peter likarish. introverted elves & consci-
entious gnomes: the expression of personality in world of warcraft. in proceedings of the
sigchi conference on human factors in computing systems, pages 753   762. acm, 2011.
789. serdar yildirim, shrikanth narayanan, and alexandros potamianos. detecting emotional
state of a child in a conversational computer game. computer speech & language, 25(1):29   
44, 2011.

790. shubu yoshida, makoto ishihara, taichi miyazaki, yuto nakagawa, tomohiro harada, and
ruck thawonmas. application of monte-carlo tree search in a    ghting game ai. in con-
sumer electronics, 2016 ieee 5th global conference on. ieee, 2016.

791. david young. learning game ai programming with lua. packt publishing ltd, 2014.
792. r. michael young, mark o. riedl, mark branly, arnav jhala, r. j. martin, and c. j. saretto.
an architecture for integrating plan-based behavior generation with interactive game envi-
ronments. journal of game development, 1(1):51   70, 2004.

793. mohammed j. zaki. spade: an ef   cient algorithm for mining frequent sequences. machine

learning, 42(1-2):31   60, 2001.

794. zhihong zeng, maja pantic, glenn i. roisman, and thomas s. huang. a survey of affect
recognition methods: audio, visual, and spontaneous expressions. pattern analysis and ma-
chine intelligence, ieee transactions on, 31(1):39   58, 2009.

795. jiakai zhang and kyunghyun cho. query-ef   cient imitation learning for end-to-end au-

tonomous driving. arxiv preprint arxiv:1605.06450, 2016.

796. peng zhang and jochen renz. qualitative spatial representation and reasoning in angry
in proceedings of the fourteenth international

birds: the extended rectangle algebra.
conference on principles of id99 and reasoning, 2014.

797. martin zinkevich, michael johanson, michael bowling, and carmelo piccione. regret min-
imization in games with incomplete information. in advances in neural information pro-
cessing systems, pages 1729   1736, 2008.

798. albert l. zobrist. feature extraction and representation for pattern recognition and the game

of go. phd thesis, the university of wisconsin, madison, 1970.

799. alexander zook. game agi beyond characters. in integrating cognitive architectures into

virtual character design, pages 266   293. igi global, 2016.

800. alexander zook and mark o. riedl. a temporal data-driven player model for dynamic
in 8th aaai conference on arti   cial intelligence and interactive

dif   culty adjustment.
digital entertainment. aaai, 2012.

801. robert zubek and ian horswill. hierarchical parallel markov models of interaction.

in

aiide, pages 141   146, 2005.

index

  -greedy, 46, 73
id165s, 173, 190
2k botprize, 96, 139, 267, 274

a behavior language, 35
aaa games, 152, 217, 270
adaptive games, 153, 284
adversarial games, 99, 113
adversarial planning, 119, 137
adversarial player, 205
adversarial search, 43
affect expression, 284
affect modeling, 284
affective computing, 21, 143, 203, 228, 284

context, 284

affective interaction, 217
affective loop, 18, 22, 284
affective sciences, 208
agent architecture, 143, 274
ai researcher, 3, 6, 263, 264
ai-assisted game design, 176, 272
ai-based game design, 286
ai-complete, 159
ale, see arcade learning environment
analytics, 206
angry birds ai competition, 146
ann, see arti   cial neural networks
ann function approximator, 84, 87, 116
annotation, 200, 219

absolute, 228
continuous, 222
discrete, 222
during-experience, 225
first-person, 221
forced, 221
free-response, 221
ordinal, 228, 233

post-experience, 225
pre-experience, 224
relative, 228
third-person, 221
time-continuous, 222
time-discrete, 223

answer set programming, 146, 162, 178, 193,

anytime algorithm, 45, 161
arcade games, 123
arcade learning environment, 23, 101, 129,

198

281

arcade video games, 23
architecture, 157, 184
arti   cial general intelligence, 266, 271, 290
arti   cial neural networks, 31, 59, 65, 174, 231

activation function, 59, 60
id26, 30, 60, 63
deep architectures, 65
learning rate, 63
multi-layer id88, 60
neuron, 59
relu, 60

asp, see answer set programming
atari 2600, 101, 106, 116, 124, 129
audio designer, 187
autoencoders, 65, 141, 178, 199, 282

stacked autoencoders, 285
id5, 171

automatic game testing, 279
avatar, 203

backgammon, 45, 85, 116, 120
balance, 192
behavior trees, 31, 34

decorator, 35
selector, 35

331

332

index

biofeedback, 160, 217, 273
board games, 3, 8, 10, 23, 119, 192, 266, 276,

sequence, 35

behavioral economics, 228
believability, 190, 268
believable agents, 144, 190, 207
believable npc, 143
benchmarks, 101, 266, 281
best-   rst search, 41

a*, 41, 100, 110, 127
uniform-cost grids, 41

279

bodily expressions, 215
body movement, 18
body stance, 18
branching factor, 45, 103
bt, see behavior trees

card games, 121
casual games, 145
cellular automata, 156, 165
censorship, 289
cheating, 95, 106, 108
checkers, 8, 43, 120

chinook, 8

chess, 8, 43, 107, 119

deep blue, 8, 16, 43, 93

ci, see computational intelligence
classes, 226

class splitting criteria, 228

classi   cation, 58, 231, 234, 243
id91, 77, 80, 207

hierarchical, 79
id116, 78

co-creation, 177
co-creativity, 154
collaborative    ltering, 289
commodore 64, 124
compositional pattern producing networks, 60,

84

computational creativity, 22, 180, 270, 286

exploratory, 283
transformational, 283

computational intelligence, 7
computational narrative, 189
concept map, 195
conceptnet, 195
id124, 198
constraint solvers, 161

sat, 161

constraints, 198
content, 19, 151, 154

audio, 19, 187
levels, 184

maps, 184
mechanics, 191
narrative, 189
necessary, 155, 184
optional, 155, 187
representation, 158
rules, 191
visuals, 186

content-intensive, 19
convolutional neural network, 195, 249, 283
cost function, 32, 62
creative facets, 177, 184, 282
creative path, 178
creativity, 152, 191
id104, 188, 200, 247, 272
culture, 218

darwinian evolution, 52
data analyst, 243
data corpus, 254
data mining, 213, 243, 288
data ownership, 289
data privacy, 288
data science, 18
data-driven, 25, 212, 230
deathmatch, 195
decision tree learning, 30, 68

c4.5, 70
gain ratio, 70
 , 69, 243
information gain, 69

id90, 31, 68, 231, 243
deep convolutional neural network, 120, 249,

251

deep fusion, 251
deep learning, 65, 86
deep q network, 86, 106, 116, 145, 236
deep id24, 88, 118, 129
deep id23, 115, 131, 134
demographics, 218
dendrogram, 79, 240
depth, 192
designer, 156, 159, 174, 175, 178, 179, 187,

188, 190, 191, 198, 221, 263, 271

designer modeling, 275
deterministic, 45, 112
diamond-square algorithm, 170
doom, 106, 139, 141
drama management, 273
id145, 74, 76, 115
dynamic scripting, 118

economics, 31, 37
electrocardiography, 215

index

333

electrodermal activity, 215
electroencephalography, 215
electromyography, 215
eliza, 144
embodied conversational agents, 143, 144
emotion elicitation, 284
emotion recognition, 284
emotions, 37, 203
end user, 260, 262
episodic memory, 226, 233
error function, 32, 62
evaluation function, 159
evolutionary algorithms, 49, 52, 97, 179
evolutionary computation, 30, 49, 266

covariance matrix adaptation evolution

strategy, 55
crossover, 52
evolutionary strategies, 31, 54
feasible-infeasible 2-population, 55, 198
fitness function, 32, 49, 159
generation, 53
id107, 31, 55
genetic programming, 31
inversion, 51
multiobjective, 56
mutation, 50
natural evolution strategy, 55
representation, 49

evolutionary planning, 113
evolutionary id23, 117
evolutionary robotics, 117
experience replay, 116, 130
expert-knowledge systems, 32
exploration vs. exploitation, 104
expressive npc, 143
expressive range, 158, 199
expressivity, 199
eye gaze, 129

facial expression, 214
fac  ade, 190, 273, 287
feature selection, 247
fighting game ai competition, 146
fighting games, 146
finite state machines, 31, 33

hierarchical, 33

first-person shooters, 92, 139, 196
flow channel, 209
fog of war, 102
forward model, 106, 281
fractals, 156
frequent pattern mining, 30, 77, 80, 82

apriori, 30, 80
generalized sequential patterns, 30, 81

id122, see finite state machines
function approximator, 118
fuzzy logic, 134
fuzzy set, 37

galvanic skin response, 215
game adaptation, 275, 289
game affective loop, 284
game ai, 4

ethical considerations, 287
academia, 10
areas, 259
dominant methods, 261
ethical considerations, 279
frontier research, 26, 279, 291
general, 279
industry, 11
panorama, 26, 259
secondary methods, 261
game analytics, 20, 25, 207
game context, 264
game controller, 18
game curator, 286
game data mining, 20, 25, 252, 260
game design, 25, 157, 195, 207, 211, 236,

242, 244, 271, 280, 287

game directing, 286
game experience questionnaire, 221
game facets, 282
game generation, 193, 283
game industry, 37
game metrics, 206, 273
game stakeholder, 275
game studies, 189, 208
game testing, 207
game theory, 27, 31, 72
game user study, 200
games with a purpose, 141
gaussian process, 232
gaze tracking, 129, 216
gender, 218
general emotional intelligence, 284
general game affective loop, 284
general game ai, 279
general game design, 280
general game generation, 283
general game playing, 40, 108, 129, 280, 281
general game playing competition, 23, 109,

281

general general game ai, 280
general intelligence, 23, 282, 284, 290
general level design, 282
general video game ai competition, 23, 113,

130, 281

334

index

general video game description language, 291
id3, 171
generative space, 199
genetic programming, 117
geneva wheel model, 226
gesture, 18, 216
global optimization, 52
go, 16, 45, 93, 107, 112, 119

alphago, 9, 16, 112
grammars, 31, 163, 192

grammatical evolution, 31

graphics, 186
graphs, 31
grid-based path-planning, 41
ground truth, 220, 234, 245, 285
gvgai, see general video game ai

competition

haptics, 18, 216
hci, see human-computer interaction
head pose, 215
heart rate variability, 18, 250
hearthstone, 122
heatmap, 199, 214
hebbian learning, 59, 77
heightmap, 169
hidden information, 102
hill climber, 50

gradient-based, 50
randomized, 50
horror games, 217
human computation, 142
human-computer interaction, 203, 237, 264

rich, 17, 204

human-like, 95, 128, 143, 207, 236, 268, 281
hybrid algorithms, 30, 82, 118, 208

ideation tools, 286
imitation, 207
indie game development, 187, 270
intelligent tutoring systems, 143
intensity map, 169
interaction design, 270
interactive evolution, 178, 187
interactive    ction, 144, 190, 216
interactive narrative, 144, 271
interactive storytelling, 189
iterative re   nement, 187
iterative width search, 40

killer application, 11, 22
id99, 20

l-systems, 164

learnability, 192, 236
learning classi   er systems, 118
learning objective, 141
level design, 177, 184, 282
likert, 226
id156, 233
linked data, 219
local optimum, 51
local search, 50
logic programming, 161
id168, 32

machine learning, 6, 11, 20, 32, 59, 71, 77,

108, 134, 148, 171, 206, 212, 230, 234,
273, 286

macro-actions, 220
mario ai competition, 41, 96, 110, 126, 266
marketing, 207, 228
markov decision process, 32, 72
markov models, 173
markov property, 72, 76, 100
mcts, see id169
memory-experience gap, 221
micro-actions, 220
midpoint displacement algorithm, 169
minecraft, 92, 141, 148, 169, 185, 288

project malmo, 148

minimax, 8, 30, 42, 103, 109

  -   pruning, 100

mixed-initiative co-creation, 273
mixed-initiative co-creativity, 201
modalities of input, 215, 218
monetization, 207, 243
id169, 30, 45, 112, 130, 174,

276, 281

id26, 45, 46
expansion, 46
rollout, 45, 112
selection, 46
simulation, 46
ucb1, 46

moore neighborhood, 127
motion tracking, 215
ms pac-man, 29, 33, 35, 38, 40, 42, 44, 47, 51,

56, 65, 68, 70, 76, 80, 82, 84, 87, 125

competition, 149

multi-player, 99
multiagent systems, 27
multimodal, 18
multimodal fusion, 251
muscle activation, 216

natural language processing, 21, 144, 209
navigation, 21, 41

index

335

navigation mesh, 41
neat, see neuroevolution of augmenting

neuroevolution, 30, 83, 84, 117, 129, 131,

topologies

140, 245, 287

129, 133, 287

neuroevolution of augmenting topologies, 84,

273

player archetypes, 211
player behavior, 206
player behavior modeling, 220, 260, 273
player character, 203
player experience, 25, 176, 180, 206, 212, 245,

neuroscience, 208, 209
nintendo nes, 124
nintendo wii, 95
nlp, see natural language processing
no free lunch, 31, 58
noise, 169

perlin noise, 171

non-deterministic, 44, 100
non-player character, 6, 14, 24, 99

behavior, 110

np-hard, 16
npc, see non-player character

objective function, 32
observability, 102
one-and-a-half-player, 99
ontology, 123
open-source, 290
openai universe, 132
opponent modeling, 205
optimization, 50, 68, 113, 189
orchestration, 195

pac-man, 29, 125, 213
pairwise preference, 228, 234
path-planning, 110
path   nding, 26, 41
pcg, see procedural content generation
peak-end rule, 226
perfect information, 102
personality, 218, 288
personality traits, 288
personalization, 236
personas, 96
phenomenological debugging, 242
photoplethysmography, 215
photorealism, 186
physical games, 211
physiological signal, 216, 254
physiology, 18, 209, 214, 274
planning, 21, 41, 113, 133, 146, 189, 262, 266

hierarchical task network, 189

platformer experience dataset, 249, 253
platformers, 104, 126, 201
play for the experience, 92, 268
play to win, 92, 266
play traces, 245

player experience modeling, 180, 182, 220,

234, 245, 260, 273

player expertise, 218
player metrics, 206, 214
player model

input, 204, 213
methods, 204
output, 219

player model input

context, 217
gameplay, 214
objective, 214

player modeling, 9, 182, 203, 264, 268, 273

ethics, 288
hybrid algorithms, 213
methods, 230
model-based, 208, 208
model-free, 208, 212
of   ine, 236
runtime, 236

player pro   le, 218
player pro   ling, 205
playtesting, 94, 133, 146, 200, 236, 268, 285
playthroughs, 20, 192, 267
poker, 45, 102, 121, 205
posture, 214, 216
potential    elds, 134
practical wisdom, 31, 199
prediction, 207
preference, 232
preference learning, 58, 232, 234, 247, 250

neuroevolution, 182, 247
rankid166, 71

preference learning toolbox, 233
preschooler games, 211
prey-predator games, 211, 249
probabilistic models, 31
procedural architecture, 184
procedural audio, 187
procedural content generation, 9, 151, 273

assisted, 271
autonomous, 156, 175, 180, 270
constructive, 156
controllable, 156
deterministic, 155
evaluation, 197
experience-agnostic, 157, 175, 182

336

index

experience-driven, 157, 175, 180, 247, 275,

286

fractal, 169
generate-and-test, 156
grammar-based, 162
machine learning, 171, 195
mixed-initiative, 156, 162, 175, 176, 271
noise, 169
non-controllable, 156
of   ine, 175
orchestration, 283
runtime, 175
search-based, 157
solver-based, 161
stochastic, 155

procedural personas, 27, 200, 236, 244, 275,

289

protocol design, 200
psychology, 203, 208, 228

adaptation level theory, 229

psychometrics, 234, 236
psychophysiology, 208, 249
pupil dilation, 215
pupillometry, 216

id24, 31, 73, 74, 76, 116

discount factor, 75
learning rate, 75

racing games, 106, 136

torcs, 106, 138

ranks, 226
ratings, 226, 233

inter-personal biases, 234
inter-personal differences, 227

rbf networks, 60
real-time games, 104
real-time strategy, 105
regression, 58, 231, 233
id23, 8, 30, 71, 85, 101,

108, 115, 230, 235, 266

backup, 74
id64, 74
exploration vs. exploitation, 73
policy, 72
reward, 32
world model, 73

relu, 88
representation, 30, 106
respiration, 216
retro learning environment, 131
reward, 71, 230, 236
rl, see id23
rogue, 9, 151, 185

role-playing game, 93, 104
rpg, see role-playing game
rubber band ai, 95

sandbox games, 146
search tree, 39, 43
self-assessment manikin, 226
self-organizing map, 239
self-reporting, 231
semantic memory, 226
semantics, 195
sentient sketchbook, 40, 177, 267
id31, 209
serious games, 141
simulated annealing, 51
simulated car racing championship, 138, 266
simulation-based testing, 94, 95, 267
single-player, 99
skin conductance, 250
sound

diegetic, 188
non-diegetic, 188

sparcraft, 134
speech, 18, 214, 216
starcraft, 16, 21, 94, 102, 133, 276

torchcraft, 17

steam, 253
stochasticity, 100, 197
story generation, 189, 273
strategy games, 132
strips, 115
super mario bros, 16, 47, 96, 126, 246
supervised learning, 30, 57, 108, 118, 230

generalization, 57

support vector machines, 30, 66, 231

hard margin, 66
kernel, 67
maximum margin, 66
rankid166, 71
soft margin, 66
support vectors, 66

surprise search, 187
suspension of disbelief, 22
symbolic representation, 114

taxonomy, 73, 154, 204, 207, 263
td learning, 30, 31, 74, 87, 236, 266
td-gammon, 8, 85, 116
telemetry, 20
text-based adventure games, 144, 216
theory of    ow, 209
theory of fun, 211
think-aloud protocol, 221
tic-tac-toe, 8, 43

index

337

training signal, 32, 77, 232, 237
tree search, 20, 39, 101, 103, 108, 109, 120

classic tree search, 109

turing test, 96, 129, 140, 267, 268, 274, 281
turn-based games, 104
turtle graphics, 164
two-player, 99

u-matrix, 242
uninformed search, 40

breadth-   rst, 40
depth-   rst, 40

unity, 39, 201
unreal engine, 39, 189
unsupervised learning, 30, 77, 229, 237

association mining, 207, 229
id91, 77, 207, 229, 237
frequent pattern mining, 80, 238, 248
hierarchical id91, 30, 240
id116, 30, 240
self-organizing maps, 30, 59, 78, 239

usability, 209
user experience, 208, 273, 285
user modeling, 203, 228

user retention, 232, 243
user studies, 200
user testing, 237
utility, 30, 77, 158, 200, 245
utility-based ai, 32, 37

video game description language, 130, 192
virtual agents, 143, 190
virtual camera, 189, 254
virtual cinematography, 144
virtual humans, 143
virtual reality, 216
visual cues, 248
visualization, 198
vizdoom, 139, 141
voxel, 169, 184

weapon generation, 160, 186, 195
weapon selection, 37
weka, 243
id138, 195

z-machine, 145
zx spectrum, 124

