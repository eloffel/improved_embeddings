   #[1]rss: 40 latest updates [2]rss: 40 newest packages [3]pypi

   [4]skip to main content (button) switch to mobile version

   warning: some features may not work without javascript. please try
   enabling it if you encounter problems.

   [5]pypi
   search pypi ____________________ (button) search

   [6]help [7]donate [8]log in [9]register

   search pypi ____________________ (button) search

inflect 2.1.0

   pip install inflect (button) copy pip instructions
   [10]latest version

   last released: nov 12, 2018

   correctly generate plurals, singular nouns, ordinals, indefinite
   articles; convert numbers to words

navigation

   [11]project description [12]release history [13]download files

project links

   [14]homepage

statistics

   github statistics: stars: forks: open issues/prs:

   view statistics for this project via [15]libraries.io, or by using
   [16]google bigquery

meta

   license: mit license

   author: [17]paul dyson

   maintainer: [18]alex gronholm

   tags: plural, inflect, participle

   requires: python >=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*

maintainers

   [19]avatar for agronholm from gravatar.com [20]agronholm [21]avatar for
   jaraco from gravatar.com [22]jaraco [23]avatar for pwdyson from
   gravatar.com [24]pwdyson

classifiers

   development status
          [25]4 - beta

   intended audience
          [26]developers

   license
          [27]osi approved :: mit license

   natural language
          [28]english

   operating system
          [29]os independent

   programming language
          [30]python
          [31]python :: 2
          [32]python :: 2.7
          [33]python :: 3
          [34]python :: 3.4
          [35]python :: 3.5
          [36]python :: 3.6
          [37]python :: 3.7

   topic
          [38]software development :: libraries :: python modules
          [39]text processing :: linguistic

   [40]project description [41]project details [42]release history
   [43]download files

project description

   [44]https://travis-ci.org/jazzband/inflect.svg?branch=master
   [45]https://coveralls.io/repos/github/jazzband/inflect/badge.svg?branch
   =master [46]code style: black [47]jazzband

   this is a [48]jazzband project. by contributing you agree to abide by
   the [49]contributor code of conduct and follow the [50]guidelines.

name

   inflect.py - correctly generate plurals, singular nouns, ordinals,
   indefinite articles; convert numbers to words.

installation

   pip install inflect

synopsis

import inflect
p = inflect.engine()

# methods:

# plural plural_noun plural_verb plural_adj singular_noun no num
# compare compare_nouns compare_nouns compare_adjs
# a an
# present_participle
# ordinal number_to_words
# join
# inflect classical gender
# defnoun defverb defadj defa defan


# unconditionally form the plural

     print("the plural of ", word, " is ", p.plural(word))


# conditionally form the plural

     print("i saw", cat_count, p.plural("cat",cat_count))


# form plurals for specific parts of speech

     print(p.plural_noun("i",n1), p.plural_verb("saw",n1), p.plural_adj("my",n2)
, \)
           p.plural_noun("saw",n2)


# form the singular of plural nouns

     print("the singular of ", word, " is ", p.singular_noun(word))

# select the gender of singular pronouns

     print(p.singular_noun('they')  # 'it')
     p.gender('f')
     print(p.singular_noun('they')  # 'she')


# deal with "0/1/n" -> "no/1/n" translation:

     print("there ", p.plural_verb("was",errors), p.no(" error",errors))


# use default counts:

     print(p.num(n1,""), p.plural("i"), p.plural_verb(" saw"), p.num(n2), p.plur
al_noun(" saw"))
     print("there ", p.num(errors,''), p.plural_verb("was"), p.no(" error"))


# compare two words "number-insensitively":

     print("same\n"      if p.compare(word1, word2))
     print("same noun\n" if p.compare_nouns(word1, word2))
     print("same verb\n" if p.compare_verbs(word1, word2))
     print("same adj.\n" if p.compare_adjs(word1, word2))


# add correct "a" or "an" for a given word:

     print("did you want ", p.a(thing), " or ", p.an(idea))


# convert numerals into ordinals (i.e. 1->1st, 2->2nd, 3->3rd, etc.)

     print("it was", p.ordinal(position), " from the left\n")

# convert numerals to words (i.e. 1->"one", 101->"one hundred and one", etc.)
# returns a single string...

   words = p.number_to_words(1234)      # "one thousand, two hundred and thirty-
four"
   words = p.number_to_words(p.ordinal(1234)) # "one thousand, two hundred and t
hirty-fourth"


# get back a list of strings, one for each "chunk"...

   words = p.number_to_words(1234, getlist=true)    # ("one thousand","two hundr
ed and thirty-four")


# optional parameters change translation:

   words = p.number_to_words(12345, group=1)
   # "one, two, three, four, five"

   words = p.number_to_words(12345, group=2)
   # "twelve, thirty-four, five"

   words = p.number_to_words(12345, group=3)
   # "one twenty-three, forty-five"

   words = p.number_to_words(1234, andword='')
   # "one thousand, two hundred thirty-four"

   words = p.number_to_words(1234, andword=', plus')
   # "one thousand, two hundred, plus thirty-four" #todo: i get no comma before
plus: check perl

   words = p.number_to_words(555_1202, group=1, zero='oh')
   # "five, five, five, one, two, oh, two"

   words = p.number_to_words(555_1202, group=1, one='unity')
   # "five, five, five, unity, two, oh, two"

   words = p.number_to_words(123.456, group=1, decimal='mark')
   # "one two three mark four five six"  #todo: docbug: perl gives commas here a
s do i

# literal style only names numbers less than a certain threshold...

   words = p.number_to_words(   9, threshold=10);    # "nine"
   words = p.number_to_words(  10, threshold=10);    # "ten"
   words = p.number_to_words(  11, threshold=10);    # "11"
   words = p.number_to_words(1000, threshold=10);    # "1,000"

# join words into a list:

   mylist = join(("apple", "banana", "carrot"))
       # "apple, banana, and carrot"

   mylist = join(("apple", "banana"))
       # "apple and banana"

   mylist = join(("apple", "banana", "carrot"), final_sep="")
       # "apple, banana and carrot"


# require "classical" plurals (eg: "focus"->"foci", "cherub"->"cherubim")

     p.classical()               # use all classical plurals

     p.classical(all=true)       # use all classical plurals
     p.classical(all=false)      # switch off classical mode

     p.classical(zero=true)      #  "no error" instead of "no errors"
     p.classical(zero=false)     #  "no errors" instead of "no error"

     p.classical(herd=true)      #  "2 buffalo" instead of "2 buffalos"
     p.classical(herd=false)     #  "2 buffalos" instead of "2 buffalo"

     p.classical(persons=true)   # "2 chairpersons" instead of "2 chairpeople"
     p.classical(persons=false)  # "2 chairpeople" instead of "2 chairpersons"

     p.classical(ancient=true)   # "2 formulae" instead of "2 formulas"
     p.classical(ancient=false)  # "2 formulas" instead of "2 formulae"



# interpolate "plural()", "plural_noun()", "plural_verb()", "plural_adj()", "sin
gular_noun()",
# a()", "an()", "num()" and "ordinal()" within strings:

     print(p.inflect("the plural of {0} is plural({0})".format(word)))
     print(p.inflect("the singular of {0} is singular_noun({0})".format(word)))
     print(p.inflect("i saw {0} plural("cat",{0})".format(cat_count)))
     print(p.inflect("plural(i,{0}) plural_verb(saw,{0}) plural(a,{1}) plural_no
un(saw,{1})".format(n1, n2)))
     print(p.inflect("num({0},)plural(i) plural_verb(saw) num({1},)plural(a) plu
ral_noun(saw)".format(n1, n2)))
     print(p.inflect("i saw num({0}) plural("cat")\nnum()".format(cat_count)))
     print(p.inflect("there plural_verb(was,{0}) no(error,{0})".format(errors)))
     print(p.inflect("there num({0},) plural_verb(was) no(error)".format(errors)
))
     print(p.inflect("did you want a({0}) or an({1})".format(thing, idea)))
     print(p.inflect("it was ordinal({0}) from the left".format(position)))


# add user-defined inflections (overriding inbuilt rules):

     p.defnoun( "vax", "vaxen" )  # singular => plural

     p.defverb( "will" , "shall",  # 1st person singular => plural
               "will" , "will",   # 2nd person singular => plural
               "will" , "will")   # 3rd person singular => plural

     p.defadj(  "hir"  , "their")  # singular => plural

     p.defa("h")        # "ay halways sez 'haitch'!"

     p.defan(   "horrendous.*" )    # "an horrendous affectation"

description

   the methods of the class engine in module inflect.py provide plural
   inflections, singular noun inflections,    a   /   an    selection for english
   words, and manipulation of numbers as words.

   plural forms of all nouns, most verbs, and some adjectives are
   provided. where appropriate,    classical    variants (for example:
      brother    ->    brethren   ,    dogma    ->    dogmata   , etc.) are also provided.

   single forms of nouns are also provided. the gender of singular
   pronouns can be chosen (for example    they    ->    it    or    she    or    he    or
      they   ).

   pronunciation-based    a   /   an    selection is provided for all english
   words, and most initialisms.

   it is also possible to inflect numerals (1,2,3) to ordinals (1st, 2nd,
   3rd) and to english words (   one   ,    two   ,    three   ).

   in generating these inflections, inflect.py follows the oxford english
   dictionary and the guidelines in fowler   s modern english usage,
   preferring the former where the two disagree.

   the module is built around standard british spelling, but is designed
   to cope with common american variants as well. slang, jargon, and other
   english dialects are not explicitly catered for.

   where two or more inflected forms exist for a single word (typically a
      classical    form and a    modern    form), inflect.py prefers the more
   common form (typically the    modern    one), unless    classical    processing
   has been specified (see modern vs classical inflections).

forming plurals and singulars

inflecting plurals and singulars

   all of the plural... plural inflection methods take the word to be
   inflected as their first argument and return the corresponding
   inflection. note that all such methods expect the singular form of the
   word. the results of passing a plural form are undefined (and unlikely
   to be correct). similarly, the si... singular inflection method expects
   the plural form of the word.

   the plural... methods also take an optional second argument, which
   indicates the grammatical    number    of the word (or of another word with
   which the word being inflected must agree). if the    number    argument is
   supplied and is not 1 (or "one" or "a", or some other adjective that
   implies the singular), the plural form of the word is returned. if the
      number    argument does indicate singularity, the (uninflected) word
   itself is returned. if the number argument is omitted, the plural form
   is returned unconditionally.

   the si... method takes a second argument in a similar fashion. if it is
   some form of the number 1, or is omitted, the singular form is
   returned. otherwise the plural is returned unaltered.

   the various methods of inflect.engine are:

   plural_noun(word, count=none)

     the method plural_noun() takes a singular english noun or pronoun
     and returns its plural. pronouns in the nominative (   i    ->    we   ) and
     accusative (   me    ->    us   ) cases are handled, as are possessive
     pronouns (   mine    ->    ours   ).

   plural_verb(word, count=none)

     the method plural_verb() takes the singular form of a conjugated
     verb (that is, one which is already in the correct    person    and
        mood   ) and returns the corresponding plural conjugation.

   plural_adj(word, count=none)

     the method plural_adj() takes the singular form of certain types of
     adjectives and returns the corresponding plural form. adjectives
     that are correctly handled include:    numerical    adjectives (   a    ->
        some   ), demonstrative adjectives (   this    ->    these   ,    that    ->
        those   ), and possessives (   my    ->    our   ,    cat   s    ->    cats      ,
        child   s    ->    childrens      , etc.)

   plural(word, count=none)

     the method plural() takes a singular english noun, pronoun, verb, or
     adjective and returns its plural form. where a word has more than
     one inflection depending on its part of speech (for example, the
     noun    thought    inflects to    thoughts   , the verb    thought    to
        thought   ), the (singular) noun sense is preferred to the (singular)
     verb sense.

     hence plural("knife") will return    knives    (   knife    having been
     treated as a singular noun), whereas plural("knifes") will return
        knife    (   knifes    having been treated as a 3rd person singular
     verb).

     the inherent ambiguity of such cases suggests that, where the part
     of speech is known, plural_noun, plural_verb, and plural_adj should
     be used in preference to plural.

   singular_noun(word, count=none)

     the method singular_noun() takes a plural english noun or pronoun
     and returns its singular. pronouns in the nominative (   we    ->    i   )
     and accusative (   us    ->    me   ) cases are handled, as are possessive
     pronouns (   ours    ->    mine   ). when third person singular pronouns are
     returned they take the neuter gender by default (   they    ->    it   ),
     not (   they   ->    she   ) nor (   they    ->    he   ). this can be changed with
     gender().

   note that all these methods ignore any whitespace surrounding the word
   being inflected, but preserve that whitespace when the result is
   returned. for example, plural(" cat  ") returns     cats    .

   gender(genderletter)

     the third person plural pronoun takes the same form for the female,
     male and neuter (e.g.    they   ). the singular however, depends upon
     gender (e.g.    she   ,    he   ,    it    and    they           they    being the gender
     neutral form.) by default singular_noun returns the neuter form,
     however, the gender can be selected with the gender method. pass the
     first letter of the gender to gender to return the f(eminine),
     m(asculine), n(euter) or t(hey) form of the singular. e.g.
     gender(   f   ) followed by singular_noun(   themselves   ) returns
        herself   .

numbered plurals

   the plural... methods return only the inflected word, not the count
   that was used to inflect it. thus, in order to produce    i saw 3 ducks   ,
   it is necessary to use:
print("i saw", n, p.plural_noun(animal,n))

   since the usual purpose of producing a plural is to make it agree with
   a preceding count, inflect.py provides a method (no(word, count))
   which, given a word and a(n optional) count, returns the count followed
   by the correctly inflected word. hence the previous example can be
   rewritten:
print("i saw ", p.no(animal,n))

   in addition, if the count is zero (or some other term which implies
   zero, such as "zero", "nil", etc.) the count is replaced by the word
      no   . hence, if n had the value zero, the previous example would
   print(the somewhat more elegant::)

     i saw no animals

   rather than:
i saw 0 animals

   note that the name of the method is a pun: the method returns either a
   number (a no.) or a "no", in front of the inflected word.

reducing the number of counts required

   in some contexts, the need to supply an explicit count to the various
   plural... methods makes for tiresome repetition. for example:
print(plural_adj("this",errors), plural_noun(" error",errors), \)
      plural_verb(" was",errors), " fatal."

   inflect.py therefore provides a method (num(count=none, show=none))
   which may be used to set a persistent    default number    value. if such a
   value is set, it is subsequently used whenever an optional second
      number    argument is omitted. the default value thus set can
   subsequently be removed by calling num() with no arguments. hence we
   could rewrite the previous example:
p.num(errors)
print(p.plural_adj("this"), p.plural_noun(" error"), p.plural_verb(" was"), "fat
al.")
p.num()

   normally, num() returns its first argument, so that it may also be
      inlined    in contexts like:
print(p.num(errors), p.plural_noun(" error"), p.plural_verb(" was"), " detected.
")
if severity > 1:
    print(p.plural_adj("this"), p.plural_noun(" error"), p.plural_verb(" was"),
"fatal.")

   however, in certain contexts (see interpolating inflections in strings)
   it is preferable that num() return an empty string. hence num()
   provides an optional second argument. if that argument is supplied
   (that is, if it is defined) and evaluates to false, num returns an
   empty string instead of its first argument. for example:
print(p.num(errors,0), p.no("error"), p.plural_verb(" was"), " detected.")
if severity > 1:
    print(p.plural_adj("this"), p.plural_noun(" error"), p.plural_verb(" was"),
"fatal.")

number-insensitive equality

   inflect.py also provides a solution to the problem of comparing words
   of differing plurality through the methods compare(word1, word2),
   compare_nouns(word1, word2), compare_verbs(word1, word2), and
   compare_adjs(word1, word2). each of these methods takes two strings,
   and compares them using the corresponding plural-inflection method
   (plural(), plural_noun(), plural_verb(), and plural_adj()
   respectively).

   the comparison returns true if:
     * the strings are equal, or
     * one string is equal to a plural form of the other, or
     * the strings are two different plural forms of the one word.

   hence all of the following return true:
p.compare("index","index")      # returns "eq"
p.compare("index","indexes")    # returns "s:p"
p.compare("index","indices")    # returns "s:p"
p.compare("indexes","index")    # returns "p:s"
p.compare("indices","index")    # returns "p:s"
p.compare("indices","indexes")  # returns "p:p"
p.compare("indexes","indices")  # returns "p:p"
p.compare("indices","indices")  # returns "eq"

   as indicated by the comments in the previous example, the actual value
   returned by the various compare methods encodes which of the three
   equality rules succeeded:    eq    is returned if the strings were
   identical,    s:p    if the strings were singular and plural respectively,
      p:s    for plural and singular, and    p:p    for two distinct plurals.
   inequality is indicated by returning an empty string.

   it should be noted that two distinct singular words which happen to
   take the same plural form are not considered equal, nor are cases where
   one (singular) word   s plural is the other (plural) word   s singular.
   hence all of the following return false:
p.compare("base","basis")       # although both -> "bases"
p.compare("syrinx","syringe")   # although both -> "syringes"
p.compare("she","he")           # although both -> "they"

p.compare("opus","operas")      # although "opus" -> "opera" -> "operas"
p.compare("taxi","taxes")       # although "taxi" -> "taxis" -> "taxes"

   note too that, although the comparison is    number-insensitive    it is
   not case-insensitive (that is, plural("time","times") returns false. to
   obtain both number and case insensitivity, use the lower() method on
   both strings (that is, plural("time".lower(), "times".lower()) returns
   true).

other verb forms

present participles

   inflect.py also provides the present_participle method, which can take
   a 3rd person singular verb and correctly inflect it to its present
   participle:
p.present_participle("runs")   # "running"
p.present_participle("loves")  # "loving"
p.present_participle("eats")   # "eating"
p.present_participle("bats")   # "batting"
p.present_participle("spies")  # "spying"

providing indefinite articles

selecting indefinite articles

   inflect.py provides two methods (a(word, count=none) and an(word,
   count=none)) which will correctly prepend the appropriate indefinite
   article to a word, depending on its pronunciation. for example:
p.a("cat")        # -> "a cat"
p.an("cat")       # -> "a cat"
p.a("euphemism")      # -> "a euphemism"
p.a("euler number")   # -> "an euler number"
p.a("hour")       # -> "an hour"
p.a("houri")      # -> "a houri"

   the two methods are identical in function and may be used
   interchangeably. the only reason that two versions are provided is to
   enhance the readability of code such as:
print("that is ", an(errortype), " error)
print("that is ", a(fataltype), " fatal error)

   note that in both cases the actual article provided depends only on the
   pronunciation of the first argument, not on the name of the method.

   a() and an() will ignore any indefinite article that already exists at
   the start of the string. thus:
half_arked = [
    "a elephant",
    "a giraffe",
    "an ewe",
    "a orangutan",
]

for txt in half_arked:
    print(p.a(txt))

# prints:
#     an elephant
#     a giraffe
#     a ewe
#     an orangutan

   a() and an() both take an optional second argument. as with the
   plural... methods, this second argument is a    number    specifier. if its
   value is 1 (or some other value implying singularity), a() and an()
   insert    a    or    an    as appropriate. if the number specifier implies
   plurality, (a() and an() insert the actual second argument instead. for
   example:
p.a("cat",1)      # -> "a cat"
p.a("cat",2)      # -> "2 cat"
p.a("cat","one")      # -> "one cat"
p.a("cat","no")       # -> "no cat"

   note that, as implied by the previous examples, a() and an() both
   assume that their job is merely to provide the correct qualifier for a
   word (that is:    a   ,    an   , or the specified count). in other words, they
   assume that the word they are given has already been correctly
   inflected for plurality. hence, if n has the value 2, then:
print(p.a("cat",n))

   prints    2 cat   , instead of    2 cats   . the correct approach is to use:
print(p.a(p.plural("cat",n),n))

   or, better still:
print(p.no("cat",n))

   note too that, like the various plural... methods, whenever a() and
   an() are called with only one argument they are subject to the effects
   of any preceding call to num(). hence, another possible solution is:
p.num(n)
print(p.a(p.plural("cat")))

indefinite articles and initialisms

      initialisms    (sometimes inaccurately called    acronyms   ) are terms
   which have been formed from the initial letters of words in a phrase
   (for example,    nato   ,    nbl   ,    s.o.s.   ,    scuba   , etc.)

   such terms present a particular challenge when selecting between    a   
   and    an   , since they are sometimes pronounced as if they were a single
   word (   nay-tow   ,    sku-ba   ) and sometimes as a series of letter names
   (   en-eff-ell   ,    ess-oh-ess   ).

   a() and an() cope with this dichotomy using a series of inbuilt rules,
   which may be summarized as:

     if the word starts with a single letter, followed by a period or
     dash (for example,    r.i.p.   ,    c.o.d.   ,    e-mail   ,    x-ray   ,
        t-square   ), then choose the appropriate article for the sound of
     the first letter (   an r.i.p.   ,    a c.o.d.   ,    an e-mail   ,    an x-ray   ,
        a t-square   ).

     if the first two letters of the word are capitals, consonants, and
     do not appear at the start of any known english word, (for example,
        lcd   ,    xml   ,    ywca   ), then once again choose    a    or    an    depending
     on the sound of the first letter (   an lcd   ,    an xml   ,    a ywca   ).

     otherwise, assume the string is a capitalized word or a
     pronounceable initialism (for example,    led   ,    opec   ,    faq   ,
        unesco   ), and therefore takes    a    or    an    according to the
     (apparent) pronunciation of the entire word (   a led   ,    an opec   ,    a
     faq   ,    a unesco   ).

   note that rules 1 and 3 together imply that the presence or absence of
   punctuation may change the selection of indefinite article for a
   particular initialism (for example,    a faq    but    an f.a.q.   ).

indefinite articles and    soft h   s   

   words beginning in the letter    h    present another type of difficulty
   when selecting a suitable indefinite article. in a few such words (for
   example,    hour   ,    honour   ,    heir   ) the    h    is not voiced at all, and so
   such words inflect with    an   . the remaining cases (   voiced h   s   ) may be
   divided into two categories:    hard h   s    (such as    hangman   ,
      holograph   ,    hat   , etc.) and    soft h   s    (such as    hysterical   ,
      horrendous   ,    holy   , etc.)

   hard h   s always take    a    as their indefinite article, and soft h   s
   normally do so as well. but some english speakers prefer    an    for soft
   h   s (although the practice is now generally considered an affectation,
   rather than a legitimate grammatical alternative).

   at present, the a() and an() methods ignore soft h   s and use    a    for
   any voiced    h   . the author would, however, welcome feedback on this
   decision (envisaging a possible future    soft h    mode).

inflecting ordinals

   occasionally it is useful to present an integer value as an ordinal
   rather than as a numeral. for example:
enter password (1st attempt): ********
enter password (2nd attempt): *********
enter password (3rd attempt): *********
no 4th attempt. access denied.

   to this end, inflect.py provides the ordinal() method. ordinal() takes
   a single argument and forms its ordinal equivalent. if the argument
   isn   t a numerical integer, it just adds    -th   .

converting numbers to words

   the method number_to_words takes a number (cardinal or ordinal) and
   returns an english representation of that number.
word = p.number_to_words(1234567)

   puts the string:
"one million, two hundred and thirty-four thousand, five hundred and sixty-seven
"

   into words.

   a list can be return where each comma-separated chunk is returned as a
   separate element. hence:
words = p.number_to_words(1234567, wantlist=true)

   puts the list:
["one million",
 "two hundred and thirty-four thousand",
 "five hundred and sixty-seven"]

   into words.

   non-digits (apart from an optional leading plus or minus sign, any
   decimal points, and ordinal suffixes     see below) are silently ignored,
   so the following all produce identical results:
p.number_to_words(5551202)
p.number_to_words(5_551_202)
p.number_to_words("5,551,202")
p.number_to_words("555-1202")

   that last case is a little awkward since it   s almost certainly a phone
   number, and    five million, five hundred and fifty-one thousand, two
   hundred and two    probably isn   t what   s wanted.

   to overcome this, number_to_words() takes an optional argument,
      group   , which changes how numbers are translated. the argument must be
   a positive integer less than four, which indicated how the digits of
   the number are to be grouped. if the argument is 1, then each digit is
   translated separately. if the argument is 2, pairs of digits (starting
   from the left) are grouped together. if the argument is 3, triples of
   numbers (again, from the left) are grouped. hence:
p.number_to_words("555-1202", group=1)

   returns "five, five, five, one, two, zero, two", whilst:
p.number_to_words("555-1202", group=2)

   returns "fifty-five, fifty-one, twenty, two", and:
p.number_to_words("555-1202", group=3)

   returns "five fifty-five, one twenty, two".

   phone numbers are often written in words as
   "five..five..five..one..two..zero..two", which is also easy to achieve:
join '..', p.number_to_words("555-1202", group=>1)

   number_to_words also handles decimal fractions. hence:
p.number_to_words("1.2345")

   returns "one point two three four five" in a scalar context and
   ("one","point","two","three","four","five")) in an array context.
   exponent form ("1.234e56") is not yet handled.

   multiple decimal points are only translated in one of the    grouping   
   modes. hence:
p.number_to_words(101.202.303)

   returns "one hundred and one point two zero two three zero three",
   whereas:
p.number_to_words(101.202.303, group=1)

   returns "one zero one point two zero two point three zero three".

   the digit '0' is unusual in that in may be translated to english as
      zero   ,    oh   , or    nought   . to cater for this diversity, number_to_words
   may be passed a named argument,    zero   , which may be set to the desired
   translation of '0'. for example:
print(join "..", p.number_to_words("555-1202", group=3, zero='oh'))

   prints "five..five..five..one..two..oh..two". by default, zero is
   rendered as    zero   .

   likewise, the digit '1' may be rendered as    one    or    a/an    (or very
   occasionally other variants), depending on the context. so there is a
   'one' argument as well:
for num in [3,2,1,0]:
      print(p.number_to_words(num, one='a solitary', zero='no more'),)
      p.plural(" bottle of beer on the wall", num)

# prints:
#     three bottles of beer on the wall
#     two bottles of beer on the wall
#     a solitary bottle of beer on the wall
#     no more bottles of beer on the wall

   care is needed if the word    a/an    is to be used as a 'one' value.
   unless the next word is known in advance, it   s almost always necessary
   to use the a function as well:
    for word in ["cat aardvark ewe hour".split()]:
        print(p.a("{0} {1}".format(p.number_to_words(1, one='a'), word)))

# prints:
#     a cat
#     an aardvark
#     a ewe
#     an hour

   another major regional variation in number translation is the use of
      and    in certain contexts. the named argument    and    allows the
   programmer to specify how    and    should be handled. hence:
print(scalar p.number_to_words("765", andword=''))

   prints    seven hundred sixty-five   , instead of    seven hundred and
   sixty-five   . by default, the    and    is included.

   the translation of the decimal point is also subject to variation (with
      point   ,    dot   , and    decimal    being the favorites). the named argument
      decimal    allows the programmer to how the decimal point should be
   rendered. hence:
print(scalar p.number_to_words("666.124.64.101", group=3, decimal='dot'))

   prints    six sixty-six, dot, one twenty-four, dot, sixty-four, dot, one
   zero one    by default, the decimal point is rendered as    point   .

   number_to_words also handles the ordinal forms of numbers. so:
print(p.number_to_words('1st'))
print(p.number_to_words('3rd'))
print(p.number_to_words('202nd'))
print(p.number_to_words('1000000th'))

   prints:
first
third
two hundred and twenty-second
one millionth

   two common idioms in this regard are:
print(p.number_to_words(ordinal(number)))

   and:
print(p.ordinal(p.number_to_words(number)))

   these are identical in effect, except when number contains a decimal:
number = 99.09
print(p.number_to_words(p.ordinal(number));    # ninety-ninth point zero nine)
print(p.ordinal(p.number_to_words(number));    # ninety-nine point zero ninth)

   use whichever you feel is most appropriate.

converting lists of words to phrases

   when creating a list of words, commas are used between adjacent items,
   except if the items contain commas, in which case semicolons are used.
   but if there are less than two items, the commas/semicolons are omitted
   entirely. the final item also has a conjunction (usually    and    or    or   )
   before it. and although it   s technically incorrect (and sometimes
   misleading), some people prefer to omit the comma before that final
   conjunction, even when there are more than two items.

   that   s complicated enough to warrant its own method: join(). this
   method expects a tuple of words, possibly with one or more options. it
   returns a string that joins the list together in the normal english
   usage. for example:
print("you chose ", p.join(selected_items))
# you chose barley soup, roast beef, and yorkshire pudding

print("you chose ", p.join(selected_items, final_sep=>""))
# you chose barley soup, roast beef and yorkshire pudding

print("please chose ", p.join(side_orders, conj=>"or"))
# please chose salad, vegetables, or ice-cream

   the available options are:
option named    specifies                default value

conj            final conjunction        "and"
sep             inter-item separator     ","
last_sep        final separator          value of 'sep' option
sep_spaced      space follows sep        true
conj_spaced     spaces around conj       true

interpolating inflections in strings

   by far the commonest use of the inflection methods is to produce
   message strings for various purposes. for example:
print(p.num(errors), p.plural_noun(" error"), p.plural_verb(" was"), " detected.
")
if severity > 1:
    print(p.plural_adj("this"), p.plural_noun(" error"), p.plural_verb(" was"),
"fatal.")

   unfortunately the need to separate each method call detracts
   significantly from the readability of the resulting code. to ameliorate
   this problem, inflect.py provides a string-interpolating method
   (inflect(txt)), which recognizes calls to the various inflection
   methods within a string and interpolates them appropriately.

   using inflect the previous example could be rewritten:
print(p.inflect("num({0}) plural_noun(error) plural_verb(was) detected.".format(
errors)))
if severity > 1:
    print(p.inflect("plural_adj(this) plural_noun(error) plural_verb(was) fatal.
"))

   note that inflect also correctly handles calls to the num() method
   (whether interpolated or antecedent). the inflect() method has a
   related extra feature, in that it automatically cancels any    default
   number    value before it returns its interpolated string. this means
   that calls to num() which are embedded in an inflect()-interpolated
   string do not    escape    and interfere with subsequent inflections.

modern vs classical inflections

   certain words, mainly of latin or ancient greek origin, can form
   plurals either using the standard english    -s    suffix, or with their
   original latin or greek inflections. for example:
p.plural("stigma")            # -> "stigmas" or "stigmata"
p.plural("torus")             # -> "toruses" or "tori"
p.plural("index")             # -> "indexes" or "indices"
p.plural("millennium")        # -> "millenniums" or "millennia"
p.plural("ganglion")          # -> "ganglions" or "ganglia"
p.plural("octopus")           # -> "octopuses" or "octopodes"

   inflect.py caters to such words by providing an    alternate state    of
   inflection known as    classical mode   . by default, words are inflected
   using their contemporary english plurals, but if classical mode is
   invoked, the more traditional plural forms are returned instead.

   the method classical() controls this feature. if classical() is called
   with no arguments, it unconditionally invokes classical mode. if it is
   called with a single argument, it turns all classical inflects on or
   off (depending on whether the argument is true or false). if called
   with two or more arguments, those arguments specify which aspects of
   classical behaviour are to be used.

   thus:
p.classical()                # switch on classical mode
print(p.plural("formula")        # -> "formulae")

p.classical(all=false)               # switch off classical mode
print(p.plural("formula")        # -> "formulas")

p.classical(cmode=true)           # classical mode iff cmode
print(p.plural("formula")        # -> "formulae" (if cmode))
                             # -> "formulas" (otherwise)

p.classical(herd=true)          # switch on classical mode for "herd" nouns
print(p.plural("wilderbeest")    # -> "wilderbeest")

p.classical(names=true)         # switch on classical mode for names
print(p.plural("sally")          # -> "sallies")
print(p.plural("sally")          # -> "sallys")

   note however that classical() has no effect on the inflection of words
   which are now fully assimilated. hence:
p.plural("forum")             # always -> "forums"
p.plural("criterion")         # always -> "criteria"

   lei assumes that a capitalized word is a person   s name. so it forms the
   plural according to the rules for names (which is that you don   t
   inflect, you just add -s or -es). you can choose to turn that behaviour
   off (it   s on by the default, even when the module isn   t in classical
   mode) by calling `` classical(names=0) ``

user-defined inflections

adding plurals at run-time

   inflect.py provides five methods which allow the programmer to override
   the module   s behaviour for specific cases:

   defnoun(singular, plural)

     the defnoun method takes a pair of string arguments: the singular
     and the plural forms of the noun being specified. the singular form
     specifies a pattern to be interpolated (as m/^(?:$first_arg)$/i).
     any noun matching this pattern is then replaced by the string in the
     second argument. the second argument specifies a string which is
     interpolated after the match succeeds, and is then used as the
     plural form. for example:
defnoun( 'cow'        , 'kine')
defnoun( '(.+i)o'     , '$1i')
defnoun( 'spam(mer)?' , '\\$\\%\\@#\\$\\@#!!')

     note that both arguments should usually be specified in single
     quotes, so that they are not interpolated when they are specified,
     but later (when words are compared to them). as indicated by the
     last example, care also needs to be taken with certain characters in
     the second argument, to ensure that they are not unintentionally
     interpolated during comparison.

     the second argument string may also specify a second variant of the
     plural form, to be used when    classical    plurals have been
     requested. the beginning of the second variant is marked by a    |   
     character:
defnoun( 'cow'        , 'cows|kine')
defnoun( '(.+i)o'     , '$1os|$1i')
defnoun( 'spam(mer)?' , '\\$\\%\\@#\\$\\@#!!|varmints')

     if no classical variant is given, the specified plural form is used
     in both normal and    classical    modes.

   defverb(s1, p1, s2, p2, s3, p3)

     the defverb method takes three pairs of string arguments (that is,
     six arguments in total), specifying the singular and plural forms of
     the three    persons    of verb. as with defnoun, the singular forms are
     specifications of run-time-interpolated patterns, whilst the plural
     forms are specifications of (up to two) run-time-interpolated
     strings:
defverb('am'       , 'are',
         'are'      , 'are|art",
         'is'       , 'are')

defverb('have'     , 'have',
         'have'     , 'have",
         'ha(s|th)' , 'have')

     note that as with defnoun, modern/classical variants of plurals may
     be separately specified, subsequent definitions replace previous
     ones, and none   ed plural forms revert to the standard behaviour.

   defadj(singular, plural)

     the defadj method takes a pair of string arguments, which specify
     the singular and plural forms of the adjective being defined. as
     with defnoun and defadj, the singular forms are specifications of
     run-time-interpolated patterns, whilst the plural forms are
     specifications of (up to two) run-time-interpolated strings:
defadj( 'this'     , 'these')
defadj( 'red'      , 'red|gules')

     as previously, modern/classical variants of plurals may be
     separately specified, subsequent definitions replace previous ones,
     and none   ed plural forms revert to the standard behaviour.

   defa(pattern) and defan(pattern)

     the defa and defan methods each take a single argument, which
     specifies a pattern. if a word passed to a() or an() matches this
     pattern, it will be prefixed (unconditionally) with the
     corresponding indefinite article. for example:
defa( 'error')
defa( 'in.+')

defan('mistake')
defan('error')

     as with the other def_... methods, such redefinitions are sequential
     in effect so that, after the above example,    error    will be
     inflected with    an   .

the <$home/.inflectrc file

   this has not been implemented in the python version yet

   when it is imported, inflect.py executes (as perl code) the contents of
   any file named .inflectrc which it finds in the in the directory where
   lingua/en/inflect.pm is installed, or in the current home directory
   ($env{home}), or in both. note that the code is executed within the
   inflect.py namespace.

   hence the user or the local perl guru can make appropriate calls to
   defnoun, defverb, etc. in one of these .inflectrc files, to permanently
   and universally modify the behaviour of the module. for example

     > cat /usr/local/lib/perl5/text/inflect/.inflectrc

     defnoun    unix    =>    un*x|unices   

   defverb    teco    =>    teco   , # literally:    to edit with teco   
             teco    =>    teco   ,    tecos    =>    teco   

     defa    euler.*   ; #    yewler    turns in his grave

   note that calls to the def_... methods from within a program will take
   precedence over the contents of the home directory f<.inflectrc> file,
   which in turn takes precedence over the system-wide f<.inflectrc> file.

diagnostics

   this has not been implemented in the python version yet

   on loading, if the perl code in a .inflectrc file is invalid
   (syntactically or otherwise), an appropriate fatal error is issued. a
   common problem is not ending the file with something that evaluates to
   true (as the five def_... methods do).

   using the five def_... methods directly in a program may also result in
   fatal diagnostics, if a (singular) pattern or an interpolated (plural)
   string is somehow invalid.

   specific diagnostics related to user-defined inflections are:

   "bad user-defined singular pattern:\t %s"

     the singular form of a user-defined noun or verb (as defined by a
     call to defnoun, defverb, defadj, defa or defan) is not a valid perl
     regular expression. the actual perl error message is also given.

   "bad user-defined plural string: '%s'"

     the plural form(s) of a user-defined noun or verb (as defined by a
     call to defnoun, defverb or defadj) is not a valid perl interpolated
     string (usually because it interpolates some undefined variable).

   "bad .inflectrc file (%s): %s"

     some other problem occurred in loading the named local or global
     f<.inflectrc> file. the perl error message (including the line
     number) is also given.

   there are no diagnosable run-time error conditions for the actual
   inflection methods, except number_to_words and hence no run-time
   diagnostics. if the inflection methods are unable to form a plural via
   a user-definition or an inbuilt rule, they just    guess    the commonest
   english inflection: adding    -s    for nouns, removing    -s    for verbs, and
   no inflection for adjectives.

   inflect.py can raise the following execeptions:

   badchunkingoptionerror

     the optional argument to number_to_words() wasn   t 1, 2 or 3.

   numoutofrangeerror

     number_to_words() was passed a number larger than
     999,999,999,999,999,999,999,999,999,999,999,999 (that is: nine
     hundred and ninety-nine decillion, nine hundred and ninety-nine
     nonillion, nine hundred and ninety-nine octillion, nine hundred and
     ninety-nine septillion, nine hundred and ninety-nine sextillion,
     nine hundred and ninety-nine quintillion, nine hundred and
     ninety-nine quadrillion, nine hundred and ninety-nine trillion, nine
     hundred and ninety-nine billion, nine hundred and ninety-nine
     million, nine hundred and ninety-nine thousand, nine hundred and
     ninety-nine :-)

     the problem is that number_to_words doesn   t know any words for
     number components bigger than    decillion   .

   unknownclassicalmodeerror

   badnumvalueerror

   baduserdefinedpatternerror

   badrcfileerror

other issues

2nd person precedence

   if a verb has identical 1st and 2nd person singular forms, but
   different 1st and 2nd person plural forms, then when its plural is
   constructed, the 2nd person plural form is always preferred.

   the author is not currently aware of any such verbs in english, but is
   not quite arrogant enough to assume ipso facto that none exist.

nominative precedence

   the singular pronoun    it    presents a special problem because its plural
   form can vary, depending on its    case   . for example:
it ate my homework       ->  they ate my homework
it ate it                ->  they ate them
i fed my homework to it  ->  i fed my homework to them

   as a consequence of this ambiguity, plural() or plural_noun have been
   implemented so that they always return the nominative plural (that is,
      they   ).

   however, when asked for the plural of an unambiguously accusative    it   
   (namely, plural("to it"), plural_noun("from it"), plural("with it"),
   etc.), both methods will correctly return the accusative plural (   to
   them   ,    from them   ,    with them   , etc.)

the plurality of zero

   the rules governing the choice between:
there were no errors.

   and
there was no error.

   are complex and often depend more on intent rather than content. hence
   it is infeasible to specify such rules algorithmically.

   therefore, inflect.py contents itself with the following compromise: if
   the governing number is zero, inflections always return the plural form
   unless the appropriate    classical    inflection is in effect, in which
   case the singular form is always returned.

   thus, the sequence:
p.num(0)
print(p.inflect("there plural(was) no(choice)"))

   produces    there were no choices   , whereas:
p.classical(zero=true)
p.num(0)
print(p.inflect("there plural(was) no(choice)"))

   it will print(   there was no choice   .)

homographs with heterogeneous plurals

   another context in which intent (and not content) sometimes determines
   plurality is where two distinct meanings of a word require different
   plurals. for example:
three basses were stolen from the band's equipment trailer.
three bass were stolen from the band's aquarium.

i put the mice next to the cheese.
i put the mouses next to the computers.

several thoughts about leaving crossed my mind.
several thought about leaving across my lawn.

   inflect.py handles such words in two ways:
     * if both meanings of the word are the same part of speech (for
       example,    bass    is a noun in both sentences above), then one
       meaning is chosen as the    usual    meaning, and only that meaning   s
       plural is ever returned by any of the inflection methods.
     * if each meaning of the word is a different part of speech (for
       example,    thought    is both a noun and a verb), then the noun   s
       plural is returned by plural() and plural_noun() and the verb   s
       plural is returned only by plural_verb().

   such contexts are, fortunately, uncommon (particularly
      same-part-of-speech    examples). an informal study of nearly 600
      difficult plurals    indicates that plural() can be relied upon to    get
   it right    about 98% of the time (although, of course, ichthyophilic
   guitarists or cyber-behaviouralists may experience higher rates of
   confusion).

   if the choice of a particular    usual inflection    is considered
   inappropriate, it can always be reversed with a preliminary call to the
   corresponding def_... method.

note

   there will be no further correspondence on:

      octopi   .

     despite the populist pandering of certain new world dictionaries,
     the plural is    octopuses    or (for the pendantic classicist)
        octopodes   . the suffix    -pus    is greek, not latin, so the plural is
        -podes   , not    pi   .

      virus   .

     had no plural in latin (possibly because it was a mass noun). the
     only plural is the anglicized    viruses   .

authors

   thorben kr  ger ([51]github@benthor.name) * established python 3
   compatibility

   paul dyson ([52]pwdyson@yahoo.com) * converted code from perl to python
   * added singular_noun functionality

   original perl version of the code and documentation: damian conway
   ([53]damian@conway.org), matthew persico (ord inflection)

bugs and irritations

   the endless inconsistencies of english.

   (please report words for which the correct plural or indefinite article
   is not formed, so that the reliability of inflect.py can be improved.)

project details

project links

   [54]homepage

statistics

   github statistics: stars: forks: open issues/prs:

   view statistics for this project via [55]libraries.io, or by using
   [56]google bigquery

meta

   license: mit license

   author: [57]paul dyson

   maintainer: [58]alex gronholm

   tags: plural, inflect, participle

   requires: python >=2.7, !=3.0.*, !=3.1.*, !=3.2.*, !=3.3.*

maintainers

   [59]avatar for agronholm from gravatar.com [60]agronholm [61]avatar for
   jaraco from gravatar.com [62]jaraco [63]avatar for pwdyson from
   gravatar.com [64]pwdyson

classifiers

   development status
          [65]4 - beta

   intended audience
          [66]developers

   license
          [67]osi approved :: mit license

   natural language
          [68]english

   operating system
          [69]os independent

   programming language
          [70]python
          [71]python :: 2
          [72]python :: 2.7
          [73]python :: 3
          [74]python :: 3.4
          [75]python :: 3.5
          [76]python :: 3.6
          [77]python :: 3.7

   topic
          [78]software development :: libraries :: python modules
          [79]text processing :: linguistic

release history [80]release notifications

   this version
   history node
   [81]

   2.1.0

   nov 12, 2018
   history node
   [82]

   2.0.1

   nov 12, 2018
   history node
   [83]

   2.0.0

   nov 12, 2018
   history node
   [84]

   1.0.2

   nov 12, 2018
   history node
   [85]

   1.0.1

   sep 23, 2018
   history node
   [86]

   1.0.0

   jul 26, 2018
   history node
   [87]

   0.3.1

   may 8, 2018
   history node
   [88]

   0.3.0

   may 8, 2018
   history node
   [89]

   0.2.5

   jan 9, 2015
   history node
   [90]

   0.2.4

   jun 9, 2013
   history node
   [91]

   0.2.3

   jun 10, 2012
   history node
   [92]

   0.2.1

   aug 31, 2010
   history node
   [93]

   0.2.0

   aug 6, 2010
   history node
   [94]

   0.1.8

   jul 10, 2010
   history node
   [95]

   0.1.7

   jul 4, 2010
   history node
   [96]

   0.1.6

   jul 3, 2010
   history node
   [97]

   0.1.5

   jun 26, 2010
   history node
   [98]

   0.1.4

   jun 24, 2010
   history node
   [99]

   0.1.3

   jun 21, 2010
   history node
   [100]

   0.1.2

   jun 21, 2010
   history node
   [101]

   0.1.1

   jun 17, 2010
   history node
   [102]

   0.1

   jun 14, 2010

download files

   download the file for your platform. if you're not sure which to
   choose, learn more about [103]installing packages.
   filename, size & hash [104]sha256 hash help file type python version
   upload date
   [105]inflect-2.1.0-py2.py3-none-any.whl (41.0 kb) copy sha256 hash
   sha256 wheel py2.py3 nov 12, 2018
   [106]inflect-2.1.0.tar.gz (98.8 kb) copy sha256 hash sha256 source none
   nov 12, 2018

   logo

     * help
     * [107]installing packages
     * [108]uploading packages
     * [109]user guide
     * [110]faqs

     * about pypi
     * [111]pypi on twitter
     * [112]infrastructure dashboard
     * [113]package index name retention
     * [114]our sponsors

     * contributing to pypi
     * [115]bugs and feedback
     * [116]contribute on github
     * [117]development credits

     * using pypi
     * [118]code of conduct
     * [119]report security issue
     * [120]privacy policy
     * [121]terms of use
     __________________________________________________________________

   status: [122]all systems operational

   developed and maintained by the python community, for the python
   community.
   [123]donate today!

      2019 [124]python software foundation

   (button) desktop version

   supported by
   [125]elastic elastic search [126]pingdom pingdom monitoring [127]google
   google bigquery [128]sentry sentry error logging [129]aws aws cloud
   computing [130]datadog datadog monitoring [131]fastly fastly cdn
   [132]signalfx signalfx supporter [133]digicert digicert ev certificate
   [134]statuspage statuspage status page

references

   1. https://pypi.org/rss/updates.xml
   2. https://pypi.org/rss/packages.xml
   3. https://pypi.org/opensearch.xml
   4. https://pypi.org/project/inflect/#content
   5. https://pypi.org/
   6. https://pypi.org/help/
   7. https://donate.pypi.org/
   8. https://pypi.org/account/login/
   9. https://pypi.org/account/register/
  10. https://pypi.org/project/inflect/
  11. https://pypi.org/project/inflect/#description
  12. https://pypi.org/project/inflect/#history
  13. https://pypi.org/project/inflect/#files
  14. https://github.com/jazzband/inflect
  15. https://libraries.io/pypi/inflect
  16. https://packaging.python.org/guides/analyzing-pypi-package-downloads/
  17. mailto:pwdyson@yahoo.com
  18. mailto:alex.gronholm@nextday.fi
  19. https://pypi.org/user/agronholm/
  20. https://pypi.org/user/agronholm/
  21. https://pypi.org/user/jaraco/
  22. https://pypi.org/user/jaraco/
  23. https://pypi.org/user/pwdyson/
  24. https://pypi.org/user/pwdyson/
  25. https://pypi.org/search/?c=development+status+::+4+-+beta
  26. https://pypi.org/search/?c=intended+audience+::+developers
  27. https://pypi.org/search/?c=license+::+osi+approved+::+mit+license
  28. https://pypi.org/search/?c=natural+language+::+english
  29. https://pypi.org/search/?c=operating+system+::+os+independent
  30. https://pypi.org/search/?c=programming+language+::+python
  31. https://pypi.org/search/?c=programming+language+::+python+::+2
  32. https://pypi.org/search/?c=programming+language+::+python+::+2.7
  33. https://pypi.org/search/?c=programming+language+::+python+::+3
  34. https://pypi.org/search/?c=programming+language+::+python+::+3.4
  35. https://pypi.org/search/?c=programming+language+::+python+::+3.5
  36. https://pypi.org/search/?c=programming+language+::+python+::+3.6
  37. https://pypi.org/search/?c=programming+language+::+python+::+3.7
  38. https://pypi.org/search/?c=topic+::+software+development+::+libraries+::+python+modules
  39. https://pypi.org/search/?c=topic+::+text+processing+::+linguistic
  40. https://pypi.org/project/inflect/#description
  41. https://pypi.org/project/inflect/#data
  42. https://pypi.org/project/inflect/#history
  43. https://pypi.org/project/inflect/#files
  44. https://travis-ci.org/jazzband/inflect
  45. https://coveralls.io/github/jazzband/inflect?branch=master
  46. https://github.com/ambv/black
  47. https://jazzband.co/
  48. https://jazzband.co/
  49. https://jazzband.co/about/conduct
  50. https://jazzband.co/about/guidelines
  51. mailto:github@benthor.name
  52. mailto:pwdyson@yahoo.com
  53. mailto:damian@conway.org
  54. https://github.com/jazzband/inflect
  55. https://libraries.io/pypi/inflect
  56. https://packaging.python.org/guides/analyzing-pypi-package-downloads/
  57. mailto:pwdyson@yahoo.com
  58. mailto:alex.gronholm@nextday.fi
  59. https://pypi.org/user/agronholm/
  60. https://pypi.org/user/agronholm/
  61. https://pypi.org/user/jaraco/
  62. https://pypi.org/user/jaraco/
  63. https://pypi.org/user/pwdyson/
  64. https://pypi.org/user/pwdyson/
  65. https://pypi.org/search/?c=development+status+::+4+-+beta
  66. https://pypi.org/search/?c=intended+audience+::+developers
  67. https://pypi.org/search/?c=license+::+osi+approved+::+mit+license
  68. https://pypi.org/search/?c=natural+language+::+english
  69. https://pypi.org/search/?c=operating+system+::+os+independent
  70. https://pypi.org/search/?c=programming+language+::+python
  71. https://pypi.org/search/?c=programming+language+::+python+::+2
  72. https://pypi.org/search/?c=programming+language+::+python+::+2.7
  73. https://pypi.org/search/?c=programming+language+::+python+::+3
  74. https://pypi.org/search/?c=programming+language+::+python+::+3.4
  75. https://pypi.org/search/?c=programming+language+::+python+::+3.5
  76. https://pypi.org/search/?c=programming+language+::+python+::+3.6
  77. https://pypi.org/search/?c=programming+language+::+python+::+3.7
  78. https://pypi.org/search/?c=topic+::+software+development+::+libraries+::+python+modules
  79. https://pypi.org/search/?c=topic+::+text+processing+::+linguistic
  80. https://pypi.org/help/#project-release-notifications
  81. https://pypi.org/project/inflect/2.1.0/
  82. https://pypi.org/project/inflect/2.0.1/
  83. https://pypi.org/project/inflect/2.0.0/
  84. https://pypi.org/project/inflect/1.0.2/
  85. https://pypi.org/project/inflect/1.0.1/
  86. https://pypi.org/project/inflect/1.0.0/
  87. https://pypi.org/project/inflect/0.3.1/
  88. https://pypi.org/project/inflect/0.3.0/
  89. https://pypi.org/project/inflect/0.2.5/
  90. https://pypi.org/project/inflect/0.2.4/
  91. https://pypi.org/project/inflect/0.2.3/
  92. https://pypi.org/project/inflect/0.2.1/
  93. https://pypi.org/project/inflect/0.2.0/
  94. https://pypi.org/project/inflect/0.1.8/
  95. https://pypi.org/project/inflect/0.1.7/
  96. https://pypi.org/project/inflect/0.1.6/
  97. https://pypi.org/project/inflect/0.1.5/
  98. https://pypi.org/project/inflect/0.1.4/
  99. https://pypi.org/project/inflect/0.1.3/
 100. https://pypi.org/project/inflect/0.1.2/
 101. https://pypi.org/project/inflect/0.1.1/
 102. https://pypi.org/project/inflect/0.1/
 103. https://packaging.python.org/installing/
 104. https://pip.pypa.io/en/stable/reference/pip_install/#hash-checking-mode
 105. https://files.pythonhosted.org/packages/86/02/e6b11020a9c37d25b4767a1d0af5835629f6e75d6f51553ad07a4c73dc31/inflect-2.1.0-py2.py3-none-any.whl
 106. https://files.pythonhosted.org/packages/5e/79/fc91ef0768c6ac564c2d820ff2658b6a82686aeb71145980b71c50d0a122/inflect-2.1.0.tar.gz
 107. https://packaging.python.org/installing/
 108. https://packaging.python.org/tutorials/packaging-projects/
 109. https://packaging.python.org/
 110. https://pypi.org/help/
 111. https://twitter.com/pypi
 112. https://dtdg.co/pypi
 113. https://www.python.org/dev/peps/pep-0541/
 114. https://pypi.org/sponsors/
 115. https://pypi.org/help/#feedback
 116. https://github.com/pypa/warehouse
 117. https://github.com/pypa/warehouse/graphs/contributors
 118. https://www.pypa.io/en/latest/code-of-conduct/
 119. https://pypi.org/security/
 120. https://www.python.org/privacy/
 121. https://pypi.org/policy/terms-of-use/
 122. https://status.python.org/
 123. https://donate.pypi.org/
 124. https://www.python.org/psf/
 125. https://www.elastic.co/
 126. https://www.pingdom.com/
 127. https://cloud.google.com/
 128. https://getsentry.com/for/python
 129. https://aws.amazon.com/
 130. https://www.datadoghq.com/
 131. https://www.fastly.com/
 132. https://www.signalfx.com/
 133. https://www.digicert.com/
 134. https://statuspage.io/
