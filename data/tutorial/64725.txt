algorithms for id23

draft of the lecture published in the

synthesis lectures on arti   cial intelligence and machine learning

series

by

morgan & claypool publishers

csaba szepesv  ari
june 9, 2009   

contents

1 overview

2 id100

2.1 preliminaries
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.2 id100 . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.3 value functions . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
2.4 id145 algorithms for solving mdps . . . . . . . . . . . . . .

3 value prediction problems

3.1 temporal di   erence learning in    nite state spaces . . . . . . . . . . . . . . .
3.1.1 tabular td(0)
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
3.1.2 every-visit monte-carlo . . . . . . . . . . . . . . . . . . . . . . . . .
3.1.3 td(  ): unifying monte-carlo and td(0) . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . .
3.2.1 td(  ) with function approximation . . . . . . . . . . . . . . . . . . .
3.2.2 gradient temporal di   erence learning . . . . . . . . . . . . . . . . . .
3.2.3 least-squares methods . . . . . . . . . . . . . . . . . . . . . . . . . .

3.2 algorithms for large state spaces

   last update: march 12, 2019

1

3

7
7
8
12
16

17
18
18
21
23
25
29
33
36

3.2.4 the choice of the function space . . . . . . . . . . . . . . . . . . . . .

42

45
45
47
47
49
50
51
56
56
59
62
64
65

72
72
73
73
73

74
74
78

4 control

4.1 a catalog of learning problems . . . . . . . . . . . . . . . . . . . . . . . . . .
4.2 closed-loop interactive learning . . . . . . . . . . . . . . . . . . . . . . . . .
4.2.1 online learning in bandits . . . . . . . . . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . .
4.2.2 active learning in bandits
4.2.3 active learning in id100
. . . . . . . . . . . . .
. . . . . . . . . . . . .
4.2.4 online learning in id100
4.3 direct methods . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
4.3.1 id24 in    nite mdps . . . . . . . . . . . . . . . . . . . . . . . .
4.3.2 id24 with function approximation . . . . . . . . . . . . . . . .
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
implementing a critic . . . . . . . . . . . . . . . . . . . . . . . . . . .
implementing an actor . . . . . . . . . . . . . . . . . . . . . . . . . .

4.4 actor-critic methods

4.4.1
4.4.2

5 for further exploration

5.1 further reading . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.2 applications . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.3 software . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .
5.4 acknowledgements
. . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

a the theory of discounted markovian decision processes

a.1 contractions and banach   s    xed-point theorem . . . . . . . . . . . . . . . .
a.2 application to mdps . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .

abstract

id23 is a learning paradigm concerned with learning to control a

system so as to maximize a numerical performance measure that expresses a long-term

objective. what distinguishes id23 from supervised learning is that

only partial feedback is given to the learner about the learner   s predictions. further,

the predictions may have long term e   ects through in   uencing the future state of the

controlled system. thus, time plays a special role. the goal in id23

is to develop e   cient learning algorithms, as well as to understand the algorithms   

merits and limitations. id23 is of great interest because of the large

number of practical applications that it can be used to address, ranging from problems

in arti   cial intelligence to operations research or control engineering. in this book, we

focus on those algorithms of id23 that build on the powerful theory of

id145. we give a fairly comprehensive catalog of learning problems,

2

figure 1: the basic id23 scenario

describe the core ideas together with a large number of state of the art algorithms,

followed by the discussion of their theoretical properties and limitations.

keywords:
id23; id100; temporal di   erence learn-
ing; stochastic approximation; two-timescale stochastic approximation; monte-carlo meth-
ods; simulation optimization; function approximation; stochastic gradient methods; least-
squares methods; over   tting; bias-variance tradeo   ; online learning; active learning; plan-
ning; simulation; pac-learning; id24; actor-critic methods; policy gradient; natural
gradient

1 overview

id23 (rl) refers to both a learning problem and a sub   eld of machine
learning. as a learning problem, it refers to learning to control a system so as to maxi-
mize some numerical value which represents a long-term objective. a typical setting where
id23 operates is shown in figure 1: a controller receives the controlled
system   s state and a reward associated with the last state transition. it then calculates an
action which is sent back to the system. in response, the system makes a transition to a
new state and the cycle is repeated. the problem is to learn a way of controlling the system
so as to maximize the total reward. the learning problems di   er in the details of how the
data is collected and how performance is measured.
in this book, we assume that the system that we wish to control is stochastic. further,
we assume that the measurements available on the system   s state are detailed enough so
that the the controller can avoid reasoning about how to collect information about the

3

  rewardstateactionsystemsystemcontrollercontrollerstate. problems with these characteristics are best described in the framework of markovian
decision processes (mdps). the standard approach to    solve    mdps is to use dynamic
programming, which transforms the problem of    nding a good controller into the problem
of    nding a good value function. however, apart from the simplest cases when the mdp has
very few states and actions, id145 is infeasible. the rl algorithms that
we discuss here can be thought of as a way of turning the infeasible id145
methods into practical algorithms so that they can be applied to large-scale problems.
there are two key ideas that allow rl algorithms to achieve this goal. the    rst idea is to
use samples to compactly represent the dynamics of the control problem. this is important
for two reasons: first, it allows one to deal with learning scenarios when the dynamics is
unknown. second, even if the dynamics is available, exact reasoning that uses it might
be intractable on its own. the second key idea behind rl algorithms is to use powerful
function approximation methods to compactly represent value functions. the signi   cance
of this is that it allows dealing with large, high-dimensional state- and action-spaces. what
is more, the two ideas    t nicely together: samples may be focused on a small subset of the
spaces they belong to, which clever function approximation techniques might exploit. it is
the understanding of the interplay between id145, samples and function
approximation that is at the heart of designing, analyzing and applying rl algorithms.
the purpose of this book is to allow the reader to have a chance to peek into this beautiful
   eld. however, certainly we are not the    rst to set out to accomplish this goal. in 1996,
kaelbling et al. have written a nice, compact survey about the approaches and algorithms
available at the time (kaelbling et al., 1996). this was followed by the publication of the book
by bertsekas and tsitsiklis (1996), which detailed the theoretical foundations. a few years
later sutton and barto, the    fathers    of rl, published their book, where they presented their
ideas on rl in a very clear and accessible manner (sutton and barto, 1998). a more recent
and comprehensive overview of the tools and techniques of id145/optimal
control is given in the two-volume book by bertsekas (2007a,b) which devotes one chapter
to rl methods.1 at times, when a    eld is rapidly developing, books can get out of date
pretty quickly. in fact, to keep up with the growing body of new results, bertsekas maintains
an online version of his chapter 6 of volume ii of his book, which, at the time of writing
this survey counted as much as 160 pages (bertsekas, 2010). other recent books on the
subject include the book of gosavi (2003) who devotes 60 pages to id23
algorithms in chapter 9, concentrating on average cost problems, or that of cao (2007) who
focuses on id189. powell (2007) presents the algorithms and ideas from an
operations research perspective and emphasizes methods that are capable of handling large

1in this book, rl is called neuro-id145 or approximate id145. the
term neuro-id145 stems from the fact that, in many cases, rl algorithms are used with
arti   cial neural networks.

4

control spaces, chang et al. (2008) focuses on adaptive sampling (i.e., simulation-based
performance optimization), while the center of the recent book by busoniu et al. (2010) is
function approximation.
thus, by no means do rl researchers lack a good body of literature. however, what seems
to be missing is a self-contained and yet relatively short summary that can help newcomers
to the    eld to develop a good sense of the state of the art, as well as existing researchers to
broaden their overview of the    eld, an article, similar to that of kaelbling et al. (1996), but
with an updated contents. to    ll this gap is the very purpose of this short book.
having the goal of keeping the text short, we had to make a few, hopefully, not too trou-
bling compromises. the    rst compromise we made was to present results only for the total
expected discounted reward criterion. this choice is motivated by that this is the criterion
that is both widely used and the easiest to deal with mathematically. the next compro-
mise is that the background on mdps and id145 is kept ultra-compact
(although an appendix is added that explains these basic results). apart from these, the
book aims to cover a bit of all aspects of rl, up to the level that the reader should be
able to understand the whats and hows, as well as to implement the algorithms presented.
naturally, we still had to be selective in what we present. here, the decision was to focus
on the basic algorithms, ideas, as well as the available theory. special attention was paid to
describing the choices of the user, as well as the tradeo   s that come with these. we tried
to be impartial as much as possible, but some personal bias, as usual, surely remained. the
pseudocode of almost twenty algorithms was included, hoping that this will make it easier
for the practically inclined reader to implement the algorithms described.
the target audience is advanced undergaduate and graduate students, as well as researchers
and practitioners who want to get a good overview of the state of the art in rl quickly.
researchers who are already working on rl might also enjoy reading about parts of the rl
literature that they are not so familiar with, thus broadening their perspective on rl. the
reader is assumed to be familiar with the basics of id202, calculus, and id203
theory. in particular, we assume that the reader is familiar with the concepts of random
variables, conditional expectations, and markov chains.
it is helpful, but not necessary,
for the reader to be familiar with statistical learning theory, as the essential concepts will
be explained as needed. in some parts of the book, knowledge of regression techniques of
machine learning will be useful.
this book has three parts. in the    rst part, in section 2, we provide the necessary back-
ground.
it is here where the notation is introduced, followed by a short overview of the
theory of id100 and the description of the basic id145
algorithms. readers familiar with mdps and id145 should skim through
this part to familiarize themselves with the notation used. readers, who are less familiar

5

with mdps, must spend enough time here before moving on because the rest of the book
builds heavily on the results and ideas presented here.
the remaining two parts are devoted to the two basic rl problems (cf. figure 2), one part
devoted to each.
in section 3, the problem of learning to predict values associated with
states is studied. we start by explaining the basic ideas for the so-called tabular case when
the mdp is small enough so that one can store one value per state in an array allocated in
a computer   s main memory. the    rst algorithm explained is td(  ), which can be viewed
as the learning analogue to value iteration from id145. after this, we
consider the more challenging situation when there are more states than what    ts into a
computer   s memory. clearly, in this case, one must compress the table representing the
values. abstractly, this can be done by relying on an appropriate function approximation
method. first, we describe how td(  ) can be used in this situation. this is followed by the
description of some new gradient based methods (gtd2 and tdc), which can be viewed
as improved versions of td(  ) in that they avoid some of the convergence di   culties that
td(  ) faces. we then discuss least-squares methods (in particular, lstd(  ) and   -lspe)
and compare them to the incremental methods described earlier. finally, we describe choices
available for implementing function approximation and the tradeo   s that these choices come
with.
the second part (section 4) is devoted to algorithms that are developed for control learning.
first, we describe methods whose goal is optimizing online performance.
in particular,
we describe the    optimism in the face of uncertainty    principle and methods that explore
their environment based on this principle. state of the art algorithms are given both for
bandit problems and mdps. the message here is that clever exploration methods make
a large di   erence, but more work is needed to scale up the available methods to large
problems. the rest of this section is devoted to methods that aim at developing methods
that can be used in large-scale applications. as learning in large-scale mdps is signi   cantly
more di   cult than learning when the mdp is small, the goal of learning is relaxed to
learning a good enough policy in the limit. first, direct methods are discussed which aim at
estimating the optimal action-values directly. these can be viewed as the learning analogue
of value iteration of id145. this is followed by the description of actor-
critic methods, which can be thought of as the counterpart of the policy iteration algorithm
of id145. both methods based on direct policy improvement and policy
gradient (i.e., which use parametric policy classes) are presented.
the book is concluded in section 5, which lists some topics for further exploration.

6

figure 2: types of id23 problems and approaches.

2 id100

the purpose of this section is to introduce the notation that will be used in the subsequent
parts and the most essential facts that we will need from the theory of markov decision
processes (mdps) in the rest of the book. readers familiar with mdps should skim through
this section to familiarize themselves with the notation. readers unfamiliar with mdps are
suggested to spend enough time with this section to understand the details. proofs of most
of the results (with some simpli   cations) are included in appendix a. the reader who is
interested in learning more about mdps is suggested to consult one of the many excellent
books on the subject, such as the books of bertsekas and shreve (1978), puterman (1994),
or the two-volume book by bertsekas (2007a,b).

product of two    nite-dimensional vectors, u, v     rd is (cid:104)u, v(cid:105) =(cid:80)d

2.1 preliminaries
we use n to denote the set of natural numbers: n = {0, 1, 2, . . .}, while r denotes the set
of reals. by a vector v (unless it is transposed, v(cid:62)), we mean a column vector. the inner
i=1 uivi. the resulting 2-
norm is (cid:107)u(cid:107)2 = (cid:104)u, u(cid:105). the maximum norm for vectors is de   ned by (cid:107)u(cid:107)    = maxi=1,...,d |ui|,
while for a function f : x     r, (cid:107)    (cid:107)    is de   ned by (cid:107)f(cid:107)    = supx   x |f (x)|. a mapping
t between the metric spaces (m1, d1), (m2, d2) is called lipschitz with modulus l     r if
for any a, b     m1, d2(t (a), t (b))     l d1(a, b). if t is lipschitz with a modulus l     1, it
is called a non-expansion.
if l < 1, the mapping is called a contraction. the indicator
function of event s will be denoted by i{s} (i.e., i{s} = 1 if s holds and i{s} = 0, otherwise).
   
      v shall denote the partial derivative of v with respect to   , which is a
if v = v(  , x),
d-dimensional row vector if        rd. the total derivative of some expression v with respect
d   v)(cid:62).
to    will be denoted by d
if p is a distribution or a id203 measure, then x     p means that x is a random
variable drawn from p .

d   v (and will be treated as a row vector). further,      v = ( d

7

!"#$%&'%()*+,-#.%'#"+'%()!(,%&/.%'#"+'%()!(,%&/.0#+"&12()'"(,2.2 id100

for ease of exposition, we restrict our attention to countable mdps and the discounted total
expected reward criterion. however, under some technical conditions, the results extend to
continuous state-action mdps, too. this also holds true for the results presented in later
parts of this book.
a countable mdp is de   ned as a triplet m = (x ,a,p0), where x is the countable non-
empty set of states, a is the countable non-empty set of actions. the transition id203
kernel p0 assigns to each state-action pair (x, a)     x   a a id203 measure over x    r,
which we shall denote by p0(  |x, a). the semantics of p0 is the following: for u     x    r,
p0(u|x, a) gives the id203 that the next state and the associated reward belongs to the
set u provided that the current state is x and the action taken is a.2 we also    x a discount
factor 0            1 whose role will become clear soon.
the transition id203 kernel gives rise to the state transition id203 kernel, p, which,
for any (x, a, y)     x    a    x triplet gives the id203 of moving from state x to some
other state y provided that action a was chosen in state x:

p(x, a, y) = p0({y}    r| x, a).

in addition to p, p0 also gives rise to the immediate reward function r : x    a     r,
which gives the expected immediate reward received when action a is chosen in state x: if
(y(x,a), r(x,a))     p0(  | x, a), then

r(x, a) = e(cid:2)r(x,a)

(cid:3) .

in what follows, we shall assume that the rewards are bounded by some quantity r > 0:
for any (x, a)     x    a, |r(x,a)|     r almost surely.3
it is immediate that if the random
rewards are bounded by r then (cid:107)r(cid:107)    = sup(x,a)   x  a |r(x, a)|     r also holds. an mdp is
called    nite if both x and a are    nite.
id100 are a tool for modeling sequential decision-making problems
where a decision maker interacts with a system in a sequential fashion. given an mdp m,
this interaction happens as follows: let t     n denote the current time (or stage), let xt     x
2the id203 p0(u|x, a) is de   ned only when u is a borel-measurable set. borel-measurability is a
technical notion whose purpose is to prevent some pathologies. the collection of borel-measurable subsets
of x    r include practically all    interesting    subsets x    r. in particular, they include subsets of the form
{x}    [a, b] and subsets which can be obtained from such subsets by taking their complement, or the union
(intersection) of at most countable collections of such sets in a recursive fashion.

3   almost surely    means the same as    with id203 one    and is used to refer to the fact that the
statement concerned holds everywhere on the id203 space with the exception of a set of events with
measure zero.

8

and at     a denote the random state of the system and the action chosen by the decision
maker at time t, respectively. once the action is selected, it is sent to the system, which
makes a transition:

(xt+1, rt+1)     p0(  | xt, at).

(1)
in particular, xt+1 is random and p (xt+1 = y|xt = x, at = a) = p(x, a, y) holds for any
x, y     x , a     a. further, e [rt+1|xt, at] = r(xt, at). the decision maker then observes
the next state xt+1 and reward rt+1, chooses a new action at+1     a and the process is
repeated. the goal of the decision maker is to come up with a way of choosing the actions
so as to maximize the expected total discounted reward.
the decision maker can select its actions at any stage based on the observed history. a rule
describing the way the actions are selected is called a behavior. a behavior of the decision
maker and some initial random state x0 together de   ne a random state-action-reward se-
quence ((xt, at, rt+1); t     0), where (xt+1, rt+1) is connected to (xt, at) by (1) and at is the
action prescribed by the behavior based on the history x0, a0, r1, . . . , xt   1, at   1, rt, xt.4
the return underlying a behavior is de   ned as the total discounted sum of the rewards
incurred:

   (cid:88)

r =

  trt+1.

t=0

thus, if    < 1 then rewards far in the future worth exponentially less than the reward
received at the    rst stage. an mdp when the return is de   ned by this formula is called a
discounted reward mdp. when    = 1, the mdp is called undiscounted.
the goal of the decision-maker is to choose a behavior that maximizes the expected return,
irrespectively of how the process is started. such a maximizing behavior is said to be optimal.

example 1 (inventory control with lost sales): consider the problem of day-to-day control
of an inventory of a    xed maximum size in the face of uncertain demand: every evening,
the decision maker must decide about the quantity to be ordered for the next day. in the
morning, the ordered quantity arrives with which the inventory is    lled up. during the day,
some stochastic demand is realized, where the demands are independent with a common    xed
distribution, see figure 3. the goal of the inventory manager is to manage the inventory so
as to maximize the present monetary value of the expected total future income.
the payo    at time step t is determined as follows: the cost associated with purchasing at
items is ki{at>0} + cat. thus, there is a    xed entry cost k of ordering nonzero items and
each item must be purchased at a    xed price c. here k, c > 0. in addition, there is a cost of
holding an inventory of size x > 0. in the simplest case, this cost is proportional to the size

4mathematically, a behavior is an in   nite sequence of id203 kernels   0,   1, . . . ,   t, . . ., where
  t =

the action space a:

to a id203 distribution over

  t maps histories of
  t(  |x0, a0, r0, . . . , xt   1, at   1, rt   1, xt).

length t

9

of the inventory with proportionality factor h > 0. finally, upon selling z units the manager
is paid the monetary amount of p z, where p > 0. in order to make the problem interesting,
we must have p > h, otherwise there is no incentive to order new items.
this problem can be represented as an mdp as follows: let the state xt on day t     0 be the
size of the inventory in the evening of that day. thus, x = {0, 1, . . . , m}, where m     n is
the maximum inventory size. the action at gives the number of items ordered in the evening
of day t. thus, we can choose a = {0, 1, . . . , m} since there is no need to consider orders
larger than the inventory size. given xt and at, the size of the next inventory is given by

xt+1 = ((xt + at)     m     dt+1)+,

(2)

where a     b is a shorthand notation for the minimum of the numbers a, b, (a)+ = a     0 =
max(a, 0) is the positive part of a, and dt+1     n is the demand on the (t + 1)th day.
by assumption, (dt; t > 0) is a sequence of independent and identically distributed (i.i.d.)
integer-valued random variables. the revenue made on day t + 1 is
rt+1 =    k i{at>0}     c ((xt + at)     m     xt)+

    h xt

+ p ((xt + at)     m     xt+1)+.

equations (2)   (3) can be written in the compact form

(xt+1, rt+1) = f (xt, at, dt+1),
with an appropriately chosen function f . then, p0 is given by

   (cid:88)

p0(u | x, a) = p (f (x, a, d)     u ) =

i{f (x,a,d)   u} pd(d).

d=0

here pd(  ) is the id203 mass function of the random demands and d     pd(  ). this
   nishes the de   nition of the mdp underlying the inventory optimization problem.

inventory control is just one of the many operations research problems that give rise to
an mdp. other problems include optimizing transportation systems, optimizing schedules
or production. mdps arise naturally in many engineering optimal control problems, too,
such as the optimal control of chemical, electronic or mechanical systems (the latter class
includes the problem of controlling robots). quite a few id205 problems can
also be represented as mdps (e.g., optimal coding, optimizing channel allocation, or sensor
networks). another important class of problems comes from    nance. these include, amongst
others, optimal portfolio management and option pricing.

10

(3)

(4)

figure 3: illustration of the inventory management problem

in the case of the inventory control problem, the mdp was conveniently speci   ed by a
transition function f (cf., (4)). in fact, transition functions are as powerful as transition
kernels: any mdp gives rise to some transition function f and any transition function f
gives rise to some mdp.
in some problems, not all actions are meaningful in all states. for example, ordering more
items than what one has room for in the inventory does not make much sense. however,
such meaningless actions (or forbidden actions) can always be remapped to other actions,
just like it was done above.
in some cases, this is unnatural and leads to a convoluted
dynamics. then, it might be better to introduce an additional mapping which assigns the
set of admissible actions to each state.
in some mdps, some states are impossible to leave: if x is such a state, xt+s = x holds
almost surely for any s     1 provided that xt = x, no matter what actions are selected
after time t. by convention, we will assume that no reward is incurred in such terminal
or absorbing states. an mdp with such states is called episodic. an episode then is the
(generally random) time period from the beginning of time until a terminal state is reached.
in an episodic mdp, we often consider undiscounted rewards, i.e., when    = 1.
example 2 (gambling): a gambler enters a game whereby she may stake any fraction at    
[0, 1] of her current wealth xt     0. she wins her stake back and as much more with id203
p     [0, 1], while she loses her stake with id203 1     p. thus, the fortune of the gambler
evolves according to

xt+1 = (1 + st+1at)xt.

here (st; t     1) is a sequence of independent random variables taking values in {   1, +1}
with p (st+1 = 1) = p. the goal of the gambler is to maximize the id203 that her wealth
reaches an a priori given value w    > 0. it is assumed that the initial wealth is in [0, w   ].
this problem can be represented as an episodic mdp, where the state space is x = [0, w   ]

11

19:007:0014:00and the action space is a = [0, 1].5 we de   ne

xt+1 = (1 + st+1at)xt     w   ,

(5)

when 0     xt < w    and make w    a terminal state: xt+1 = xt if xt = w   . the immediate
reward is zero as long as xt+1 < w    and is one when the state reaches w    for the    rst time:

         1, xt < w    and xt+1 = w   ;

0, otherwise.

rt+1 =

if we set the discount factor to one, the total reward along any trajectory will be one or
zero depending on whether the wealth reaches w   . thus, the expected total reward is just the
id203 that the gambler   s fortune reaches w   .
based on the two examples presented so far, the reader unfamiliar with mdps might believe
that all mdps come with handy    nite, one-dimensional state- and action-spaces. if only this
was true! in fact, in practical applications the state- and action-spaces are often very large,
multidimensional spaces. for example, in a robot control application, the dimensionality
of the state space can be 3   6 times the number of joints the robot has. an industrial
robot   s state space might easily be 12   20 dimensional, while the state space of a humanoid
robot might easily have 100 dimensions. in a real-world inventory control application, items
would have multiple types, the prices and costs would also change based on the state of
the    market   , whose state would thus also become part of the mdp   s state. hence, the
state space in any such practical application would be very large and very high dimensional.
the same holds for the action spaces. thus, working with large, multidimensional state- and
action-spaces should be considered the normal situation, while the examples presented in this
section with their one-dimensional, small state spaces should be viewed as the exceptions.

2.3 value functions

the obvious way of    nding an optimal behavior in some mdp is to list all behaviors and
then identify the ones that give the highest possible value for each initial state. since, in
general, there are too many behaviors, this plan is not viable. a better approach is based on
computing value functions. in this approach, one    rst computes the so-called optimal value
function, which then allows one to determine an optimal behavior with relative easiness.
the optimal value, v    (x), of state x     x gives the highest achievable expected return when
the process is started from state x. the function v     : x     r is called the optimal value
5hence, in this case the state and action spaces are continuous. notice that our de   nition of mdps is

general enough to encompass this case, too.

12

function. a behavior that achieves the optimal values in all states is optimal.
deterministic stationary policies represent a special class of behaviors, which, as we shall see
soon, play an important role in the theory of mdps. they are speci   ed by some mapping
  , which maps states to actions (i.e.,    : x     a). following    means that at any time t     0
the action at is selected using

at =   (xt).

(6)

more generally, a stochastic stationary policy (or just stationary policy)    maps states to
distributions over the action space. when referring to such a policy   , we shall use   (a|x)
to denote the id203 of action a being selected by    in state x. note that if a stationary
policy is followed in an mdp, i.e., if

at       (  | xt),

t     n,

the state process (xt; t     0) will be a (time-homogeneous) markov chain. we will use   stat
to denote the set of all stationary policies. for brevity, in what follows, we will often say
just    policy    instead of    stationary policy   , hoping that this will not cause confusion.
a stationary policy and an mdp induce what is called a markov reward processes (mrp): an
mrp is determined by the pair m = (x ,p0), where now p0 assigns a id203 measure
over x   r to each state. an mrp m gives rise to the stochastic process ((xt, rt+1); t     0),
where (xt+1, rt+1)     p0(  | xt). (note that (zt; t     0), zt = (xt, rt) is a time-homogeneous
markov process, where r0 is an arbitrary random variable, while ((xt, rt+1); t     0) is a
second-order markov process.) given a stationary policy    and the mdp m = (x ,a,p0),
the transition kernel of the mrp (x ,p   
0 (  | x) =

(cid:80)
a   a   (a|x)p0(  | x, a). an mrp is called    nite if its state space is    nite.

0 ) induced by    and m is de   ned using p   

let us now de   ne value functions underlying stationary policies.6 for this, let us    x some
policy          stat. the value function, v    : x     r, underlying    is de   ned by

(cid:34)    (cid:88)

t=0

(cid:35)

(cid:12)(cid:12)(cid:12) x0 = x

v   (x) = e

  trt+1

x     x ,

,

(7)

with the understanding (i) that the process (rt; t     1) is the    reward-part    of the process
((xt, at, rt+1); t     0) obtained when following policy    and (ii) x0 is selected at random
such that p (x0 = x) > 0 holds for all states x. this second condition makes the conditional
expectation in (7) well-de   ned for every state. if the initial state distribution satis   es this
condition, it has no in   uence on the de   nition of values.

6value functions can also be de   ned underlying any behavior analogously to the de   nition given below.

13

the value function underlying an mrp is de   ned the same way and is denoted by v :

(cid:34)    (cid:88)

t=0

(cid:35)

(cid:12)(cid:12)(cid:12) x0 = x

v (x) = e

  trt+1

x     x .

,

it will also be useful to de   ne the action-value function, q   : x    a     r, underlying a
policy          stat in an mdp: assume that the    rst action a0 is selected randomly such that
p (a0 = a) > 0 holds for all a     a, while for the subsequent stages of the decision process
the actions are chosen by following policy   . let ((xt, at, rt+1); t     0) be the resulting
stochastic process, where x0 is as in the de   nition of v   . then

(cid:34)    (cid:88)

t=0

(cid:12)(cid:12)(cid:12) x0 = x, a0 = a

(cid:35)

q  (x, a) = e

  trt+1

x     x , a     a.

,

similarly to v    (x), the optimal action-value q   (x, a) at the state-action pair (x, a) is de   ned
as the maximum of the expected return under the constraints that the process starts at state
x, and the    rst action chosen is a. the underlying function q    : x    a     r is called the
optimal action-value function.
the optimal value- and action-value functions are connected by the following equations:

v    (x) = sup
a   a

q   (x, a),

q   (x, a) = r(x, a) +   

(cid:88)

y   x

p(x, a, y)v    (y),

x     x ,
x     x , a     a.

in the class of mdps considered here, an optimal stationary policy always exists:

v    (x) = sup
       stat

v   (x),

x     x .

in fact, any policy          stat which satis   es the equality

  (a|x) q   (x, a) = v    (x)

(8)

(cid:88)

a   a

simultaneously for all states x     x is optimal. notice that in order (8) to hold,   (  |x)
must be concentrated on the set of actions that maximize q   (x,  ). in general, given some
action-value function, q : x    a     r, an action that maximizes q(x,  ) for some state x is
called greedy with respect to q in state x. a policy that chooses greedy actions only with
respect to q in all states is called greedy w.r.t. q.
thus, a greedy policy with respect to q    is optimal, i.e., the knowledge of q    alone is
su   cient for    nding an optimal policy. similarly, knowing v    , r and p also su   ces to act

14

optimally.
the next question is how to    nd v     or q   . let us start with the simpler question of how to
   nd the value function of a policy:
fact 1 (bellman equations for deterministic policies): fix an mdp m = (x ,a,p0), a
discount factor    and deterministic policy          stat. let r be the immediate reward function
of m. then v    satis   es

v   (x) = r(x,   (x)) +   

p(x,   (x), y)v   (y),

x     x .

(9)

this system of equations is called the bellman equation for v   . de   ne the bellman operator
underlying   , t    : rx     rx , by

(t   v )(x) = r(x,   (x)) +   

p(x,   (x), y)v (y),

x     x .

(cid:88)

y   x

(cid:88)

y   x

with the help of t   , equation (9) can be written in the compact form

t   v    = v   .

(10)

note that this is a linear system of equations in v    and t    is an a   ne linear operator. if
0 <    < 1 then t    is a maximum-norm contraction and the    xed-point equation t   v = v
has a unique solution.
when the state space x is    nite, say, it has d states, rx can be identi   ed with the d-
dimensional euclidean space and v     rx can be thought of as a d-dimensional vector: v    
rd. with this identi   cation, t   v can also be written as r   +   p   v with an appropriately
de   ned vector r       rd and matrix p        rd  d. in this case, (10) can be written in the
form

(11)
the above facts also hold true in mrps, where the bellman operator t : rx     rx is
de   ned by

r   +   p   v    = v   .

(t v )(x) = r(x) +   

p(x, y)v (y),

x     x .

the optimal value function is known to satisfy a certain    xed-point equation:

fact 2 (bellman optimality equations): the optimal value function satis   es the    xed-point
equation

r(x, a) +   

p(x, a, y)v    (y)

,

x     x .

(12)

(cid:40)

v    (x) = sup
a   a

(cid:41)

(cid:88)

y   x

(cid:88)

y   x

15

de   ne the bellman optimality operator operator, t     : rx     rx , by

(cid:40)

(cid:88)

y   x

(cid:41)

(t    v )(x) = sup
a   a

r(x, a) +   

p(x, a, y)v (y)

x     x .

,

(13)

note that this is a nonlinear operator due to the presence of sup. with the help of t    ,
equation (12) can be written compactly as

t    v     = v    .

if 0 <    < 1, then t     is a maximum-norm contraction, and the    xed-point equation t    v = v
has a unique solution.

in order to minimize clutter, in what follows we will write expressions like (t   v )(x) as
t   v (x), with the understanding that the application of operator t    takes precedence to the
applycation of the point evaluation operator,       (x)   .
the action-value functions underlying a policy (or an mrp) and the optimal action-value
function also satisfy some    xed-point equations similar to the previous ones:

fact 3 (bellman operators and fixed-point equations for action-value functions): with a
slight abuse of notation, de   ne t    : rx  a     rx  a and t     : rx  a     rx  a as follows:

t   q(x, a) = r(x, a) +   

t    q(x, a) = r(x, a) +   

p(x, a, y)q(y,   (y)),

(x, a)     x    a,

p(x, a, y) sup
a(cid:48)   a

q(y, a(cid:48)),

(x, a)     x    a.

(14)

(15)

(cid:88)
(cid:88)

y   x

y   x

note that t    is again a   ne linear, while t     is nonlinear. the operators t    and t     are
maximum-norm contractions. further, the action-value function of   , q  , satis   es t   q   =
q   and q   is the unique solution to this    xed-point equation. similarly, the optimal action-
value function, q   , satis   es t    q    = q    and q    is the unique solution to this    xed-point
equation.

2.4 id145 algorithms for solving mdps

the above facts provide the basis for the value- and policy-iteration algorithms.
value iteration generates a sequence of value functions

vk+1 = t    vk,

k     0,

16

where v0 is arbitrary. thanks to banach   s    xed-point theorem, (vk; k     0) converges to v    
at a geometric rate.
value iteration can also be used in conjunction with action-value functions; in which case,
it takes the form

qk+1 = t    qk,

k     0,

which again converges to q    at a geometric rate. the idea is that once vk (or qk) is close to
v     (resp., q   ), a policy that is greedy with respect to vk (resps., qk) will be close-to-optimal.
in particular, the following bound is known to hold: fix an action-value function q and let
   be a greedy policy w.r.t. q. then the value of policy    can be lower bounded as follows
(e.g., singh and yee, 1994, corollary 2):

v   (x)     v    (x)     2
1       

(cid:107)q     q   (cid:107)   ,

x     x .

(16)

policy iteration works as follows. fix an arbitrary initial policy   0. at iteration k > 0,
compute the action-value function underlying   k (this is called the policy evaluation step).
next, given q  k, de   ne   k+1 as a policy that is greedy with respect to q  k (this is called the
policy improvement step). after k iterations, policy iteration gives a policy not worse than
the policy that is greedy w.r.t. to the value function computed using k iterations of value
iteration if the two procedures are started with the same initial value function. however, the
computational cost of a single step in policy iteration is much higher (because of the policy
evaluation step) than that of one update in value iteration.

3 value prediction problems

in this section, we consider the problem of estimating the value function v underlying
some markov reward process (mrp). value prediction problems arise in a number of ways:
estimating the id203 of some future event, the expected time until some event occurs,
or the (action-)value function underlying some policy in an mdp are all value prediction
problems. speci   c applications are estimating the failure id203 of a large power grid
(frank et al., 2008) or estimating taxi-out times of    ights on busy airports (balakrishna
et al., 2008), just to mention two of the many possibilities.
since the value of a state is de   ned as the expectation of the random return when the
process is started from the given state, an obvious way of estimating this value is to compute
an average over multiple independent realizations started from the given state. this is an
instance of the so-called monte-carlo method. unfortunately, the variance of the returns can
be high, which means that the quality of the estimates will be poor. also, when interacting

17

with a system in a closed-loop fashion (i.e., when estimation happens while interacting with
the system), it might be impossible to reset the state of the system to some particular
state. in this case, the monte-carlo technique cannot be applied without introducing some
additional bias. temporal di   erence (td) learning (sutton, 1984, 1988), which is without
doubt one of the most signi   cant ideas in id23, is a method that can be
used to address these issues.

3.1 temporal di   erence learning in    nite state spaces

the unique feature of td learning is that it uses id64: predictions are used as
targets during the course of learning.
in this section, we    rst introduce the most basic
td algorithm and explain how id64 works. next, we compare td learning to
(vanilla) monte-carlo methods and argue that both of them have their own merits. finally,
we present the td(  ) algorithm that uni   es the two approaches. here we consider only the
case of small,    nite mrps, when the value-estimates of all the states can be stored in the
main memory of a computer in an array or table, which is known as the tabular case in
the id23 literature. extensions of the ideas presented here to large state
spaces, when a tabular representations is not feasible, will be described in the subsequent
sections.

3.1.1 tabular td(0)
fix some    nite markov reward process m. we wish to estimate the value function v
underlying m given a realization ((xt, rt+1); t     0) of m. let   vt(x) denote the estimate of
state x at time t (say,   v0     0). in the tth step td(0) performs the following calculations:

  t+1 = rt+1 +      vt(xt+1)       vt(xt),

  vt+1(x) =   vt(x) +   t   t+1 i{xt=x},

x     x .

(17)

here the step-size sequence (  t; t     0) consists of (small) nonnegative numbers chosen by
the user. algorithm 1 shows the pseudocode of this algorithm.
a closer inspection of the update equation reveals that the only value changed is the one
associated with xt, i.e., the state just visited (cf.
line 2 of the pseudocode). further,
when   t     1, the value of xt is moved towards the    target    rt+1 +      vt(xt+1). since the
target depends on the estimated value function, the algorithm uses id64. the term
   temporal di   erence    in the name of the algorithm comes from that   t+1 is de   ned as the

18

algorithm 1 the function implementing the tabular td(0) algorithm. this function must
be called after each transition.
function td0(x, r, y, v )
input: x is the last state, y is the next state, r is the immediate reward associated with
1:        r +       v [y ]     v [x]
2: v [x]     v [x] +         
3: return v

this transition, v is the array storing the current value estimates

di   erence between values of states corresponding to successive time steps. in particular,   t+1
is called a temporal di   erence error.
just like many other algorithms in id23, tabular td(0) is a stochastic
approximation (sa) algorithm. it is easy to see that if it converges, then it must converge
to a function   v such that the expected temporal di   erence given   v ,

f   v (x) def= e(cid:104)

rt+1 +      v (xt+1)       v (xt)

(cid:12)(cid:12)(cid:12) xt = x

(cid:105)

,

is zero for all states x, at least for all states that are sampled in   nitely often. a simple
calculation shows that f   v = t   v       v , where t is the bellman-operator underlying the
mrp considered. by fact 1, f   v = 0 has a unique solution, the value function v . thus, if
td(0) converges (and all states are sampled in   nitely often) then it must converge to v .
to study the algorithm   s convergence properties, for simplicity, assume that (xt; t     n) is
a stationary, ergodic markov chain.7 further, identify the approximate value functions   vt
with d-dimensional vectors as before (e.g.,   vt,i =   vt(xi), i = 1, . . . , d, where d = |x| and
x = {x1, . . . , xd}). then, assuming that the step-size sequence satis   es the robbins-monro
(rm) conditions,

   (cid:88)

   (cid:88)

  t =    ,

t < +   ,
  2

t=0

t=0

the sequence (   vt     rd; t     n) will track the trajectories of the ordinary di   erential equation
(ode)

(18)
where c = 1/d and v(t)     rd (e.g., borkar, 1998). borrowing the notation used in (11), the
above ode can be written as

  v(t) = c f (v(t)),

t     0,

  v = r + (  p     i)v.

note that this is a linear ode. since the eigenvalues of   p     i all lie in the open left half
complex plane, this ode is globally asymptotically stable. from this, using standard results
7remember that a markov chain (xt; t     n) is ergodic if it is irreducible, aperiodic and positive recurrent.

practically, this means that the law of large number holds for su   ciently regular functions of the chain.

19

of sa it follows that   vt converges almost surely to v .

on step-sizes since many of the algorithms that we will discuss use step-sizes, it is worth-
while spending some time on discussing their choice. a simple step-size sequence that satis   es
the above conditions is   t = c/t, with c > 0. more generally, any step-size sequence of the
form   t = ct      will work as long as 1/2 <        1. of these step-size sequences,    = 1 gives the
smallest step-sizes. asymptotically, this choice will be the best, but from the point of view of
the transient behavior of the algorithm, choosing    closer to 1/2 will work better (since with
this choice the step-sizes are bigger and thus the algorithm will make larger moves). it is
possible to do even better than this. in fact, a simple method, called iterate-averaging due to
polyak and juditsky (1992), is known to achieve the best possible asymptotic rate of conver-
gence. however, despite its appealing theoretical properties, iterate-averaging is rarely used
in practice. in fact, in practice people often use constant step-sizes, which clearly violates
the rm conditions. this choice is justi   ed based on two grounds: first, the algorithms are
often used in a non-stationary environment (i.e., the policy to be evaluated might change).
second, the algorithms are often used only in the small sample regime. (when a constant
step-size is used, the parameters converge in distribution. the variance of the limiting distri-
bution will be proportional to the step-size chosen.) there is also a great deal of work going
into developing methods that tune step-sizes automatically, see (sutton, 1992; schraudolph,
1999; george and powell, 2006) and the references therein. however, the jury is still out on
which of these methods is the best.
with a small change, the algorithm can also be used on an observation sequence of the form
((xt, rt+1, yt+1); t     0), where (xt; t     0) is an arbitrary ergodic markov chain over x ,
(yt+1, rt+1)     p0(  | xt). the change concerns the de   nition of temporal di   erences:

  t+1 = rt+1 +      v (yt+1)       v (xt).

then, with no extra conditions,   vt still converges almost surely to the value function un-
derlying the mrp (x ,p0). in particular, the distribution of the states (xt; t     0) does not
play a role here.
this is interesting for multiple reasons. for example, if the samples are generated using a
simulator, we may be able to control the distribution of the states (xt; t     0) independently
of the mrp. this might be useful to counterbalance any unevenness in the stationary dis-
tribution underlying the markov kernel p. another use is to learn about some target policy
in an mdp while following some other policy, often called the behavior policy. assume for
simplicity that the target policy is deterministic. then ((xt, rt+1, yt+1), t     0) could be
obtained by skipping all those state-action-reward-next state quadruples in the trajectory

20

generated by using the behavior policy, where the action taken does not match the action
that would have been taken in the given state by the target policy, while keeping the rest.
this technique might allow one to learn about multiple policies at the same time (more
generally, about multiple long-term prediction problems). when learning about one policy,
while following another is called o   -policy learning. because of this, we shall also call learn-
ing based on triplets ((xt, rt+1, yt+1); t     0) when yt+1 (cid:54)= xt+1 o   -policy learning. a third,
technical use is when the goal is to apply the algorithm to an episodic problem. in this case,
the triplets (xt, rt+1, yt+1) are chosen as follows: first, yt+1 is sampled from the transition
kernel p(x,  ). if yt+1 is not a terminal state, we let xt+1 = yt+1; otherwise, xt+1     p0(  ),
where p0 is a user-chosen distribution over x .
in other words, when a terminal state is
reached, the process is restarted from the initial state distribution p0. the period between
the time of a restart from p0 and reaching a terminal state is called an episode (hence
the name of episodic problems). this way of generating a sample shall be called continual
sampling with restarts from p0.
   
being a standard linear sa method, the rate of convergence of tabular td(0) will be of
t) (consult the paper by tadi  c (2004) and the references therein for
the usual order o(1/
precise results). however, the constant factor in the rate will be largely in   uenced by the
choice of the step-size sequence, the properties of the kernel p0 and the value of   .

3.1.2 every-visit monte-carlo

as mentioned before, one can also estimate the value of a state by computing sample means,
giving rise to the so-called every visit monte-carlo method. here we de   ne more precisely
what we mean by this and compare the resulting method to td(0).
to    rm up the ideas, consider some episodic problem (otherwise, it is impossible to    nitely
compute the return of a given state since the trajectories are in   nitely long). let the
underlying mrp be m = (x ,p0) and let ((xt, rt+1, yt+1); t     0) be generated by continual
sampling in m with restarts from some distribution p0 de   ned over x . let (tk; k     0) be
the sequence of times when an episode starts (thus, for each k, xtk is sampled from p0).
for a given time t, let k(t) be the unique episode index such that t     [tk, tk+1). let

rt =

  s   trs+1

(19)

s=t

denote the return from time t on until the end of the episode. clearly, v (x) = e [rt|xt = x],
for any state x such that p (xt = x) > 0. hence, a sensible way of updating the estimates
is to use

  vt+1(x) =   vt(x) +   t(rt       vt(x)) i{xt=x},

x     x .

21

tk(t)+1   1(cid:88)

algorithm 2 the function that implements the every-visit monte-carlo algorithm to es-
timate value functions in episodic mdps. this routine must be called at the end of each
episode with the state-reward sequence collected during the episode. note that the algorithm
as shown here has linear time- and space-complexity in the length of the episodes.
function everyvisitmc(x0, r1, x1, r2, . . . , xt   1, rt , v )
input: xt is the state at time t, rt+1 is the reward associated with the tth transition, t is
1: sum     0
2: for t     t     1 downto 0 do
sum     rt+1 +       sum
target[xt]     sum
v [xt]     v [xt] +       (target[xt]     v [xt])

the length of the episode, v is the array storing the current value function estimate

3:
4:
5:
6: end for
7: return v

monte-carlo methods such as the above one, since they use multi-step predictions of the
value (cf. equation (19)), are called multi-step methods. the pseudo-code of this update-
rule is shown as algorithm 2.
this algorithm is again an instance of stochastic approximation. as such, its behavior is
governed by the ode   v(t) = v     v(t). since the unique globally asymptotically stable
equilibrium of this ode is v ,   vt again converges to v almost surely. since both algorithms
achieve the same goal, one may wonder which algorithm is better.

e(cid:104)   vt(3)
(cid:105)

td(0) or monte-carlo? first, let us consider an example when td(0) converges faster.
consider the undiscounted episodic mrp shown on figure 4. the initial states are either 1
or 2. with high id203 the process starts at state 1, while the process starts at state
2 less frequently. consider now how td(0) will behave at state 2. by the time state 2 is
visited the kth time, on the average state 3 has already been visited 10 k times. assume that
  t = 1/(t + 1). at state 3 the td(0) update reduces to averaging the bernoulli rewards
incurred upon leaving state 3. at the kth visit of state 2, var

(cid:105)     1/(10 k) (clearly,

(cid:104)   vt(3)

= v (3) = 0.5). thus, the target of the update of state 2 will be an estimate of
the true value of state 2 with accuracy increasing with k. now, consider the monte-carlo
method. the monte-carlo method ignores the estimate of the value of state 3 and uses the
bernoulli rewards directly. in particular, var [rt|xt = 2] = 0.25, i.e., the variance of the
target does not change with time. on this example, this makes the monte-carlo method
slower to converge, showing that sometimes id64 might indeed help.
to see an example when id64 is not helpful, imagine that the problem is modi   ed so
that the reward associated with the transition from state 3 to state 4 is made deterministically

22

figure 4: an episodic markov reward process. in this example, all transitions are determin-
istic. the reward is zero, except when transitioning from state 3 to state 4, when it is given
by a bernoulli random variable with parameter 0.5. state 4 is a terminal state. when the
process reaches the terminal state, it is reset to start at state 1 or 2. the id203 of
starting at state 1 is 0.9, while the id203 of starting at state 2 is 0.1.

equal to one. in this case, the monte-carlo method becomes faster since rt = 1 is the true
target value, while for the value of state 2 to get close to its true value, td(0) has to wait
until the estimate of the value at state 3 becomes close to its true value. this slows down
the convergence of td(0). in fact, one can imagine a longer chain of states, where state i + 1
follows state i, for i     {1, . . . , n} and the only time a nonzero reward is incurred is when
transitioning from state n     1 to state n . in this example, the rate of convergence of the
monte-carlo method is not impacted by the value of n , while td(0) would get slower with
n increasing (for an informal argument, see sutton, 1988; for a formal one with exact rates,
see beleznay et al., 1999).

3.1.3 td(  ): unifying monte-carlo and td(0)

the previous examples show that both monte-carlo and td(0) have their own merits.
interestingly, there is a way to unify these approaches. this is achieved by the so-called
td(  ) family of methods (sutton, 1984, 1988). here,        [0, 1] is a parameter that allows
one to interpolate between the monte-carlo and td(0) updates:    = 0 gives td(0) (hence
the name of td(0)), while    = 1, i.e., td(1) is equivalent to a monte-carlo method. in
essence, given some    > 0, the targets in the td(  ) update are given as some mixture of

23

  00334422110p0(1)=0:9p0(2)=0:1r  ber(0:5)the multi-step return predictions

t+k(cid:88)

rt:k =

  s   trs+1 +   k+1   vt(xt+k+1),

s=t

where the mixing coe   cients are the exponential weights (1       )  k, k     0. thus, for    > 0
td(  ) will be a multi-step method. the algorithm is made incremental by the introduction
of the so-called eligibility traces.
in fact, the eligibility traces can be de   ned in multiple ways and hence td(  ) exists in corre-
spondingly many multiple forms. the update rule of td(  ) with the so-called accumulating
traces is as follows:

  t+1 = rt+1 +      vt(xt+1)       vt(xt),

zt+1(x) = i{x=xt} +      zt(x),
  vt+1(x) =   vt(x) +   t   t+1 zt+1(x),

z0(x) = 0,

x     x .

here zt(x) is the eligibility trace of state x. the rationale of the name is that the value of
zt(x) modulates the in   uence of the td error on the update of the value stored at state x.
in another variant of the algorithm, the eligibility traces are updated according to

zt+1(x) = max(i{x=xt},      zt(x)),

x     x .

to td(0) (since lim     0+(1       )(cid:80)

this is called the replacing traces update. in these updates, the trace-decay parameter   
controls the amount of id64: when    = 0 the above algorithms become identical
k   0   krt:k = rt:0 = rt+1 +      vt(xt+1)). when    = 1,
we get the td(1) algorithm, which with accumulating traces will simulate the previously
described every-visit monte-carlo algorithm in episodic problems. (for an exact equivalence,
one needs to assume that the value updates happen only at the end of trajectories, up to
which point the updates are just accumulated. the statement then follows because the
discounted sum of temporal di   erences along a trajectory from a start state to a terminal
state telescopes and gives the di   erence between the return along the trajectory and the
value estimate of at the start state.) replacing traces and    = 1 correspond to a version
of the monte-carlo algorithm where a state is updated only when it is encountered for
the    rst time in a trajectory. the corresponding algorithm is called    rst-visit monte-carlo
method. the formal correspondence between the    rst-visit monte-carlo method and td(1)
with replacing traces is known to hold for the undiscounted case only (singh and sutton,

24

algorithm 3 the function that implements the tabular td(  ) algorithm with replacing
traces. this function must be called after each transition.
function tdlambda(x, r, y, v, z)
input: x is the last state, y is the next state, r is the immediate reward associated with
this transition, v is the array storing the current value function estimate, z is the array
storing the eligibility traces
1:        r +       v [y ]     v [x]
2: for all x     x do

z[x]                 z[x]
if x = x then

z[x]     1

3:
4:
5:
6:
7:
8: end for
9: return (v, z)

end if
v [x]     v [x] +             z[x]

1996). algorithm 3 gives the pseudocode corresponding to the variant with replacing traces.
in practice, the best value of    is determined by trial and error.
in fact, the value of   
can be changed even during the algorithm, without impacting convergence. this holds for
a wide range of other possible eligibility trace updates (for precise conditions, see bertsekas
and tsitsiklis, 1996, section 5.3.3 and 5.3.6). the replacing traces version of the algorithm
is believed to perform better in practice (for some examples when this happens, consult
sutton and barto, 1998, section 7.8). it has been noted that    > 0 is helpful when the
learner has only partial knowledge of the state, or (in the related situation) when function
approximation is used to approximate the value functions in a large state space     the topic
of the next section.
in summary, td(  ) allows one to estimate value functions in mrps. it generalizes monte-
carlo methods, it can be used in non-episodic problems, and it allows for id64.
further, by appropriately tuning    it can converge signi   cantly faster than monte-carlo
methods or td(0).

3.2 algorithms for large state spaces

when the state space is large (or in   nite), it is not feasible to keep a separate value for each
state in the memory. in such cases, we often seek an estimate of the values in the form

v  (x) =   (cid:62)  (x),

x     x ,

where        rd is a vector of parameters and    : x     rd is a mapping of states to d-
dimensional vectors. for state x, the components   i(x) of the vector   (x) are called the

25

features of state x and    is called a feature extraction method. the individual functions
  i : x     r de   ning the components of    are called basis functions.

examples of function approximation methods given access to the state, the features
(or basis functions) can be constructed in a great many di   erent ways. if x     r (i.e., x     r)
one may use a polynomial, fourier, or wavelet basis up to some order. for example, in
the case of a polynomial basis,   (x) = (1, x, x2, . . . , xd   1)(cid:62), or, an orthogonal system of
polynomials if a suitable measure (such as the stationary distribution) over the states is
available. this latter choice may help to increase the convergence speed of the incremental
algorithms that we will discuss soon.
in the case of multidimensional state spaces, the tensor product construction is a commonly
used way to construct features given features of the states    individual components. the
tensor product construction works as follows: imagine that x     x1    x2    . . .    xk. let
  (i) : xi     rdi be a feature extractor de   ned for the ith state component. the tensor
product    =   (1)     . . .       (k) feature extractor will have d = d1d2 . . . dk components, which
can be conveniently indexed using multi-indices of the form (i1, . . . , ik), 1     ij     dj, j =
(xk). when x     rk, one particularly
1, . . . , k. then   (i1,...,ik)(x) =   (1)
i1
popular choice is to use radial basis function (rbf) networks, when   (i)(xi) = (g(|xi    
i     r (j = 1, . . . , di) is    xed by the user and g is
x(1)
i
a suitable function. a typical choice for g is g(z) = exp(      z2 ) where    > 0 is a scale
parameter. the tensor product construct in this cases places gaussians at points of a
regular grid and the ith basis function becomes

|), . . . , g(|xi     x(di)

|))(cid:62). here x(j)

(x2) . . .   (k)
ik

(x1)  (2)
i2

i

  i(x) = exp(     (cid:107)x     x(i)(cid:107)2),

where x(i)     x now denotes a point on a regular d1    . . .    dk grid. a related method is to
use kernel smoothing:

(cid:80)d
(cid:80)d
i=1   i g((cid:107)x     x(i)(cid:107))
j=1 g((cid:107)x     x(j)(cid:107))

d(cid:88)

=

  i

(cid:80)d
g((cid:107)x     x(i)(cid:107))
j=1 g((cid:107)x     x(j)(cid:107))

v  (x) =

.

(20)

more generally, one may use v  (x) =(cid:80)d

i=1

i=1   isi(x), where si     0 and(cid:80)d

i=1 si(x)     1 holds
for any x     x .
in this case, we say that v   is an averager. averagers are important
in id23 because the mapping    (cid:55)    v   is a non-expansion in the max-
norm, which makes them    well-behaved    when used together with approximate dynamic
programming.
an alternative to the above is to use binary features, i.e., when   (x)     {0, 1}d. binary
features may be advantageous from a computational point of view: when   (x)     {0, 1}d

26

then v  (x) = (cid:80)

i:  i(x)=1   i. thus, the value of state x can be computed at the cost of s
additions if   (x) is s-sparse (i.e., if only s elements of   (x) are non-zero), provided that
there is a direct way of computing the index of the non-zero components of the feature
vector.
this is the case when the state aggregation is used to de   ne the features.
in this case,
the coordinate functions of    (the individual features) correspond to indicators of non-
overlapping regions of the state space x whose union covers x (i.e., the regions form a
partition of the state space). clearly, in this case,   (cid:62)  (x) will be constant over the individual
regions, thus state aggregation essentially    discretizes    the state space. a state aggregator
function approximator is also an averager.
another choice that leads to binary features is tile coding (originally called cmac, albus,
1971, 1981). in the simplest version of tile coding, the basis functions of    correspond to
indicator functions of multiple shifted partitions (tilings) of the state space: if s tilings are
used,    will be s-sparse. to make tile coding an e   ective function approximation method,
the o   sets of the tilings corresponding to di   erent dimensions should be di   erent.

the curse of dimensionality the issue with tensor product constructions, state aggre-
gation and straightforward tile coding is that when the state space is high dimensional they
quickly become intractable: for example, a tiling of [0, 1]d with cubical regions with side-
lengths of    gives rise to d =      d-dimensional feature- and parameter-vectors. if    = 1/2
and d = 100, we get the enormous number d     1030. this is problematic since state-
representations with hundreds of dimensions are common in applications. at this stage,
one may wonder if it is possible at all to successfully deal with applications when the state
lives in a high dimensional space. what often comes at rescue is that the actual problem
complexity might be much lower than what is predicted by merely counting the number of
dimensions of the state variable (although, there is no guarantee that this happens). to see
why sometimes this holds, note that the same problem can have multiple representations,
some of which may come with low-dimensional state variables, some with high.
since,
in many cases, the state-representation is chosen by the user in a conservative fashion, it
may happen that in the chosen representation many of the state variables are irrelevant.
it may also happen that the states that are actually encountered lie on (or lie close to) a
low-dimensional submanifold of the chosen high dimensional    state-space   .
to illustrate this, imagine an industrial robot arm with say 3 joints and 6 degrees of freedom.
the intrinsic dimensionality of the state is then 12, twice the number of degrees of freedom
of the arm since the dynamics is second-order. one (approximate) state representation
is to take high resolution camera images of the arm in close succession (to account for the
dynamics) from multiple angles (to account for occlusions). the dimensionality of the chosen

27

state representation will easily be in the range of millions, yet the intrinsic dimensionality
will still be 12. in fact, the more cameras we have, the higher the dimensionality will be.
a simple-minded approach, which aims for minimizing the dimensionality would suggest to
use as few cameras as possible. but more information should not hurt! therefore, the quest
should be for clever algorithms and function approximation methods that can deal with
high-dimensional but low complexity problems.
possibilities include using strip-like tilings combined with hash functions, interpolators that
use low-discrepancy grids (lemieux, 2009, chapter 5 and 6), or random projections (das-
gupta and freund, 2008). nonlinear function approximation methods (examples of which
include neural networks with sigmoidal transfer functions in the hidden layers or rbf net-
works where the centers are also considered as parameters) and nonparametric techniques
also hold great promise.

nonparametric methods
in a nonparametric method, the user does not start with a
   xed    nite-dimensional representation, such as in the previous examples, but allows for the
representation to grow and change as needed. for example, in a k-nearest neighbor method
for regression, given the data dn = [(x1, v1), . . . , (xn, vn)], where xi     rk, vi     r, the value
at location x is predicted using

n(cid:88)

i=1

v (k)d (x) =

vi

k (k)d (x, xi)

k

,

zero otherwise. note that k =(cid:80)n

where k (k)d (x, x(cid:48)) is one when x(cid:48) is closer to x than the kth closest neighbor of x in d and is
j=1 k (k)d (x, xj). replacing k in the above expression with
this sum and replacing k (k)d (x,  ) with some other data based kernel kd (e.g., a gaussian
centered around x with standard deviation proportional to the distance to the kth nearest
neighbor), we arrive at nonparametric kernel smoothing:

n(cid:88)

i=1

(cid:80)n

kd(x, xi)
j=1 kd(x, xj)

,

v (k)d (x) =

vi

which should be compared to its parametric counterpart (20). other examples include meth-
ods that work by    nding an appropriate function in some large (in   nite dimensional) function
space that    ts an empirical error. the function space is usually a reproducing kernel hilbert
space which is a convenient choice from the point of view of optimization. in special cases,
we get spline smoothers (wahba, 2003) and gaussian process regression (rasmussen and
williams, 2005). another idea is to split the input space recursively into    ner regions using
some heuristic criterion and then predict with some simple method the values in the leafs,

28

leading to tree-based methods. the border between parametric and nonparametric methods
is blurry. for example, a linear predictor when the number of basis functions is allowed to
change (i.e., when new basis functions are introduced as needed) becomes a nonparametric
method. thus, when one experiments with di   erent feature extraction methods, from the
point of view of the overall tuning process, we can say that one really uses a nonparametric
technique. in fact, if we take this viewpoint, it follows that in practice    true    parametric
methods are rarely used if they are used at all.
the advantage of nonparametric methods is their inherent    exibility. however, this comes
usually at the price of increased computational complexity. therefore, when using non-
parametric methods, e   cient implementations are important (e.g., one should use k-d trees
when implementing nearest neighbor methods, or the fast gaussian transform when imple-
menting a gaussian smoother). also, nonparametric methods must be carefully tuned as
they can easily over   t or under   t. for example, in a k-nearest neighbor method if k is too
large, the method is going to introduce too much smoothing (i.e., it will under   t), while if
k is too small, it will    t to the noise (i.e., over   t). over   tting will be further discussed in
section 3.2.4. for more information about nonparametric regression, the reader is advised
to consult the books by h  ardle (1990); gy  or    et al. (2002); tsybakov (2009).
although our discussion below will assume a parametric function approximation method
(and in many cases linear function approximation), many of the algorithms can be extended
to nonparametric techniques. we will mention when such extensions exist as appropriate.
up to now, the discussion implicitly assumed that the state is accessible for measurement.
this is, however, rarely the case in practical applications. luckily, the methods that we
will discuss below do not actually need to access the states directly, but they can perform
equally well when some    su   ciently descriptive feature-based representation    of the states
is available (such as the camera images in the robot-arm example). a common way of
arriving at such a representation is to construct state estimators (or observers, in control
terminology) based on the history of the observations, which has a large literature both in
machine learning and control. the discussion of these techniques, however, lies outside of
the scope of the present book.

3.2.1 td(  ) with function approximation

let us return to the problem of estimating a value function v of a markov reward process
m = (x ,p0), but now assume that the state space is large (or even in   nite). let d =
((xt, rt+1); t     0) be a realization of m. the goal, as before, is to estimate the value
function of m given d in an incremental manner.
choose a smooth parametric function-approximation method (v  ;        rd) (i.e., for any
       rd, v   : x     r is such that      v  (x) exists for any x     x ). the generalization of

29

algorithm 4 the function implementing the td(  ) algorithm with linear function approx-
imation. this function must be called after each transition.
function tdlambdalinfapp(x, r, y,   , z)
input: x is the last state, y is the next state, r is the immediate reward associated with
this transition,        rd is the parameter vector of the linear function approximation,
z     rd is the vector of eligibility traces

1:        r +         (cid:62)  [y ]       (cid:62)  [x]
2: z       [x] +             z
3:           +             z
4: return (  , z)

tabular td(  ) with accumulating eligibility traces to the case when the value functions are
approximated using members of (v  ;        rd) uses the following updates (sutton, 1984, 1988):

  t+1 = rt+1 +   v  t(xt+1)     v  t(xt),
zt+1 =      v  t(xt) +      zt,
  t+1 =   t +   t   t+1 zt+1,

z0 = 0.

(21)

here zt     rd. algorithm 4 shows the pseudocode of this algorithm.
to see that this algorithm is indeed a generalization of tabular td(  ) assume that x =
{x1, . . . , xd} and let v  (x) =   (cid:62)  (x) with   i(x) = i{x=xi}. note that since v   is linear in the
parameters (i.e., v   =   (cid:62)  ), it holds that      v   =   . hence, identifying zt,i (  t,i) with zt(xi)
(resp.,   vt(xi)) we see that the update (21), indeed, reduces to the previous one.
in the o   -policy version of td(  ), the de   nition of   t+1 becomes
  t+1 = rt+1 +   v  t(yt+1)     v  t(xt).

unlike the tabular case, under o   -policy sampling, convergence is no longer guaranteed, but,
in fact, the parameters may diverge (see, e.g., bertsekas and tsitsiklis, 1996, example 6.7,
p. 307). this is true for linear function approximation when the distributions of (xt; t     0)
do not match the stationary distribution of the mrp m. another case when the algorithm
may diverge is when it is used with a nonlinear function-approximation method (see, e.g.,
bertsekas and tsitsiklis, 1996, example 6.6, p. 292). for further examples of instability, see
baird (1995); boyan and moore (1995).
on the positive side, almost sure convergence can be guaranteed when (i) a linear function-
approximation method is used with    : x     rd; (ii) the stochastic process (xt; t     0) is

30

an ergodic markov process whose stationary distribution    is the same as the stationary
distribution of the mrp m; and (iii) the step-size sequence satis   es the rm conditions
(tsitsiklis and van roy, 1997; bertsekas and tsitsiklis, 1996, p. 222, section 5.3.7).
in
the results cited, it is also assumed that the components of    (i.e.,   1, . . . ,   d) are linearly
independent. when this holds, the limit of the parameter vector will be unique. in the other
case, i.e., when the features are redundant, the parameters will still converge, but the limit
will depend on the parameter vector   s initial value. however, the limiting value function will
be unique (bertsekas, 2010).
assuming that td(  ) converges, let   (  ) denote the limiting value of   t.
let

f = {v   |        rd}

be the space of functions that can be represented using the chosen features   . note that
f is a linear subspace of the vector space of all real-valued functions with domain x . the
limit   (  ) is known to satisfy the so-called projected    xed-point equation

v  (  ) =   f ,   t (  )v  (  ),

(22)

where the operators t (  ) and   f ,   are de   ned as follows: for m     n let t [m] be the m-step
lookahead bellman operator:

(cid:34) m(cid:88)

t=0

(cid:12)(cid:12)(cid:12) x0 = x

(cid:35)

.

t [m]   v (x) = e

  trt+1 +   m+1   v (xm+1)

clearly, v , the value function to be estimated is a    xed point of t [m] for any m     0.
assume that    < 1. then, operator t (  ) is de   ned as the exponentially weighted average of
t [0], t [1], . . .:

   (cid:88)

t (  )   v (x) = (1       )

  m t [m]   v (x).

m=0

for    = 1, we let t (1)   v = lim     1    t (  )   v = v . notice that for    = 0, t (0) = t . operator
  f ,   is a projection: it projects functions of states to the linear space f with respect to the
weighted 2-norm (cid:107)f(cid:107)2

   =(cid:80)

x   x f 2(x)  (x):

  f ,  

  v = argmin

f   f

(cid:107)   v     f(cid:107)  .

the essence of the proof of convergence of td(  ) is that the composite operator   f ,  t (  )
is a contraction with respect to the norm (cid:107)  (cid:107)  . this result heavily exploits that    is the
stationary distribution underlying m (which de   nes t (  )). for other distributions, the

31

composite operator might not be a contraction; in which case, td(  ) might diverge.
as to the quality of the solution found, the following error bound holds for the    xed point
of (22):

(cid:107)v  (  )     v (cid:107)      

1   
1         

(cid:107)  f ,  v     v (cid:107)   .

here      =   (1      )/(1        ) is the contraction modulus of   f ,  t (  ) (tsitsiklis and van roy,
1999a; bertsekas, 2007b). (for sharper bounds, see yu and bertsekas 2008; scherrer 2010.)
from the error bound we see that v  (1) is the best approximation to v within f with respect
to the norm (cid:107)  (cid:107)   (this should come at no surprise as td(1) minimizes this mean-squared
error by design). we also see that as we let        0 the bound allows for larger errors. it is
known that this is not an artifact of the analysis. in fact, in example 6.5 of the book by
bertsekas and tsitsiklis (1996) (p. 288), a simple mrp with n states and a one-dimensional
feature extractor    is given such that v  (0) is a very poor approximation to v , while v  (1)
is a reasonable approximation. thus, in order to get good accuracy when working with
   < 1, it is not enough to choose the function space f so that the best approximation to
v has small error. at this stage, however, one might wonder if using    < 1 makes sense
at all. a recent paper by van roy (2006) suggests that when considering performance loss
bounds instead of approximation errors and the full, control-learning task (cf. section 4),
   = 0 will in general be at no disadvantage compared to using    = 1, at least, when state-
aggregation is considered. thus, while the mean-squared error of the solution might be large,
when the solution is used in control, the performance of the resulting policy will still be as
good as that of one that is obtained by calculating the td(1) solution. however, the major
reason to prefer td(  ) with    < 1 over td(1) is because empirical evidence suggests that
it converges much faster than td(1), the latter of which, at least for practical sample sizes,
often produces very poor estimates (e.g., sutton and barto, 1998, section 8.6).

td(  ) solves a model sutton et al. (2008) and parr et al. (2008) observed independently
of each other that the solution obtained by td(0) can be thought of as the solution of a
deterministic mrp with a linear dynamics. in fact, as we will argue now this also holds in
the case of td(  ).
this suggests that if the deterministic mrp captures the essential features of the original
mrp, v  (  ) will be a good approximation to v . to    rm up this statement, following parr
et al. (2008), let us study the bellman error

   (  )(   v ) = t (  )   v       v

of   v : x     r under t (  ). note that    (  )(   v ) : x     r. a simple contraction argument
shows that

(cid:13)(cid:13)(cid:13)   . hence, if    (  )(   v ) is small,   v is close to v .

(cid:13)(cid:13)(cid:13)   (  )(   v )

(cid:13)(cid:13)(cid:13)v       v

(cid:13)(cid:13)(cid:13)   

    1
1     

32

the following error decomposition can be shown to hold:8

   (  )(v  (  )) = (1       )

  m   [r]

m +   

(1       )

(cid:88)

m   0

(cid:40)

(cid:41)

  m   [  ]
m

  (  ).

(cid:88)

m   0

m = rm       f ,  rm and    [  ]

m = p m+1  (cid:62)       f ,  p m+1  (cid:62) are the errors of modeling the
here    [r]
m-step rewards and transitions with respect to the features   , respectively; rm : x     r is
de   ned by rm(x) = e [rm+1 | x0 = x] and p m+1  (cid:62) denotes a function that maps states to d-
dimensional row-vectors and which is de   ned by p m+1  (cid:62)(x) = (p m+1  1(x), . . . , p m+1  d(x)).
here p m  i : x     r is the function de   ned by p m  i(x) = e [  i(xm)| x0 = x]. thus, we see
that the bellman error will be small if the m-step immediate rewards and the m-step feature-
expectations are well captured by the features. we can also see that as    gets closer to 1, it
becomes more important for the features to capture the structure of the value function, and
as    gets closer to 0, it becomes more important to capture the structure of the immediate
rewards and the immediate feature-expectations. this suggests that the    best    value of   
(i.e., the one that minimizes (cid:107)   (  )(v  (  ))(cid:107)) may depend on whether the features are more
successful at capturing the short-term or the long-term dynamics (and rewards).

3.2.2 gradient temporal di   erence learning

that td(  ) can diverge in o   -policy learning situations spoils its otherwise immaculate
record. in section 3.2.3, we will introduce some methods that avoid this issue. however,
as we will see it, the computational (time and storage) complexity of these methods will be
signi   cantly larger than that of td(  ). in this section, we present two recent algorithms
introduced by sutton et al. (2009b,a), which also overcome the instability issue, converge to
the td(  ) solutions in the on-policy case, and yet they are almost as e   cient as td(  ).
for simplicity, we consider the case when    = 0, ((xt, rt+1, yt+1); t     0) is a stationary
process, xt        (    can be di   erent from the stationary distribution of p) and when linear
function approximation is used with linearly independent features. assume that   (0), the
solution to (22), exists. consider the objective function

j(  ) = (cid:107)v         f ,  t v  (cid:107)2
   .

(23)

notice that all solutions to (22) are minimizers of j, and there are no other minimizers of
j when (22) has solutions. thus, minimizing j will give a solution to (22). let       denote a
minimizer of j. since, by assumption, the features are linearly independent, the minimizer

8parr et al. (2008) observed this for    = 0. the extension to    > 0 is new.

33

of j is unique, i.e.,       is well-de   ned. introduce the shorthand notations

  t+1(  ) = rt+1 +   v  (yt+1)     v  (xt)

= rt+1 +     (cid:62)  (cid:48)

t+1       (cid:62)  t,

  t =   (xt),

  (cid:48)
t+1 =   (yt+1).

a simple calculation allows us to rewrite j in the following form:

taking the gradient of the objective function we get

j(  ) = e [  t+1(  )  t]

t

(cid:62) e(cid:2)  t  (cid:62)
     j(  ) =    2e(cid:2)(  t         (cid:48)
w(  ) = e(cid:2)  t  (cid:62)

(cid:3)   1 e [  t+1(  )  t] .
(cid:3) w(  ),
(cid:3)   1 e [  t+1(  )  t] .

t+1)  (cid:62)

t

t

where

(24)

(25)

(26)

let us now introduce two sets of weights:   t to approximate       and wt to approximate w(     ).
in gtd2 (   gradient temporal di   erence learning, version 2   ), the update of   t is chosen to
follow the negative stochastic gradient of j based on (26) assuming that wt     w(  t), while
the update of wt is chosen so that for any    xed   , wt would converge almost surely to w(  ):

  t+1 =   t +   t (  t         (cid:48)
t+1)   (cid:62)
wt+1 = wt +   t(  t+1(  t)       (cid:62)

t wt,

t wt)   t.

here (  t; t     0), (  t; t     0) are two step-size sequences. note that the update equation for
(wt; t     0) is just the basic least-mean square (lms) rule, which is a widely used update
rule in signal processing (widrow and stearns, 1985).
sutton et al. (2009a) have shown
that under the standard rm conditions on the step-sizes and some other mild technical
conditions (  t) converges to the minimizer of j(  ), almost surely. however, unlike for td(0),
convergence is guaranteed independently of the distribution of (xt; t     0). at the same time,
the update of gtd2 costs only twice as much as the cost of td(0). algorithm 5 shows the
pseudocode of gtd2.
to arrive at the second algorithm called tdc (   temporal di   erence learning with correc-
tions   ), write the gradient as

(cid:16)e [  t+1(  )  t]       e(cid:2)  (cid:48)

t+1  (cid:62)

t

(cid:17)

(cid:3) w(  )

.

     j(  ) =    2

34

algorithm 5 the function implementing the gtd2 algorithm. this function must be called
after each transition.
function gtd2(x, r, y,   , w)
input: x is the last state, y is the next state, r is the immediate reward associated with
this transition,        rd is the parameter vector of the linear function approximation,
w     rd is the auxiliary weight

1: f       [x]
2: f(cid:48)       [y ]
3:        r +         (cid:62)f(cid:48)       (cid:62)f
4: a     f(cid:62)w
5:           +       (f           f(cid:48))    a
6: w     w +       (       a)    f
7: return (  , w)

leaving the update wt unchanged, we then arrive at,

(cid:16)
(cid:16)

  t+1 =   t +   t

wt+1 = wt +   t

  t+1(  t)  t         (cid:48)
  t+1(  t)       (cid:62)

t wt

(cid:17)

  t.

t+1   (cid:62)

t wt

(cid:17)

,

the pseudocode of this update is identical to that of gtd2 except that line 5 should be
replaced by

          +       (      f           a    f(cid:48)).

in tdc, the update of wt must use larger step-sizes than the update of   t:   t = o(  t). this
makes tdc a member of the family of the so-called two-timescale stochastic approximation
algorithms (borkar, 1997, 2008). if, in addition to this condition, the standard rm conditions
are also satis   ed by both step-size sequences,   t           holds again almost surely (sutton
et al., 2009a). more recently, these algorithms have been extended to nonlinear function
approximation (maei et al., 2010a). also, one can show that it su   ces if   t (cid:28)   t (maei,
2010, personal communication). the algorithms can also be extended to use eligibility traces
(maei and sutton, 2010).
note that although these algorithms are derived from the gradient of an objective function,
they are not true stochastic gradient methods in the sense that the expected weight update
direction can be di   erent from the direction of the negative gradient of the objective function.
in fact, these methods belong to the larger class of pseudo-gradient methods. the two
methods di   er in how they approximate the gradients, and it remains to be seen whether
one of them is better than the other.

35

3.2.3 least-squares methods

the methods discussed so far are similar to the lms algorithm of adaptive    ltering in
that they are taking small steps in the parameter space following some noisy, gradient-
like signal. as such, similarly to the lms algorithm, they are sensitive to the choice of
the step-sizes, the distance between the initial parameter and the limit point   (  ), or the
eigenvalue structure of the matrix a that determines the dynamics of updates (e.g., for

t+1)(cid:62)(cid:3)). over the years, many ideas appeared in the literature to

td(0), a = e(cid:2)  t(  t         (cid:48)

address these issues. these are essentially parallel to those available in the adaptive    ltering
literature. a non-exhaustive list includes the use of adaptive step-sizes (sutton, 1992; george
and powell, 2006), normalizing the updates (bradtke, 1994) or reusing previous samples
(lin, 1992). although these techniques can indeed help, each have their own weaknesses. in
adaptive    ltering, the algorithm that is known to address all the de   ciencies of lms is known
as the ls (   least-squares   ) algorithm. in this section, we review the analogous methods of
id23.

lstd: least-squares temporal di   erence learning in the limit of an in   nite number
of examples, td(0)    nds a parameter vector    that satis   es

e [   t   t+1(  ) ] = 0,

(27)

where we used the notation of the previous section. given a    nite sample

dn = ((x0, r1, y1), (x1, r2, y2), . . . , (xn   1, rn, yn)),

one can approximate (27) by

n   1(cid:88)

  t   t+1(  ) = 0.

(28)

1
n

plugging in   t+1(  ) = rt+1     (  t         (cid:48)
particular, if the matrix   an = 1

t=0

(cid:80)n   1
t=0   t(  t         (cid:48)

n

t+1)(cid:62)  , we see that this equation is linear in   . in
t+1)(cid:62) is non-singular, the solution is simply

(cid:80)n   1

  n =   a   1

n

  bn,

(29)

n

where   bn = 1
t=0 rt+1  t. if inverting   an can be a   orded (i.e., the dimensionality of the
features is not too large and the method is not called too many times) then this method
can give a better approximation to the equilibrium solution than td(0) or some other
incremental    rst-order method since the latter are negatively impacted by the eigenvalue

spread of the matrix e(cid:104)   an

(cid:105)

.

the idea of directly computing the solution of (28) is due to bradtke and barto (1996),

36

algorithm 6 the function implementing the rlstd algorithm. this function must be
called after each transition.
initially, c should be set to a diagonal matrix with small
positive diagonal elements: c =    i, with    > 0.
function rlstd(x, r, y, c,   )
input: x is the last state, y is the next state, r is the immediate reward associated with
this transition, c     rd  d, and        rd is the parameter vector of the linear function
approximation

(cid:46) g is a 1    d row vector

1: f       [x]
2: f(cid:48)       [y ]
3: g     (f       f(cid:48))(cid:62)c
4: a     1 + gf
5: v     cf
6:        r +         (cid:62)f(cid:48)       (cid:62)f
7:           +    / a    v
8: c     c     v g / a
9: return (c,   )

who call the resulting algorithm least-squares temporal di   erence learning or lstd. using
the terminology of stochastic programming, lstd can be seen to use sample average ap-
proximation (shapiro, 2003).
in the terminology of statistics, it belongs to the so-called
z-estimation family of procedures (e.g., kosorok, 2008, section 2.2.5). it is a simple obser-
vation that when the lstd solution exists, lstd minimizes the empirical approximation
to the projected squared bellman error, (cid:107)  f ,  (t v     v )(cid:107)2
  , over the linear space f (antos
et al., 2008).
using the sherman-morrison formula, one can derive an incremental version of lstd, anal-
ogously to how the recursive least-squares (rls) method is derived in adaptive    ltering
widrow and stearns (1985). the resulting algorithm is called    recursive lstd    (rlstd)
and works as follows (bradtke and barto, 1996): choose   0     rd and let c0     rd  d such
that c0 is a    small    positive de   nite matrix (e.g., c0 =   i, for    > 0    small   ). then, for
t     0,

ct+1 = ct     ct   t(  t         (cid:48)
1 + (  t         (cid:48)
ct
1 + (  t         (cid:48)

  t+1 =   t +

t+1)(cid:62)ct
t+1)(cid:62)ct  t

t+1)(cid:62)ct  t

,

  t+1(  t)  t.

the computational complexity of one update is o(d2). algorithm 6 shows the pseudocode
of this algorithm.
boyan (2002) extended lstd to incorporate the    parameter of td(  ) and called the
resulting algorithm lstd(  ). (note that for    > 0 to make sense one needs xt+1 = yt+1;

37

n   1(cid:88)

t=0

1
n

otherwise, the td errors do not telescope). the lstd(  ) solution is derived from (21). it
is de   ned as the parameter value that makes the cumulated updates zero:

  t+1(  )zt+1 = 0,

(30)

where zt+1 = (cid:80)t

s=0(    )t   s  s are the eligibility traces. this is again linear in    and the
previous comments apply. the recursive form of lstd(  ), rlstd(  ), has been studied by
xu et al. (2002) and (independently) by nedi  c and bertsekas (2003). (see algorithm 16 for
the pseudocode of a closely related algorithm.)
one issue with lstd(  ) as stated here that equation (30) might fail to have a solution. in
the on-policy case, for large enough sample sizes at least, a solution will always exist. when
a solution does not exist, a commonly suggested trick is to add a small positive diagonal
matrix to the matrix to be inverted (this corresponds to starting with a positive diagonal
matrix in rlstd). however, this trick is not guaranteed to work. a better approach is based
on the observation that when the matrix is invertible then the lstd parameter vector is
a minimizer of the projected bellman error. since the minimizer of the projected bellman
error is always well de   ned, instead of the solving for the zero of (30) , one can aim for
minimizing the projected bellman error.
under standard assumptions on the sample, it follows from the law of large numbers and a
simple continuity argument that lstd(  ) (and its recursive variants) converge almost surely
to the solution of the projected    xed-point equation (22) if this solution exists. this was
formally shown for    = 0 by bradtke and barto (1996), and for    > 0 by xu et al. (2002)
and nedi  c and bertsekas (2003). although these results were shown only for the on-policy
case, it is easy to see that they also hold in the o   -policy case provided that the limiting
solution exists.
as promised, (r)lstd(  ) avoids the di   culties associated with tuning the incremental
algorithms: it neither relies on step-sizes, nor is it sensitive to the eigenvalue structure of a, or
the choice of the initial value of   . experimental results by bradtke and barto (1996); boyan
(2002); xu et al. (2002) and others have indeed con   rmed that the parameters obtained using
(r)lstd(  ) converge faster than those obtained by td(  ). however, their computational
properties are quite di   erent from those of td(  ). we will discuss the implications of this
after we have reviewed the lspe algorithm.

lspe: least-squares policy evaluation an alternative to lstd (and lstd(  )) is
  -least squares policy evaluation (  -lspe for short) due to bertsekas and io   e (1996). the
basic idea of this algorithm is to mimic multi-step value iteration. again, the method assumes
that linear function-approximation is used.

38

algorithm 7 the function implementing the batch-mode   -lspe update. this function
must be called repeatedly until convergence.
function lambdalspe(d,   )
input: d = ((xt, at, rt+1, yt+1); t = 0, . . . , n     1) is a list of transitions,        rd is the
1: a, b,        0
(cid:46) a     rd  d, b     rd,        r
2: for t = n     1 downto 0 do

parameter vector

                      + (cid:0)rt+1 +         (cid:62)  [yt+1]     v(cid:1)

f       [xt]
v       (cid:62)f
b     b + (v +   )    f
a     a + f    f(cid:62)

3:
4:
5:
6:
7:
8: end for
9:   (cid:48)     a   1b
10:           +       (  (cid:48)       )
11: return   

it works as follows. de   ne the (n     s)-step prediction of the value of xs as

s,n (  ) =   (cid:62)  s +
  v (  )

(    )q   s   q+1(  )

n   1(cid:88)
(cid:16)    (cid:62)  s       v (  )
n   1(cid:88)

q=s

s=0

(cid:17)2

s,n (  )

.

and de   ne the loss

jn(    ,   ) =

1
n

then,   -lspe updates the parameters by

  t+1 =   t +   t(argmin

    

jnt(    ,   t)       t),

(31)

where (  t; t     0) is a step-size sequence and (nt; t     0) is a non-decreasing sequence of
integers. (bertsekas and io   e (1996) only considered the case when nt = t, which is a logical
choice when the algorithm is used in an online learning scenario. when the algorithm is
used with a    nite (say, n) observations, we can set nt = n or nt = min(n, t).) note that jn
is quadratic in     , hence the solution to the minimization problem can be obtained in closed
form. the resulting algorithm is shown as algorithm 7. a recursive, incremental version of
  -lspe is also available. similarly to lstd(  ), it requires o(d2) operations per time step
when nt = t.
to get a sense of the behavior of   -lspe, consider the update in the special case when    = 0

39

and   t = 1:

(cid:110)    (cid:62)  (xs)     (rs+1 +   v  t(ys+1))
(cid:111)2

.

nt   1(cid:88)

s=0

1
nt

  t+1 = argmin

    

thus, in this case,   -lspe solves a id75 problem, implementing the so-called
   tted value iteration algorithm for policy evaluation with linear function approximation.
for a    xed, non-random value of   t, the true regression function underlying the above least-
squares problem is e [rs+1 +   v  t(ys+1)|xs = x], which is just t v  t(x). thus, if the function
space f is rich enough and the sample size nt is large, one may expect   (cid:62)
t+1   to be close
to t v  t(x), and we see that the algorithm implements value iteration in an approximate
manner. the case when    > 0 can be given a similar interpretation.
when   t < 1, the parameters are moved towards the minimizer of jnt(  ,   t) in proportion to
the size of   t. the role of smoothing the updates this way is (i) to stabilize the parameters for
small sample sizes (i.e., when nt and d are in the same range) and (ii) to ensure that policies
are changed gradually when the algorithm is used as a subroutine of a control algorithm (cf.
section 4). the idea of smoothing the parameter updates could also be used together with
lstd.
just like lstd(  ), the multi-step version of   -lspe (i.e., when    > 0) requires xt+1 = yt+1.
the parameter    plays a role similar to its role in other td methods: increasing    is expected
to reduce bias and increase variance, though unlike td(  ),   -lspe bootstraps even when
   = 1. however, the e   ect of id64 is diminishing with nt        .
under standard assumptions on the sample and when nt = t,   -lspe is known to converge
almost surely to the solution of the projected    xed-point equation (22), both for decreasing
(nedi  c and bertsekas, 2003) and constant step-sizes (bertsekas et al., 2004). in the latter
case, convergence is guaranteed if 0 <   t        < (2     2    )/(1 +        2    ). note that 1 is
always included in this range.
according to bertsekas et al. (2004)   -lspe is competitive with lstd in the sense that
the distance between the parameters updated by lstd(  ) and   -lspe becomes, very soon,
smaller than the statistical inaccuracy resulting from the use of a    nite sample. experimental
results obtained by bertsekas et al. (2004) and earlier by bertsekas and io   e (1996) to train a
tetris playing program indicate that   -lspe, is indeed, a competitive algorithm. moreover,
  -lspe is always well-de   ned (all inverses involved exist in the limit or with appropriate
initialization), whereas lstd(  ) might be ill-de   ned in o   -policy settings.

comparing least-squares and td-like methods. the price of the increased stabil-
ity and accuracy of least-squares techniques is their increased computational complexity.
in particular, for a sample of size n, the complexity of a straightforward implementation of
lstd is o(nd2 + d3), while the complexity of rlstd is o(nd2) (the same applies to lspe).

40

for comparison, the computational complexity of the lightweight, incremental methods dis-
cussed previously is only o(nd) (or less when the features are sparse). thus, the lightweight
algorithms can do d passes on the sample while a least-squares method makes a single pass.
the trick of saving and reusing the observations to increase the accuracy of td-based al-
gorithms was    rst suggested by lin (1992), who dubbed his method    experience replay   .
when the value of d is large, this may be enough for the lightweight methods to perform as
well as the least-squares methods given the same computation time. when d is very large,
the least-squares methods might not be feasible at all. for example, silver et al. (2007) use
over a million features when building a value function for the game of go. when d is in this
range, least-squares methods are not feasible.
it becomes very complicated to compare these approaches if we take into account the fre-
quency at which the observations arrive, the storage space available, the access time of
storage, etc. hence, here we look at one interesting case when new observations are avail-
able at negligible cost. in this case, there is no need to (store and) reuse data and the quality
of solutions will depend on the methods    computation speed.
to compare the two approaches,    x some time t available for computation.
in time t ,
the least-squares methods are limited to process a sample of size n     t /d2, while the
lightweight methods can process a sample of size n(cid:48)     nd. let us now look at the precision
of the resulting parameters. assume that the limit of the parameters is      . denote by   t
the parameter obtained by (say) lstd after processing t observations and denote by   (cid:48)
t
the parameter obtained by a td-method. then, one expects that (cid:107)  t          (cid:107)     c1t    1
2 and
(cid:107)  (cid:48)
t          (cid:107)     c2t    1

2 . thus,

(cid:107)  (cid:48)
n(cid:48)          (cid:107)
(cid:107)  n          (cid:107)     c2

c1

d    1
2 .

(32)

hence, if c2/c1 < d1/2 then the lightweight td-like method will achieve a better accuracy,
while in the opposite case the least-squares procedures will perform better. as usual, it is
di   cult to decide this a priori. as a rule of thumb, based on (32), we expect that when
d is relatively small, least-squares methods might be converging faster; while if d is large,
then the lightweight, incremental methods will give better results given a    xed computation
budget. notice that this analysis is not speci   c to id23 methods, but it
applies in all cases when an incremental lightweight procedure is compared to a least-squares-
like procedure (for a similar analysis in a supervised learning problem see, e.g., bottou and
bousquet, 2008).
realizing the need for e   cient and robust methods, geramifard et al. (2007) have recently
introduced an incremental version of lstd, called ilstd, which, just like lstd, computes
the matrix   an and vector   bn, but in each time step, only one dimension of the parameter
vector is updated. for sparse features, i.e., when only s components of the feature vector are

41

nonzero, the per-iteration complexity of this method is o(sd), while experimentally it has
been demonstrated that it is almost as accurate as lstd given the same number of samples
(assuming again sparsity). the storage space needed by ilstd after processing n samples
is o(min(ns2 + d, d2)). thus, when the features are sparse and ns2 (cid:28) d2, ilstd might be
competitive with lstd and incremental td-methods.

3.2.4 the choice of the function space

in order to be able to discuss the choice of the function space in a meaningful manner,
we need to de   ne how the quality of an approximate value function is measured. when
the ultimate goal is value-prediction, a reasonable choice is to use the mean-squared error
(mse) with respect to an appropriate distribution over the states (say,   ). the choice of a
metric is less clear when the goal is to learn a good controller and value estimation is only
used as a subroutine of a more complex algorithm (such as the ones that will be reviewed in
section 4). therefore, in lack of a good understanding of this case, for the purpose of this
section, we will stick to the mse as the quality-measure. however, we believe that most of
the conclusions of this section would hold for other measures, too.
learning can be viewed as the process of selecting some function from some space of functions
(f) that can be represented (   nitely) in the computer   s memory.9 for simplicity, assume
that the functions available are described by d parameters: f = {v   |        rd}. one measure
that characterizes the choice of f is how well functions from f can approximate the target
function v , leading to the de   nition of the approximation error underlying f:

v     f (cid:107)v       v (cid:107)  .

inf

to decrease the approximation error, one is encouraged to choose a larger function space
(i.e., when v   is linear we may add independent features to make f larger). however, as we
will argue now, since learning by de   nition uses incomplete information, increasing the size
of the function space is a double-edged sword.
for simplicity, let us consider linear function approximation, and assume that lstd, as
speci   ed by (28), is used to obtain the parameters. to make the situation even simpler,
assume that the discount factor,   , is zero and ((xt, rt+1); t     0) is an i.i.d. sample with
xt       . in this case,

v (x) = r(x) = e [rt+1|xt = x] .

thanks to    = 0, lstd can actually be seen to compute the minimizer of the empirical loss

9we do not deal with issues of precision, i.e., that computers cannot really represent real numbers.

42

function,

n   1(cid:88)

t=0

1
n

ln(  ) =

(  (cid:62)  (xt)     rt+1)2.

assume that the dimensionality of the feature space, d, is so large that the matrix whose rows
are   (x0)(cid:62), . . . ,   (xn   1)(cid:62) has full row rank (in particular, assume that d     n). this implies
that the minimum of ln is zero and if   n denotes the solution of (28) then   (cid:62)
n   (xt) = rt+1
holds for t = 0, . . . , n     1. if the observed rewards are noisy, the resulting function will be a
n        v (cid:107)  , will be
poor approximation to the value function, v , i.e., the estimation error, (cid:107)  (cid:62)
large. the phenomenon of    tting to the    noise    is called over   tting. if a smaller d is chosen
(in general, if a smaller function space f is chosen), then over   tting will be less likely to
happen. however, in this case, the approximation error will get larger. hence, there is a
tradeo    between the approximation and the estimation errors.
to quantify this tradeo   , let       be the parameter vector that minimizes the loss

l(  ) = e(cid:2)(  (cid:62)  (xt)     rt+1)2(cid:3) .

that is,

      = argmin

l(  ).

  

(a simple argument shows that v      is actually the projection of v to f.) the following
bound is known to hold if the random rewards are bounded by some value r and, after
   nding the optimal weights, at prediction time, the predicted values are back-projected to
[   r,r] (gy  or    et al., 2002, theorem 11.3, p. 192):

e(cid:2)(cid:107)  (cid:62)

n        v (cid:107)2(cid:3)     c1

d (1 + log n)

n

+ c2 (cid:107)  (cid:62)

           v (cid:107)2
  .

(33)

here c2 is a universal constant, while c1 is a constant that scales linearly with the variance
and range of the random rewards.10 the    rst term on the right-hand side bounds the
estimation error, while the second term is due to the approximation error.
increasing d
increases the    rst term, while it is generally expected to decrease the second.
the argument that leads to bounds of the above form is as follows: by the law of large
numbers, ln(  ) converges to l(  ) for any    xed value of   . hence, by minimizing ln(  ), one
hopes to obtain a good approximation to       (more precisely, to   (cid:62)
      ). however, that ln(  )
converges to l(  ) at every value of    does not mean that the function ln(  ) is uniformly
close to l(  ). thus, the minimizer of ln might not give a small loss, as measured by l
(cf. figure 5). guaranteeing that the two functions are uniformly close to each other (say,

10note that without truncation, c1 would not be independent of the distribution of xt. although the

theorem is stated for the expected error, similar results can be shown to hold with high id203.

43

figure 5: convergence of ln(  ) to l(  ). shown are the curves of the empirical loss, ln and
the true loss l, as a function of the parameter   . if the two curves are uniformly close to
each other (i.e., for every   , ln(  )    l(  ) is small), then one can expect that the loss of   (cid:62)
n   
will be close to the loss of   (cid:62)

      .

over the set {   | ln(  )     ln(0)}) is harder when the dimensionality of    is larger, hence the
tradeo    between estimation and approximation errors.
bounds similar to (33) hold even when    > 0, e.g.
for value functions estimated using
lstd and even when the sequence (xt; t     0) is dependent provided that it    mixes well   
(for some initial steps in this direction consult the work of antos et al. (2008)). in fact,
when    (cid:54)= 0, the noise comes both from the immediate rewards rt+1 and the    next states   ,
yt+1. the tradeo    between the approximation and estimation errors also shows up when
control algorithms are used: munos and szepesv  ari (2008) and antos et al. (2007, 2008)
derive    nite-sample performance bounds for some variants of    tted value iteration, a    tted
actor-critic method and an approximate policy iteration method, respectively.
recognizing the importance of the choice of the function space, as well as the di   culty of
choosing it right, there has been a growing interest in automating this choice lately. one
class of methods aims at constructing a parsimonious set of features (basis functions). these
include tuning the parameter of gaussian rbf either using a gradient- or the cross-id178-
method in the context of lstd (menache et al., 2005), deriving new basis functions with

44

  lossfunctions  >  '  >n'  >'llnl(  )ln(  )nonparametric techniques (keller et al., 2006; parr et al., 2007) or using a combination
of numerical analysis and nonparametric techniques (mahadevan, 2009). these methods,
however, do not attempt to control the tradeo    between the approximation and estimation
errors. to account for this de   ciency, other researchers explore nonparametric techniques
originating at supervised learning. examples of this line of research include the use of
regression trees (ernst et al., 2005), or    kernelizing    the value estimation algorithms (e.g.,
rasmussen and kuss, 2004; engel et al., 2005; ghavamzadeh and engel, 2007; xu et al., 2007;
taylor and parr, 2009). these approaches implicitly or explicitly regularize the estimates
to control the loss. kolter and ng (2009) designed an algorithm inspired by lasso that
uses (cid:96)1-id173 to implement feature selection in the context of lstd. although the
approaches above are inspired by principled methods of supervised learning, not much is
known about their statistical properties. recently, farahmand et al. (2009, 2008) have
developed another id173-based approach that comes with statistical guarantees.
the di   culty of using (some) nonparametric techniques is that they are computationally ex-
pensive. as a result, when the algorithms are used for planning and a fast simulator is used
to generate data (so that the cost of generating new data is negligible), it might be better
to use an appropriate fast incremental method and a simple linear function-approximation
method with many features than to use a sophisticated but computationally expensive non-
parametric method. computational e   ciency is less important if a limited amount of data is
available only and the quality of the solutions is the primary concern, or when the problem
is complex enough so that tuning the function approximation is necessary, but hand-tuning
is infeasible.

4 control

we now turn to the problem of learning a (near-)optimal policy. we start by discussing
the various forms of control learning problems (section 4.1), followed by a discussion of
interactive learning (section 4.2). in the last two sections (sections 4.3 and 4.4), the learning
counterparts of the classical methods of id145 are discussed.

4.1 a catalog of learning problems

figure 6 shows the basic types of control learning problems. the    rst criterion that the space
of problems is split upon is whether the learner can actively in   uence the observations.
in case she can, then we talk about interactive learning, otherwise one is facing a non-

45

figure 6: types of id23 problems

interactive learning problem.11
interactive learning is potentially easier since the learner
has the additional option to in   uence the distribution of the sample. however, the goal of
learning is usually di   erent in the two cases, making these problems incomparable in general.
in the case of non-interactive learning, the natural goal is to    nd a good policy given the ob-
servations. a common situation is when the sample is    xed. for example, the sample can be
the result of some experimentation with some physical system that happened before learn-
ing started. in machine learning terms, this corresponds to batch learning. (batch learning
problems are not to be confused with batch learning methods, which are the opposite of
incremental a.k.a. recursive, or iterative methods.) since the observations are uncontrolled,
the learner working with a    xed sample has to deal with an o   -policy learning situation. in
other cases, the learner can ask for more data (i.e., when a simulator is used to generate new
data). here the goal might be to learn a good policy as quickly as possible.
consider now interactive learning. one possibility is that learning happens while interacting
with a real system in a closed-loop fashion. a reasonable goal then is to optimize online per-
formance, making the learning problem an instance of online learning. online performance
can be measured in di   erent ways. a natural measure is to use the sum of rewards incurred
during learning. an alternative cost measure is the number of times the learner   s future
expected return falls short of the optimal return, i.e., the number of times the learner com-
mits a    mistake   . another possible goal is to produce a well-performing policy as soon as
possible (or    nd a good policy given a    nite number of samples), just like in non-interactive
learning. as opposed to the non-interactive situation, however, here the learner has the
option to control the samples so as to maximize the chance of    nding such a good policy.
this learning problem is an instance of active learning.
when a simulator is available, the learning algorithms can be used to solve planning problems.
in planning, the previous performance metrics become irrelevant and the algorithms    running

11the terms    active learning    and    passive learning    might appeal and their meaning indeed covers the
situations discussed here. however, unfortunately, the term    active learning    is already reserved in machine
learning for a special case of interactive learning. as a result, we also decided against calling non-interactive
learning    passive learning    so that no one is tempted to call interactive learning    active learning   .

46

!"#$"%&#%'("$")*+,$-%&#%'("$")./&$",%('+,$/"0%'("$")&1+%"'($/2",%('+,$/"time and memory requirements become the primary concern.

4.2 closed-loop interactive learning

in this section we    rst
the special feature of interactive learning is the need to explore.
use bandits (i.e., mdps with a single state) to illustrate the need for exploration, both in
online and active learning. next, we discuss active learning in mdps. this is followed by a
discussion of algorithms available for online learning in mdps.

4.2.1 online learning in bandits

consider an mdp that has a single state. let the problem be that of maximizing the return
while learning. since there is only one state, this is an instance of the classical bandit problems
(robbins, 1952). a basic observation then is that a bandit learner who always chooses the
action with the best estimated payo    (i.e., who always makes the greedy choice) can fail to
   nd the best action with positive id203, which in turn leads to a large loss. thus, a
good learner must take actions that look suboptimal, i.e., must explore. the question is then
how to balance the frequency of exploring and exploiting (i.e., greedy) actions.
a simple strategy is to    x    > 0 and choose a randomly selected action with id203   ,
and go with the greedy choice otherwise. this is the so-called   -greedy strategy. another
simple strategy is the so-called    boltzmann exploration    strategy, according to which, given
the sample means, (qt(a); a     a), of the actions at time t, the next action is drawn from
the multinomial distribution (  (a); a     a), where

(cid:80)

  (a) =

exp(    qt(a) )
a(cid:48)   a exp(    qt(a(cid:48)) )

.

here    > 0 controls the greediness of action selection (           results in a greedy choice).
the di   erence between boltzmann exploration and   -greedy is that   -greedy does not take
into account the relative values of the actions, while boltzmann exploration does. these
algorithms extend easily to the case of unrestricted mdps provided that some estimates of
the action-values is available.
if the parameter of   -greedy is made a function of time and the resulting sequence is appro-
priately tuned,   -greedy can be made competitive with other, more sophisticated algorithms.
however, the best choice is problem dependent and there is no known automated way of
obtaining good results with   -greedy (auer et al., 2002). the same holds for the boltzmann
exploration strategy.
a better approach might be to implement the so-called optimism in the face of uncertainty
(ofu) principle due to lai and robbins (1985), according to which the learner should choose

47

the action with the best upper con   dence bound (ucb). a very successful recent algorithm,
ucb1, implements this principle by assigning the following ucb to action a at time t (auer
et al., 2002):

(cid:115)

ut(a) = rt(a) + r

2 log t
nt(a)

.

here nt(a) is the number of times action a was selected up to time t and rt(a) is the sample
mean of the nt(a) rewards observed for action a, whose range is [   r, +r]. it can be shown
that the failure id203 of ut(a) is t   4. notice that an action   s ucb is larger if less
information is available for it. further, an action   s ucb value increases even if it is not
tried. algorithms 8 and 9 show the pseudocode of ucb1, in the form of two routines, one
to be used for action selection and the other for updating the internal statistics.
when the variance of the rewards associated with some of the actions are small, it makes
sense to estimate these variances and use them in place of the range r in the above algo-
rithm. a principled way of doing this was proposed and analyzed by audibert et al. (2009).
the resulting algorithm often outperforms ucb1 and can be shown to be essentially unim-
provable. the algorithm that we will describe in section 4.2.4 implements the ofu principle
in mdps in a way similar to ucb1.
the setting considered here is called the frequentist agnostic setting, where the only assump-
tion made about the distribution of rewards is that they are independent across the actions
and time steps and that they belong to the [0, 1] interval. however, there is no other a
priori knowledge about their distributions. an alternative, historically signi   cant, variant
of the problem is when the reward distributions have some known parametric form and the
parameters are assumed to be drawn form a known prior distribution. the problem then
is to    nd a policy which maximizes the total expected cumulated discounted reward, where
the expectation is both over the random rewards and the parameters of their distributions.
this problem can be represented as an mdp whose state at time t is the posterior over the
parameters of the reward distributions. for example, if the rewards assume bernoulli distri-
butions and their parameters are sampled from a beta distribution then the state at time t
will be a 2|a| dimensional vector (since the beta distribution has two parameters). thus,
the state space of this mdp can be rather complicated even for the simplest examples. in
his groundbreaking paper, gittins (1989) showed that rather surprisingly, the optimal policy
in this mdp assumes a simple index-form, which, in some special cases can be calculated
exactly and e   ciently (e.g., in the case of bernoulli reward distributions mentioned above).
the conceptual di   culty of this so-called bayesian approach is that although the policy
is optimal on the average for a collection of randomly chosen environments, there is no
guarantee that the policy will perform well on the individual environments. the appeal of
the bayesian approach, however, is that it is conceptually very simple and the exploration

48

algorithm 8 the function implementing action selection in ucb1. by assumption, initially
n[a] = 0, r[a] = 0 and the reward received lie in the [0, 1] interval. further, for c > 0,
c/0 =    .
function ucb1select(r, n, t)
input: r, n are arrays of size |a|, t is the number of time steps so far
1: u max           
2: for all a     a do

u     r[a] + r    sqrt( 2    log(t)/n[a])
if u > u max then

a(cid:48)     a, u max     u

3:
4:
5:
6:
7: end for
8: return a(cid:48)

end if

problem is reduced to a computational problem.

algorithm 9 the function implementing the update routine of ucb1. the update, which
updates the action counters and the estimates of the average reward, must be called after
each interaction.
function ucb1update(a, r, r, n)
input: a is the last action selected, r is the associated reward, r, n are arrays of size |a|,
t is the number of time steps so far
1: n[a]     n[a] + 1
2: r[a] = r[a] + 1.0 / n[a]    (r     r[a])
3: return r, n

4.2.2 active learning in bandits

consider now active learning, still in the case when the mdp has a single state. let the goal
be to    nd an action with the highest immediate reward given (say) t interactions. since
the rewards received during the course of interaction do not matter, the only reason not to
try an action is if it can be seen to be worse than some other action with su   cient certainty.
the remaining actions should be tried in the hope of proving that some are suboptimal. a
simple way to achieve this is to compute upper and lower con   dence bounds for each action:

ut(a) = qt(a) + r

lt(a) = qt(a)     r

(cid:114)
(cid:114)

log(2|a|t /  )

2t

log(2|a|t /  )

2t

,

,

49

and eliminate an action a if ut(a) < maxa(cid:48)   a lt(a(cid:48)). here 0 <    < 1 is a user chosen
parameter which speci   es the target con   dence with which the algorithm is allowed to fail
to return an action with the highest expected reward. apart from constant factors and
using estimated variances in the con   dence bounds, this algorithm is unimprovable (even-
dar et al., 2002; tsitsiklis and mannor, 2004; mnih et al., 2008).

4.2.3 active learning in id100

there exist only a few theoretical works that consider active learning in mdps. deterministic
environments have been considered by thrun (1992) (see also berman, 1998). it turns out
that the bounds given in thrun (1992) can be signi   cantly improved as follows:12
assume that the mdp m is deterministic. then the mdp   s transition structure can be
recovered in at most n2m steps, where n = |x|, m = |a| (ortner, 2008). a procedure
that achieves this is as follows: the task is to explore all actions in all states exactly once.
hence, at any time t, given the    known part    of the dynamics, we    nd the closest state
in at most n     1 steps, this state is reached and the action
with an unexplored action.
chosen is explored. since there are altogether nm state-action pairs to explore, the total
number of time steps needed is n2m. 13 given the transition structure, the reward structure
can be explored up to accuracy    with id203 1        after at most k = log(nm/  )/  2
visits to all state-action pairs. if it takes e(    n2m) time-steps to visit all state-action pairs
by some exploration policy, then in ke steps the learner will have an   -accurate model of
the environment. knowing such a model allows the learner to    nd a policy whose value
is 4    /(1       )2-close to the optimal value in each state (assuming, for simplicity,        0.5).
thus, altogether, to    nd an overall   -optimal policy, at most n2m+4e log(nm/  )/((1     )2  )2
steps are needed.
according to the author   s knowledge, there exist no works that consider the analogous
problem of    nding a uniformly almost-optimal strategy in a stochastic mdp. even-dar
et al. (2002) consider active-learning in    nite stochastic mdps but only under the (strong)
assumption that the learner can reset the state of the mdp to an arbitrary state. this way
they avoid the challenge of navigating in the unknown mdp.
that this is indeed a major challenge can be seen because there exists mdps where random
exploration takes exponential time in the mdps    size to visit all parts of the state space.
consider for example a chain-like mdp with n states, say x = {1, 2, . . . , n}. let a =
{l1, l2, r}. actions l1 and l2 decrement the state by one, while action r increments it
by one. the state is not changed at the boundaries when the action would lead to a state

12curiously, this argument is new.
13this bound improves the bound of thrun (1992). the bound can be shown to be tight in an asymptotic

sense.

50

outside of x . the policy that selects actions uniformly at random will need 3(2n     n     1)
steps on average to reach state n from state 1 (howard, 1960). however, a policy that
systematically explores the state space will only need o(n) actions to reach state n from
state 1. assume now that all immediate rewards are zero except at state n where the reward
is one. consider an explore-then-exploit learner that explores the mdp randomly until
its estimates are su   cient accurate (e.g., until it visited all state-action pairs su   ciently
many times). clearly, the learner will take exponentially many steps before switching to
exploitation and hence the learner will su   er a huge regret. the situation is not much better
if the agent uses a simple exploration strategy based on some estimates of the values of the
actions.
a problem closely related to active learning (without a reset) was studied by kearns and
singh (2002). they proposed the e3-algorithm that explores an unknown (stochastic) mdp
and stops when it knows a good policy for the state just visited. they proved that in
discounted mdps e3 needs a polynomial number of interactions and uses poly-resources in
the relevant parameters of the problem before it stops. in a follow-up work, brafman and
tennenholtz (2002) introduced the r-max algorithm which re   nes the e3 algorithm and
proved similar results. another re   nement of e3 is due to domingo (1999) who proposed
to use adaptive sampling to increase e   ciency when the mdp has many near-deterministic
if the problem is undiscounted, both e3 and r-max need the knowledge of
transitions.
the so-called   -mixing time of the mdp to work properly. when this knowledge is not
available, the algorithms do not know when to stop (brafman and tennenholtz, 2002).
little is known about the performance of active learning algorithms on practical problems.
some experimental results (for some heuristic algorithms) can be found in the paper by
s  im  sek and barto (2006).

4.2.4 online learning in id100

let us now return to online learning in mdps. one possible goal then is to minimize regret,
i.e., the di   erence of the total reward that would have been achieved by the optimal policy
and that of received by the learner. this problem is considered in the    rst part of this section.
another possible goal is to minimize the number of time steps when the algorithm   s future
expected return falls short of the optimal expected return by some prespeci   ed amount. this
problem is considered in the second part of this section.

regret minimization and the ucrl2 algorithm consider a    nite (small) mdp
m = (x ,a,p0). assume that the random immediate rewards are bound to lie in [0, 1] and,
for simplicity, assume that all deterministic (stationary) policies visit all states eventually
with id203 one, i.e., the mdp is unichain.

51

under this condition, every policy    gives rise to a recurrent markov chain on x and a
unique stationary distribution     . de   ne the long-run average reward of    by

(cid:88)

x   x

     =

    (x)r(x,   (x)).

(if we want to emphasize the dependence of the long-run average reward on the mdp m,
we will write     (m).) let       denote the optimal long-run average reward:

      = max
       stat

    .

consider some learning algorithm a (i.e., a is a history dependent behavior). de   ne the
regret of a by

t = (cid:80)t   1

t = t           ra
ra
t ,

t=0 rt+1 is the sum of rewards received up to time t while following a.
where ra
minimizing the regret is clearly equivalent to maximizing the total reward. hence, from now
on, we consider the problem of minimizing regret. notice that if ra
t = o(t ), i.e., if the rate
of growth of the regret is sublinear then the long-term average reward of a is      , i.e., a is
consistent.
the ucrl2 algorithm described below achieves logarithmic regret. in order to state this
bound de   ne d, the so-called diameter of the mdp, as the largest number of steps (on
average) it takes to reach some state from some other state in the mdp. further, let g be
the    gap    between the performance of the optimal policy and the second best policy. then,
according to auer et al. (2010), if the con   dence parameter of ucrl2 is set to    = 1/(3t ),
the following holds for the expected regret:

(cid:105)

rucrl2(1/(3t ))

t

= o(d2|x|2|a| log(t )/g).

one issue with this bound is that the gap g could be very small, in which case, the bound
might be vacuous for small values of t . an alternative bound, which is independent of g,
takes the form

(cid:105)

= o(d|x|(cid:112)|a|t log t )

rucrl2(1/(3t ))

t

(auer et al., 2010).
note that these bounds are vacuous when the mdp has an in   nite diameter, as happens
to be the case when the mdp has some states which are not accessible from some other
states, i.e., if the mdp has transient states. the only algorithm that is known to enjoy some
regret bounds even when the mdp has transient states is due to bartlett and tewari (2009).
however, this algorithm requires the a priori knowledge of some parameter of the mdp. at

52

e(cid:104)

e(cid:104)

present, it is not known if such a knowledge is necessary to achieve a non-trivial bound. the
issue with transient states is that it is very costly to distinguish between transient states and
states that are just hard to reach.
the ucrl2 algorithm (algorithm 10) implements the optimism in the face of uncertainty
principle: it constructs con   dence intervals around the estimates of the transition probabil-
ities and the immediate reward function. these de   ne a set of plausible mdps, ct. when
it comes to compute a policy, ucrl2    nds a model m   
t that gives
(approximately) the highest average reward within this class:
   
    (m)     1/
t.

t     ct and a policy      

t (m   

       

t )     max
  ,m   ct

note that an essential element of ucrl2 is that it does not update the policy in each time
step but waits until the quality of the statistics available for at least one state-action pair
is su   ciently improved. this is implemented in line 6 by the check of the visit-count of the
current state-action pair.
a crucial step of the algorithm is the computation of      
t . this is done by the procedure
optsolve (cf. algorithm 11), using undiscounted value iteration over a special mdp. in
this mdp, the actions are of the form of a pair (a, p), where a     a and p is a plausible next-
state distribution given the statistics collected so far at (x, a). the next-state distribution
associated to (a, p) is exactly p. further, the immediate reward at x associated to (a, p) is
the highest plausible reward given the local statistics at (x, a).

pac-mdp algorithms as mentioned before, an alternative to minimizing the regret
is to minimize the number of times the learner   s future expected return falls short of the
optimal return by a prespeci   ed margin (kakade, 2003). an online learning algorithm is
called pac-mdp if this measure can be bounded with high id203 as a polynomial
function of the natural parameters of the mdp and if in each time step polynomially many
computational steps are performed. algorithms that are known to be pac-mdp include r-
max (brafman and tennenholtz, 2002; kakade, 2003),14 mbie (strehl and littman, 2005),
delayed id24 (strehl et al., 2006), the optimistic-initialization-based algorithm of szita
and l  orincz (2008), and mormax by szita and szepesv  ari (2010). of these, mormax
enjoys the best bound for the number of   -suboptimal steps, t  . according to this bound,

14the published proofs for e3 (kearns and singh, 1998) and r-max concern a slightly di   erent criterion;
see the discussion of the previous section. kakade (2003) proved that (an improved version of) r-max is
pac-mdp. he also proved lower bounds.

53

2, n(cid:48)

3, r(cid:48)     0

algorithm 10 the ucrl2 algorithm.
function ucrl2(  )
input:        [0, 1] is a con   dence parameter
1: for all x     x do   [x]     a1
2: n2, n3, r, n(cid:48)
3: t     1
4: while true do
a       [x]
5:
if n(cid:48)
6:
7:
8:
9:
10:
end if
11:
(r, y )     executeinworld( a )
12:
2[x, a]     n(cid:48)
n(cid:48)
2[x, a] + 1
13:
3[x, a, y ]     n(cid:48)
n(cid:48)
3[x, a, y ] + 1
14:
r(cid:48)[x, a]     r(cid:48)[x, a] + r
15:
x     y
16:
t     t + 1
17:
18: end while

2[x, a]     max(1, n2[x, a]) then
2, n3     n3 + n(cid:48)
n2     n2 + n(cid:48)
3, r(cid:48)     0
2, n(cid:48)
n(cid:48)
       optsolve(n2, n3, r,   , t)
a       [x]

3, r     r + r(cid:48)

(cid:46) initialize policy
(cid:46) initialize arrays

(cid:46) enough new information?
(cid:46) update model

(cid:46) update policy

(cid:46) execute action in the    world   

with id203 1       ,

(cid:32)

|x||a|

(cid:19)2

(cid:18) vmax

  (1       )2

log

(cid:19)(cid:33)

(cid:18)1

  

,

t   =   o

where   o(  ) hides terms which are logarithmic in the mdp parameters and vmax is an upper
bound on the optimal value function (i.e., vmax     (cid:107)r(cid:107)   /(1       )). one notable feature of
this bounds that it scales (log) linearly with the size of the state space. a similar bound is
available for delayed id24 (though the dependence of this bound is worse on the other
parameters), but no bounds with this feature are yet available for the other algorithms. the
algorithms mentioned here all implement the ofu principle in some way.
the main issue with all these algorithms (including ucrl and its variants) is that they
are inherently limited to (small)    nite spaces. larger state-spaces are explicitly considered
by kakade et al. (2003) and strehl and littman (2008), who considered restricted classes
of mdps and provided    meta-algorithms    to address the exploration problem. there are
two di   culties with these approaches. first, in practice, it may be di   cult to verify if the
particular problem one is interested in belongs to the said classes of mdps. second, the
proposed algorithms require black-box mdp solvers. since solving large mdps is a di   cult
problem on its own, the algorithms may be hard to implement.

54

(cid:46) initialize policy

(cid:46) u[idx[1]]     u[idx[2]]     . . .

m           , m        
idx     sort(u)
for all x     x do
unew[  ]           
for all a     a do

algorithm 11 procedure for    nding an optimistic policy used by ucrl2.
function optsolve(n2, n3, r,   , t)
input: n2, n3 store counters, r stores total rewards,        [0, 1] is a con   dence parameter
1: u[  ]     0,   [  ]     a1
2: repeat
3:
4:
5:
6:
7:
8:
9:
10:
11:
12:
13:
14:
15:
16:
17:
18:
19:
20:
21:
22:
23:
24:
25:
26:

r     r[x, a] / n2[x, a] + sqrt( 7    ln(2    |x|    |a|    t /   ) / (2    max(1, n2[x, a])) )
c     sqrt( 14    ln(2    |a|    t /   ) / max(1, n2[x, a]) )
p[  ]     n3[x, a,   ] / n2[x, a]
p[idx[1]]     min(1, p[idx[1]] + c/2)
j     |x| + 1
repeat
j     j     1
p     sum(p[  ])     p[idx[j]]
p[idx[j]]     min(0, 1     p )

end for
m     max(m, unew     u[x]), m     min(m, unew     u[x])
u(cid:48)[x]     unew

until p + p[idx[j]]     1
v     r + inner product(p[  ], u[  ])
if v > unew then

  [x]     a, unew     v

end for
u     u(cid:48)

end if

27: until m     m < 1.0 / sqrt(t)
28: return   

an alternative to the above techniques is to use a bayesian approach to address the explo-
ration issue (e.g., dearden et al., 1998, 1999; strens, 2000; poupart et al., 2006; ross and
pineau, 2008). the pros and contras of this approach are the same as in the case of bandits,
the only di   erence being that the computational challenges multiply.
to the best of our knowledge, the only experimental works that concerns online learning in
continuous state mdps are due to jong and stone (2007) and nouri and littman (2009).
jong and stone (2007) proposed a method that can be interpreted as a practical implemen-
tation of the ideas in kakade et al. (2003), while nouri and littman (2009) experimented
with multi-resolution regression trees and    tted q-iteration. the main message of these
works is that explicit exploration control can indeed be bene   cial.
despite the potential huge performance gains that can result from using systematic explo-

55

ration, current practitioners of id23 largely neglect the issue of systematic
exploration or, at best, use simple heuristics to guide exploration. certainly, there are some
cases when systematic exploration is not needed (e.g., szepesv  ari, 1997; nascimento and
powell, 2009). further, some simple methods, such as optimistic initialization, might give
reasonable performance in practice. since systematic exploration is hardly possible without
a good collection of learning algorithms aimed at learning good policies in an e   cient man-
ner, in what follows, we will focus on reviewing the algorithms that might belong to such a
collection.

4.3 direct methods

in this section, we review algorithms whose aim is to approximate the optimal action-value
function q    directly. the reviewed algorithms can be thought of as sample-based, ap-
proximate versions of value iteration that generate some sequence of action-value functions
(qk; k     0). the idea is that if qk is close to q   , the policy that is greedy with respect to
qk will be close to optimal as shown by the bound (16).
the    rst algorithm that we review is id24 by watkins (1989). we start by describing
this algorithm for (small)    nite mdps, which is followed by a description of its various
extensions that work even in large mdps.

4.3.1 id24 in    nite mdps
fix a    nite mdp m = (x ,a,p0) and a discount factor   . the id24 algorithm of
watkins (1989) keeps an estimate qt(x, a) of q   (x, a) for each state-action pair (x, a)    
x    a. upon observing (xt, at, rt+1, yt+1), the estimates are updated as follows:

  t+1(q) = rt+1 +    max

a(cid:48)   a q(yt+1, a(cid:48))     q(xt, at),

qt+1(x, a) = qt(x, a) +   t   t+1(qt) i{x=xt,a=at},

(x, a)     x    a.

(34)

here at     a and (yt+1, rt+1)     p0(  | xt, at). when learning from a trajectory, xt+1 = yt+1,
but this is not necessary for the convergence of the algorithm. id24 is an instance of
td learning: the updates are based on the td-error   t+1(qt). algorithm 12 shows the
pseudocode of id24.
in stochastic equilibrium, one must have e [  t+1(q)| xt = x, at = a] = 0 for any (x, a)    
x    a that is visited in   nitely often. a trivial calculation shows that

e(cid:104)

  t+1(q)

(cid:12)(cid:12)(cid:12) xt = x, at = a

(cid:105)

= t    q (x, a)     q(x, a),

x     x , a     a,

56

algorithm 12 the function implementing the tabular id24 algorithm. this function
must be called after each transition.
function qlearning(x, a, r, y, q)
input: x is the last state, a is the last action, r is the immediate reward received, y is
1:        r +       maxa(cid:48)   a q[y, a(cid:48)]     q[x, a]
2: q[x, a]     q[x, a] +         
3: return q

the next state, q is the array storing the current action-value function estimate

where t     is the bellman optimality operator de   ned by (15). hence, under the minimal
assumption that every state-action pair is visited in   nitely often, in stochastic equilibrium,
one must have t    q = q. using fact 3, we see that if the algorithm converges, it must
converge to q    under the stated condition. the sequence (qt; t     0) is indeed known to
converge to q    when appropriate local learning rates are used (tsitsiklis, 1994; jaakkola
et al., 1994).15 the rate of convergence of id24 was studied by szepesv  ari (1997) in
an asymptotic setting and later by even-dar and mansour (2003) in a    nite-sample setting.
the key observation that lead to the discovery of id24 is that unlike the optimal state
values, the optimal action-values can be expressed as expectations (compare equations (13)
and (15)). this, in turn, allows one to estimate the action-values in an incremental manner.
there exist multi-step versions of id24 (e.g., sutton and barto, 1998, section 7.6).
however, these are not as appealing (and straightforward) as the multi-step extensions of
td(0) since id24 is an inherently o   -policy algorithm: the temporal di   erences un-
derlying id24 do not telescope even when xt+1 = yt+1.

what policy to follow during learning? a major attraction of id24 is its sim-
plicity and that it allows one to use an arbitrary sampling strategy to generate the training
data provided that in the limit, all state-action pairs are updated in   nitely often.
in a
closed-loop situation, the commonly used strategies are to sample the actions following the
  -greedy action selection scheme or the boltzmann scheme (in the latter case, the id203
of selecting action a at time t is chosen to be proportional to e   qt(xt,a) ). with appropriate
tuning, one can then achieve asymptotic consistency of the behavior policy (cf., szepesv  ari,
1998, section 5.2 and singh et al., 2000). however, as discussed in section 4.2, in closed-
loop learning, more systematic exploration might be necessary to achieve reasonable online
performance.

post-decision states
in many practical problems, a set z (the set of    post-decision
states   ) smaller than x    a can be identi   ed such that the transition probabilities de-

15watkins (1989) did not provide a rigorous convergence analysis. watkins and dayan (1992) gave a proof

for the case when all policies eventually lead to an absorbing state.

57

compose according to

p(x, a, y) = pa(f (x, a), y),

x, y     x , a     a.

here f : x    a     z is some known transition function and pa : z    x     [0, 1] is
an appropriate id203 kernel. function f determines the deterministic    e   ect    of the
actions, while pa captures their stochastic e   ect. many operations research problems enjoy
this structure. for example, in the inventory control problem (example 1), f (x, a) = (x +
a)     m . further examples are given by powell (2007). note that sutton and barto (1998)
calls post-decision states    afterstates   .
if a problem admits post-decision states, learning the immediate reward function (if it is not
a : z     r, de   ned by
known) and the so-called post-decision state optimal value function, v    

(cid:88)

y   x

v    
a(z) =

pa(z, y) v    (y),

z     z,

a(f (x, a)), which follows immediately from the de   nitions.

need to compute argmaxa   a r(x, a) +   (cid:80)

might be both more economical and e   cient than learning an action-value function. update
rules and action selection strategies can be derived based on the identity q   (x, a) = r(x, a) +
  v    
to see another potential advantage of using post-decision state value functions, assume that
we have access to the transition probabilities.
in such a case, we might be tempted to
approximate the state-value function instead of approximating the action-value function.
then, in order to compute the greedy action (which is necessary in many algorithms), we
y   x p(x, a, y)v (y). this is a so-called stochastic
optimization problem (the modi   er    stochastic    refers to that the optimization objective is
de   ned with an expectation). this problem might be computationally challenging when the
number of next states is large, and/or the number of actions is large (e.g., if a is a large or
in   nite subset of a euclidean space), and/or p does not enjoy a nice structure. on the other
hand, if one uses a post-decision state value function va, then computing a greedy action
reduces to    nding argmaxa   a r(x, a) +   va(f (x, a)). thus, the expectation is avoided, i.e.,
no stochastic optimization problem needs to be solved. further, with a judiciously chosen
approximation architecture (such as piecewise linear, concave, separable), the optimization
problem might be tractable even for large (or in   nite) action spaces. thus, post-decision
state value functions might be advantageous as they allow one to avoid another layer of
complexity. of course, the same applies to using action-value functions, but, as discussed
previously, post-decision state value functions may require less storage and potentially require
fewer samples to learn than action-value functions. for further details, ideas and examples
consult (powell, 2007).

58

algorithm 13 the function implementing the id24 algorithm with linear function
approximation. this function must be called after each transition.
function qlearninglinfapp(x, a, r, y,   )
input: x is the last state, y is the next state, r is the immediate reward associated with
1:        r +       maxa(cid:48)   a   (cid:62)  [y, a(cid:48)]       (cid:62)  [x, a]
2:           +               [x, a]
3: return   

this transition,        rd parameter vector

4.3.2 id24 with function approximation
the obvious extension of id24 to function approximation with parametric forms (q  ;       
rd) is

  t+1 =   t +   t   t+1(q  t)     q  t(xt, at).

(compare this with (21) when    = 0). algorithm 13 shows the pseudocode corresponding to
the case when a linear function-approximation method is used, i.e., when q   =   (cid:62)   where
   : x    a     rd.
although the above update rule is widely used in practice, little can be said about its
convergence properties. in fact, since td(0) is a special case of this algorithm (when there
is only one action for every state), just like td(0), this update rule will also fail to converge
when o   -policy sampling or nonlinear function approximation is used (cf. section 3.2.1).
the only known convergence result is due to melo et al. (2008) who prove convergence
under rather restrictive conditions on the sample distribution. more recently, along the line
of the recent gradient-like td algorithms, maei et al. (2010b) proposed the greedy gradient
id24 (greedy gq) algorithm which lifts the previous restrictive conditions: this new
algorithm is guaranteed to converge independently of the sampling distribution. however,
since the objective function used in the derivation of this algorithm is non-convex, the
algorithm may get stuck in local minima even when used with linear function approximation.

state aggregation since the above update rule may fail to converge, it is natural to
restrict the value function-approximation method employed and/or modify the update pro-
cedure as necessary. in this spirit, let us    rst consider the case when q   is a state (and action)
aggregator (cf. section 3.2). then, if ((xt, at); t     0) is stationary then the algorithm will
behave exactly like tabular id24 in an appropriately de   ned    induced mdp   . hence
it will converge to some approximation of the optimal action-value function q    (bertsekas
and tsitsiklis, 1996, section 6.7.7).

59

action-value function has the form of a linear averager: q  (x, a) = (cid:80)d
si(x, a)     0 (i = 1, . . . , d) and (cid:80)d

soft state aggregation one undesirable property of aggregation is that the value function
will not be smooth at the boundaries of the underlying regions. singh et al. (1995) proposed
to address this by a    softened    version of id24. in their algorithm, the approximate
i=1 si(x, a)  i, where
i=1 si(x, a) = 1. the update rule is modi   ed so that at
any time, only one component of the parameter vector   t is updated. the component to
be updated is selected by randomly drawing an index it     {1, . . . , d} from the multinomial
distribution with parameters (s1(xt, at), . . . , sd(xt, at)).

interpolation-based id24 szepesv  ari and smart (2004) proposed a modi   cation
of this algorithm, which they call interpolation based id24 (ibid24). ibq simul-
taneously updates all the components of the parameter vector thereby reducing the updates   
variance. ibid24 can also be viewed as a generalization of id24 used with state
and action aggregation to interpolators (tsitsiklis and van roy, 1996, section 8 discusses
interpolators in the context of    tted value iteration with known models). the idea is to
treat every component   i of the parameter vector as a value estimate of some    representa-
tive    state-action pair, (xi, ai)     x    a (i = 1, . . . , d). that is, (q  ;        rd) is chosen such
that q  (xi, ai) =   i holds for all i = 1, . . . , d. this makes q   an interpolator (explaining
the name of the algorithm). next, choose the similarity functions si : x    a     [0,   ). for
example, one can use si(x, a) = exp(   c1d1(x, xi)2     c2d2(a, ai)2), where c1, c2 > 0, and d1, d2
are appropriate    distance    functions. the update rule of ibid24 is as follows:

  t+1,i = rt+1 +    max

a(cid:48)   a q  t(yt+1, a(cid:48))     q  t(xi, ai),

  t+1,i =   t,i +   t,i   t+1,i si(xt, at),

i = 1, . . . , d.

each component is updated based on how well it predicts the total future reward and how
similar its associated state-action pair is to the state-action pair just visited. if the similarity
is small, the impact of the error   t+1,i on the change of the component will also be small.
the algorithm uses local step-size sequences, (  t,i; t     0), i.e., one step-size for each of the
components.
szepesv  ari and smart (2004) prove that this algorithm converges almost surely as long as (i)
the function-class q   satis   es the above interpolation property and the mapping    (cid:55)    q   is a
non-expansion (i.e., (cid:107)q     q  (cid:48)(cid:107)        (cid:107)       (cid:48)(cid:107)    holds for any   ,   (cid:48)     rd); (ii) the local step-size
sequences (  t,i; t     0) are appropriately chosen and (iii) all regions of the state-action space
x    a are    su   ciently visited    by ((xt, at); t     0). they also provide error bounds on the
quality of the action-value function learned. the heart of the analysis is that since    (cid:55)    q  

60

algorithm 14 the function implementing one iteration of the    tted q-iteration algorithm.
the function must be called until some criterion of convergence is met. the methods pre-
dict and regress are speci   c to the regression method chosen. the method predict(z,   )
should return the predicted value at the input z given the regression parameters   , while
regress(s), given a list of input-output pairs s, should implement a regression algorithm
that solves the regression problem given by s and returns new parameters that can be used
in predict.
function fittedq(d,   )
input: d = ((xi, ai, ri+1, yi+1); i = 1, . . . , n) is a list of transitions,    are the regressor
1: s     []
2: for i = 1     n do

(cid:46) create empty list

parameters

(cid:46) target at (xi, ai)

t     ri+1 + maxa(cid:48)   a predict((yi+1, a(cid:48)),   )
s     append(s,(cid:104)(xi, ai), t(cid:105))

3:
4:
5: end for
6:        regress(s)
7: return   

is a non-expansion, the algorithm implements an incremental approximate version of value
iteration, with the underlying operator being a contraction. this is because a non-expansion
applied after a contraction or a contraction applied after a non-expansion is a contraction.
the idea of using non-expansions has    rst appeared in the works of gordon (1995) and
tsitsiklis and van roy (1996) in the study of    tted value iteration.

fitted q-iteration fitted q-iteration implements    tted value iteration with action-value
functions. given the previous iterate, qt, the idea is to form a monte-carlo approximation
to (t    qt)(x, a) at selected state-action pairs and then regress on the resulting points using
one   s favorite regression method. algorithm 14 shows the pseudocode of this method.
it is known that    tted q-iteration might diverge unless a special regressor is used (baird,
1995; boyan and moore, 1995; tsitsiklis and van roy, 1996). ormoneit and sen (2002)
suggest to use kernel averaging, while ernst et al. (2005) suggest using tree based regressors.
these are guaranteed to converge (say, if the same data is fed to the algorithm in each
iteration) as they implement local averaging and as such results of gordon (1995); tsitsiklis
and van roy (1996) are applicable to them.
riedmiller (2005) reports good empirical
results with neural networks, at least when new observations obtained by following a policy
greedy with respect to the latest iterate are incrementally added to the set of samples used
in the updates. that the sample is changed is essential if no good initial policy is available,
i.e., when in the initial sample states which are frequently visited by    good    policies are
underrepresented (a theoretical argument for why this is important is given by van roy
(2006) in the context of state aggregation).

61

antos et al. (2007) and munos and szepesv  ari (2008) prove    nite-sample performance bounds
that apply to a large class of regression methods that use empirical risk minimization over
a    xed space f of candidate action-value functions. their bounds depend on the worst-case
bellman error of f:

1(f) = sup
e   
q   f

q(cid:48)   f (cid:107)q(cid:48)     t    q(cid:107)   ,

inf

1(f) mea-
where    is the distribution of state-action pairs in the training sample. that is, e   
sures how close f is to t    f def= {t    q| q     f}. the bounds derived have the form of the
   nite-sample bounds that hold in supervised learning (cf. equation 33), except that the
1(f). note that in the earlier-mentioned counterexam-
approximation error is measured by e   
1(f) =    , suggesting that it is the lack of
ples to the convergence of    tted-value iteration, e   
   exibility of the function approximation method that causes divergence.

4.4 actor-critic methods

actor-critic methods implement generalized policy iteration. remember that policy iteration
works by alternating between a complete policy evaluation and a complete policy improve-
ment step. when using sample-based methods or function approximation, exact evaluation
of the policies may require in   nitely many samples or might be impossible due to the restric-
tions of the function-approximation technique. hence, id23 algorithms
simulating policy iteration must change the policy based on incomplete knowledge of the
value function.
algorithms that update the policy before it is completely evaluated are said to implement
generalized policy iteration (gpi). in gpi, there are two closely interacting processes of an
actor and a critic: the actor aims at improving the current policy, while the critic evaluates
the current policy, thus helping the actor. the interaction of the actor and the critic is
illustrated on figure 7 in a closed-loop learning situation.
note that, in general, the policy that is used to generate the samples (i.e., the behavior
policy) could be di   erent from the one that is evaluated and improved in the actor-critic
system (i.e., the target policy). this can be useful because the critic must learn about actions
not preferred by the current target policy so that the critic can improve the target policy.
this is impossible to achieve if the behavior policy is the same as the target policy and if
the target policy is deterministic. this is one reason the target policy is usually a stochastic
policy. however, even if the target policy is stochastic, the quality of the estimates of the
values of low-id203 actions can be very poor since less information is received for such
actions. it might appear then that choosing actions completely at random might give the
most information. however, this is clearly not the case since such a random policy might not
visit the important parts of the state-space, as discussed before. therefore, in practice, the

62

figure 7: the actor-critic architecture

behavior policy often mixes a certain (small) amount of exploration into the target policy.
there are many ways to implement an actor-critic architecture. if the action-space is small,
the critic may, e.g., use an approximate action-value function and the actor could follow an
  -greedy or boltzmann exploration strategy. if the action-space is large or continuous, the
actor itself may use function-approximation.
note that unlike perfect policy iteration, a gpi method may generate a policy that is sub-
stantially worse than the previous one. thus, the quality of the sequence of generated policies
may oscillate or even diverge when the policy evaluation step is incomplete, irrespective of
whether policy improvement is exact or approximate (bertsekas and tsitsiklis, 1996, exam-
ple 6.4, p. 283). in practice, gpi tends to generate policies that improve at the beginning.
however, at later stages, the policies often oscillate. a common practice, therefore, is to
store the sequence of policies obtained and when learning is over, measure the performance
of the stored policies by running some tests and then select the empirically best performing
one.
just like in the case of    tted value iteration, the performance of actor-critic methods can
be controlled by increasing the       exibility    of the function approximation methods. finite-
sample performance bounds are given by antos et al. (2007) when both the actor and the
critic use function approximation.
in the next section (section 4.4.1), we    rst describe value estimation methods (used by the
critic), while in section 4.4.2, we describe some methods that implement policy improvement
(used by the actor). in particular, we    rst describe greedy methods of policy improvement,
followed by a somewhat di   erent idea when the actor uses gradient ascent on the performance
function de   ned by a parametric family of policies.

63

  rewardstateactionsystemsystemactoractorcriticcriticvalues4.4.1

implementing a critic

the job of the critic is to estimate the value of the current target policy of the actor.
this is a value prediction problem. therefore, the critic can use the methods described in
section 3. since the actor needs action values, the algorithms are typically modi   ed so that
they estimate action values directly. when td(  ) is appropriately extended, the algorithm
known as sarsa(  ) is obtained. this is the    rst algorithm that we describe below. when
lstd(  ) is extended, we get lstd-q(  ), which is described next.   -lspe could also be
extended, but, for the sake of brevity, this extension is not discussed here.

sarsa in the case of    nite (and small) state and action spaces, similarly to id24,
sarsa keeps track of the action-value underlying the possible state-action pairs (rummery
and niranjan, 1994):

  t+1(q) = rt+1 +    q(yt+1, a(cid:48)

t+1)     q(xt, at),
qt+1(x, a) = qt(x, a) +   t   t+1(qt) i{x=xt,a=at},

(x, a)     x    a.

(35)

t+1       (  |yt+1). compared to id24, the dif-
here (yt+1, rt+1)     p0(  | xt, at) and a(cid:48)
ference is in the de   nition of the td error. the algorithm got its name from its use of the
current state, current action, next reward, next state, and next action. when    is    xed,
sarsa is just td(0) applied to state-action pairs. hence, its convergence follows from the
convergence results underlying td(0).
the multi-step extension of sarsa follows along the lines of the similar extension of td(0),
giving rise to the sarsa(  ) algorithm due to rummery and niranjan (1994); rummery
(1995). the tabular algorithms can be extended to the case of function approximation the
same way tabular td(  ) was extended. algorithm 15 shows the pseudocode of sarsa(  )
when it is used with linear function approximation. being a td-algorithm, the resulting
algorithm is subject to the same limitations as td(  ) (cf. section 3.2.1), i.e., it might
diverge in o   -policy situations. it is, however, possible to extend gtd2 and tdc to work
with action values (and use    > 0) so that the resulting algorithms would become free of
these limitations. for details consult (maei and sutton, 2010).

lstd-q(  ) when lstd(  ) is generalized to action-value functions, we get the lstd-
q(  ) algorithm, which solves (30), where now   t =   (xt, at),    : x    a     rd, and

  t+1(  ) = rt+1 +   vt+1     q  (xt, at),

64

algorithm 15 the function implementing the sarsa(  ) algorithm with linear function
approximation. this function must be called after each transition.
function sarsalambdalinfapp(x, a, r, y, a(cid:48),   , z)
input: x is the last state, a is the last action chosen, r is the immediate reward received
when transitioning to y , where action a(cid:48) is chosen.        rd is the parameter vector of
the linear function approximation, z     rd is the vector of eligibility traces

1:        r +         (cid:62)  [y, a(cid:48)]       (cid:62)  [x, a]
2: z       [x, a] +             z
3:           +             z
4: return (  , z)

where, assuming that the policy    to be evaluated is a stochastic policy, vt+1 is given by

vt+1 =

  (a|yt+1)q  (yt+1, a) = (cid:104)   ,

  (a|yt+1)  (yt+1, a)(cid:105).

(cid:88)

a   a

(cid:88)

a   a

(cid:80)

(for deterministic policies this simpli   es to vt+1 = q  (yt+1,   (yt+1)).)
if the action space is large and stochastic policies are considered, evaluating the sums
a   a   (a|x)  (x, a) (or integrals in the case of continuous action spaces) might be infea-
t+1       (  |yt+1) and
t+1). when the sample consists of trajectories of   , one may set

features,    : x     rd, restrict    so that(cid:80)
and de   ne q  (x, a) =   (cid:62)(  (x) +   (x, a)). then v  (x) = (cid:80)

sible. one possibility then is to sample actions from the policy   : a(cid:48)
use vt+1 = q  (yt+1, a(cid:48)
a(cid:48)
t+1 = at+1, which gives rise to    sarsa-like    version of lstd-q(  ).
an alternative, which is expected to produce better estimates, is to introduce some state
a   a   (a|x)  (x, a) = 0 holds for any state x     x
a   a   (a|x)q  (x, a) =   (cid:62)  (x).
hence, setting vt+1 = v  (yt+1) does not introduce any bias, while it is expected to reduce
variance since vt+1 does not depend on the randomness of a(cid:48)
t+1 (peters et al., 2003; peters
and schaal, 2008).16 we will further discuss this choice in the next section.
the pseudocode of lstd-q(  ) is shown as algorithm 16. note that just like in the case of
lstd(  ), the inverse in line 9 might not exist. following standard steps, it is possible to
derive a recursive version of lstd-q(  ).
finally, we note that the various td-errors de   ned in this section can also be used in the
sarsa algorithm.

4.4.2

implementing an actor

policy improvement can be implemented in two ways: one idea is moving the current policy
towards the greedy policy underlying the approximate action-value function obtained from

16peters et al. (2003); peters and schaal (2008) consider the special case when the parameters between

the approximate state-value function v   and the action-value function are not shared.

65

algorithm 16 the function implementing the lstd-q(  ) algorithm with linear function
approximation to evaluate a policy   . note that if    is a deterministic policy than the sum
in line 5 can be replaced by g       [yt+1,   (yt+1)].
function lstdqlambda(d,   )
input: d = ((xt, at, rt+1, yt+1); t = 0, . . . , n    1) is a list of transitions,    is the stochastic
policy to be evaluated
1: a, b, z     0
(cid:46) a     rd  d, b, z     rd
2: for t = 0 to n     1 do
f       [xt, at]
z                 z + f
g     sum(   (  |yt+1)      [yt+1,  ] )
a     a + z    (f           g)(cid:62)
b     b + rt+1    z

3:
4:
5:
6:
7:
8: end for
9:        a   1b
10: return   

the critic. another idea is to perform gradient ascent directly on the performance surface un-
derlying a chosen parametric policy class. in the next sections, we describe speci   c methods
that implement these ideas.

greedy improvements the closest to policy iteration is to let the critic evaluate the
current policy based on a lot of data and then switch to the policy that is greedy with
respect to the obtained action-value function. notice that if the action space is    nite, the
action choices of the greedy policy can be computed    on the    y    (on an as needed basis),
i.e., the greedy policy does not need to be explicitly computed or stored, making it possible
to use this algorithm in very large, or in   nite state spaces.
if the policy is evaluated by
lstd-q(0), this strategy gives rise to the lspi (least-squares policy iteration) algorithm of
lagoudakis and parr (2003). the variant that uses lstd-q(  ) to evaluate policies with a
batch of data is shown as algorithm 17.
finite-sample performance bounds for lspi and generalizations of it are obtained by antos
et al. (2008). antos et al. (2007) extend these results to continuous action spaces, where
given the current action value function q, the next policy is chosen to maximize

(cid:88)

x   x

(cid:90)

a

  q,   =

  (x)

q(x, a)   (da|x)

over a restricted policy class. they argue for the necessity of restricting the policies to
prevent over   tting in this case.
the methods mentioned above switch policies without enforcing continuity. this may be

66

algorithm 17 the function implementing the lspi(  ) algorithm with linear function ap-
proximation. in practice, the convergence criterion is often replaced by some other criterion.
greedypolicy(  ) should return a function that takes as arguments a pair of the form
(x, a) and return 1 for the action that maximizes   (cid:62)  (x,  ), while it returns 0, otherwise.
function lspi(d,   )
input: d = ((xt, at, rt+1, yt+1); t = 0, . . . , n     1) is a list of transitions,    is an accuracy
1:   (cid:48)     0
2: repeat
3:
4:

         (cid:48)
  (cid:48)     lstdqlambda(d, greedypolicy(  ))

parameter

5: until (cid:107)         (cid:48)(cid:107)       
6: return   

dangerous when the action-value function estimate of the last policy is inaccurate since if
the new policy is radically di   erent than the previous one, it might be hard for the algorithm
to recover from this    failure   . in such cases, incremental changes might work better.
one way to ensure incremental changes is to update the parameters    of a parametric policy-
class (    ;        rd   ) by performing stochastic gradient ascent on   q,     (e.g., bertsekas and
tsitsiklis, 1996, p. 317; kakade and langford, 2002 considers such incremental updates when
the policies are given in a tabular form). an indirect way of performing (approximately)
greedy updates is to choose the target policy to be an   -greedy policy (or a boltzmann-policy)
corresponding to the current action-value function. perkins and precup (2003) analyze this
choice with linear function approximation and when the behavior and target policies are the
same. they prove the following result: let    be the mapping of action-value functions to
policies that de   nes the policy updates. assume that (i) the exact td(0) solution is obtained
in each iteration and (ii)    is globally lipschitz with a lipschitz constant smaller than c(m)
and the image space of    contains only   -soft policies (with some    xed    > 0). then the
sequence of policies generated by the algorithm converges almost surely. the lipschitzness
property means that (cid:107)  q1       q2(cid:107)     l(cid:107)q1     q2(cid:107) holds for all action-value functions, where
both norms are the (unweighted) 2-norms. the constant c(m) depends on the mdp m. a
policy    is called   -soft, if   (a|x)        holds for all x     x , a     a. more recently, van roy
(2006) obtained non-trivial performance bounds for state aggregation for a similar setting.
the methods discussed so far update the policy quite infrequently. an alternative is to inter-
leave the updates of the policy and the value function. singh et al. (2000) prove asymptotic
consistency when glie (greedy in the limit with in   nite exploration) policies are followed
and tabular sarsa(0) is used as the critic.

67

policy gradient
in this section, we review id189 (for a sensitivity-
based approach, see cao, 2007). these methods perform stochastic gradient ascent on the
performance surface induced by a smoothly parameterized policy class    = (    ;        rd   ) of
stochastic stationary policies. when the action space is    nite, a popular choice is to use the
so-called gibbs policies:

    (a|x) =

(cid:80)

exp(  (cid:62)  (x, a))
a(cid:48)   a exp(  (cid:62)  (x, a(cid:48)))

,

x     x , a     a.

here    : x    a     rd   is an appropriate feature-extraction function. if the action space
is a subset of a da-dimension euclidean space, a popular choice is to use gaussian policies
when given some parametric mean g  (x, a) and covariance     (x, a) functions; the density
specifying the action-selection distribution under    is de   ned by

(cid:16)   (a     g  (x, a))(cid:62)     1

(cid:17)
   (x, a) (a     g  (x, a)

.

exp

    (a|x) =

(cid:112)(2  )dadet(    (x, a))

1

care must be taken to ensure that      is positive de   nite. for simplicity,      is often taken
to be      =   i with some    > 0.
given   , formally, the problem is to    nd the value of    corresponding to the best performing
policy:

argmax

  

     =?

here, the performance,     , can be measured by the expected return of policy     , with respect
to some initial distribution over the states.17 the initial distribution can be the stationary
distribution underlying the policy chosen, in which case maximizing      will be equivalent to
maximizing the long-run average reward (sutton et al., 1999a).

the policy gradient theorem assume that the markov chain resulting from following
any policy      is ergodic, regardless of the choice of   . the question is how to estimate the
gradient of     .
let      : x    a     rd   be the score function underlying     :

    (x, a) =

log     (a|x),

   
     

(x, a)     x    a.

  (x, a)    (cid:80)

de   ne

for example, in the case of gibbs policies, the score function takes the form     (x, a) =

a(cid:48)   a     (a(cid:48)|x)  (x, a(cid:48)).

g(  ) =(cid:0)q     (x, a)     h(x)(cid:1)     (x, a).

(36)

17an overall best policy, as measured by the value function, might not exist within the restricted class   .

68

here (x, a) is a sample from the stationary state-action distribution underlying policy     ;
q     is the action-value function of      and h is an arbitrary bounded function. according
to the policy gradient theorem (see, e.g., bhatnagar et al., 2009 and the references therein),
g(  ) is an unbiased estimate of the gradient:

          = e [g(  )] .

let (xt, at) be a sample from the stationary distribution underlying     t. then, for (  t; t    
0), the update rule

  gt =(cid:0)   qt(xt, at)     h(xt)(cid:1)     (xt, at),

implements stochastic gradient ascent as long as

  t+1 =   t +   t

  gt,

e(cid:104)   qt(xt, at)    t(xt, at)
(cid:105)

= e [q    t (x, a)    t(xt, at)] .

(37)

(38)

the role of h in (37) is to reduce the variance of the gradient estimate   gt so as to speed up
the rate of convergence of the algorithm. although a good choice can only gain a constant
factor in terms of speeding up convergence, in practice, the gain can be substantial. one
choice is h = v     t , i.e., the value function underlying policy     t. although this will not
explicitly minimize the variance of   gt (nor that of g(  t)), it is still expected to reduce the
variance compared to using h = 0 and is thus generally recommended. of course, the value
function of the current policy will normally not be available, but it must be estimated. this
can be done together with constructing an estimator   qt, as we shall see soon.
as the update rule (37) is an instance of stochastic gradient ascent, the sequence (  t) will
converge almost surely to some local optimum of     , provided that the step-size sequence
(  t; t     0) satis   es the rm conditions and the problem is su   ciently regular (in general,
though, only convergence to a stationary point of      can be proven).
the di   culty in implementing (37) is twofold: (i) one needs to construct an appropriate
estimator   qt (and possibly h); (ii) the random variables (xt, at) must come from the
stationary distribution of     t. in episodic problems, these di   culties can be addressed by
updating the parameters at the end of the episodes, giving rise to williams    reinforce
algorithm (williams, 1987). note that reinforce is a direct policy search algorithm as it
does not use value functions. it is also a member of the family of likelihood ratio methods
(glynn, 1990).
in non-episodic problems, a two-timescale algorithm can be used that constructs on esti-
mator   qt on the faster timescale using an appropriate value-function-estimation method

69

and updates the policy parameters on the slower timescale. we now describe an interesting
proposal to implement this, due to sutton et al. (1999a) and konda and tsitsiklis (1999).

compatible function approximation assume that a linear-in-the-parameters function
approximation is used to estimate   qt, but choose the feature-extraction function to be the
score function underlying the policy class:

q  (x, a) =   (cid:62)    (x, a),

(x, a)     x    a.

(39)

this choice of the function approximation method is called compatible with the policy pa-
rameterization. note that the basis functions depend on    (as    =   t changes,      will also
change). what is a suitable value of    for a    xed value   t? substituting q   for   qt in (38),
we get

e(cid:2)    t(xt, at)    t(xt, at)(cid:62)(cid:3)    = e [q    t (xt, at)    t(xt, at)] .

de   ne f   = e(cid:2)    (x, a)    (x, a)(cid:62)(cid:3), g   = e [q     (x, a)    (x, a)] and let      (  ) be the

solution to the linear system of equations

f      = g  .

when this equation holds, q     (  t) satis   es (38). notice that      (  ) is the parameter that
minimizes the mean-squared error

e(cid:2)(q  (x, a)     q     (x, a))2(cid:3) .

the above derivations suggest the following closed-loop learning algorithm: (i) at any time
t policy     t is followed, (ii)   t is updated on the faster timescale (say) by an appropriate
version of sarsa(1), (iii) the policy parameters are updated on the slower timescale by

  t+1 =   t +   t (q  t(xt, at)     h(xt))     t(xt, at).

(40)

algorithm 18 shows the corresponding pseudocode. konda and tsitsiklis (2003) proved that
(under some regularity conditions) lim inf t                t = 0 holds almost surely if the average-
cost version of sarsa(1) is used to update   t. they have also shown that if sarsa(  ) is
used and m   = lim inf t                t then lim     1 m   = 0.

natural actor-critic another possible update rule is

  t+1 =   t +   t   t,

(41)

70

algorithm 18 an actor-critic algorithm that uses compatible function approximation and
sarsa(1).
function sarsaactorcritic(x)
input: x is the current state
1:   ,   , z     0
2: a     a1
3: while true do
(r, y )     executeinworld( a )
4:
a(cid:48)     draw(    (y,  ))
5:
(  , z)     sarsalambdalinfapp(x, a, r, y, a(cid:48),   , z)
6:
          
7:
v     sum(     (y,   )      (cid:62)  [x,   ] )
8:
9:
x     y
10:
a     a(cid:48)
11:
12: end while

          +      (cid:0)  (cid:62)  [x, a]     v(cid:1)      

(cid:46) use    = 1 and    (cid:29)   

      log     (x, a)

(cid:46) pick any action

   f    1

            , we see that      (  )(cid:62)          =        (cid:62)

which de   nes the natural actor-critic (nac) algorithm (the pseudocode of the resulting
algorithm di   ers from that of algorithm 18 only in that in line 9 the update of    should
be replaced by           +         ). assuming that f   is positive de   nite, since g   =          
             > 0 unless           = 0.
and      (  ) = f    1
this shows that the above algorithm implements a stochastic pseudo-gradient algorithm,
and thus it converges under the same conditions as (40).
interestingly, the nac update result in a faster convergence rate than the previous rule.
the reason is that      (  ) can be shown to be a so-called natural gradient (amari, 1998)
of     . this was    rst noted by kakade (2001). following a natural gradient means that
the algorithm performs gradient ascent directly in a metric space underlying the objects
of interest, in this case in the space of stochastic policies (with an appropriate metric), as
opposed to performing gradient ascent in the (euclidean) metric space of the parameters
(note that the de   nition of a gradient is dependent on the metric used). in particular, that
     (  ) is a natural gradient implies that the actual parameterization becomes irrelevant in
the sense that the trajectories underlying the ode      =      (  ) are invariant to arbitrary
smooth equivalent reparameterizations of the policy class (    ;        rd   ). in the case of the
gibbs policy class, a non-singular linear transformation of the features is a simple example
for such a reparameterization. because of this invariance property, a natural gradient is
said to be covariant. it is believed that following a natural gradient generally improves the
behavior of gradient ascent methods. this is nicely demonstrated by kakade (2001) on a
simple two-state mdp, where the    normal    gradient is very small in a large part of the
parameter space, while the natural gradient behaves in a reasonable manner. other positive
examples were given by bagnell and schneider (2003); peters et al. (2003) and peters and

71

schaal (2008).
as to the estimation of      (  ), peters and schaal (2008) (and earlier peters et al. (2003))
suggest to use lstd-q(  ). in particular, they suggested using both state features and the
compatible state-action features as described in section 4.4.1 (note, however, that only    = 1
gives an unbiased estimate of the gradient). their algorithm keeps the value of   t    xed until
the parameter   t as calculated by lstd-q(  ) stabilizes. when this happens   t is updated
by (41) and the internal statistics collected by lstd-q(  ) is    discounted    by a discount
factor 0 <    < 1.
they also observe that the original actor-critic (barto et al., 1983;
sutton, 1984) when used in a    nite mdp with no function approximation implements a nac
update. more recently, bhatnagar et al. (2009) proposed several two-timescale algorithms
and proved the convergence of the policy parameters to a neighborhood of the local maxima
of the objective function when the critic uses td(0)-like updates.

5 for further exploration

inevitably, due to space constraints, this review must miss a large portion of the reinforce-
ment learning literature.

5.1 further reading

one topic of particular interest not discussed is e   cient sampling-based planning (kearns
et al., 1999; szepesv  ari, 2001; kocsis and szepesv  ari, 2006; chang et al., 2008). the main
lesson here is that o   -line planning in the worst-case can scale exponentially with the dimen-
sionality of the state space (chow and tsitsiklis, 1989), while online planning (i.e., planning
for the    current state   ) can break the curse of dimensionality by amortizing the planning
e   ort over multiple time steps (rust, 1996; szepesv  ari, 2001).
other topics of interest include the id135-based approaches (de farias and van
roy, 2003, 2004, 2006), dual id145 (wang et al., 2008), techniques based on
sample average approximation (shapiro, 2003) such as pegasus (ng and jordan, 2000),
online learning in mdps with arbitrary reward processes (even-dar et al., 2005; yu et al.,
2009; neu et al., 2010), or learning with (almost) no restrictions in a competitive framework
(hutter, 2004).
other important topics include learning and acting in partially observed mdps (for recent
developments, see, e.g., littman et al., 2001; toussaint et al., 2008; ross et al., 2008), learning
and acting in games or under some other optimization criteria (littman, 1994; heger, 1994;
szepesv  ari and littman, 1999; borkar and meyn, 2002), or the development of hierarchical
and multi-time-scale methods (dietterich, 1998; sutton et al., 1999b).

72

5.2 applications

the numerous successful applications of id23 include (in no particular or-
der) learning in games (e.g., backgammon (tesauro, 1994) and go (silver et al., 2007)),
applications in networking (e.g., packet routing (boyan and littman, 1994), channel alloca-
tion (singh and bertsekas, 1997)), applications to operations research problems (e.g., tar-
geted marketing (abe et al., 2004), maintenance problems (gosavi, 2004), job-shop schedul-
ing (zhang and dietterich, 1995), elevator control (crites and barto, 1996), pricing (rus-
mevichientong et al., 2006), vehicle routing (proper and tadepalli, 2006), inventory control
(chang et al., 2007),    eet management (sim  ao et al., 2009)), learning in robotics (e.g., con-
trolling quadrupedales (kohl and stone, 2004), humanoid robots (peters et al., 2003), or
helicopters (abbeel et al., 2007)), and applications to    nance (e.g., option pricing (tsitsiklis
and van roy, 1999b, 2001; yu and bertsekas, 2007; li et al., 2009)). for further applications,
see the lists at the urls

    http://www.cs.ualberta.ca/~szepesva/research/rlapplications.html and
    http://umichrl.pbworks.com/successes-of-reinforcement-learning.

5.3 software

there are numerous software packages that support the development and testing of rl
algorithms. perhaps, the most notable of these are the rl-glue and rl-library pack-
ages. the rl-glue package available from http://glue.rl-community.org is intended
for helping to standardize rl experiments. it is a free, language-neutral software package
that implements a standardized rl interface (tanner and white, 2009). the rl-library
(http://library.rl-community.org) builds on the top of rl-glue.
its purpose is to
provide trusted implementations of various rl testbeds and algorithms. the most notable
other rl software packages are clsquare,18 piqle,19 rl toolbox,20 jrlf21 and libpg.22
these o   er the implementation of a large number of algorithms, testbeds, intuitive visual-
izations, programming tools, etc. many of these packages support rl-glue.

5.4 acknowledgements

i am truly indebted to my family for their love, support and patience. thank you mom,
be  ata, d  avid, r  eka, eszter, csongor! special thanks to r  eka who helped me draw figure 3.

18http://www.ni.uos.de/index.php?id=70
19http://piqle.sourceforge.net/
20http://www.igi.tugraz.at/ril-toolbox/
21http://mykel.kochenderfer.com/?page_id=19
22http://code.google.com/p/libpgrl/

73

a number of individuals have read various versions of the manuscript, full or in parts and
helped me to reduce the number of mistakes by sending corrections. they include dimitri
bertsekas, g  abor bal  azs, bernardo avila pires, warren powell, rich sutton, nikos vlassis,
hengshuai yao and shimon whiteson. thank you! of course, all the remaining mistakes
are mine. if i have left out someone from the above list, this was by no means intentional.
if this is the case, please remind me in an e-mail (better yet, send me some comments or
suggestions). independently of whether they have contacted me before or not, readers are
encouraged to e-mail me if they    nd errors, typos or they just think that some topic should
have been included (or left out). i plan to periodically update the text and i will try to
accommodate all the requests. finally, i wish to thank remi munos, and rich sutton, my
closest collaborators over the last few years, from whom i have learned and continue to learn
a lot. i also wish to thank all my students, the members of rlai group and all researchers
of rl who continue to strive to push the boundaries of what we can do with reinforcement
learning. this book is made possible by you.

a the theory of discounted markovian decision pro-

cesses

the purpose of this section is to give a short proof of the basic results of the theory of
markovian decision processes. all the results will be worked out for the discounted expected
total cost criterion. first, we give a short overview of contraction mappings and banach   s
   xed-point theorem. next, we show how this powerful result can be applied to proof a
number of basic results about value functions and optimal policies.

a.1 contractions and banach   s    xed-point theorem

we start with some basic de   nitions which we will need in the rest of this section.
de   nition 1 (norm). let v be a vector space over the reals. then f : v     r+
on v provided that the following hold:

0 is a norm

1. if f (v) = 0 for some v     v then v = 0;
2. for any        r, v     v , f (  v) = |  | f (v);
3. for any v, u     v , f (v + u)     f (v) + f (u).

a vector space together with a norm is called a normed vector space.

74

according to the de   nition a norm is a function that assigns a nonnegative number to each
vector. this number is often called the    length    or just the    norm    of the vector. the norm
of a vector v is often denoted by (cid:107)v(cid:107).
example 3: here are a few examples of norms over the vector space v = (rd, +,     ).

1. (cid:96)p norms: for p     1,

2. (cid:96)    norm:

(cid:32) d(cid:88)

(cid:33)1/p

(cid:107)v(cid:107)p =

|vi|p

.

i=1

(cid:107)v(cid:107)    = max
1   i   d

|vi|.

3. the weighted variants of these norms are de   ned as follows:

(cid:17)1/p

(cid:16)(cid:80)d

         

|vi|p
wi
max1   i   d

i=1

|vi|
wi

,

(cid:107)v(cid:107)p =

,

if 1     p <    ;
if p =    ,

where wi > 0.

4. the matrix-weighted 2-norm is de   ned as follows:

(cid:107)v(cid:107)2

p = vt p v.

here p is a    xed, positive de   nite matrix.

similarly, one can de   ne norms over spaces of functions. for example, if v is the vector
space of functions over the domain x which are bounded then

(cid:107)f(cid:107)    = sup
x   x

|f (x)|.

(a function is called bounded exactly when (cid:107)f(cid:107)    < +   .)
we will be interested in the convergence of sequences in normed vector spaces.
de   nition 2 (convergence in norm). let v = (v,(cid:107)    (cid:107)) be a normed vector space. let
vn     v be a sequence of vectors (n     n). the sequence (vn; n     0) is said to converge to
the vector v in the norm (cid:107)    (cid:107) if limn       (cid:107)vn     v(cid:107) = 0. this will be denoted by vn    (cid:107)  (cid:107) v.
note that in a d-dimensional vector space vn    (cid:107)  (cid:107) v is the same as requiring that for each
1     i     d, vn,i     vi (here vn,i denotes the ith component of vn). however, this does not hold
for in   nite dimensional vector spaces. take for example x = [0, 1] and the space of bounded

75

functions over x . let

         1,

0,

fn(x) =

if x < 1/n;

otherwise .

de   ne f so that f (x) = 0 if x (cid:54)= 0 and f (0) = 1. then fn(x)     f (x) for each x (i.e., fn
converges to f (x) pointwise). however, (cid:107)fn     f(cid:107)    = 1 (cid:54)    0.
if we have a sequence of real-numbers (an; n     0), we can test if the sequence converges
without the knowledge of the limiting value by verifying if it is a cauchy sequence, i.e.,
whether limn       supm   n |an     am| = 0. (   sequences with vanishing oscillations    is possibly
a more descriptive name for cauchy sequences.) it is a quite notable property of the real
numbers that every cauchy sequence of reals assumes a limit.
the extension of the concept of cauchy sequences to normed vector spaces is straightforward:
de   nition 3 (cauchy sequence). let (vn; n     0) be a sequence of vectors of a normed vector-
space v = (v,(cid:107)    (cid:107)). then vn is called a cauchy-sequence if limn       supm   n (cid:107)vn     vm(cid:107) = 0.

normed vector spaces where all cauchy sequences are convergent are special: one can    nd
examples of normed vector spaces such that some of the cauchy sequences in the vector
space do not have a limit.

de   nition 4 (completeness). a normed vector space v is called complete if every cauchy
sequence in v is convergent in the norm of the vector space.

to pay tribute to banach, the great polish mathematician of the    rst half of the 20th century,
we have the following de   nition:

de   nition 5 (banach space). a complete, normed vector space is called a banach space.

one powerful result in the theory of banach spaces concerns contraction mappings, or con-
traction operators. these are special lipschitzian mappings:
de   nition 6. let v = (v,(cid:107)    (cid:107)) be a normed vector space. a mapping t : v     v is called
l-lipschitz if for any u, v     v ,

(cid:107)t u     t v(cid:107)     l(cid:107)u     v(cid:107).

a mapping t is called a non-expansion if it is lipschitzian with l     1.
it is called a
contraction if it is lipschitzian with l < 1. in this case, l is called the contraction factor of
t and t is called an l-contraction.
note that if t is lipschitz, it is also continuous in the sense that if vn    (cid:107)  (cid:107) v then also
t vn    (cid:107)  (cid:107) t v. this is because (cid:107)t vn     t v(cid:107)     l(cid:107)vn     v(cid:107)     0 as n        .

76

de   nition 7 (fixed point). let t : v     v be some mapping. the vector v     v is called
a    xed point of t if t v = v.
theorem 1 (banach   s    xed-point theorem). let v be a banach space and t : v     v
be a contraction mapping. then t has a unique    xed point. further, for any v0     v , if
vn+1 = t vn then vn    (cid:107)  (cid:107) v, where v is the unique    xed point of t and the convergence is
geometric:

(cid:107)vn     v(cid:107)       n(cid:107)v0     v(cid:107).

proof. pick any v0     v and de   ne vn as in the statement of the theorem. we    rst demon-
strate that (vn) converges to some vector. then we will show that this vector is a    xed point
of t . finally, we show that t has a single    xed point.
assume that t is a   -contraction. to show that (vn) converges it su   ces to show that (vn)
is a cauchy sequence (since v is a banach, i.e., complete normed vector-space). we have

(cid:107)vn+k     vn(cid:107) = (cid:107)t vn   1+k     t vn   1(cid:107)

      (cid:107)vn   1+k     vn   1(cid:107) =   (cid:107)t vn   2+k     t vn   2(cid:107)
      2(cid:107)vn   2+k     vn   2(cid:107)

...

      n(cid:107)vk     v0(cid:107) .

now,

(cid:107)vk     v0(cid:107)     (cid:107)vk     vk   1(cid:107) + (cid:107)vk   1     vk   2(cid:107) + . . . + (cid:107)v1     v0(cid:107)
and, by the same logic as used before, (cid:107)vi     vi   1(cid:107)       i   1(cid:107)v1     v0(cid:107). hence,

(cid:107)vk     v0(cid:107)    (cid:0)  k   1 +   k   2 + . . . + 1(cid:1) (cid:107)v1     v0(cid:107)     1
(cid:19)

(cid:18) 1

1       

(cid:107)vn+k     vn(cid:107)       n

(cid:107)v1     v0(cid:107)

,

1       

(cid:107)v1     v0(cid:107).

thus,

and so

(cid:107)vn+k     vn(cid:107) = 0,

n       sup
lim
k   0

showing that (vn; n     0) is indeed a cauchy sequence. let v be its limit.
now, let us go back to the de   nition of the sequence (vn; n     0):

taking the limes of both sides, on the one hand, we get that vn+1    (cid:107)  (cid:107) v. on the other

vn+1 = t vn.

77

hand, t vn    (cid:107)  (cid:107) t v, since t is a contraction, hence it is continuous. thus, the left-hand side
converges to v, while the right-hand side converges to t v, while the left and right-hand sides
are equal. therefore, we must have v = t v, showing that v is a    xed point of t .
let us consider the problem of uniqueness of the    xed point of t . let us assume that v, v(cid:48)
are both    xed points of t . then, (cid:107)v     v(cid:48)(cid:107) = (cid:107)t v     t v(cid:48)(cid:107)       (cid:107)v     v(cid:48)(cid:107), or (1      )(cid:107)v     v(cid:48)(cid:107)     0.
since a norm takes only nonnegative values and    < 1, we get that (cid:107)v     v(cid:48)(cid:107) = 0. thus,
v     v(cid:48) = 0, or v = v(cid:48),    nishing the proof of the    rst part of the statement.
for the second part, we have

(cid:107)vn     v(cid:107) = (cid:107)t vn   1     t v(cid:107)

      (cid:107)vn   1     v(cid:107) =   (cid:107)t vn   2     t v(cid:107)
      2(cid:107)vn   2     v(cid:107)

...

      n(cid:107)v0     v(cid:107).

a.2 application to mdps
for the purpose of this section, we de   ne v     by

v    (x) = sup
       stat

v   (x),

x     x .

thus, v    (x) is an upper bound on the value that we can achieve by choosing some stationary
policy   . note that if the supremum was taken over the larger class of all policies, we could
possibly get a larger function. however, in the case of mdps considered in this section, these
two optimal value functions are actually the same. although, this is not hard to prove, we
omit the proof.
let b(x ) be the space of bounded functions with domain x :

b(x ) = { v : x     r : (cid:107)v (cid:107)    < +   } .

in what follows, we will view b(x ) as a normed-vector space with the norm (cid:107)  (cid:107)   . it is easy
to show that (b(x ),(cid:107)    (cid:107)   ) is complete: if (vn; n     0) is a cauchy sequence in it then for
any x     x , (vn(x); n     0) is also a cauchy sequence over the reals. denoting by v (x) the
limit of (vn(x)), one can show that (cid:107)vn     v (cid:107)        0. vaguely speaking, this holds because
(vn; n     0) is a cauchy sequence in the norm (cid:107)    (cid:107)    so the rate of convergence of vn(x) to

78

(cid:88)

y   x

(cid:88)

y   x

(cid:12)(cid:12)(cid:12)(cid:88)
(cid:88)
(cid:88)

y   x

y   x

y   x

v (x) is independent of x.
pick any stationary policy   . remember that the bellman operator underlying   , t    :
b(x )     b(x ), is de   ned by

(t   v )(x) = r(x,   (x)) +   

p(x,   (x), y)v (y),

x     x .

note that t    is well-de   ned: if u     b(x ), then t   u     b(x ) holds true.
it is easy to see that v    as de   ned by (7) is a    xed point to t   :

v   (x) = e [r1|x0 = x] +   

= t   v   (x).

p(x,   (x), y)e

  trt+2|x1 = y

it is also easy to see that t    is a contraction in (cid:107)    (cid:107)   :

(cid:34)    (cid:88)

t=0

(cid:35)

(cid:12)(cid:12)(cid:12)

(cid:107)t   u     t   v (cid:107)    =    sup
x   x
       sup
x   x
       sup
x   x

p(x,   (x), y)(u (y)     v (y))

p(x,   (x), y)|u (y)     v (y)|

p(x,   (x), y)(cid:107)u     v (cid:107)   

where the last line follows from(cid:80)

=    (cid:107)u     v (cid:107)   ,
y   x p(x,   (x), y) = 1.

it follows that in order to    nd v   , one can construct the sequence v0, t   v0, (t   )2v0, . . .,
which, by banach   s    xed-point theorem will converge to v    at a geometric rate.
now, recall the de   nition of the bellman optimality operator: t     : b(x )     b(x ),

(cid:40)

(cid:88)

y   x

(cid:41)

(t    v )(x) = sup
a   a

r(x, a) +   

p(x, a, y)v (y)

x     x .

,

(42)

again, t     is well-de   ned. we now show that t     is also a   -contraction with respect to the
supremum norm (cid:107)    (cid:107)   .
to see this    rst note that

| sup
a   a

f (a)     sup
a   a

g(a)|     sup
a   a

|f (a)     g(a)|,

which can be seen using an elementary case analysis. using this inequality and then pro-

79

ceeding as with the analysis of t    we get,

(cid:107)t    u     t    v (cid:107)          

sup

(x,a)   x  a

(cid:88)
(cid:88)

y   x

p(x, a, y)|u (y)     v (y)|

p(x, a, y)(cid:107)u     v (cid:107)   

      

sup

(x,a)   x  a
y   x
=    (cid:107)u     v (cid:107)   ,

thus proving the statement. here, the last equality follows by(cid:80)

y   x p(x, a, y) = 1.

the main result of this section is the following theorem:
theorem 2. let v be the    xed point of t     and assume that there is policy    which is greedy
w.r.t v : t   v = t    v . then v = v     and    is an optimal policy.
proof. pick any stationary policy   . then t        t     in the sense that for any function
v     b(x ), t   v     t    v holds (u     v means that u (x)     v (x) holds for any x     x ).
thus, v    = t   v        t    v   , i.e., v        t    v   . since t    u     t    v follows from u     v , we
also have t    v        (t    )2v   . chaining the inequalities, we get v        (t    )2v   . continuing
this way, we get for all n     0 that v        (t    )nv   . since t     is a contraction, the right-hand
side converges to v , the unique    xed point of t     (at this stage we cannot know if v = v    
or not). thus, v        v . since    was arbitrary, we get that v         v .
pick now a policy    such that t   v = t    v . since v is the    xed-point of t    , we have
t   v = v . since t    has a unique    xed point, v   , we have v    = v , showing that v     = v
and that    is an optimal policy.

in the statement of the theorem, we were careful in assuming that a greedy policy w.r.t. v
exists. note that this always holds for    nite action spaces, and it will hold for in   nite action
spaces under some extra (continuity) assumptions.
the following theorem serves as the basis of the policy iteration algorithm:

theorem 3 (policy improvement theorem). choose some stationary policy   0 and let    be
greedy w.r.t. v   0: t   v   0 = t    v   0. then v        v   0, i.e.,    is an improvement upon   0.
in particular, if t    v   0(x) > v   0(x) for some state x then    strictly improves upon   0 at x:
v   (x) > v   0(x). on the other hand, when t    v   0 = v   0 then   0 is an optimal policy.
proof. we have t   v   0 = t    v   0     t   0v   0 = v   0. applying t    to both sides, we get
(t   )2v   0     t   v   0     v   0. continuing this way, we get that for any n     0, (t   )nv   0     v   0.
taking the limit of both sides, we get that v        v   0.
for the second part, notice that we have (t   )nv   0(x)     t    v   0(x) > v   0(x). hence, taking
the limit, we have v   (x)     t    v   0(x) > v   0(x).

80

the third part is proven as follows: since t    v   0 = v   0, v   0 is a    xed point of t    . since
t     is a contraction, it has a single    xed point, v . thus v = v   0. but we also know that
v   0     v         v . hence,   0 must be an optimal policy.

the policy iteration procedure generates a sequence of policy   1,   2, . . . such that   i is greedy
w.r.t. v   i   1, i = 1, 2, . . .. let us assume further that when choosing a greedy policy, if no
improvement is possible, we keep the previous policy and stop the iteration.
we have the following immediate corollary:

corollary 4. if the mdp is    nite, the policy iteration procedure terminates in a    nite
number of steps and returns an optimal policy. further, a stationary policy of an mdp is
optimal if and only if its value function is a    xed point of t    .

proof. from the previous theorem, we know that the sequence of policies is strictly improv-
ing. since in a    nite mdp there are a    nite number of policies, the procedure must thus ter-
minate. when the procedure terminates, for the    nal policy   , we have t    v    = t   v    = v   .
thus, by the last part of the previous theorem,    is an optimal policy.
the second part follows immediately from theorem 3.
corollary 5. let v be the unique    xed point of t    . then any policy that is greedy w.r.t.
v is an optimal policy. further, if there exists an optimal stationary policy       then v = v    
and the policy       is greedy w.r.t. v    .

proof. the    rst part follows immediately from theorem 2.
for the second part, assume that       is an optimal stationary policy. hence, v      
thus, v      
t    v      

= v    .
. by the second part of corollary 4, we must in fact have

= t      
. thus v           v         v = v      

, i.e., all of them are equal and t      

v           t    v      

v     = t    v    .

= v      

the second part of this corollary in essence shows that the only policies that are optimal are
the ones which are greedy w.r.t. to v    .

references

a. prieditis, s. j. r., editor (1995). proceedings of the 12th international conference on

machine learning (icml 1995), san francisco, ca, usa. morgan kaufmann.

abbeel, p., coates, a., quigley, m., and ng, a. y. (2007). an application of reinforcement

learning to aerobatic helicopter    ight. in sch  olkopf et al. (2007), pages 1   8.

abe, n., verma, n. k., apt  e, c., and schroko, r. (2004). cross channel optimized marketing
in kim, w., kohavi, r., gehrke, j., and dumouchel, w.,

by id23.

81

editors, proceedings of the tenth acm sigkdd international conference on knowledge
discovery and data mining, pages 767   772, new york, ny, usa. acm.

albus, j. s. (1971). a theory of cerebellar function. mathematical biosciences, 10:25   61.

albus, j. s. (1981). brains, behavior, and robotics. byte books, subsidiary of mcgraw-

hill, peterborough, new hampshire.

amari, s. (1998). natural gradient works e   ciently in learning. neural computation,

10(2):251   276.

antos, a., munos, r., and szepesv  ari, c. (2007). fitted q-iteration in continuous action-

space mdps. in platt et al. (2008), pages 9   16.

antos, a., szepesv  ari, c., and munos, r. (2008). learning near-optimal policies with
bellman-residual minimization based    tted policy iteration and a single sample path.
machine learning, 71(1):89   129. published online first: 14 nov, 2007.

audibert, j.-y., munos, r., and szepesv  ari, c. (2009). exploration-exploitation trade-
o    using variance estimates in multi-armed bandits. theoretical computer science,
410(19):1876   1902.

auer, p., cesa-bianchi, n., and fischer, p. (2002). finite time analysis of the multiarmed

bandit problem. machine learning, 47(2-3):235   256.

auer, p., jaksch, t., and ortner, r. (2010). near-optimal regret bounds for reinforcement

learning. journal of machine learning research, 11:1563   1600.

bagnell, j. a. and schneider, j. g. (2003). covariant policy search. in gottlob, g. and walsh,
t., editors, proceedings of the eighteenth international joint conference on arti   cial
intelligence (ijcai-03), pages 1019   1024, san francisco, ca, usa. morgan kaufmann.

baird, l. c. (1995). residual algorithms: id23 with function approxima-

tion. in a. prieditis (1995), pages 30   37.

balakrishna, p., ganesan, r., sherry, l., and levy, b. (2008). estimating taxi-out times
with a id23 algorithm. in 27th ieee/aiaa digital avionics systems
conference, pages 3.d.3   1     3.d.3   12.

bartlett, p. l. and tewari, a. (2009). regal: a id173 based algorithm for rein-
forcement learning in weakly communicating mdps. in proceedings of the 25th annual
conference on uncertainty in arti   cial intelligence.

82

barto, a. g., sutton, r. s., and anderson, c. w. (1983). neuronlike adaptive elements that
can solve di   cult learning control problems. ieee transactions on systems, man, and
cybernetics, 13:834   846.

beleznay, f., gr  obler, t., and szepesv  ari, c. (1999). comparing value-function estima-
tion algorithms in undiscounted problems. technical report tr-99-02, mindmaker ltd.,
budapest 1121, konkoly th. m. u. 29-33, hungary.

berman, p. (1998). on-line searching and navigation. in fiat, a. and woeginger, g., editors,

online algorithms: the state of the art, chapter 10. springer, berlin, heidelberg.

bertsekas, d. p. (2007a). id145 and optimal control, volume 1. athena

scienti   c, belmont, ma, 3 edition.

bertsekas, d. p. (2007b). id145 and optimal control, volume 2. athena

scienti   c, belmont, ma, 3 edition.

bertsekas, d. p. (2010). approximate id145 (online chapter). in dynamic
programming and optimal control, volume 2, chapter 6. athena scienti   c, belmont, ma,
3 edition.

bertsekas, d. p., borkar, v. s., and nedi  c, a. (2004). improved temporal di   erence methods
with linear function approximation. in si, j., barto, a. g., powell, w. b., and wunsch ii,
d., editors, learning and approximate id145, chapter 9, pages 235   257.
ieee press.

bertsekas, d. p. and io   e, s. (1996). temporal di   erences-based policy iteration and appli-

cations in neuro-id145. lids-p-2349, mit.

bertsekas, d. p. and shreve, s. (1978). stochastic optimal control (the discrete time

case). academic press, new york.

bertsekas, d. p. and tsitsiklis, j. n. (1996). neuro-id145. athena scienti   c,

belmont, ma.

bhatnagar, s., sutton, r. s., ghavamzadeh, m., and lee, m. (2009). natural actor-critic

algorithms. automatica. in press.

borkar, v. s. (1997). stochastic approximation with two time scales. systems & control

letters, 29(5):291   294.

borkar, v. s. (1998). asynchronous stochastic approximations. siam j. control and opti-

mization, 36(3):840   851.

83

borkar, v. s. (2008). stochastic approximation: a dynamical systems viewpoint. cam-

bridge university press.

borkar, v. s. and meyn, s. p. (2002). risk-sensitive optimal control for markov decision

processes with monotone cost. mathematics of operations research, 27(1):192   209.

bottou, l. and bousquet, o. (2008). the tradeo   s of large scale learning. in platt et al.

(2008), pages 161   168.

boyan, j. a. (2002). technical update: least-squares temporal di   erence learning. machine

learning, 49:233   246.

boyan, j. a. and littman, m. l. (1994). packet routing in dynamically changing networks:
a id23 approach.
in cowan, j. d., tesauro, g., and alspector, j.,
editors, nips-6: advances in neural information processing systems: proceedings of the
1993 conference, pages 671   678. morgan kau   man, san francisco, ca, usa.

boyan, j. a. and moore, a. w. (1995). generalization in id23: safely

approximating the value function. in tesauro et al. (1995), pages 369   376.

bradtke, s. j. (1994). incremental id145 for on-line adaptive optimal
control. phd thesis, department of computer and information science, university of
massachusetts, amherst, massachusetts.

bradtke, s. j. and barto, a. g. (1996). linear least-squares algorithms for temporal di   er-

ence learning. machine learning, 22:33   57.

brafman, r. i. and tennenholtz, m. (2002). r-max - a general polynomial time algorithm
for near-optimal id23. journal of machine learning research, 3:213   
231.

busoniu, l., babuska, r., schutter, b., and ernst, d. (2010). id23
and id145 using function approximators. automation and control
engineering series. crc press.

cao, x. r. (2007). stochastic learning and optimization: a sensitivity-based approach.

springer, new york.

chang, h. s., fu, m. c., hu, j., and marcus, s. i. (2007). an asymptotically e   cient
ieee

simulation-based algorithm for    nite horizon stochastic id145.
transactions on automatic control, 52(1):89   94.

84

chang, h. s., fu, m. c., hu, j., and marcus, s. i. (2008). simulation-based algorithms for

id100. springer verlag.

chow, c. s. and tsitsiklis, j. n. (1989). the complexity of id145. journal

of complexity, 5:466   488.

cohen, w. w. and hirsh, h., editors (1994). proceedings of the 11th international conference

on machine learning (icml 1994), san francisco, ca, usa. morgan kaufmann.

cohen, w. w., mccallum, a., and roweis, s. t., editors (2008). proceedings of the 25th in-
ternational conference machine learning (icml 2008), volume 307 of acm international
conference proceeding series, new york, ny, usa. acm.

cohen, w. w. and moore, a., editors (2006). proceedings of the 23rd international confer-
ence on machine learning (icml 2006), volume 148 of acm international conference
proceeding series, new york, ny, usa. acm.

crites, r. h. and barto, a. g. (1996). improving elevator performance using reinforcement
learning. in touretzky, d., mozer, m. c., and hasselmo, m. e., editors, nips-8: advances
in neural information processing systems: proceedings of the 1995 conference, pages
1017   1023, cambridge, ma, usa. mit press.

s  im  sek, o. and barto, a. (2006). an intrinsic reward mechanism for e   cient exploration.

in cohen and moore (2006), pages 833   840.

danyluk, a. p., bottou, l., and littman, m. l., editors (2009). proceedings of the 26th
annual international conference on machine learning (icml 2009), volume 382 of acm
international conference proceeding series, new york, ny, usa. acm.

dasgupta, s. and freund, y. (2008). random projection trees and low dimensional manifolds.
in ladner, r. e. and dwork, c., editors, 40th annual acm symposium on theory of
computing, pages 537   546. acm.

de farias, d. p. and van roy, b. (2003). the id135 approach to approximate

id145. operations research, 51(6):850   865.

de farias, d. p. and van roy, b. (2004). on constraint sampling in the id135
approach to approximate id145. mathematics of operations research,
29(3):462   478.

de farias, d. p. and van roy, b. (2006). a cost-shaping linear program for average-cost
approximate id145 with performance guarantees. mathematics of oper-
ations research, 31(3):597   620.

85

de raedt, l. and wrobel, s., editors (2005). proceedings of the 22nd international confer-
ence on machine learning (icml 2005), volume 119 of acm international conference
proceeding series, new york, ny, usa. acm.

dearden, r., friedman, n., and andre, d. (1999). model based bayesian exploration. in
laskey, k. and prade, h., editors, proceedings of the fifteenth conference on uncertainty
in arti   cial intelligence (uai   99), pages 150   159. morgan kaufmann.

dearden, r., friedman, n., and russell, s. (1998). bayesian id24.

in proceedings
of the 15th national conference on arti   cial intelligence (aaai), pages 761   768. aaai
press.

dietterich, t. (1998). the maxq method for hierarchical id23. in shavlik

(1998), pages 118   126.

dietterich, t. g., becker, s., and ghahramani, z., editors (2001). advances in neural

information processing systems 14, cambridge, ma, usa. mit press.

domingo, c. (1999). faster near-optimal id23: adding adaptiveness to the
e3 algorithm. in watanabe, o. and yokomori, t., editors, proc. of the 10th international
conference on algorithmic learning theory, volume 1720 of lecture notes in computer
science, pages 241   251. springer.

engel, y., mannor, s., and meir, r. (2005). id23 with gaussian processes.

in de raedt and wrobel (2005), pages 201   208.

ernst, d., geurts, p., and wehenkel, l. (2005). tree-based batch mode reinforcement

learning. journal of machine learning research, 6:503   556.

even-dar, e., kakade, s. m., and mansour, y. (2005). experts in a markov decision pro-
cess. in saul, l. k., weiss, y., and bottou, l., editors, advances in neural information
processing systems 17, pages 401   408, cambridge, ma, usa. mit press.

even-dar, e., mannor, s., and mansour, y. (2002). pac bounds for multi-armed bandit
and id100. in kivinen, j. and sloan, r. h., editors, proceedings of
the 15th annual conference on computational learning theory computational learning
theory (colt 2002), volume 2375 of lecture notes in computer science, pages 255   270.
springer.

even-dar, e. and mansour, y. (2003). learning rates for id24. journal of machine

learning research, 5:1   25.

86

farahmand, a., ghavamzadeh, m., szepesv  ari, c., and mannor, s. (2008). regularized
   tted q-iteration: application to planning. in girgin, s., loth, m., munos, r., preux, p.,
and ryabko, d., editors, revised and selected papers of the 8th european workshop on
recent advances in id23 (ewrl 2008), volume 5323 of lecture notes
in computer science, pages 55   68. springer.

farahmand, a., ghavamzadeh, m., szepesv  ari, c., and mannor, s. (2009). regularized

policy iteration. in koller et al. (2009), pages 441   448.

frank, j., mannor, s., and precup, d. (2008). id23 in the presence of

rare events. in cohen et al. (2008), pages 336   343.

f  urnkranz, j., sche   er, t., and spiliopoulou, m., editors (2006). proceedings of the 17th

european conference on machine learning (ecml-2006). springer.

george, a. p. and powell, w. b. (2006). adaptive stepsizes for recursive estimation with

applications in approximate id145. machine learning, 65:167   198.

geramifard, a., bowling, m. h., zinkevich, m., and sutton, r. s. (2007). ilstd: eligibility

traces and convergence analysis. in sch  olkopf et al. (2007), pages 441   448.

ghahramani, z., editor (2007). proceedings of the 24th international conference on machine
learning (icml 2007), volume 227 of acm international conference proceeding series,
new york, ny, usa. acm.

ghavamzadeh, m. and engel, y. (2007). bayesian actor-critic algorithms. in ghahramani

(2007), pages 297   304.

gittins, j. c. (1989). multi-armed bandit allocation indices. wiley-interscience series in

systems and optimization. wiley, chichester, ny.

glynn, p. w. (1990). likelihood ratio gradient estimation for stochastic systems. commu-

nications of the acm, 33(10):75   84.

gordon, g. j. (1995). stable function approximation in id145. in a. priedi-

tis (1995), pages 261   268.

gosavi, a. (2003). simulation-based optimization: parametric optimization techniques and

id23. springer netherlands.

gosavi, a. (2004). id23 for long-run average cost. european journal of

operational research, 155(3):654   674.

87

gy  or   , l., kohler, m., krzy  zak, a., and walk, h. (2002). a distribution-free theory of

nonparametric regression. springer-verlag, new york.

gy  or   , l., kohler, m., krzy  zak, a., and walk, h. (2002). a distribution-free theory of

nonparametric regression. springer-verlag.

h  ardle, w. (1990). applied nonparametric regression. cambridge university press cam-

bridge.

heger, m. (1994). consideration of risk in id23.

in cohen and hirsh

(1994), pages 105   111.

howard, r. a. (1960). id145 and markov processes. the mit press,

cambridge, ma.

hutter, m.

(2004).
on algorithmic id203.

universal arti   cial

sions
http://www.idsia.ch/   marcus/ai/uaibook.htm.

based

intelligence:

springer, berlin.

sequential deci-
pages,

300

jaakkola, t., jordan, m., and singh, s. (1994). on the convergence of stochastic iterative

id145 algorithms. neural computation, 6(6):1185   1201.

jong, n. k. and stone, p. (2007). model-based exploration in continuous state spaces. in
miguel, i. and ruml, w., editors, 7th international symposium on abstraction, refor-
mulation, and approximation (sara 2007), volume 4612 of lecture notes in computer
science, pages 258   272, whistler, canada. springer.

kaelbling, l., littman, m., and moore, a. (1996). id23: a survey. journal

of arti   cial intelligence research, 4:237   285.

kakade, s. (2001). a natural policy gradient. in dietterich et al. (2001), pages 1531   1538.

kakade, s. (2003). on the sample complexity of id23. phd thesis, gatsby

computational neuroscience unit, university college london.

kakade, s., kearns, m. j., and langford, j. (2003). exploration in metric state spaces. in
fawcett, t. and mishra, n., editors, proceedings of the 20th international conference on
machine learning (icml 2003), pages 306   312. aaai press.

kakade, s. and langford, j. (2002). approximately optimal approximate reinforcement
learning. in sammut, c. and ho   mann, a. g., editors, proceedings of the 19th interna-
tional conference on machine learning (icml 2002), pages 267   274, san francisco, ca,
usa. morgan kaufmann.

88

kearns, m. and singh, s. (2002). near-optimal id23 in polynomial time.

machine learning, 49(2   3):209   232.

kearns, m. and singh, s. p. (1998). near-optimal performance for id23 in

polynomial time. in shavlik (1998), pages 260   268.

kearns, m. j., mansour, y., and ng, a. y. (1999). approximate planning in large pomdps

via reusable trajectories. in solla et al. (1999), pages 1001   1007.

keller, p. w., mannor, s., and precup, d. (2006). automatic basis function construction
for approximate id145 and id23. in cohen and moore
(2006), pages 449   456.

kocsis, l. and szepesv  ari, c. (2006). bandit based monte-carlo planning. in f  urnkranz

et al. (2006), pages 282   293.

kohl, n. and stone, p. (2004). policy gradient id23 for fast quadrupedal
locomotion. in proceedings of the 2004 ieee international conference on robotics and
automation, pages 2619   2624. ieee.

koller, d., schuurmans, d., bengio, y., and bottou, l., editors (2009). advances in neural

information processing systems 21, cambridge, ma, usa. mit press.

kolter, j. z. and ng, a. y. (2009). id173 and feature selection in least-squares

temporal di   erence learning. in danyluk et al. (2009), pages 521   528.

konda, v. r. and tsitsiklis, j. n. (1999). actor-critic algorithms. in solla et al. (1999),

pages 1008   1014.

konda, v. r. and tsitsiklis, j. n. (2003). on actor-critic algorithms. siam j. control and

optimization, 42(4):1143   1166.

kosorok, m. r. (2008). introduction to empirical processes and semiparametric id136.

springer.

lagoudakis, m. and parr, r. (2003). least-squares policy iteration. journal of machine

learning research, 4:1107   1149.

lai, t. l. and robbins, h. (1985). asymptotically e   cient adaptive allocation rules. ad-

vances in applied mathematics, 6:4   22.

lemieux, c. (2009). monte carlo and quasi-monte carlo sampling. springer.

89

li, y., szepesv  ari, c., and schuurmans, d. (2009). learning exercise policies for american
options. in proc. of the twelfth international conference on arti   cial intelligence and
statistics, jmlr: w&cp, volume 5, pages 352   359.

lin, l.-j. (1992). self-improving reactive agents based on id23, planning

and teaching. machine learning, 9:293   321.

littman, m. l. (1994). markov games as a framework for multi-agent id23.

in cohen and hirsh (1994), pages 157   163.

littman, m. l., sutton, r. s., and singh, s. p. (2001). predictive representations of state.

in dietterich et al. (2001), pages 1555   1561.

maei, h., szepesv  ari, c., bhatnagar, s., silver, d., precup, d., and sutton, r. (2010a).
convergent temporal-di   erence learning with arbitrary smooth function approximation.
in nips-22, pages 1204   1212.

maei, h., szepesv  ari, c., bhatnagar, s., and sutton, r. (2010b). toward o   -policy learning

control with function approximation. in wrobel et al. (2010).

maei, h. r. and sutton, r. s. (2010). gq(  ): a general gradient algorithm for temporal-
di   erence prediction learning with eligibility traces. in baum, e., hutter, m., and kitzel-
mann, e., editors, proceedings of the third conference on arti   cial general intelligence,
pages 91   96. atlantis press.

mahadevan, s. (2009). learning representation and control in id100:

new frontiers. foundations and trends in machine learning, 1(4):403   565.

mcallester, d. a. and myllym  aki, p., editors (2008). proceedings of the 24th conference in

uncertainty in arti   cial intelligence (uai   08). auai press.

melo, f. s., meyn, s. p., and ribeiro, m. i. (2008). an analysis of id23

with function approximation. in cohen et al. (2008), pages 664   671.

menache, i., mannor, s., and shimkin, n. (2005). basis function adaptation in temporal

di   erence id23. annals of operations research, 134(1):215   238.

mnih, v., szepesv  ari, c., and audibert, j.-y. (2008). empirical bernstein stopping.

in

cohen et al. (2008), pages 672   679.

munos, r. and szepesv  ari, c. (2008). finite-time bounds for    tted value iteration. journal

of machine learning research, 9:815   857.

90

nascimento, j. and powell, w. (2009). an optimal approximate id145
algorithm for the lagged asset acquisition problem. mathematics of operations research,
34:210   237.

nedi  c, a. and bertsekas, d. p. (2003). least squares policy evaluation algorithms with linear

function approximation. discrete event dynamic systems, 13(1):79   110.

neu, g., gy  orgy, a., and szepesv  ari, c. (2010). the online loop-free stochastic shortest-path

problem. in colt-10.

ng, a. y. and jordan, m. (2000). pegasus: a policy search method for large mdps and
pomdps. in boutilier, c. and goldszmidt, m., editors, proceedings of the 16th confer-
ence in uncertainty in arti   cial intelligence (uai   00), pages 406   415, san francisco ca.
morgan kaufmann.

nouri, a. and littman, m. (2009). multi-resolution exploration in continuous spaces. in

koller et al. (2009), pages 1209   1216.

ormoneit, d. and sen, s. (2002). kernel-based id23. machine learning,

49:161   178.

ortner, r. (2008). online regret bounds for id100 with deterministic
transitions. in freund, y., gy  or   , l., tur  an, g., and zeugmann, t., editors, proc. of the
19th international conference on algorithmic learning theory (alt 2008), volume 5254
of lecture notes in computer science, pages 123   137. springer.

parr, r., li, l., taylor, g., painter-wake   eld, c., and littman, m. l. (2008). an analysis of
linear models, linear value-function approximation, and feature selection for reinforcement
learning. in cohen et al. (2008), pages 752   759.

parr, r., painter-wake   eld, c., li, l., and littman, m. l. (2007). analyzing feature gener-

ation for value-function approximation. in ghahramani (2007), pages 737   744.

perkins, t. and precup, d. (2003). a convergent form of approximate policy iteration. in
s. becker, s. t. and obermayer, k., editors, advances in neural information processing
systems 15, pages 1595   1602, cambridge, ma, usa. mit press.

peters, j. and schaal, s. (2008). natural actor-critic. neurocomputing, 71(7   9):1180   1190.

peters, j., vijayakumar, s., and schaal, s. (2003). id23 for humanoid
robotics. in humanoids2003, third ieee-ras international conference on humanoid
robots, pages 225   230.

91

platt, j. c., koller, d., singer, y., and roweis, s. t., editors (2008). advances in neural

information processing systems 20, cambridge, ma, usa. mit press.

polyak, b. and juditsky, a. (1992). acceleration of stochastic approximation by averaging.

siam journal on control and optimization, 30:838   855.

poupart, p., vlassis, n., hoey, j., and regan, k. (2006). an analytic solution to discrete

bayesian id23. in cohen and moore (2006), pages 697   704.

powell, w. b. (2007). approximate id145: solving the curses of dimen-

sionality. john wiley and sons, new york.

proper, s. and tadepalli, p. (2006). scaling model-based average-reward reinforcement

learning for product delivery. in f  urnkranz et al. (2006), pages 735   742.

puterman, m. (1994). id100     discrete stochastic dynamic program-

ming. john wiley & sons, inc., new york, ny.

rasmussen, c. and williams, c. (2005). gaussian processes for machine learning (adaptive

computation and machine learning). the mit press.

rasmussen, c. e. and kuss, m. (2004). gaussian processes in id23. in
thrun, s., saul, l. k., and sch  olkopf, b., editors, advances in neural information pro-
cessing systems 16, pages 751   759, cambridge, ma, usa. mit press.

riedmiller, m. (2005). neural    tted q iteration        rst experiences with a data e   cient
neural id23 method. in gama, j., camacho, r., brazdil, p., jorge, a.,
and torgo, l., editors, proceedings of the 16th european conference on machine learning
(ecml-05), volume 3720 of lecture notes in computer science, pages 317   328. springer.

robbins, h. (1952). some aspects of the sequential design of experiments. bulletin of the

american mathematics society, 58:527   535.

ross, s. and pineau, j. (2008). model-based bayesian id23 in large struc-

tured domains. in mcallester and myllym  aki (2008), pages 476   483.

ross, s., pineau, j., paquet, s., and chaib-draa, b. (2008). online planning algorithms for

pomdps. journal of arti   cial intelligence research, 32:663   704.

rummery, g. a. (1995). problem solving with id23. phd thesis, cambridge

university.

92

rummery, g. a. and niranjan, m. (1994). on-line id24 using connectionist systems.
technical report cued/f-infeng/tr 166, cambridge university engineering depart-
ment.

rusmevichientong, p., salisbury, j. a., truss, l. t., van roy, b., and glynn, p. w. (2006).
opportunities and challenges in using online preference data for vehicle pricing: a case
study at general motors. journal of revenue and pricing management, 5(1):45   61.

rust, j. (1996). using randomization to break the curse of dimensionality. econometrica,

65:487   516.

scherrer, b. (2010). should one compute the temporal di   erence    x point or minimize the

bellman residual? the uni   ed oblique projection view. in wrobel et al. (2010).

sch  olkopf, b., platt, j. c., and ho   man, t., editors (2007). advances in neural information

processing systems 19, cambridge, ma, usa. mit press.

schraudolph, n. (1999). local gain adaptation in stochastic id119.

in ninth
international conference on arti   cial neural networks (icann 99), volume 2, pages
569   574.

shapiro, a. (2003). monte carlo sampling methods. in stochastic programming, handbooks

in or & ms, volume 10. north-holland publishing company, amsterdam.

shavlik, j. w., editor (1998). proceedings of the 15th international conference on machine

learning (icml 1998), san francisco, ca, usa. morgan kau   mann.

silver, d., sutton, r. s., and m  uller, m. (2007). id23 of local shape in
in veloso, m. m., editor, proceedings of the 20th international joint

the game of go.
conference on arti   cial intelligence (ijcai 2007), pages 1053   1058.

sim  ao, h. p., day, j., george, a. p., gi   ord, t., nienow, j., and powell, w. b. (2009). an
approximate id145 algorithm for large-scale    eet management: a case
application. transportation science, 43(2):178   197.

singh, s. p. and bertsekas, d. p. (1997). id23 for dynamic channel al-
location in cellular telephone systems. in mozer, m. c., jordan, m. i., and petsche, t.,
editors, nips-9: advances in neural information processing systems: proceedings of the
1996 conference, pages 974   980, cambridge, ma, usa. mit press.

singh, s. p., jaakkola, t., and jordan, m. i. (1995). id23 with soft state

aggregation. in tesauro et al. (1995), pages 361   368.

93

singh, s. p., jaakkola, t., littman, m. l., and szepesv  ari, c. (2000). convergence results for
single-step on-policy reinforcement-learning algorithms. machine learning, 38(3):287   308.

singh, s. p. and sutton, r. s. (1996). id23 with replacing eligibility

traces. machine learning, 32:123   158.

singh, s. p. and yee, r. c. (1994). an upper bound on the loss from approximate optimal-

value functions. machine learning, 16(3):227   233.

solla, s. a., leen, t. k., and m  uller, k. r., editors (1999). advances in neural information

processing systems 12, cambridge, ma, usa. mit press.

strehl, a. l., li, l., wiewiora, e., langford, j., and littman, m. l. (2006). pac model-free

id23. in cohen and moore (2006), pages 881   888.

strehl, a. l. and littman, m. l. (2005). a theoretical analysis of model-based interval

estimation. in de raedt and wrobel (2005), pages 857   864.

strehl, a. l. and littman, m. l. (2008). online id75 and its application to

model-based id23. in platt et al. (2008), pages 1417   1424.

strens, m. (2000). a bayesian framework for id23. in langley, p., edi-
tor, proceedings of the 17th international conference on machine learning (icml 2000),
pages 943   950. morgan kaufmann.

sutton, r. s. (1984). temporal credit assignment in id23. phd thesis,

university of massachusetts, amherst, ma.

sutton, r. s. (1988). learning to predict by the method of temporal di   erences. machine

learning, 3(1):9   44.

sutton, r. s. (1992). gain adaptation beats least squares. in proceedings of the 7th yale

workshop on adaptive and learning systems, pages 161   166.

sutton, r. s. and barto, a. g. (1998). id23: an introduction. bradford

book. mit press.

sutton, r. s., maei, h. r., precup, d., bhatnagar, s., silver, d., szepesv  ari, c., and
wiewiora, e. (2009a). fast gradient-descent methods for temporal-di   erence learning
with linear function approximation. in danyluk et al. (2009), pages 993   1000.

sutton, r. s., mcallester, d. a., singh, s. p., and mansour, y. (1999a). policy gradient
methods for id23 with function approximation. in solla et al. (1999),
pages 1057   1063.

94

sutton, r. s., precup, d., and singh, s. p. (1999b). between mdps and semi-mdps:
a framework for temporal abstraction in id23. arti   cial intelligence,
112:181   211.

sutton, r. s., szepesv  ari, c., geramifard, a., and bowling, m. h. (2008). dyna-style
planning with linear function approximation and prioritized sweeping. in mcallester and
myllym  aki (2008), pages 528   536.

sutton, r. s., szepesv  ari, c., and maei, h. r. (2009b). a convergent o(n) temporal-
di   erence algorithm for o   -policy learning with linear function approximation. in koller
et al. (2009), pages 1609   1616.

szepesv  ari, c. (1997). the asymptotic convergence-rate of id24. in jordan, m. i.,
kearns, m. j., and solla, s. a., editors, advances in neural information processing sys-
tems 10, pages 1064   1070, cambridge, ma, usa. mit press.

szepesv  ari, c. (1997). learning and exploitation do not con   ict under minimax optimality. in
someren, m. and widmer, g., editors, machine learning: ecml   97 (9th european conf.
on machine learning, proceedings), volume 1224 of lecture notes in arti   cial intelligence,
pages 242   249. springer, berlin.

szepesv  ari, c. (1998). static and dynamic aspects of optimal sequential decision making.
phd thesis, bolyai institute of mathematics, university of szeged, szeged, aradi vrt. tere
1, hungary, 6720.

szepesv  ari, c. (2001). e   cient approximate planning in continuous space markovian decision

problems. ai communications, 13:163   176.

szepesv  ari, c. and littman, m. l. (1999). a uni   ed analysis of value-function-based

reinforcement-learning algorithms. neural computation, 11:2017   2059.

szepesv  ari, c. and smart, w. d. (2004). interpolation-based id24. in brodley, c. e.,
editor, proceedings of the 21st international conference on machine learning (icml
2004), pages 791   798. acm.

szita, i. and l  orincz, a. (2008). the many faces of optimism: a unifying approach. in cohen

et al. (2008), pages 1048   1055.

szita, i. and szepesv  ari, c. (2010). model-based id23 with nearly tight

exploration complexity bounds. in wrobel et al. (2010).

tadi  c, v. b. (2004). on the almost sure rate of convergence of linear stochastic approximation

algorithms. ieee transactions on id205, 5(2):401   409.

95

tanner, b. and white, a. (2009).

language-independent software for
reinforcement-learning experiments. journal of machine learning research, 10:2133   2136.

rl-glue:

taylor, g. and parr, r. (2009). kernelized value function approximation for reinforcement

learning. in danyluk et al. (2009), pages 1017   1024.

tesauro, g. (1994). td-gammon, a self-teaching backgammon program, achieves master-

level play. neural computation, 6(2):215   219.

tesauro, g., touretzky, d., and leen, t., editors (1995). nips-7: advances in neural
information processing systems: proceedings of the 1994 conference, cambridge, ma,
usa. mit press.

thrun, s. b. (1992). e   cient exploration in id23. technical report cmu-

cs-92-102, carnegie mellon university, pittsburgh, pa.

toussaint, m., charlin, l., and poupart, p. (2008). hierarchical pomdp controller opti-
mization by likelihood maximization. in mcallester and myllym  aki (2008), pages 562   570.

tsitsiklis, j. n. (1994). asynchronous stochastic approximation and id24. machine

learning, 16(3):185   202.

tsitsiklis, j. n. and mannor, s. (2004). the sample complexity of exploration in the multi-

armed bandit problem. journal of machine learning research, 5:623   648.

tsitsiklis, j. n. and van roy, b. (1996). feature-based methods for large scale dynamic

programming. machine learning, 22:59   94.

tsitsiklis, j. n. and van roy, b. (1997). an analysis of temporal di   erence learning with

function approximation. ieee transactions on automatic control, 42:674   690.

tsitsiklis, j. n. and van roy, b. (1999a). average cost temporal-di   erence learning. auto-

matica, 35(11):1799   1808.

tsitsiklis, j. n. and van roy, b. (1999b). optimal stopping of markov processes: hilbert
space theory, approximation algorithms, and an application to pricing    nancial derivatives.
ieee transactions on automatic control, 44:1840   1851.

tsitsiklis, j. n. and van roy, b. (2001). regression methods for pricing complex american-

style options. ieee transactions on neural networks, 12:694   703.

tsybakov, a. (2009). introduction to nonparametric estimation. springer verlag.

96

van roy, b. (2006). performance loss bounds for approximate value iteration with state

aggregation. mathematics of operations research, 31(2):234   244.

wahba, g. (2003). reproducing kernel hilbert spaces     two brief reviews. in proceedings of

the 13th ifac symposium on system identi   cation, pages 549   559.

wang, t., lizotte, d. j., bowling, m. h., and schuurmans, d. (2008). stable dual dynamic

programming. in platt et al. (2008).

watkins, c. j. c. h. (1989). learning from delayed rewards. phd thesis, king   s college,

cambridge, uk.

watkins, c. j. c. h. and dayan, p. (1992). id24. machine learning, 3(8):279   292.

widrow, b. and stearns, s. (1985). adaptive signal processing. prentice hall, englewood

cli   s, nj.

williams, r. j. (1987). a class of gradient-estimating algorithms for id23
in neural networks. in proceedings of the ieee first international conference on neural
networks, san diego, ca.

wrobel, s., f  urnkranz, j., and joachims, t., editors (2010). proceedings of the 27th an-
nual international conference on machine learning (icml 2010), acm international
conference proceeding series, new york, ny, usa. acm.

xu, x., he, h., and hu, d. (2002). e   cient id23 using recursive least-

squares methods. journal of arti   cial intelligence research, 16:259   292.

xu, x., hu, d., and lu, x. (2007). kernel-based least squares policy iteration for reinforce-

ment learning. ieee transactions on neural networks, 18:973   992.

yu, h. and bertsekas, d. (2007). id24 algorithms for optimal stopping based on least

squares. in proceedings of the european control conference.

yu, j. and bertsekas, d. p. (2008). new error bounds for approximations from projected lin-
ear equations. technical report c-2008-43, department of computer science, university
of helsinki. revised july, 2009.

yu, j. y., mannor, s., and shimkin, n. (2009). id100 with arbitrary

reward processes. mathematics of operations research. to appear.

zhang, w. and dietterich, t. g. (1995). a id23 approach to job-shop
scheduling. in perrault, c. r. and mellish, c. s., editors, proceedings of the fourteenth

97

international joint conference on arti   cial intelligence (ijcai 95), pages 1114   1120,
san francisco, ca, usa. morgan kaufmann.

98

