introduction to machine learning

67577 - fall, 2008

amnon shashua

school of computer science and engineering

the hebrew university of jerusalem

jerusalem, israel

9
0
0
2

 
r
p
a
3
2

 

 
 
]

g
l
.
s
c
[
 
 

1
v
4
6
6
3

.

4
0
9
0
:
v
i
x
r
a

contents

1

3

4

2 maximum likelihood/ maximum id178 duality

bayesian decision theory
1.1

1.2
1.3 bayes classi   er for 2-class normal distributions

independence constraints
1.1.1 example: coin toss
1.1.2 example: gaussian density estimation
incremental bayes classi   er

2.1 ml and empirical distribution
2.2 relative id178
2.3 maximum id178 and duality ml/maxent
em algorithm: ml over mixture of distributions
3.1 the em algorithm: general
3.2 em with i.i.d. data
3.3 back to the coins example
3.4 gaussian mixture
3.5 application examples

page 1
5
7
7
9
10
12
12
14
15
19
21
24
24
26
27
3.5.1 gaussian mixture and id91
27
3.5.2 multinomial mixture and    bag of words    application 27
30
large margin classi   er as a quadratic id135 31
34
36
37
38
39
39

support vector machines and id81s
4.1
4.2 the support vector machine
4.3 the kernel trick

4.3.1 the homogeneous polynomial kernel
4.3.2 the non-homogeneous polynomial kernel
4.3.3 the rbf kernel
4.3.4 classifying new instances

iii

iv

5

6

7

8

9

contents

spectral analysis i: pca, lda, cca
5.1 pca: statistical perspective

5.1.1 maximizing the variance of output coordinates
5.1.2 decorrelation: diagonalization of the covariance

matrix

5.2 pca: optimal reconstruction
5.3 the case n >> m
5.4 kernel pca
5.5 fisher   s lda: basic idea
5.6 fisher   s lda: general derivation
5.7 fisher   s lda: 2-class
5.8
5.9 canonical correlation analysis
spectral analysis ii: id91
6.1 id116 algorithm for id91

lda versus id166

6.1.1 matrix formulation of id116

6.2 min-cut
6.3

spectral id91: ratio-cuts and normalized-cuts
6.3.1 ratio-cuts
6.3.2 normalized-cuts

the formal (pac) learning model
7.1 the formal model
7.2 the rectangle learning problem
7.3

learnability of finite concept classes
7.3.1 the realizable case
7.3.2 the unrealizable case

the vc dimension
8.1 the vc dimension
8.2 the relation between vc dimension and pac learning
the double-sampling theorem
9.1 a polynomial bound on the sample size m for pac

learning

9.2 optimality of id166 revisited

10 appendix
bibliography

41
42
43

46
47
49
49
50
52
54
54
55
58
59
60
62
63
64
65
69
69
73
75
76
77
80
81
85
89

89
95
97
105

1

bayesian decision theory

during the next few lectures we will be looking at the id136 from training
data problem as a random process modeled by the joint id203 distribu-
tion over input (measurements) and output (say class labels) variables. in
general, estimating the underlying distribution is a daunting and unwieldy
task, but there are a number of constraints or    tricks of the trade    so to
speak that under certain conditions make this task manageable and fairly
e   ective.

to make things simple, we will assume a discrete world, i.e., that the
values of our random variables take on a    nite number of values. consider
for example two random variables x taking on k possible values x1, ..., xk
and h taking on two values h1, h2. the values of x could stand for a body
mass index (bmi) measurement weight/height2 of a person and h stands
for the two possibilities h1 standing for the    person being over-weight    and
h2 as the possibility    person of normal weight   . given a bmi measurement
we would like to estimate the id203 of the person being over-weight.
the joint id203 p (x, h) is a two dimensional array (2-way array)
with 2k entries (cells). each training example (xi, hj) falls into one of those
cells, therefore p (x = xi, h = hj) = p (xi, hj) holds the ratio between the
number of hits into cell (i, j) and the total number of training examples

(assuming the training data arrive i.i.d.). as a result(cid:80)
p (hj) =(cid:80)
measurement     these are called priors. likewise, p (xi) = (cid:80)

the projections of the array onto its vertical and horizontal axes by sum-
ming over columns or over rows is called marginalization and produces
i p (xi, hj) the sum over the j   th row is the id203 p (h = hj),
i.e., the id203 of a person being over-weight (or not) before we see any
j p (xi, hj)
is the id203 p (x = xi) which is the id203 of receiving such
a bmi measurement to begin with     this is often called evidence. note

ij p (xi, hj) = 1.

1

2

bayesian decision theory

h1

h2

2
0

5
0

4
3

2
3

1
2

x1

x2

x3

x4

x5

fig. 1.1. joint id203 p (x, h) where x ranges over 5 discrete values and h
over two values. each entry contains the number of hits for the cell (xi, hj). the
joint id203 p (xi, hj) is the number of hits divided by the total number of hits
(22). see text for more details.

that, by de   nition, (cid:80)

j p (hj) = (cid:80)

i p (xi) = 1.

in fig. 1.1 we have that
p (h1) = 14/22, p (h2) = 8/22 that is there is a higher prior id203 of a
person being over-weight than being of normal weight. also p (x3) = 7/22
is the highest meaning that we encounter bmi = x3 with the highest prob-
ability.
the id155 p (hj | xi) = p (xi, hj)/p (xi) is the ratio be-
tween the number of hits in cell (i, j) and the number of hits in the i   th
column, i.e., the id203 that the outcome is h = hj given the measure-
ment x = xi. in fig. 1.1 we have p (h2 | x3) = 3/7. note that

(cid:88)

p (hj | xi) =(cid:88)

j

j

(cid:88)

p (xi, hj)

p (xi)

=

1

p (xi)

j

p (xi, hj) = p (xi)/p (xi) = 1.

likewise, the id155 p (xi | hj) = p (xi, hj)/p (hj) is the
number of hits in cell (i, j) normalized by the number of hits in the j   th row
and represents the id203 of receiving bmi = xi given the class label
h = hj (over-weight or not) of the person. in fig. 1.1 we have p (x3 | h2) =
3/8 which is the id203 of receiving bmi = x3 given that the person is

known to be of normal weight. note that(cid:80)

i p (xi | hj) = 1.

the bayes formula arises from:

p (xi | hj)p (hj) = p (xi, hj) = p (hj | xi)p (xi),

from which we get:

p (hj | xi) = p (xi | hj)p (hj)

.

p (xi)

the left hand side p (hj | xi) is called the posterior id203 and p (xi | hj)
is called the class conditional likelihood. the bayes formula provides a
way to estimate the posterior id203 from the prior, evidence and class
likelihood. it is useful in cases where it is natural to compute (or collect
data of) the class likelihood, yet it is not quite simple to compute directly

bayesian decision theory

3

the posterior. for example, given a measurement    12    we would like to
estimate the id203 that the measurement came from tossing a pair
of dice or from spinning a roulette table. if x = 12 is our measurement,
and h1 stands for    pair of dice    and h2 for    roulette    then it is natural
to compute the class conditional: p (   12    |    pair of dice   ) = 1/36 and
p (   12    |    roulette   ) = 1/38. computing the posterior directly is much
more di   cult. as another example, consider medical diagnosis. once it is
known that a patient su   ers from some disease hj, it is natural to evaluate
the probabilities p (xi | hj) of the emerging symptoms xi. as a result, in
many id136 problems it is natural to use the class conditionals as the
basic building blocks and use the bayes formula to invert those to obtain
the posteriors.

the bayes rule can often lead to unintuitive results     the one in particu-
lar is known as    base rate fallacy    which shows how an nonuniform prior can
in   uence the mapping from likelihoods to posteriors. on an intuitive basis,
people tend to ignore priors and equate likelihoods to posteriors. the follow-
ing example is typical: consider the    cancer test kit    problem    which has the
following features: given that the subject has cancer    c   , the id203
of the test kit producing a positive decision    +    is p (+ | c) = 0.98 (which
means that p (    | c) = 0.02) and the id203 of the kit producing a neg-
ative decision    -    given that the subject is healthy    h    is p (    | h) = 0.97
(which means also that p (+ | h) = 0.03). the prior id203 of cancer
in the population is p (c) = 0.01. these numbers appear at    rst glance
as quite reasonable, i.e, there is a id203 of 98% that the test kit will
produce the correct indication given that the subject has cancer. what
we are actually interested in is the id203 that the subject has cancer
given that the test kit generated a positive decision, i.e., p (c | +). using
bayes rule:
p (c | +) = p (+ | c)p (c)

p (+ | c)p (c)

= 0.266

p (+ | c)p (c) + p (+ | h)p (h)

p (+)

=

which means that there is a 26.6% chance that the subject has cancer given
that the test kit produced a positive response     by all means a very poor
performance.
if we draw the posteriors p (h1 |x) and p (h2 | x) using the id203
distribution array in fig. 1.1 we will see that p (h1 |x) > p (h2 | x) for all
values of x smaller than a value which is in between x3 and x4. therefore
the decision which will minimize the id203 of misclassi   cation would

    this example is adopted from yishai mansour   s class notes on machine learning.

4

bayesian decision theory

be to choose the class with the maximal posterior:
p (hj | x),

h    = argmax

j

which is known as the maximal a posteriori (map) decision principle. since
p (x) is simply a id172 factor, the map principle is equivalent to:

h    = argmax

j

p (x | hj)p (hj).

in the case where information about the prior p (h) is not known or it is
known that the prior is uniform, the we obtain the maximum likelihood
(ml) principle:

h    = argmax

j

p (x | hj).

the map principle is a particular case of a more general principle, known
as    proper bayes   , where a loss is incorporated into the decision process.
let l(hi, hj) be the loss incurred by deciding on class hi when in fact hj is
the correct class. for example, the    0/1    id168 is:

(cid:26) 1 i (cid:54)= j

0 i = j

(cid:27)

l(hi, hj) =

the least-squares id168 is: l(hi, hj) = (cid:107)hi     hj(cid:107)2 typically used when
the outcomes are vectors in some high dimensional space rather than class
labels. we de   ne the expected risk:

r(hi | x) =(cid:88)

l(hi, hj)p (hj | x).

the proper bayes decision policy is to minimize the expected risk:

j

h    = argmin

j

r(hj | x).

the map policy arises in the case l(hi, hj) is the 0/1 id168:

r(hi | x) =(cid:88)

j(cid:54)=i

p (hj | x) = 1     p (hi | x),

thus,

argmin

j

r(hj | x) = argmax

j

p (hj | x).

1.1 independence constraints

5

1.1 independence constraints

at this point we may pause and ask what have we obtained? well, not
much. clearly, the id136 problem is captured by the joint id203
distribution and we do not need all these formulas to see this. how do
we obtain the necessary data to    ll in the id203 distribution array to
begin with? clearly without additional simplifying constraints the task is
not practical as the size of these kind of arrays are exponential in the number
of variables. there are three families of simplifying constraints used in the
literature:
    statistical independence constraints,
    parametric form of the class likelihood p (xi | hj) where the id136
    structural assumptions     latent (hidden) variables, id114.
today we will focus on the    rst of these simplifying constraints     statistical
independence properties.
consider two random variables x and y . the variables are statistically
independent x   y if p (x | y ) = p (x) meaning that information about
the value of y does not add anything about x. the independence condition
is equivalent to the constraint: p (x, y ) = p (x)p (y ). this can be easily
if x   y then p (x, y ) = p (x | y )p (y ) = p (x)p (y ). on the
proven:
other hand, if p (x, y ) = p (x)p (y ) then

becomes a density estimation problem,

p (x | y ) = p (x, y )
p (y )

= p (x)p (y )

p (y )

= p (x).

let the values of x range over x1, ..., xk and the values of y range over
y1, ..., yl. the associated k    l 2-way array, p (x = xi, y = yj) is repre-
sented by the outer product p (xi, yj) = p (xi)p (yj) of two vectors p (x) =
(p (x1), ..., p (xk)) and p (y ) = (p (y1), ..., p (yl)). in other words, the 2-way
array viewed as a matrix is of rank 1 and is determined by k + l (minus 2
because the sum of each vector is 1) parameters rather than kl (minus 1)
parameters.
likewise, if x1   x2   ....   xn are n statistically independent random vari-
ables where xi ranges over ki discrete and distinct values, then the n-way
array p (x1, ..., xn) = p (x1)    ...    p (xn) is an outer-product of n vectors
and is therefore determined by k1 + ... + kn (minus n) parameters instead
of k1k2...kn (minus 1) parameters   . viewed as a tensor, the joint probabil-
    i am a bit over simplifying things because we are ignoring here the fact that the entries of
the array should be non-negative. this means that there are additional non-linear constraints
which e   ectively reduce the number of parameters     but nevertheless it stays exponential.

6

bayesian decision theory

ity is a rank 1 tensor. the main point is that the statistical independence
assumption reduced the representation of the multivariate joint distribution
from exponential to linear size.

since our variables are typically divided to measurement variables and
an output/class variable h (or in general h1, ..., hl), it is useful to intro-
duce another, weaker form, of independence known as conditional indepen-
dence. variables x, y are conditionally independent given h, denoted by
x   y | h, i    p (x | y, h) = p (x | h) meaning that given h, the value of y
does not add any information about x. this is equivalent to the condition
p (x, y | h) = p (x | h)p (y | h). the proof goes as follows:
    if p (x | y, h) = p (x | h), then

p (x, y | h) = p (x, y, h)

= p (x | y, h)p (y, h)

p (h)

p (h)
= p (x | y, h)p (y | h)p (h)

p (h)

= p (x | h)p (y | h)

    if p (x, y | h) = p (x | h)p (y | h), then

p (x | y, h) = p (x, y, h)
p (y, h)

= p (x, y | h)
p (y | h)

= p (x | h).

consider as an example, joe and mo live on opposite sides of the city.
joe goes to work by train and mo by car. let x be the event    joe is late
to work    and y be the event    mo is late for work   . clearly x and y are
not independent because there could be other factors. for example, a train
strike will cause joe to be late, but because of the strike there would be
extra tra   c (people using their car instead of the train) thus causing mo to
be pate as well. therefore, a third variable h standing for the event    train
strike    would decouple x and y .

from a computational standpoint, the conditional independence assump-
tion has a similar e   ect to the unconditional independence. let x range
over k distinct value, y range over r distinct values and h range over s
distinct values. then p (x, y, h) is a 3-way array of size k    r    s. given
that x   y | h means that p (x, y | h = hi), a 2-way    slice    of the 3-way
array along the h axis is represented by the outer-product of two vectors
p (x | h = hi)p (y | h = hi). as a result the 3-way array is represented by
s(k + r    2) parameters instead of skr    1. likewise, if x1   ....   xn | h then
the n-way array p (x1, ..., xn | h = hi) (which is a slice along the h axis of
the (n + 1)-array p (x1, ..., xn, h)) is represented by an outer-product of n
vectors, i.e., by k1 + .. + kn     n parameters.

1.1 independence constraints

7

1.1.1 example: coin toss

m(cid:89)

i=1

(cid:88)

i

we will use the ml principle to estimate the bias of a coin. let x be a
random variable taking the value {0, 1} and h would be our hypothesis
taking a real value in [0, 1] standing for the coin   s bias. if the coin   s bias is
q then p (x = 0 | h = q) = q and p (x = 1 | h = q) = 1    q. we receive m
i.i.d. examples x1, ..., xm where xi     {0, 1}. we wish to determine the value
of q. given that x1   ...   xm | h, the ml problem we must solve is:

q    = argmax

q

p (x1, ..., xm | h = q) =

p (xi | q) = argmax

q

log p (xi | q).

let 0            m stand for the number of    0    instances, i.e.,    = |{xi = 0 | i =
1, ..., m}|. therefore our ml problem becomes:

q    = argmax

{   log q + (n       ) log(1     q)}

q

taking the partial derivative with respect to q and setting it to zero:

[   log q + (n       ) log(1     q)] =   

q        n       

1     q    = 0,

   
   q

produces the result:

q    =   
n

.

1.1.2 example: gaussian density estimation

so far we considered constraints induced by conditional independent state-
ments among the random variables as a means to reduce the space and time
complexity of the multivariate distribution array. another approach would
be to assume some form of parametric form governing the entries of the array
    the most popular assumption is gaussian distribution p (x1, ..., xn)    
n(  , e) with mean vector    and covariance matrix e. the parameters of
the density function are denoted by    = (  , e) and for every vector x     rn
we have:

p (x |   ) =

1

(2  )n/2|e|1/2

exp    1

2 (x     )(cid:62)e   1(x     ) .

assume we are given an i.i.d sample of k points s = {x1, ..., xk}, xi     rn,
and we would like to    nd the bayes optimal   :

      = argmax

p (s |   ),

  

8

bayesian decision theory

k(cid:89)

i=1

by maximizing the likelihood (here we are assuming that the the priors p (  )
are equal, thus the maximum likelihood and the map would produce the
same result). because the sample was drawn i.i.d. we can assume that:

p (s |   ) =

p (xi |   ).

i log p (xi |   ) and since log is monotonously
increasing we have that       = argmax
l(  ). the parameter estimation would
be recovered by taking derivatives with respect to   , i.e.,      l = 0. we have:

  

let l(  ) = log p (s |   ) =(cid:80)
log |e|     k(cid:88)

l(  ) =    1
2

n
2

log(2  )    (cid:88)

i=1

i

(xi       )(cid:62)e   1(xi       ).

(1.1)

1
2

we will start with a simple scenario where e =   2i, i.e., all the covariances
are zero and all the variances are equal to   2. thus, e   1 =      2i and
|e| =   2n. after substitution (and removal of items which do not depend
on   ) we have:

l(  ) =    nk log        1
2

the partial derivative with respect to   :

   l
     

from which we obtain:

(cid:88)

(cid:107)xi       (cid:107)2

.

  2

i

(       xi) = 0

the partial derivative with respect to    is:

   l
     

from which we obtain:

= nk
  

(cid:107)xi       (cid:107)2 = 0,

i

1
k

   =

=      2(cid:88)
k(cid:88)
         3(cid:88)
k(cid:88)

i=1

i

1
kn

i=1

xi.

n(cid:88)

  2 =

(cid:107)xi       (cid:107)2.

k(cid:88)

1
k

(cid:107)xi       (cid:107)2 =

j = n  2.
  2

i=1

j=1

note that the reason for dividing by n is due to the fact that   2
n =   2, so that:
  2

1 = ... =

1.2 incremental bayes classi   er

9

in the general case, e is a full rank symmetric matrix, then the derivative
of eqn. (1.1) with respect to    is:

= e   1(cid:88)

and since e   1 is full rank we obtain    = (1/k)(cid:80)

i

(       xi) = 0,

   l
     

with respect to e we note two auxiliary items:

i xi. for the derivative

   |e|
   e

= |e|e   1,

trace(ae   1) =    (e   1ae   1)(cid:62).

   
   e

using the fact that x(cid:62)y = trace(xy(cid:62)) we can transform z(cid:62)e   1z to trace(zz(cid:62)e   1)
for any vector z. given that e   1 is symmetric, then:

trace(zz(cid:62)e   1) =    e   1zz(cid:62)e   1.

   
   e

substituting z = x        we obtain:

(cid:33)

=    ke   1 + e   1

(xi       )(xi       )(cid:62)

e   1 = 0,

   l
   e

from which we obtain:

e =

1
k

(xi       )(xi       )(cid:62).

(cid:32)(cid:88)
k(cid:88)

i

i=1

1.2 incremental bayes classi   er

consider another application of conditional dependence which is the bayes
incremental rule. suppose we have processed n examples x (n) = {x1, ..., xn}
and computed somehow p (h | x (n)). we are given a new measurement x
and wish to compute (update) the posterior p (h | x (n), x). we will use
the chain rule   :
p (x | y, z) = p (x, y, z)
p (y, z

) = p (z | x, y )p (x | y )p (y )

p (z | y )p (y )

p (z | y )

= p (z | x, y )p (x | y )

to obtain:

p (h | x (n), x) = p (x | x (n), h)p (h | x (n))

p (x | x (n))

from conditional independence, p (x | x (n), h) = p (x | h). the term
p (x | x (n)) can expanded as follows:
    this is based on the rule p (x1, ..., xn) = p (x1 | x2, ..., xn)p (x2 | x3, ..., xn)         

p (xn   1 | xn)p (xn)

10

bayesian decision theory

p (x | x (n)) = (cid:88)
= (cid:88)
= (cid:88)

i

i

p (x, x (n) | h = hi)p (h = hi)

p (x (n))

p (x | h = hi)p (x (n) | h = hi)p (h = hi)

p (x (n))

p (x | h = hi)p (h = hi | x (n))

i

after substitution we obtain:

(cid:80)
p (h = hi | x (n), x) = p (x | h = hi)p (h = hi | x (n))
j p (x | h = hj)p (h = hj | x (n))

.

the old posterior p (h | x (n)) is now the prior for the updated formula.
consider the following example   : we have a coin which could be either fair
or biased towards head at a id203 of 0.6. let h = h1 be the event
that the coin is fair, and h = h2 that the coin is biased. we start with prior
probabilities p (h1) = 0.75 and p (h2) = 0.25 (we have a higher initial belief
that the coin is fair). suppose our    rst coin toss is a head, i.e., x1 =    0   .
then,

p (h1 | x1) = p (x1 | h1)p (h1)

p (x1)

=

0.5     0.75

0.5     0.75 + 0.6     0.25

= 0.714

and p (h2 | x1) = 0.286. our posterior belief that the coin is fair has gone
down after a head toss. assume we have another measurement x2 =    0   ,
then:
p (h1 | x1, x2) = p (x2 | h1)p (h1 | x1)
= 0.675,
and p (h2 | x1, x2) = 0.325, thus our belief that the coin is fair continues to
go down after head tosses.

0.5     0.714 + 0.6     0.286

0.5     0.714

id172

=

1.3 bayes classi   er for 2-class normal distributions

for the last topic in this lecture consider the 2-class id136 problem. we
will encountered this problem in this course in the context of id166 and
lda. in the bayes framework, if h = {h1, h2} denotes the    class member   
variable with two possible outcomes, then the map decision policy calls for
    adopted from ron rivest   s 1994 class notes.

1.3 bayes classi   er for 2-class normal distributions

11

making the decision based on data x:

h    = argmax

{p (h1 | x), p (h2 | x)} ,

h1,h2

or in other words the class h1 would be chosen if p (h1 | x) > p (h2 | x).
the decision surface (as a function of x) is therefore described by:

p (h1 | x)     p (h2 | x) = 0.

the questions we ask here is what would the bayes optimal decision sur-
face be like if we assume that the two classes are normally distributed with
di   erent means and the same covariance matrix? what we will see is that
under the condition of equal priors p (h1) = p (h2) the decision surface is
a hyperplane     and not only that, it is the same hyperplane produced by
lda.
claim 1 if p (h1) = p (h2) and p (x | h1)     n(  1, e) and p (x | h1)    
n(  2, e), the the bayes optimal decision surface is a hyperplane w(cid:62)(x    
  ) = 0 where    = (  1 +   2)/2 and w = e   1(  1       2). in other words, the
decision surface is described by:

x(cid:62)e   1(  1       2)     1
2

(  1 +   2)e   1(  1       2) = 0.

(1.2)
proof: the decision surface is described by p (h1 | x)     p (h2 | x) = 0
which is equivalent to the statement that the ratio of the posteriors is 1, or
equivalently that the log of the ratio is zero, and using bayes formula we
obtain:

0 = log p (x | h1)p (h1)
p (x | h2)p (h2)

= log p (x | h1)
p (x | h2) .

in other words, the decision surface is described by
log p (x | h1)   log p (x | h2) =    1
2
after expanding the two terms we obtain eqn. (1.2).

(x     1)(cid:62)e   1(x     1)+

1
2

(x     2)(cid:62)e   1(x     2) = 0.

maximum likelihood/ maximum id178 duality

2

in the previous lecture we de   ned the principle of maximum likelihood
(ml): suppose we have random variables x1, ..., xn form a random sample
from a discrete distribution whose joint id203 distribution is p (x |   )
where x = (x1, ..., xn) is a vector in the sample and    is a parameter from
some parameter space (which could be a discrete set of values     say class
membership). when p (x |   ) is considered as a function of    it is called the
likelihood function. the ml principle is to select the value of    that maxi-
mizes the likelihood function over the observations (training set) x1, ..., xm.
if the observations are sampled i.i.d. (a common, not always valid, assump-
tion), then the ml principle is to maximize:

m(cid:89)

m(cid:88)

      = argmax

p (xi |   ) = argmax log

p (xi |   ) = argmax

log p (xi |   )

i=1

i=1

m(cid:89)

  

i=1

which due to the product nature of the problem it becomes more convenient
to maximize the log likelihood. we will take a closer look today at the
ml principle by introducing a key element known as the relative id178
measure between distributions.

2.1 ml and empirical distribution

the ml principle states that the empirical distribution of an i.i.d. sequence
of examples is the closest possible (in terms of relative id178 which would
be de   ned later) to the true distribution. to make this statement clear
let x be a set of symbols {a1, ..., an} and let p (a |   ) be the id203
(belonging to a parametric family with parameter   ) of drawing a symbol
a     x . let x1, ..., xm be a sequence of symbols drawn i.i.d. according to p .
the occurrence frequency f(a) measures the number of draws of the symbol

12

2.1 ml and empirical distribution

13

a:

f(a) = |{i : xi = a}|,
and let the empirical distribution be de   ned by

  p (a) =

1
(cid:107)f(cid:107)1

i p (xi |   )

f(a) = (1/m)f(a).

p (x1, ..., xm |   ) =

which according to the de   nitions above is equal to:

the joint id203 p (x1, ..., xm |   ) is equal to the product(cid:81)

1(cid:80)
     x f(  ) f(a) =
m(cid:89)
p(xi |   ) = (cid:89)
(cid:89)
where q = {q     rn : q     0, (cid:80)
a   x
i qi = 1} denote the set of n-dimensional
id203 vectors (   id203 simplex   ). let pi stand for p (ai |   ) and
ln(cid:81)
fi stand for f(ai). since argmaxxz(x) = argmaxx ln z(x) and given that
i fi ln pi the solution to this problem can be found by setting

the ml principle is therefore equivalent to the optimization problem:

i =(cid:80)

p (a |   )f (a).

p (a |   )f (a)

max
p   q

(2.1)

i pfi

a   x

i=1

the partial derivative of the lagrangian to zero:

n(cid:88)

fi ln pi       ((cid:88)

pi     1)    (cid:88)

  ipi,

l(p,   ,   ) =

i=1

(cid:80)
where    is the lagrange multiplier associated with the equality constraint
i pi     1 = 0 and   i     0 are the lagrange multipliers associated with the
inequality constraints pi     0. we also have the complementary slackness
condition that sets   i = 0 if pi > 0.

i

i

after setting the partial derivative with respect to pi to zero we get:

pi =

1

   +   i

fi.

with the result pi = (1/  )fi. following the constraint(cid:80)
   =(cid:80)

assume for now that fi > 0 for i = 1, ..., n. then from complementary
slackness we must have   i = 0 (because pi > 0). we are left therefore
i p1 = 1 we obtain
i fi. as a result we obtain: p (a |   ) =   p (a). in case fi = 0 we could

use the convention 0 ln 0 = 0 and from continuity arrive to pi = 0.

we have arrived to the following theorem:

theorem 1 the empirical distribution estimate   p is the unique maximum

14

maximum likelihood/ maximum id178 duality

likelihood estimate of the id203 model q on the occurrence frequency
f().

this seems like an obvious result but it actually runs deep because the result
holds for a very particular (and non-intuitive at    rst glance) distance mea-
sure between non-negative vectors. let dist(f, p) be some distance measure
between the two vectors. the result above states that:

  p = argmin

dist(f, p) s.t. p     0,

pi = 1,

(2.2)

p

i
for some (family?) of distance measures dist().
it turns out that there
is only one    such distance measure, known as the relative-id178, which
satis   es the ml result stated above.

(cid:88)

2.2 relative id178

xi +(cid:88)

the relative-id178 (re) measure d(x||y) between two non-negative vec-
tors x, y     rn is de   ned as:

n(cid:88)

d(x||y) =

   (cid:88)
vectors, i.e., belong to q, then d(x||y) =(cid:80)

y = 0 and x ln x

xi ln xi
yi

i=1

i

in the de   nition we use the convention that 0 ln 0
tinuity that 0 ln 0

0 = 0 and based on con-
0 =    . when x, y are also id203
is also known as the
id181. the re measure is not a distance metric as
it is not symmetric, d(x||y) (cid:54)= d(y||x), and does not satisfy the triangle
inequality. nevertheless, it has several interesting properties which make it
a fundamental measure in statistical id136.

i xi ln xi
yi

yi.

i

the relative id178 is always non-negative and is zero if and only if

x = y. this comes about from the log-sum inequality:

(cid:88)

i

xi ln xi
yi

(cid:80)
i xi(cid:80)

i yi

xi) ln

    ((cid:88)
   (cid:88)

i

xi) ln

(cid:80)
i xi(cid:80)
xi +(cid:88)

i yi

i

i

yi =   x ln

      x +   y

  x
  y

d(x||y)     ((cid:88)

i

thus,

p

    not exactly     the picture is a bit more complex. csiszar   s 1972 measures: dist(p, f) =
i fi  (pi/fi) will satisfy eqn. 2.2 provided that   (cid:48)   1 is an exponential. however, dist(f, p)
(parameters positions are switched) will not do it, whereas the relative id178 will satisfy
eqn. 2.2 regardless of the order of the parameters p, f.

2.3 maximum id178 and duality ml/maxent

15
but a ln(a/b)     a     b for a, b     0 i    ln(a/b)     1     (b/a) which follows from
the inequality ln(x + 1) > x/(x + 1) (which holds for x >    1 and x (cid:54)= 0).
we can state the following theorem:
theorem 2 let f     0 be the occurrence frequency on a training sample.
  p     q is a ml estimate i   
  p = argmin

d(f||p) s.t. p     0,

pi = 1.

proof:

and

p

d(f||p) =    (cid:88)

i

fi ln pi +(cid:88)
(cid:88)

i

p

i

d(f||p) = argmax

argmin

p

fi ln pi = argmax

pfi
i .

(cid:88)
fi ln fi    (cid:88)

i

fi + 1,

ln(cid:89)

i

i

p

to f under the constraint (cid:80)

there are two (related) interesting points to make here. first, from the
proof of thm. 1 we observe that the non-negativity constraint p     0 need
not be enforced - as long as f     0 (which holds by de   nition) the closest p
i pi = 1 must come out non-negative. second,
the fact that the closest point p to f comes out as a scaling of f (which is by
de   nition the empirical distribution   p ) arises because of the relative-id178
measure. for example, if we had used a least-squares distance measure
(cid:107)f     p(cid:107)2 the result would not be a scaling of f.
in other words, we are
looking for a projection of the vector f onto the id203 simplex, i.e.,
the intersection of the hyperplane x(cid:62)1 = 1 and the non-negative orthant
x     0. under relative-id178 the projection is simply a scaling of f (and
this is why we do not need to enforce non-negativity). under least-sqaures,
a projection onto the hyper-plane x(cid:62)1 = 1 could take us out of the non-
negative orthant (see fig. 2.1 for illustration). so, relative-id178 is special
in that regard     it not only provides the ml estimate, but also simpli   es
the optimization process    (something which would be more noticeable when
we handle a latent class model next lecture).

2.3 maximum id178 and duality ml/maxent

the relative-id178 measure is not symmetric thus we expect di   erent out-
comes of the optimization minx d(x||y) compared to miny d(x||y). the lat-
    the fact that non-negativity    comes for free    does not apply for all class (distribution) models.

this point would be re   ned in the next lecture.

16

maximum likelihood/ maximum id178 duality

fig. 2.1. projection of a non-neagtaive vector f onto the hyperplane(cid:80)

i xi     1 = 0.
under relative-id178 the projection   p is a scaling of f (and thus lives in the
id203 simplex). under least-squares the projection p2 lives outside of the
id203 simplex, i.e., could have negative coordinates.

ter of the two, i.e., minp   q d(p0||p ), where p0 is some empirical evidence
and q is some model, provides the ml estimation. for example, in the
next lecture we will consider q the set of low-rank joint distributions (called
latent class model) and see how the ml (via relative-id178 minimization)
solution can be found.
minx d(x||y) we can state the following observation:

i pi ln pi denote the id178 function. with regard to

let h(p) =    (cid:80)

claim 2

argmin
p   q

d(p|| 1
n

1) = argmax

h(p).

p   q

proof:

d(p|| 1
n

1) =(cid:88)

pi ln pi + ((cid:88)
which follows from the condition(cid:80)
consider a linear constraint on p such as(cid:80)

i pi = 1.

i

i

in other words, the closest distribution to uniform is achieved by maxi-
mizing the id178. to make this interesting we need to add constraints.
i   ipi =   . to be concrete, con-

pi) ln(n) = ln(n)     h(p),

fp^p217

2.3 maximum id178 and duality ml/maxent

probabilities p1, ..., p6 given only the average (cid:80)
words, if we have no information except that each pi     0 and that(cid:80)

sider a die with six faces thrown many times and we wish to estimate the
i ipi. say, the average is 3.5
which is what one would expect from an unbiased die. the laplace   s prin-
ciple of insu   cient reasoning calls for assuming uniformity unless there is
additional information (a controversial assumption in some cases). in other
i pi = 1
we should choose the uniform distribution since we have no reason to choose
any other distribution. thus, employing laplace   s principle we would say
that if the average is 3.5 then the most    likely    distribution is the uniform.
what if    = 4.2? this kind of problem can be stated as an optimization
problem:

(cid:88)

(cid:88)

max
p h(p) s.t.,

pi = 1,

  ipi =   ,

i

i

where   i = i and    = 4.2. we have now two constraints and with the aid
of lagrange multipliers we can arrive to the result:

pi = exp   (1     ) exp    i .

comes for free      . following the constraint (cid:80)
1/(cid:80)

note that because of the exponential pi     0 and again    non-negativity
i pi = 1 we get exp   (1     ) =

i exp    i from which obtain:

pi =

1
z

exp    i,

where z (a function of   ) is a id172 factor and    needs to be set by
using    (see later). there is nothing special about the uniform distribution,
thus we could be seeking a id203 vector p as close as possible to some
prior id203 p0 under the constraints above:

(cid:88)

(cid:88)

p d(p||p0) s.t.,
min

pi = 1,

  ipi =   ,

i

i

with the result:

(cid:80)

pi =

1
z

p0i exp    i .

we could also consider adding more linear constraints on p of the form:

i fijpi = bj, j = 1, ..., k. the result would be:

pk
p0i exp

pi =

1
z

j=1   j fij .

id203 distributions of this form are called gibbs distributions.

in

    any measure of the class dist(p, p0) = p

will satisfy the result of pi     0 provided that   (cid:48)   1 is an exponential.

i p0i  (pi/p0i) minimized under linear constraints

18

maximum likelihood/ maximum id178 duality

practical applications the linear constraints on p could arise from average
information about the system such as temperature of a    uid (where pi are
the probabilities of the particles moving at various velocities), rainfall data
or general environmental data (where pi represent the id203 of    nding
animal colonies at discrete locations in a 3d map). a constraint of the
i fijpi = bj states that the expectation ep[fj] should be equal to
the empirical distribution    = e   p [fj] where   p is either uniform or given as
input. let

form (cid:80)

p = {p     rn : p     0,

pi = 1, ep[fj] = e  p[fj], j = 1, ..., k},

(cid:88)

and

q = {q     rn ; q is a gibbs distribution}

i

we could therefore consider looking for the ml solution for the parameters
  1, ...,   k of the gibbs distribution:
q   q d(  p||q),
min

where if   p is uniform then min d(  p||q) can be replaced by max(cid:80)
(because d((1/n)1||x) =     ln(n)    (cid:80)

i ln qi

as it turns out, the maxent and ml are duals of each other and the
intersection of the two sets p     q contains only a single point which solves
both problems.

i ln xi).

theorem 3 the following are equivalent:
    maxent: q    = argminp   p d(p||p0)
    ml: q    = argminq   qd(  p||q)
    q        p     q

in practice, the duality theorem is used to recover the parameters of the
gibbs distribution using the ml route (second line in the theorem above)
    the algorithm for doing so is known as the iterative scaling algorithm
(which we will not get into).

em algorithm: ml over mixture of distributions

3

in lecture 2 we saw that the maximum likelihood (ml) principle over i.i.d.
data is achieved by minimizing the relative id178 between a model q and
the occurrence-frequency of the training data. speci   cally, let x1, .., xm be
i.i.d. where each xi     x d is a d-tupple of symbols taken from an alphabet x
having n di   erent letters {a1, ..., an}. let   p be the empirical joint distribu-
tion, i.e., an array with d dimensions where each axis has n entries, i.e., each
entry   pi1,...,id, where ij = 1, ..., n, represents the (normalized) co-occurrence
of the d-tupe ai1, ..., aid in the training set x1, ..., xm. we wish to    nd a
joint distribution p     (also a d-array) which belongs to some model family
of distributions q closest as possible to   p in relative-id178:

p     = argmin
p   q

d(   p||p ).

k(cid:88)

in this lecture we will focus on a model of distributions q which represents
mixtures of simple distributions h    known as latent class models. a latent
class model arises when the joint id203 p (x1, ..., xd) we observe (i.e.,
from which   p is generated by observing samples x1, ..., xm) is in fact a
marginal of p (x1, ..., xd, y ) where y is a    hidden    (or    latent   ) random
variable which has k di   erent discrete values   1, ..,   k. then,

p (x1, ..., xd) =

p (x1, ..., xd | y =   j)p (y =   j).

j=1

the idea is that given the value of the hidden variable h the problem of
recovering the model p (x1, ..., xd | y =   j), which belongs to some family
of joint distributions h, is a relatively simple problem. to make this idea
clearer we consider the following example: assume we have two coins. the
   rst coin has a id203 of heads (   0   ) equal to p and the second coin
has a id203 of heads equal to q. at each trial we choose to toss coin 1

19

em algorithm: ml over mixture of distributions

20
with id203    and coin 2 with id203 1       . once a coin has been
chosen it is tossed 3 times, producing an observation x     {0, 1}3. we are
given a set of such observations d = {x1, ..., xm} where each observation xi
is a triplet of coin tosses (the same coin). given d, we can construct the
empirical distribution   p which is a 2    2    2 array de   ned as:

  pi1,i2,i3 =

|{xi = {i1, i2, i3}, i = 1, ..., m}|.

1
m

let yi     {1, 2} be a random variable associated with the observation xi such
that yi = 1 if xi was generated by coin 1 and yi = 2 if xi was generated
by coin 2.
if we knew the values of yi then our task would be simply
to estimate two separate bernoulli distributions by separating the triplets
generated from coin 1 from those generated by coin 2. since yi is not known,
we have the marginal:

p (x = (x1, x2, x3)) = p (x = (x1, x2, x3) | y = 1)p (y = 1)
+ p (x = (x1, x2, x3) | y = 2)p (y = 2)
=   pni(1     p)(3   ni) + (1       )qni(1     q)(3   ni),(3.1)
where (x1, x2, x3)     {0, 1}3 is a triplet coin toss and 0     ni     3 is the
number of heads (   0   ) in the triplet of tosses. in other words, the likelihood
p (x) of triplet of tosses x = (x1, x2, x3) is a linear combination (   mixture   )
of two bernoulli distributions. let h stand for bernoulli distributions:

h = {u   d : u     0,

ui = 1}

n(cid:88)

i=1

where u   d stands for the outer-product of u     rn with itself d times, i.e.,
an n- way array indexed by i1, ..., id, where ij     {1, ..., n}, and whose value
there is equal to ui1          uid. the model family q is a mixture of bernoulli
distributions:

  jpj

q = { k(cid:88)
(cid:19)   3
(cid:18) p

j=1

1     p

:        0,

  j = 1, pj     h},

(cid:88)
(cid:18) q

j

(cid:19)   3

where speci   cally for our coin-toss example becomes:

q = {  

+ (1       )

1     q

:   , p, q     [0, 1]}

we see therefore that the eight entries of p         q which minimizes d(   p||p )
over the set q is determined by three parameters   , p, q. for the coin-toss

3.1 the em algorithm: general

example this looks like:

(cid:19)   3

(cid:32)
1(cid:88)

  p ||   

1(cid:88)

(cid:18) p
1(cid:88)

1     p

i1=0

i2=0

i3=0

  pi1i2i3 log

argmin
0     ,p,q   1

d

= argmax
0     ,p,q   1

21

(cid:19)   3(cid:33)

(cid:18) q

+ (1       )

(cid:16)

1     q

  pni123 (1     p)(3   ni123 ) + (1       )qni123 (1     q)(3   ni123 )(cid:17)

problem over q = (cid:80)

where ni123 = i1 + i2 + i3. trying to work out an algorithm for minimizing
the unknown parameters   , p, q would be somewhat    unpleasant    (and even
more so for other families of distributions h) because of the log-over-a-sum
present in the optimization function     if we could somehow turn this into
a sum-over-log our task would be much easier. we would then be able to
turn the problem into a succession of problems over h rather than a single
j   jh. another point worth attention is the non-
negativity of the output variables     simply minimizing the relative-id178
measure under the constraints of the class model q would not guarantee a
non-negative solution. as we shall see, breaking down the problem into a
successions of problems over h would give us the    non-negativity for free   
feature.

the technique for turning the log-over-sum into a sum-over-log as part of
   nding the ml solution for a mixture model is known as the expectation-
maximization (em) algorithm introduced by dempster, laird and rubin in
1977. it is based on two ideas: (i) introduce auxiliary variables, and (ii) use
of jensen   s inequality.

3.1 the em algorithm: general

let d = {x1, ..., xm} represent the training data where xi     x is taken from
some instance space x which we leave unspeci   ed. for now, we leave matters
to be as general as possible and speci   cally we do not make independence
assumptions on the data generation process.
the ml problem is to    nd a setting of parameters    which maximizes
the likelihood p (x1, ..., xm |   ), namely, we wish to maximize p (d |   ) over
parameters   , which is equivalent to maximizing the log-likelihood:

      = argmax

log p (d |   ) = log

  

p (d, y |   )

      (cid:88)

y

       ,

where y represents the hidden variables. we will denote l(  ) = log p (d |   ).

(3.2)

(3.3)

(3.4)

(3.5)

em algorithm: ml over mixture of distributions

ditioned on the parameters    and the input sample d, i.e.,(cid:80)

22
let q(y | d,   ) be some (arbitrary) distribution of the hidden variables y con-
y q(y | d,   ) =

1. we de   ne a lower bound on l(  ) as follows:

l(  ) = log

p (d, y |   )

      (cid:88)
      (cid:88)

y

      

      

y

= log

    (cid:88)

q(y | d,   ) p (d, y |   )
q(y | d,   )
q(y | d,   ) log p (d, y |   )
q(y | d,   )
the inequality comes from jensen   s inequality log(cid:80)
when(cid:80)

= q(q,   ).

y

j   jaj     (cid:80)

j   j log aj
j   j = 1. what we have obtained is an    auxiliary    function q(q,   )

satisfying

l(  )     q(q,   ),

for all distributions q(y | d,   ). the maximization of q(q,   ) proceeds by
interleaving the variables q and    as we separately ascend on each set of
variables. at the (t + 1) iteration we    x the current value of    to be   (t)
of the t   th iteration and maximize q(q,   (t)) over q, and then maximize
q(q(t+1),   ) over   :

q(t+1) = argmax

q(q,   (t))

q

  (t+1) = argmax

q(q(t+1),   ).

  

(3.6)

(3.7)

the strategy of the em algorithm is to maximize the lower bound q(q,   )
with the hope that if we ascend on the lower bound function we will also
ascend with respect to l(  ). the claim below guarantees that an ascend on
q will also generate an ascend on l:

claim 3 (jordan-bishop) the optimal q(y | d,   (t)) at each step is
p (y | d,   (t)).
proof: we will show that q(p (y | d,   (t)),   (t)) = l(  (t)) which proves the
claim since l(  )     q(q,   ) for all q,   , thus the best q-distribution we can

3.1 the em algorithm: general

23

hope to    nd is one that makes the lower-bound meet l(  ) at    =   (t).

q(p (y | d,   (t)),   (t)) = (cid:88)
= (cid:88)
= log p (d |   (t))(cid:88)

y

y

p (y | d,   (t)) log p (d, y |   (t))
p (y | d,   (t))
p (y | d,   (t)) log p (y | d,   (t))p (d |   (t))

p (y | d,   (t))

p (y | d,   (t))

y

= l(  (t))

the proof provides also the validity for the approach of ascending along
the lower bound q(q,   ) because at the point   (t) the two functions coincide,
i.e., the lower bound function at    =   (t) is equal to l(  (t)) therefore if
we continue and ascend along q(  ) we are guaranteed to ascend along l(  )
as well        therefore, convergence is guaranteed. it can also be shown (but
omitted here) that the point of convergence is a stationary point of l(  ) (was
shown originally by c.f. je    wu in 1983 years after em was introduced in
1977) under fairly general conditions. the second step of maximizing over
   then becomes:

  (t+1) = argmax

  

p (y | d,   (t)) log p (d, y |   ).

(3.8)

(cid:88)

y

this de   nes the em algorithm. often the    expectation    step is described
as taking the expectation of:

ey   p (y | d,  (t)) [log p (d, y |   )] ,

followed by a maximization step of    nding    that maximizes the expectation
    hence the term em for this algorithm.

eqn. 3.8 describes a principle but not an algorithm because in general,
without making assumptions on the statistical relationship between the data
points and the hidden variable the problem presented in eqn. 3.8 is unwieldy.
we will reduce eqn. 3.8 to something more manageable by making the i.i.d.
assumption. this is detailed in the following section.

    this manner of deriving em was adapted from jordan and bishop   s book notes, 2001.

24

em algorithm: ml over mixture of distributions

3.2 em with i.i.d. data

the em optimization presented in eqn. 3.8 can be simpli   ed if we assume
the data points (and the hidden variable values) are i.i.d.

p (xi |   ),

p (d, y |   ) =

p (xi, yi |   ),

n(cid:89)

n(cid:89)

p (d |   ) =

and

i=1

i=1

p (y | d,   ) =

n(cid:89)

i=1

p (yi | xi,   ).

for any   (yi) we have:

(cid:88)

y

  (yi)p (y | d,   ) = (cid:88)
= (cid:88)

y1

        (cid:88)

  (yi)p (y1 | x1,   )          p (yn | xn,   )

yn

  (yi)p (yi | xi,   )

p (yj | xj,   ) = 1. substituting the simpli   cations above

this is because(cid:80)

yj

into eqn. 3.8 we obtain:

yi

k(cid:88)

m(cid:88)

  (t+1) = argmax

  

j=1

i=1

where yi     {  1, ...,   k}.

p (yi =   j | xi,   (t)) log p (xi, yi =   j |   )

(3.9)

3.3 back to the coins example

we will apply the em scheme to our running example of mixture of bernoulli
distributions. we wish to compute

q(  ,   (t)) = (cid:88)
n(cid:88)

y

=

2(cid:88)

i=1

j=1

p (y | d,   (t)) log p (d, y |   )

p (yi = j | xi,   (t)) log p (xi, yi = j |   ),

3.3 back to the coins example

25

and then maximize q() with respect to p, q,   .
q(  ,   (cid:48)) =

(cid:2)p (yi = 1 | xi,   (cid:48)) log p (xi | yi = 1,   )p (yi = 1 |   )(cid:3)
(cid:2)p (yi = 2 | xi,   (cid:48)) log p (xi | yi = 2,   )p (yi = 2 |   )(cid:3)
(cid:104)

n(cid:88)
n(cid:88)
= (cid:88)

+

i=1

i=1

  i log(  pni(1     p)(3   ni)) + (1       i) log((1       )qni(1     q)(3   ni))

(cid:105)

i

where   (cid:48) stands for   (t) and   i = p (yi = 1 | xi,   (cid:48)). the values of   i are
known since   (cid:48) = (  o, po, qo) are given from the previous iteration. the
bayes formula is used to compute   i:

  i = p (yi = 1 | xi,   (cid:48)) = p (xi | yi = 1,   (cid:48))p (yi = 1 |   (cid:48))

p (xi |   (cid:48))

=

o (1     po)(3   ni)
o (1     po)(3   ni) + (1       o)qni

  opni

  opni

o (1     qo)(3   ni)

we wish to compute: maxp,q,   q(  ,   (cid:48)). the partial derivative with respect
to    is:

from which we obtain the update formula of    given   i:

(1       i)

1

1       

= 0,

=(cid:88)

i

   q
     

=(cid:88)

   q
   p

i

i=1

  i

1
k

1
  

   =

   (cid:88)
n(cid:88)
   (cid:88)
(cid:88)
1(cid:80)
(cid:88)
1(cid:80)
i(1       i)

  ini

p =

i   i

p

i

i

i

i

q =

  i.

  i(3     ni)

1     p

= 0,

ni
3   i.

(1       i).

ni
3

the partial derivative with respect to p is:

from which we obtain the update formula:

likewise the update rule for q is:

to conclude, we start with some initial    guess    of the values of p, q,   , com-
pute the values of   i and update iteratively the values of p, q,    where at the
end of each iteration the new values of   i are computed.

26

em algorithm: ml over mixture of distributions

3.4 gaussian mixture

the gaussian mixture model assumes that p (x) where x     rd is a linear
combination of gaussian distributions

k(cid:88)

p (x) =

p (x | y = j)p (y = j)

j=1

where

p (x | y = j) =

1

(2  )d/2  d
j

    (cid:107)x   cj(cid:107)2

2  2
j

exp

,

is normally distributed with mean cj and covariance matrix   2
j i. let d =
{x1, ..., xm} be the i.i.d sample data and we wish to solve for the mean
and covariances of the individual gaussians (the    factors   ) and the mixing
coe   cients   j = p (y = j). in order to make clear where the parameters are
located we will write p (x |   j) instead of p (x | y = j) where   j = (cj,   2
j )
are the mean and variance of the j   th factor. we denote by    the collection
of mixing coe   cients   j and   j, j = 1, ..., k. let wj
i be auxiliary variables
per point xi and per factor y = j standing for:
i = p (yi = j | xi,   ).
wj

the em step (eqn. 3.9) is:

k(cid:88)
note the constraint(cid:80)

  (t+1) = argmax
  ={  ,  }

j=1

the use of bayes formula:

m(cid:88)

i=1

(t) log (  jp (xi |   j))

wj
i

s.t.

(cid:88)

j

  j = 1.

(3.10)

j   j = 1. the update formula for wj

i is done through

(t) = p (yi = j |   (t))p (xi | yi = j,   (t))

wj
i

where zi is a scaling factor so that(cid:80)

p (xi |   (t))

j wj

i = 1.

=

1
zi

j p (xi |   (t)),
  (t)

the update formula for   j, cj,   j follow by taking partial derivatives of
eqn. (3.10) and setting them to zero. taking partial derivatives with respect

3.5 application examples

27

to   j, cj and   j we obtain the update rules:

i=1

1
m

m(cid:88)
1(cid:80)
d(cid:80)

i wj
1
i wj

i

i

wj
i

m(cid:88)
m(cid:88)

i=1

i=1

  j =

cj =

j =
  2

wj
i xi,

i(cid:107)xi     cj(cid:107)2.
wj

in other words, the observations xi are weighted by wj
   tted (k times, one for each factor).

i before a gaussian is

3.5 application examples

3.5.1 gaussian mixture and id91

the gaussian mixture model is classically used for id91 applications.
in a id91 application one receives a sample of points x1, ..., xm where
each point resides in rd. the task of the learner (in this case    unsupervised   
learning) is to group the m points into k sets. let yi     {1, ..., k} where
i = 1, ..., m stands for the required labeling. the id91 solution is an
assignment of values to y1, ..., ym according to some id91 criteria.

in the gaussian mixture model points are clustered together if they arise
from the same gaussian distribution. the em algorithm provides a proba-
bilistic assignment p (yi = j | xi) which we denoted above as wj
i .

3.5.2 multinomial mixture and    bag of words    application

the multinomial mixture (the coins example we toyed with) is typically used
for representing    count    data, such as when representing text documents as
high-dimensional vectors. a vector representation of a text document asso-
ciates a word from a    xed vocabulary to a coordinate entry of the vector.
the value of the entry represents the number of times that particular word
appeared in the document. if we ignore the order in which the words ap-
peared and count only their frequency, a set of documents d1, ..., dm and a
set of words w1, ...., wn could be jointly represented by a co-occurence n   m
matrix g where gij contains the number of times word wi appeared in doc-
ij gij = 1 then we have a distribution
p (w, d). this kind of representation of a set of documents is called    bag of
words   .

ument dj. if we scale g such that(cid:80)

28

em algorithm: ml over mixture of distributions

for purposes of search and    ltering it is desired to reveal additional infor-
mation about words and documents such as to which    topic    a document
belongs to or to which topics a word is associated with. this is similar to
a id91 task where documents associated with the same topic are to be
clustered together. this can be achieved by considering the topics as the
value of a latent variable y:

p (w, d) =(cid:88)

p (w, d | y)p (y) =(cid:88)

y

y

p (w | y)p (d | y)p (y),

where we made the assumption that w   d | y (i.e., words and documents are
conditionally independent given the topic). the conditional independent
assumption gives rise to the multinomial mixture model. to be more speci   c,
ley y     {1, ..., k} denote the k possible topics and let   j = p (y = j) (note

j   j = 1), then the latent class model becomes:

that(cid:80)

p (w, d) =

  jp (w | y = j)p (d | y = j).

k(cid:88)

j=1

note that p (w | y = j) is a vector which we denote as uj     rn and p (d | y =
j) is also a vector we denote by vj     rm. the term p (w | y = j)p (d | y = j)
j of the two vectors, i.e., is a rank-1 n   m
stands for the outer-product ujv(cid:62)
matrix. the maximum-likelihood estimation problem is therefore to    nd
vectors u1, ..., uk and v1, ..., vk and scalars   1, ...,   k such that the empirical
distribution represented by the unit scaled matrix g is as close as possible
j subject to
j   j = 1, uj and vj are unit-scaled

(in relative-id178 measure) to the low-rank matrix(cid:80)
the constraints of non-negativity and(cid:80)

as well (1(cid:62)uj = 1(cid:62)vj = 1).
let xi = (w(i), d(i)) stand for the i   th example i = 1, ..., q where an
example is a pair of word and document where w(i)     {1, ..., n} is the index
to the word alphabet and d(i)     {1, ..., m} is the index to the document.
the em algorithm involves the following optimization step:

j   jujv(cid:62)

  (t+1) = argmax

  

= argmax

q(cid:88)
q(cid:88)

i=1

k(cid:88)
k(cid:88)

j=1

  

i=1

j=1

p (yi = j | xi,   (t)) log p (xi, yi = j |   )

ij log(cid:2)  juj,w(i)vj,d(i)

(cid:3)

w(t)

s.t. 1(cid:62)   = 1(cid:62)uj = 1(cid:62)vj = 1

an update rule for ujr (the r   th entry of uj) is derived below: the derivative

of the lagrangian is:

(cid:35)

3.5 application examples

ij log uj,w(i)       ujr
w(t)

   

   ujr

=    
   ujr

(cid:34) q(cid:88)
      n(r) log ujr
n(r)(cid:80)

i=1

w(i)=r w(t)
ujr

ij

=

(cid:88)

w(i)=r

       = 0

ij       ujr
w(t)

29

      

that the vector n(1), ..., n(n) is the marginal p (w) =(cid:80)

where n(r) stands for the frequency of the word wr in all the documents
d1, ..., dm. note that n(r) is the result of summing-up the r   th row of g and
d p (w, d). given
the constraint 1(cid:62)uj = 1 we obtain the update rule:

ujr     n(r)(cid:80)
s=1 n(s)(cid:80)
(cid:80)n
w(i)=r w   
d(i)=s w   

w(i)=r w(t)

ij

.

w(i)=s w(t)

has converged, then(cid:80)
to the j   th topic and(cid:80)

update rules for the remaining unknowns are similarly derived. once em
ij is the id203 of the word wr to belong
ij is the id203 that the s   th document

ij

comes from the j   th topic.

4

support vector machines and id81s

in this lecture we begin the exploration of the 2-class hyperplane separation
problem. we are given a training set of instances xi     rn, i = 1, ..., m,
and class labels yi =   1 (i.e., the training set is made up of    positive   
and    negative    examples). we wish to    nd a hyperplane direction w     rn
and an o   set scalar b such that w    xi     b > 0 for positive examples and
w    xi     b < 0 for negative examples     which together means that the
margins yi(w    xi     b) > 0 are positive.

assuming that such a hyperplane exists, clearly it is not unique. we
therefore need to introduce another constraint so that we could    nd the
most    sensible    solution among all (in   nitley many) possible hyperplanes
which separate the training data. another issue is that the framework is
very limited in the sense that for most real-world classi   cation problems
it is somewhat unlikely that there would exist a linear separating function
to begin with. we therefore need to    nd a way to extend the framework
to include non-linear decision boundaries at a reasonable cost. these two
issues will be the focus of this lecture.

regarding the    rst issue, since there is more than one separating hyper-
plane (assuming the training data is linearly separable) then the question
we need to ask ourselves is among all those solutions which of them has the
best    generalization    properties? in other words, our goal in constructing
a learning machine is not necessarily to do very well (or perfect) on the
training data, because the training data is merely a sample of the instance
space, and not necessarily a    representative    sample     it is simply a sample.
therefore, doing well on the sample (the training data) does not necessarily
guarantee (or even imply) that we will do well on the entire instance space.
the goal of constructing a learning machine is to maximize the performance
on the test data (the instances we haven   t seen), which in turn means that

30

4.1 large margin classi   er as a quadratic id135

31

we wish to generalize    good    classi   cation performance on the training set
onto the entire instance space.

a related issue to generalization is that the distribution used to generate
the training data is unknown. unlike the statistical id136 material we
had so far, this time we will not attempt to estimate the distribution. the
reason one can derive optimal learning algorithms yet bypass the need for
estimating distributions would be explained later in the course when pac-
learning will be introduced. for now we will focus only on the algorithmic
aspect of the learning problem.

the idea is to consider a subset c   of all hyperplanes which have a    xed
margin    where the margin is de   ned as the distance of the closest training
point to the hyperplane:

(cid:26) yi(w(cid:62)xi     b)

(cid:27)

(cid:107)w(cid:107)

.

   = min

i

the support vector machine (id166),    rst introduced by vapnik and his
colleagues in 1992, seeks a separating hyperplane which simultaneously min-
imizes the empirical error and maximizes the margin. the idea of maximiz-
ing the margin is intuitively appealing because a decision boundary which
lies close to some of the training instances is less likely to generalize well
because the learning machine will be susceptible to small perturbations of
those instance vectors. a formal motivation for this approach is deferred to
the pac-learning material we will introduce later in the course.

4.1 large margin classi   er as a quadratic id135
we would    rst like to set up the linear separating hyperplane as an optimiza-
tion problem which is both consistent with the training data and maximizes
the margin induce by the separating hyperplane over all possible consistent
hyperplanes.

formally speaking, the distance between a point x and the hyperplane is

de   ned by

| w    x     b |
   
w    w

.

since we are allowed to scale the parameters w, b at will (note that if w   
x     b > 0 so is (  w)    x     (  b) > 0 for all    > 0) we can set the distance
w    w by scaling
between the boundary points to the hyperplane to be 1/
w, b such the point(s) with smallest margin (closest to the hyperplane) will
   
be normalized: | w   x    b |= 1, therefore the margin is simply 2/
w    w (see
   
w    w is equivalent to argmaxw2/(w    w)
fig. 5.1). note that argmaxw2/

   

support vector machines and id81s

32
2w    w. since all positive points
which in turn is equivalent to argminw 1
and negative points should be farther away from the boundary points we
also have the separability constraints w    x     b     1 when x is a positive
instance and w   x    b        1 when x is a negative instance. both separability
constraints can be combined: y(w    x     b)     1. taken together, we have
de   ned the following optimization problem:

min
w,b

w    w

1
2
subject to
yi(w    xi     b)     1     0

i = 1, ..., m

(4.1)

(4.2)

this type of optimization problem has a quadratic criteria function and
linear inequalities and is known in the literature as a quadratic linear pro-
gramming (qp) type of problem.

this particular qp, however, requires that the training data are linearly
separable     a condition which may be unrealistic. we can relax this condi-
tion by introducing the concept of a    soft margin    in which the separability
holds approximately with some error:

min
w,b, i

w    w +   

1
2

 i

(4.3)

subject to
yi(w    xi     b)     1      i
 i     0

i = 1, ..., m

where    is some pre-de   ned weighting factor. the (non-negative) vari-
ables  i allow data points to be miss-classi   ed thereby creating an approx-
imate separation. speci   cally, if xi is a positive instance (yi = 1) then the
   soft    constraint becomes:

w    xi     b     1      i,

where if  i = 0 we are back to the original constraint where xi is either a
boundary point or laying further away in the half space assigned to positive
instances. when  i > 0 the point xi can reside inside the margin or even in
the half space assigned to negative instances. likewise, if xi is a negative
instance (yi =    1) then the soft constraint becomes:

w    xi     b        1 +  i.

l(cid:88)

i=1

4.1 large margin classi   er as a quadratic id135

33

fig. 4.1. separating hyperplane w, b with maximal margin. the boundary points
are associated with non-vanishing lagrange multipliers   i > 0 and margin errors
are associated with  i > 0 where the criteria function encourages a small number
of margin errors.

the criterion function penalizes (the l1-norm) for non-vanishing  i thus the
overall system will seek a solution with few as possible    margin errors    (see
fig. 5.1). typically, when possible, an l1 norm is preferable as the l2 norm
overly weighs high magnitude outliers which in some cases can dominate
the energy function. another note to make here is that strictly speaking
the    right thing    to do is to penalize the margin errors based on the l0
norm (cid:107) (cid:107)0
0 = |{i :  i > 0}|, i.e., the number of non-zero entries, and drop
the balancing parameter   . this is because it does not matter how far away
a point is from the hyperplane     all what matters is whether a point is
classi   ed correctly or not (see the de   nition of empirical error in lecture 4).
the problem with that is that the optimization problem would no longer be
convex and non-convex problems are notoriously di   cult to solve. moreover,
the class of id76 problems (as the one described in eqn. 4.3)
can be solved in polynomial time complexity.

so far we have described the problem formulation which when solved
would provide a solution with    sensible    generalization properties. although
we can proceed using an o   -the-shelf qlp solver, we will    rst pursue the
   dual    problem. the dual form will highlight some key properties of the
approach and will enable us to extend the framework to handle non-linear

),(bwmaximize the margin||2w0>i!0>i  0=j  34

support vector machines and id81s

decision surfaces at a very little cost. in the appendix we take a brief tour on
the basic principles associated with constrained optimization, the karush-
kuhn-tucker (kkt) theorem and the dual form. those are recommended
to read before moving to the next section.

4.2 the support vector machine

we return now to the primal problem (eqn. 6.3) representing the maximal
margin separating hyperplane with margin errors:

min
w,b, i

w    w +   

1
2

l(cid:88)

i=1

 i

subject to
yi(w    xi     b)     1      i
 i     0

i = 1, ..., m

we will now derive the lagrangian dual of this problem. by doing so a
new key property will emerge facilitated by the fact that the criteria func-
tion   (  ) (note there are no equality constraints thus there is no need for   )
involves only inner-products of the training instance vectors xi. this prop-
erty will form the key of mapping the original input space of dimension n to
a higher dimensional space thereby allowing for non-linear decision surfaces
for separating the training data.

note that with this particular problem the strong duality conditions are
satis   ed because the criteria function and the inequality constraints form a
convex set. the lagrangian takes the following form:

m(cid:88)

 i     m(cid:88)

  i [yi(w    xi     b)     1 +  i]     m(cid:88)

  i i

i=1

i=1

i=1

l(w, b,  i,   ) =

w    w +   

1
2

recall that

  (  ) = min
w,b, 

l(w, b,  ,   ,   ).

since the minimum is obtained at the vanishing partial derivatives of the
lagrangian with respect to w, b, the next step would be to evaluate those

35

(4.4)

(4.5)

(4.6)

constraints and substitute them back into l() to obtain   (  ):

4.2 the support vector machine

= w    (cid:88)
= (cid:88)

i

i

  iyi = 0

   l
   w

   l
   b

  iyixi = 0

from the    rst constraint (4.4) we obtain w =(cid:80)

=          i       i = 0

   l
    i

i   iyixi, that is, w is de-
scribed by a linear combination of a subset of the training instances. the
reason that not all instances participate in the linear superposition is due
to the kkt conditions:   i = 0 when yi(w    xi     b) > 1, i.e., the instance xi
is classi   ed correctly and is not a boundary point, and conversely,   i > 0
when yi(w    xi     b) = 1      i, i.e., when xi is a boundary point or when
xi is a margin error ( i > 0)     note that for a margin error instance the
value of  i would be the smallest possible required to reach an equality in
the constraint because the criteria function penalizes large values of  i. the
boundary points (and the margin errors) are called support vectors thus w is
de   ned by the support vectors only. the third constraint (4.6) is equivalent
to the constraint:

0       i       

i = 1, ..., l,

since   i     0. also note that if  i > 0, i.e., point xi is a margin-error point,
then by kkt conditions we must have   i = 0. as a result   i =   . therefore
based on the values of   i alone we can make the following classi   cations:
    0 <   i <   : point xi is on the margin and is not a margin-error.
      i =   : points xi is a margin-error point.
      i = 0: point xi is not on the margin.

substituting these results/constraints back into the lagrangian l() we

obtain the dual problem:

max
  1,...,  m

m(cid:88)

  i     1
2

(cid:88)

i,j

i = 1, ..., m

  (  ) =

i=1
subject to
0       i       
yi  i = 0

m(cid:88)

  i  jyiyjxi    xj

(4.7)

the criterion function   (  ) can be written in a more compact manner as

i=1

support vector machines and id81s

36
follows: let m be a l    l matrix whose entries are mij = yiyjxi    xj then
  (  ) =   (cid:62)1    1
2   (cid:62)m    where 1 is the vector of (1, ..., 1) and    is the vector
(  1, ...,   m) and   (cid:62) is the transpose (row vector). note that m is positive
de   nite, i.e., x(cid:62)mx > 0 for all vectors x (cid:54)= 0     a property which will be
important later.

the key feature of the dual problem is not so much that it is simpler
than the primal (in fact it isn   t since the primal has no equality constraints)
or that it has a more    elegant    feel, the key feature is that the problem
is completely described by the inner products of the training instances xi,
i = 1, ..., m. this fact will be shown to be a crucial ingredient in the so called
   kernel trick    for the computation of inner-products in high dimensional
spaces using simple functions de   ned on pairs of training instances.

4.3 the kernel trick

we ended with the dual formulation of the id166 problem and noticed that
the input data vectors xi are represented by the gram matrix m. in other
words, only inner-products of the input vectors play a role in the dual for-
mulation     there is no explicit use of xi or any other function of xi besides
inner-products. this observation suggests the use of what is known as the
   kernel trick    to replace the inner-products by non-linear functions.

the common principle of kernel methods is to construct nonlinear vari-
ants of linear algorithms by substituting inner-products by nonlinear kernel
functions. under certain conditions this process can be interpreted as map-
ping of the original measurement vectors (so called    input space   ) onto
some higher dimensional space (possibly in   nitely high) commonly referred
to as the    feature space   . mathematically, the kernel approach is de   ned
as follows:
let x1, ..., xl be vectors in the input space, say rn, and con-
sider a mapping   (x) : rn     f where f is an inner-product space. the
kernel-trick is to calculate the inner-product in f using a id81
k : rn   rn     r, k(xi, xj) =   (xi)(cid:62)  (xj), while avoiding explicit mappings
(evaluation of)   ().
common choices of kernel selection include the d   th order polynomial
kernels k(xi, xj) = (x(cid:62)
i xj +   )d and the gaussian rbf kernels k(xi, xj) =
exp(    1
2  2(cid:107)xi     xj(cid:107)2). if an algorithm can be restated such that the input
vectors appear in terms of inner-products only, one can substitute the inner-
products by such a id81. the resulting kernel algorithm can be
interpreted as running the original algorithm on the space f of mapped
objects   (x).

we know that m of the dual form is positive semi-de   nite because m

4.3 the kernel trick

37
can be written is m = q(cid:62)q where q = [y1x1, ..., ylxl]. therefore x(cid:62)mx =
(cid:107)qx(cid:107)2     0 for all choices of x (which means that the eigenvalues of m are
non-negative). if the entries of m are to be replaced with yiyjk(xi, xj) then
the condition we must enforce on the function k() is that it is a positive
de   nite id81. a positive de   nite function is de   ned such that
for any set of vectors x1, ..., xq and for any values of q the matrix k whose
entries are kij = k(xi, xj) is positive semi-de   nite. formally, the conditions
for admissible kernels k() are known as mercer   s conditions summarized
below:

theorem 4 (mercer   s conditions) let k(x, y) be symmetric and contin-
uous. the following conditions are equivalent:

(i) k(x, y) =(cid:80)   
(ii) for all   () satisfying(cid:82)
(cid:90)
(cid:90)
x   2(x)dx <    , then
k(x, y)  (x)  (y)dxdy     0

ing series   i > 0.

i=1   i  i(x)  i(y) =   (x)(cid:62)  (y) for any uniformly converg-

(iii) for all {xi}q
semi-de   nite.

x

y

i=1 and for all q, the matrix kij = k(xi, xj) is positive

perhaps the non-obvious condition is no. 1 which allows for the feature
map   () to have in   nitely many coordinates (a vector in hilbert space). for
example, as we shall see below, the kernel exp(    1
2  2(cid:107)xi     xj(cid:107)2) is an inner-
product of two vectors with in   nitely many coordinates. we will consider
next a number of popular kernels.

4.3.1 the homogeneous polynomial kernel

let x, y     rk and de   ne k(x, y) = (x(cid:62)y)d where d > 0 is a natural number.

then, the corresponding feature map   (x) has(cid:0)k+d   1
(cid:33)

which take the value:

(cid:32)(cid:115)(cid:18)

(cid:19)

d

(cid:1) = o(kd) coordinates

d

  (x) =

1          xnk
xn1

d

k

n1,...,nk

n1, ..., nk

where(cid:0)

ways to distribute d balls into k bins where the j   th bin hold exactly nj     0
balls):

(cid:1) = d!/(n1!          nk!) is the multinomial coe   cient (number of
(x1 + ... + xk)d = (cid:88)
ni   0,p

1          xnk
xn1
k .

n1, ..., nk

(cid:18)

i ni=d

d

ni   0,p
(cid:19)

i ni=d

support vector machines and id81s

38
the dimension of the vector space   (x) where x     rk can be measured
using the following combinatorial problem: how many arrangements of k   1

partitions to be placed among d items? the answer is(cid:0)k+d   1

(cid:1) =
(cid:1) =(cid:0)k+d   1

k   1

d

o(kd). for example, k = d = 2 gives us :

(x(cid:62)y)2 = x2
   

1y2

1 + 2x1x2y1y2 + x2

2 =   (x)(cid:62)  (y),
2y2

where   (x) = (x2

1, x2
2,

2x1x2).

4.3.2 the non-homogeneous polynomial kernel

to d, i.e., (cid:80)
to k + 1 where nk+1 is used to    ll the gap between (cid:80)k
therefore the dimension of   (x) where x     rk would be(cid:0)k+d

the feature map   (x) contains all monomials whose power is lesser or equal
i ni     d. this can be acheived by increasing the dimension
i=1 ni < d and d.

(cid:1). we have:

d

(x(cid:62)y +   )d = (x1y1 + ... + xkyk +

   

   

  

(cid:19)

  )d

d

n1, ..., nk+1

xn1
1 yn1

=

(cid:88)
ni   0,pk+1
(cid:32)(cid:115)(cid:18)

d

i=1 ni=d

(cid:18)

(cid:19)

  (x) =

n1, ..., nk+1

1          xnk
xn1

k      nk+1/2

therefore, the entries of the vector   (x) take the values:

     nk+1/2  nk+1/2

1

1 ynk

1          xnk
(cid:33)
ni   0,pk+1

i=1 ni=d

for example, k = d = 2 gives us :
(x(cid:62)y +   )2 = x2

1y2

1 + 2x1x2y1y2 + x2

2 + 2  x1y1 + 2  x2y2 +    =   (x)(cid:62)  (y),
2y2
   
   
where   (x) = (x2
  ). in this example,   () is a
mapping from r2 to r6 and hyperplanes   (w)(cid:62)  (x)   b = 0 in r6 correspond
to conics in r2:

2x1x2,

2  x1,

2  x2,

1, x2
2,

   

   

(w2

1)x2

1 + (w2

2)x2 + (2w1w2)x1x2 + (2  w1)x1 + (2  w2)x2 + (       b) = 0

assume we would like to    nd a separating conic (parabola, hyperbola,
ellipse) function rather than a line in r2. the discussion so far suggests we
construct the gram matrix m in the dual form with the d = 2 polynomial
kernel k(x, y) = (x(cid:62)y+  )2 for some parameter    of our choosing. the extra
e   ort we will need to invest is negligible     simply replace every occurrence
x(cid:62)
i xj with (x(cid:62)

i xj +   )2.

4.3 the kernel trick

39

4.3.3 the rbf kernel

the function k(x, y) = e   (cid:107)x   y(cid:107)2/2  2 known as a radial basis function
(rbf) is a id81 but with an in   nite expansion. without loss of
generality let    = 1, then we have:
e   (cid:107)x   y(cid:107)2/2 = e   (cid:107)x(cid:107)2/2e   (cid:107)y(cid:107)2/2ex(cid:62)y

(x(cid:62)y)j

e   (cid:107)x(cid:107)2/2e   (cid:107)y(cid:107)2/2

      j

    (cid:107)x(cid:107)2
2j   
j!1/j

    (cid:107)y(cid:107)2
e
2j   
j!1/j

x(cid:62)y

    (cid:107)x(cid:107)2
e
2j   
j!1/j

j

n1, ..., nk

=

=

=

j=0

j=0

   (cid:88)
   (cid:88)
   (cid:88)
       e

j=0

j!

       e
(cid:88)
p

i ni=j

(cid:18)

(cid:18)

(cid:19)1/2

  (x) =

    (cid:107)x(cid:107)2
2j   
j!1/j

j

n1, ..., nk

1          xnk
xn1

k

1          xnk
xn1

(cid:19)1/2
      
j=0,..,   ,pk

k

i=1 ni=j

from which we can see that the entries of the feature map   (x) are:

(cid:19)1/2

(cid:18)

j

n1, ..., nk

1          ynk
yn1

k

    (cid:107)y(cid:107)2
e
2j   
j!1/j

4.3.4 classifying new instances

by adopting some kernel k() we are in fact mapping x       (x), thus we
then proceed to solve for   (w) and b using some qlp solver. the qlp
solution of the dual form will yield the solution for the lagrange multipliers
  1, ...,   m. we saw from eqn. (4.4) that we can express   (w) as a function
of the (mapped) examples:

  (w) =(cid:88)

  iyi  (xi).

i

d

mapping is (cid:0)k+d

with corresponding   i > 0) and use them for the evaluation of test examples:

rather than explicitly representing   (w)     a task which may be prohibitly
expensive since in general the dimension of the feature space of a polynomial

f(x) = sign(  (w)(cid:62)  (x)     b) = sign((cid:88)

(cid:1)     we store all the support vectors (those input vectors
= sign((cid:88)

  iyi  (xi)(cid:62)  (x)     b)

  iyik(xi, x)     b).

i

i

40

support vector machines and id81s

we see that the kernel trick enabled us to look for a non-linear separating
surface by making an implicit mapping of the input space onto a higher di-
mensional feature space using the same dual form of the id166 formulation    
the only change required was in the way the gram matrix was constructed.
the price paid for this convenience is to carry all the support vectors at the
time of classi   cation f(x).

a couple of notes may be worthwhile at this point. the constant b can
be recovered from any of the support vectors. say, x+ is a positive support
vector (but not a margin error, i.e.,   i <   ). then   (w)(cid:62)  (x+)     b = 1
from which b can be recovered. the second note is that the number of
support vectors is typically around 10% of the number of training examples
(empirically). thus the computational load during evaluation of f(x) may
be relatively high. approximations have been proposed in the literature by
looking for a reduced number of support vectors (not necessarily aligned
with the training set)     but this is beyond the scope of this course.

the kernel trick gained its popularity with the introduction of the id166
but since then has taken a life of its own and has been applied to principal
component analysis (pca), ridge regression, canonical correlation analysis
(cca), qr factorization and the list goes on. we will meet again with the
kernel trick later on.

5

spectral analysis i: pca, lda, cca

in this lecture (and the following one) we will focus on id106 for
learning. today we will focus on id84 using principle
component analysis (pca), multi-class learning using linear discriminant
analysis (lda) and canonical correlation analysis (cca). in the next
lecture we will focus on spectral id91 methods.

id84 appears when the dimension of the input vector
is very large (imagine pixels in an image, for example) while the coordi-
nate measurements are highly inter-dependent (again, imagine the redun-
dancy present among neighboring pixels in an image). high dimensional
data impose computational e   ciency challenges and often translate to poor
generalization abilities of the learning engine (see lectures on pac). a di-
mensionality reduction can also be viewed as a feature extraction process
where one takes as input a large feature set (the original measurements)
and creates from them a much smaller number of new features which are
then fed into the learning engine.

in this lecture we will focus on feature extraction from a very speci   c (and
constrained) stanpoint. we would be looking for a mixing (linear combina-
tion) of the input coordinates such that we obtain a linear projection from
rn to rq for some q < n. in doing so we wish to reduce the redundancy
while preserving as much as possible the variance of the data. from a sta-
tistical standpoint this is achieved by transforming to a new set of variables,
called principal components, which are uncorrelated so that the    rst few
retain most of the variation present in all of the original coordinates. for
example, in an image processing application the input images are highly re-
dundant where neighboring pixel values are highly correlated. the purpose
of feature extraction would be to transform the input image into a vector of
output components with the least redundancy possible. form a geometric
standpoint, this is achieved by    nding the    closest    (in least squares sense)

41

42

spectral analysis i: pca, lda, cca

linear q-dimensional susbspace to the m sample points s. the new sub-
space is a lower dimensional    best approximation    to the sample s. these
two, equivalent, perspectives on data compression (dimensionality reduc-
tion) form the central idea of principal component analysis (pca) which
probably the oldest (going back to pearson 1901) and best known of the
techniques of multivariate analysis in statistics. the computation of pca
is very simple and the de   nition is straightforward, but has a wide variety
of di   erent applications, a number of di   erent derivations, quite a number
of di   erent terminologies (especially outside the statistical literature) and is
the basis for quite a number of variations on the basic technique.

we then extend the variance preserving approach for data representation
for labeled data sets. we will describe the linear classi   er approach (sepa-
rating hyperplane) form the point of view of looking for a hyperplane such
that when the data is projected onto it the separation is maximized (the dis-
tance between the class means is maximal) and the data within each class is
compact (the variance/spread is minimized). the solution is also produced,
just like pca, by a spectral analysis of the data. this approach goes under
the name of fisher   s id156 (lda).

what is common between pca and lda is (i) the use of spectral ma-
trix analysis     i.e., what can you do with eigenvalues and eigenvectors of
matrices representing subspaces of the data? (ii) these techniques produce
optimal results for normally distributed data and are very easy to imple-
ment. there is a large variety of uses of spectral analysis in statistical and
learning literature including spectral id91, multi dimensional scaling
(mds) and data modeling in general. another point to note is that this is
the    rst time in the course where the type of data distribution plays a role
in the analysis     the two techniques are de   ned for any distribution but
are optimal only under the gaussian distribution.

we will also describe a non-linear extension of pca known as kernel-
pca, but the focus would be mostly on pca itself and its analysis from
a couple of vantage points: (i) pca as an optimal reconstruction after a
dimension reduction, i.e., data compression, and (ii) pca for redundancy
reduction (decorrelation) of the output components.

5.1 pca: statistical perspective

let x1, ..., xm     rn be our sample data s of vectors in rn, arranged as
it will be convenient to assume that the data is
columns of a matrix a.

centered, i.e.,(cid:80) xi = 0. if the data is not centered we can always center it
by computing the mean vector    = (1/m)(cid:80)

i xi and replace the original data

5.1 pca: statistical perspective

43
sample with the new sample xi       . in a statistical sense, the coordinates
of the vector x     rn are considered as random variables, thus a row in the
matrix a is the sample of values of a particular random variable, drawn from
some unknown id203 distribution, associated with the row position.
we wish to    nd vectors u1, ..., uq (arranged as columns of a matrix u),
where q     min(n, m), such that the new feature measurements y = u(cid:62)x
(who are the result of linear combinations u(cid:62)
1 x, ..., u(cid:62)
q x of the original feature
measurements x) have certain desirable properties.
the idea property to seek from the new coordinates y is statistical inde-
pendence, i.e., p (y1, .., yq) = p (y1)       p (yq) which would mean that we have
removed the redundancy of the original data x in the best possible manner.
this goal, however, is too much to ask from a linear transformation and
instead we would ask for a weaker property to hold: that the pairwise co-
variance cov(yi, yj) = 0 vanishes, i.e., that the covariance matrix on the new
coordinates is diagonal. a diagonal covariance insures some redundancy re-
moval, but not as good as statistical independence. however, when the data
is normally distributed p (x)     n(  ,   ) with mean    and covariance   , then
the transformation which diagonalizes the covariance matrix also guarantees
statistical independence. among all transformations that de-correlate the
data we will seek the one that maximizes the spread (variance) of the sample
data after being projected onto the new axes vectors.

5.1.1 maximizing the variance of output coordinates

formally, we are looking for a unit vector u which maximizes(cid:80)
because (cid:80)

the property we would like to maximize is that the projection of the sample
data on the new axes is as spread as possible. to start this analysis, assume
q = 1, i.e., the n components of the input vector x are reduced to a single
output component y = u(cid:62)x. we are looking for a single vector u     rn
whose direction maximizes the variance of the output component y.
i(u(cid:62)xi)2
(see appendix a for basic statistical de   nitions and note that e[y] = 0
i xi) = 0). in other words, the projected points
onto the axis represented by the vector u are as spread as possible (in a
least squares sense). in vector notation, the optimization problem takes the
following form:

i u(cid:62)xi = u(cid:62)

i ((cid:80)

max

u

1
2

(cid:107)u(cid:62)a(cid:107)2

subject to

u(cid:62)u = 1

1
2

the lagrangian of the problem is:

l(u,   ) =

u(cid:62)aa(cid:62)u       (

1
2

u(cid:62)u     1)

1
2

44

spectral analysis i: pca, lda, cca

by taking the partial derivative    l/   u = 0 we obtain the following necessary
condition (see appendix b):

aa(cid:62)u =   u,

which tells us that u is an eigenvector of the n    n (symmetric and positive
de   nite) matrix aa(cid:62). there are n eigenvectors associated with aa(cid:62) and
we can easily convince ourselves that we are looking for the one associated
with the maximal eigenvalue: substitute   u instead of aa(cid:62)u in the criterion
function u(cid:62)aa(cid:62)u to obtain   (u(cid:62)u) =    and since the eigenvalues must be
positive (since aa(cid:62) is positive de   nite), then the optimum is obtained for
the maximal eigenvalue. the leading eigenvector u of aa(cid:62) is called the    rst
principal axis of the data sample represented by the columns of the matrix
a, and y = u(cid:62)x is called the    rst principal component of the data sample.
for convenience, we denote u1 = u and   1 =    as the leading eigenvector
and eigenvalue of aa(cid:62). next, we look for y2 = u(cid:62)
2 x which is uncorrelated
with y1 = u(cid:62)
1 x and which has maximum variance (and so on for u3, ..., uq).
two random variables are uncorrelated if their covariance vanishes. by
de   nition of covariance (see appendix a) we obtain:

cov(y1y2) = (cid:88)

1 ((cid:88)

1 xi)(u(cid:62)

(u(cid:62)
1 aa(cid:62)u2 = u(cid:62)

2 xi) = u(cid:62)

xix(cid:62)
2 aa(cid:62)u1 =   1u(cid:62)

i

i

i )u2

1 u2 = 0

= u(cid:62)

we can therefore use the condition u(cid:62)
between y1, y2. the functional to be optimized becomes:
u(cid:62)
2 u2 = 1, u(cid:62)

2 a(cid:107)2

subject to

(cid:107)u(cid:62)

max
u2

1
2

1
2

1 u2 = 0,

1 u2 = 0 to specify zero correlation

with the lagrangian being:
1
2

l(u2,   ,   ) =

2 aa(cid:62)u2       (
u(cid:62)

2 u2     1)       u(cid:62)
u(cid:62)

1 u2.

1
2

by taking the partial derivative with respect to u2 we obtain the necessary
condition:

aa(cid:62)u2       u2       u1 = 0.

multiply the equation by u1 from the left:

and noting from above that u(cid:62)
result we obtain:

1 aa(cid:62)u2       u(cid:62)
u(cid:62)

1 u1 = 0,

1 u2       u(cid:62)
1 aa(cid:62)u2 = u(cid:62)
aa(cid:62)u2 =   u2,

1 u2 = 0 we obtain    = 0. as a

5.1 pca: statistical perspective

45
so once more we have that   , u2 form an eigenvalue/eigenvector pair of aa(cid:62).
as before,    should be as large as possible from the remaining spectral de-
composition. by induction, it can be shown that the remaining principal
vectors u3, ..., uq are the decreasing order eigenvactors of aa(cid:62) and the vari-
ance of the i   th principal component yi = u(cid:62)

i x is   i.

taken together, the pca is the solution of the following optimization

problem:

max
u1,...,uq

1
2

(cid:88)

i

(cid:107)u(cid:62)

i a(cid:107)2

subject to u(cid:62)

i ui = 1, u(cid:62)

i uj = 0,

i (cid:54)= j = 1, ..., q.

it will be useful for later to write the optimization function in a more concise
manner as follows. let u be the n    q matrix whose columns are ui and
d = diag(  1, ...,   q) is an q  q diagonal matrix and   1       2     ...       q. then
from above we have that u(cid:62)u = i and aa(cid:62)u = u d. using the fact that
trace(xy(cid:62)) = x(cid:62)y, trace(ab) = trace(ba) and trace(a+b) = trace(a)+

trace(b) we can convert(cid:80)
i aa(cid:62)ui = (cid:88)

(cid:88)

u(cid:62)

i

i

i (cid:107)u(cid:62)
trace(a(cid:62)uiu(cid:62)

i a(cid:107)2 to trace(u(cid:62)aa(cid:62)u) as follows:
uiu(cid:62)

i a) = trace(a(cid:62)((cid:88)

i )a)

= trace(a(cid:62)u u(cid:62)a) = trace(u(cid:62)aa(cid:62)u)

i

thus, pca becomes the solution of the following optimization function:

trace(u(cid:62)aa(cid:62)u)

subject to u(cid:62)u = i.

(5.1)

max
u   rn  q

the solution, as saw above, is that u = [u1, ..., uq] consists of the decreasing
order eigenvectors of aa(cid:62). at the optimum, trace(u(cid:62)aa(cid:62)u) is equal to
trace(d) which is equal to the sum of eigenvalues   1 + ... +   q.

it is worthwhile noting that when q = n, u u(cid:62) = u(cid:62)u = i, and the pca
transform is a change of basis in rn known as karhunen-loeve transform.
to conclude, the pca transform looks for q orthogonal direction vectors
(called the principal axes) such that the projection of input sample vectors
onto the principal directions has the maximal spread, or equivalently that
the variance of the output coordinates y = u(cid:62)x is maximal. the principal
directions are the leading (with respect to descending eigenvalues) q eigen-
vectors of the matrix aa(cid:62). when q = n, the principal directions form a
basis of rn with the property of de-correlating the data and maximizing the
variance of the coordinates of the sample input vectors.

46

spectral analysis i: pca, lda, cca

5.1.2 decorrelation: diagonalization of the covariance matrix
in the previous section we saw that pca generates a new coordinate system
y = u(cid:62)x where the coordinates y1, ..., yq of x in the new system are uncorre-
lated. this means that the covariance matrix over the principle components
should be diagonal. in this section we will explore this perspective in more
detail.

the covariance matrix   x of the sample data x1, ..., xm with zero mean

is

(1/m)(cid:88)

xix(cid:62)

i = (1/m)aa(cid:62),

i

therefore the matrix aa(cid:62) we derived above is a scaled version of the co-
variance of the sample data (see appendix a). the scale factor 1/m was
unimportant in the process above because the eigenvectors are of unit norm,
thus any scale of aa(cid:62) would produce the same set of eigenvectors.

the o   -diagonal entries of the covariance matrix   x represent the corre-
lation (a measure of statistical dependence) between the i   th and j   th com-
ponent vectors, i.e., the entries of the input vectors x. the existence of
correlations among the components (features) of the input signal is a sign
of redundancy, therefore from the point of view of transforming the input
representation into one which is less redundant, we would like to    nd a
transformation y = u(cid:62)x with an output representation y which is associ-
ated with a diagonal covariance matrix   y, i.e., the components of y are
uncorrelated.
i = (1/m)u(cid:62)aa(cid:62)u, therefore we wish to
   nd an n    q matrix for which u(cid:62)aa(cid:62)u is diagonal.
if in addition, we
would require that the variance of the output coordinates is maximized,
i.e., trace(u(cid:62)aa(cid:62)u) is maximal (but then we need to constrain the length
of the column vectors of u, i.e., set (cid:107)ui(cid:107) = 1) then we would get a unique
solution for u where the columns are orthonormal and are de   ned as the    rst
q eigenvectors of the covariance matrix   x. this is exactly the optimization
problem de   ned by eqn. (5.1).

formally,   y = (1/m)(cid:80)

i yiy(cid:62)

we see therefore that pca    decorrelates    the input data. decorrelation
and statistical independence are not the same thing. if the coordinates are
statistically independent then the covariance matrix is diagonal   , but it does
not follow that uncorrelated variables must be statistically independent    
covariance is just one measure of dependence. in fact, the covariance is a
measure of pairwise dependency only. however, it is a fact that uncorrelated
x(x    

y(x       x)(y       y)p(x)(p(y) = (p

y(x       x)(y       y)p(x, y) = p

p

x

      xy = p
  x)p(x))(p

x

p
y(y       y)p(y)) = 0

5.2 pca: optimal reconstruction

47

variables are statistically independent if they have a multivariate normal
distribution (a gaussian). in other words, if the sample data x are drawn
from a id203 distribution p(x) which has gaussian form, the pca
transforms the sample data into a statistically independent set of variables
y = u(cid:62)x. the details are explained below.
x = (x1, ..., xn)(cid:62) is de   ned as p(x)     n(  ,   ):

recall that a multivariate normal distribution of the random variables

p(x) =

1

(2  )n/2|  |1/2

e    1

2 (x     )(cid:62)     1(x     ).

also recall that a linear combination of the variables produces also a normal
distribution n(u(cid:62)  , u(cid:62)  u):

  y =(cid:88)

(y      y)(y      y)(cid:62) =(cid:88)

(u(cid:62)x    u(cid:62)  x)(u(cid:62)x    u(cid:62)  x)(cid:62) = u(cid:62)  xu,

y

x

therefore choose u such that   y = u(cid:62)  u is a diagonal matrix   y =
diag(  2

n). we have in that case:

1, ...,   2

(2  )n/2(cid:81)

1

    1
e

2

i   i

p

i

    xi     i

   2

  i

which can be written as a product of univariate normal distributions pxi(xi):

p(x) =

1

    1

2

e

(2  )1/2  i

i=1

    xi     i

   2

  i

n(cid:89)

i=1

=

pxi(xi),

which proves the assertion that decorrelated normally distributed variables
are statistically independent.

5.2 pca: optimal reconstruction

a di   erent, yet equivalent, perspective on the pca transformation is as an
optimal reconstruction (in a least squares sense) after a dimension reduction.
we are given a sample data as before x1, ..., xm and we are looking for a small
number of orthonormal principal vectors u1, ..., uq where q < min(n, k)
which de   ne a q-dimensional linear subspace of rn which best approximate
the original input vectors in a least squares sense.
in other words, the
projection   xi of the sample points xi onto the q-dimensional subspace should
let u be the subspace spanned by the principal vectors (columns of u)
and let p be the n    n projection matrix mapping a point x     rn onto its
projection   x     u. from the de   nition of projection, the vector x       x must

i (cid:107)xi       xi(cid:107)2 over all possible q-dimensional subspaces of rn.

minimize(cid:80)

p(x) =

n(cid:89)

spectral analysis i: pca, lda, cca

48
be orthogonal to the subspace u. let y = (y1, ..., yq) be the coordinates of   x
with respect to the principal vectors, i.e., uy =   x. then, from orthogonality
we have that (x     uy)(cid:62)uw = 0 for all vectors w     rn. since this is true
for all w then u(cid:62)uy     u(cid:62)x = 0. therefore, y = (u(cid:62)u)   1u(cid:62)x and as a
result the projection matrix p becomes:

p = u(u(cid:62)u)   1u(cid:62),

satisfying p x =   x. in the case the columns of u are orthonormal, u(cid:62)u = i,
we have p = u u(cid:62). we are ready now to describe the optimization problem
on u: we wish to    nd an orthonormal set of principal vectors, u(cid:62)u = i,

i (cid:107)xi     u u(cid:62)xi(cid:107)2 is minimized.

i (cid:107)xi     u u(cid:62)xi(cid:107)2 = (cid:107)a     u u(cid:62)a(cid:107)2

i,j b2
ij
is the square frobenious norm of a matrix. the optimal reconstruction
problem therefore becomes:

f where (cid:107)b(cid:107)2

such that(cid:80)
note that (cid:80)

f = (cid:80)

(cid:107)a     u u(cid:62)a(cid:107)2

f

min
u

subject to u(cid:62)u = i.

we will show now that:

argmin

u

(cid:107)a     u u(cid:62)a(cid:107)2

f = argmax

u

trace(u(cid:62)aa(cid:62)u),

which shows that the optimal reconstruction problem is solved by pca
(recall eqn. 5.1).

from the identity (cid:107)b(cid:107)2
(cid:107)a     u u(cid:62)a(cid:107)2

f = trace(bb(cid:62)), we have:
f = trace((a     u u(cid:62)a)(a     u u(cid:62)a)(cid:62)).

expanding the right hand side gives us:
trace((a     u u(cid:62)a)(a     u u(cid:62)a)(cid:62)) = trace(aa(cid:62))     trace(aa(cid:62)u u(cid:62))

    trace(u u(cid:62)aa(cid:62)) + trace(u u(cid:62)aa(cid:62)u u(cid:62))

the second and third term are equal (commutativity of trace) and is also
equal to the 4th term due to commutativity of the trace and u(cid:62)u = i.
taken together:

(cid:107)a     u u(cid:62)a(cid:107)2

f = trace(aa(cid:62))     trace(u(cid:62)aa(cid:62)u).

to conclude, we have proven that by taking the    rst q eigenvectors of aa(cid:62)
we obtain a linear subspace which is as close as possible (in a least squares
sense) to the original sample data. hence, pca can be viewed as a vehi-
cle for optimal reconstruction after dimension reduction. the optimization

49
problem whose solution is the leading q eigenvectors of aa(cid:62) is described in
eqn. 5.1:

5.3 the case n >> m

trace(u(cid:62)aa(cid:62)u)

subject to u(cid:62)u = i.

max
u   rn  q

5.3 the case n >> m

consider the situation where n, the dimension of the input vectors, is rela-
tively large compared to the number of sample vectors m. for example, con-
sider input vectors representing 50   50 sized images of faces, i.e., n = 2500,
where m = 100. in other words, we are looking for a small number of    face
templates    (known as    eigenfaces   ) which approximate well the original set
of 100 face images. in this case, aa(cid:62) is very large, 2500  2500, yet the num-
ber of non-vanishing eigenvalues cannot be higher than 100. given that the
eigendecomposition process is o(25003), the computational burden would
be very high. however, it is possible to perform an eigendecomposition on
a(cid:62)a (a 100    100 matrix) instead, as shown next.

let the columns of q be the    rst q < m eigenvectors of a(cid:62)a, i.e., a(cid:62)aq =
qd where d is diagonal containing the corresponding eigenvalues. after
pre-multiplying both sides by a we obtain:

aa(cid:62)(aq) = (aq)d,

from which we conclude that aq contains the    rst q eigenvectors (but un-
normalized) of aa(cid:62). we have therefore that u = aqd    1

2 because:

u(cid:62)u = d    1

2 q(cid:62)a(cid:62)aqd    1

2 = d    1

2 dd    1

2 = i,

where we used the fact that q(cid:62)a(cid:62)aq = d. note that eigenvalues of a(cid:62)a
and aa(cid:62) are the same (because aa(cid:62)(aqd    1

2 ) = (aqd    1

2 )d).

5.4 kernel pca

we can take the case n >> m described in the previous section one step fur-
ther and consider such large values of n which are practically uncomputable
    a situation which results when mapping the original input vectors to a
high dimensional space:   (x) where    : rn     f for which dim(f) >> n.
for example,   (x) representing the d   th order monomials of the coordinates

(cid:1) which is exponential in d. the mappings

of x, i.e., dim(f) = (cid:0)n+d   1

of interest are those which are paired with a non-linear id81:
k(x, x(cid:48)) =   (x)(cid:62)  (x(cid:48)).

d

performing pca on a = [  (x1), ...,   (xm)] is equivalent to    nding the

50

spectral analysis i: pca, lda, cca

non-linear surface in rn (the nature of the non-linearity depends on the
choice of   ()) which best approximates the original sample data x1, ..., xm.
the problem is that aa(cid:62) is not computable     however a(cid:62)a is computable
because (a(cid:62)a)ij = k(xi, xj).

from the previous section, u = aqd    1

2 = av contains the    rst q eigen-
vectors of aa(cid:62)(where q and d are computable). since a itself is not
computable we cannot represent u explicitly, but we can project a new
vector   (x) onto the principal directions u1, ..., uq and obtain the principal
components, i.e., the output vector y = u(cid:62)  (x), as follows.

y = u(cid:62)  (x) = v (cid:62)a(cid:62)  (x) = v (cid:62)

                  

k(x1, x)

.
.
.

k(xm, x)

                   .

given the principal components (entries of y = u(cid:62)  (x) of   (x)) we can
measure, for example, the distance between   (x) and the projection     (x) =
u u(cid:62)  (x) = uy onto the linear subspace spanned by u1, ..., uq (without the
need to explicitly compute the principal axes ui), as follows.

(cid:107)  (x)         (x)(cid:107)2 =   (x)(cid:62)  (x) +     (x)

(cid:62)     (x)     2  (x)(cid:62)     (x)
= k(x, x) + y(cid:62)u(cid:62)uy     2  (x)(cid:62)(u u(cid:62)  (x))
= k(x, x)     y(cid:62)y     2y(cid:62)y
= k(x, x)     (cid:107)y(cid:107)2

5.5 fisher   s lda: basic idea

we now extend the variance preserving approach for data representation for
labeled data sets. we will focus on 2-class sets and look for a separating
hyperplane:

f(x) = w(cid:62)x + b,

such that x belongs to the    rst class if f(x) > 0 and x belongs to the second
class if f(x) < 0. in the statistical literature this type of function is called
a linear discriminant function. the decision boundary is given by the set
of points satisfying f(x) = 0 which is a hyperplane. fisher   s (1936) linear
discriminant analysis (lda) is a variance preserving approach for    nding
a linear discriminant function.

5.5 fisher   s lda: basic idea

51

fig. 5.1. id156 based on class centers alone is not su   cient.
seeking a projection which maximizes the distance between the projected centers
will prefer the horizontal axis over the vertical, yet the two classes overlap on the
horizontal axis. the projected distance along the vertical axis is smaller yet the
classes are better separated. the conclusion is that the sample variance of the two
classes must be taken into consideration as well.

we will then introduce another popular statistical technique called canon-
ical correlation analysis (cca) for learning the mapping between input and
output vectors using the notion    angle    between subspaces.

what is common in the three techniques pca, lda and cca is the use
of spectral matrix analysis     i.e., what can you do with eigenvalues and
eigenvectors of matrices representing subspaces of the data? these tech-
niques produce optimal results for normally distributed data and are very
easy to implement. there is a large variety of uses of spectral analysis in
statistical and learning literature including spectral id91, multi di-
mensional scaling (mds) and data modeling in general.

to appreciate the general idea behind fisher   s lda consider fig. 5.1. let
the centers of classes one and two be denoted by   1 and   2 respectively. a
linear discriminant function is a projection onto a 1d subspace such that
the classes would be separated the most in the 1d subspace. the obvious
   rst step in this kind of analysis is to make sure that the projected centers
    1,     2 would be separated as much as possible. we can easily see that the
direction of the 1d subspace should be proportional to   1       2 as follows:

(cid:18)w(cid:62)  1
(cid:107)w(cid:107)     w(cid:62)  2
(cid:107)w(cid:107)

(cid:19)2

(cid:18) w(cid:62)
(cid:107)w(cid:107)(  1       2)

(cid:19)2

.

=

(    1         2)2 =

the right-hand term is maximized when w       1       2. as illustrated in

52

spectral analysis i: pca, lda, cca

fig. 5.1, this type of consideration is not su   cient to capture separability
in the projected subspace because the spread (variance) of the data points
around their centers also play an important role. for example, the horizontal
axis in the    gure separates the centers better than the vertical axis but on
the other hand does a worse job in separating the classes themselves because
of the way the data points are spread around their centers. the argument
in favor of separating the centers would work if the data points were living
in a hyper-sphere around the centers, but will not be su   cient otherwise.

the basic idea behind fisher   s lda is to consider the sample covariance
matrix of the individual classes as well as their centers, in the following way.
the optimal 1d projection would that which maximizes the variance of the
projected centers while minimizes the variance of the projected data points
of each class separately. mathematically, this idea can be implemented by
maximizes the following ratio:

where s2

1 is the scaled variance of the projected points of the    rst class:

(    1         2)2
1 + s2
s2
2

,

(   xi         1)2,

(   xi         2)2,

max
w

1 = (cid:88)
2 = (cid:88)

xi   c1

xi   c2

s2

s2

and likewise,

where   x = w(cid:62)

(cid:107)w(cid:107)xi + b.

we will now formalize this approach and derive its solution. we will begin
with a general description of a multiclass problem where the sample data
points belong to q di   erent classes, and later focus on the case of q = 2.

5.6 fisher   s lda: general derivation

of the training set is l =(cid:80)

let the sample data points s be members of q classes c1, ..., cq where the
number of points belonging to class ci is denoted by li and the total number
i li. let   j denote the center of class ci and   

denote the center of the complete training set s:

xi

(cid:88)
(cid:88)

bf xi   cj

xi

xi   s

  j =

   =

1
lj
1
l

5.6 fisher   s lda: general derivation

53

let aj be the matrix associated with class cj whose columns consists of the
mean shifted data points:

aj = [x1       j, ..., xlj       j]

xi     cj.

aja(cid:62)

then, 1
is the covariance matrix associated with class cj. let sw
lj
(where    w    stands for    within   ) be the sum of the class covariance matrices:

j

q(cid:88)

i

sw =

aja(cid:62)
j .

1
lj

from the discussion in the previous section, it is
wish to minimize. to see why this is so, note
w(cid:62)(xi       j)2

(   xi         j)2 = (cid:88)

(cid:88)

=

(cid:107)w(cid:107)2

xi   cj

xi   cj

1
(cid:107)w(cid:107)2 w(cid:62)aja(cid:62)
j w.

1(cid:107)w(cid:107)2 w(cid:62)sww which we

let b be the matrix holding the class centers:

b = [  1       , ...,   q       ],

1(cid:107)w(cid:107)2 w(cid:62)sbw =(cid:80)

and let sb = 1
above it is
together, we wish to maximize the ratio (called    rayleigh   s quotient   ):

q bb(cid:62) (where    b    stands for    between   ). from the discussion
i(    i         )2 which we wish to maximize. taken

max
w j(w) =

w(cid:62)sbw
w(cid:62)sww .

the necessary condition for optimality is:

= sbw(w(cid:62)sww)     sww(w(cid:62)sbw)

(w(cid:62)sww)2

   j
   w

= 0,

from which we obtain the generalized eigensystem:

sbw = j(w)sww.

(5.2)

that is, w is the leading eigenvector of s   1
w sb (assuming sw is invertible).
the general case of    nding q such axes involves    nding the leading general-
ized eigenvectors of (sb, sw)     the derivation is out of scope of this lecture.
note that since s   1
w sb is not symmetric there may be no real-value solution,
which is a complication will not pursue further in this course. instead we
will focus now on the 2-class (q = 2) setting below.

54

spectral analysis i: pca, lda, cca

5.7 fisher   s lda: 2-class

the general derivation is simpli   ed when there are only two classes. the
covariance matrix bb(cid:62) becomes a rank-1 matrix:
bb(cid:62) = (  1       )(  1       )(cid:62) + (  2       )(  2       )(cid:62) = (  1       2)(  1       2)(cid:62).
as a result, bb(cid:62)w is a vector in direction   1       2. therefore, the solution
for w from eqn. 5.2 is:

w    = s   1

w (  1       2).
the decision boundary w(cid:62)(x       ) = 0 becomes:
(  1 +   2)(cid:62)s   1

w (  1       2)     1
2

x(cid:62)s   1

w (  1       2) = 0.

(5.3)

this decision boundary will surface again in the course when we consider
bayseian id136.
it will be shown that this decision boundary is the
maximum likelihood solution in the case where the two classes are normally
distributed with means   1,   2 and with the same covariance matrix sw.

5.8 lda versus id166

both lda and id166 search for a so called    optimal    linear discriminant
function, what is the di   erence? the heart of the matter lies in the de   nition
of what constitutes a su   cient compact representation of the data. in lda
the assumption is that each class can be represented by its mean vector and
its spread (i.e., covariance matrix). this is true for normally distributed
data     but not true in general. this means that we should expect that
lda will produce the optimal discriminant linear function when each of the
classes are normally distributed.

with id166, on the other hand, there is no assumption on how the data
is distributed. instead, the emerging result is that the data is represented
by the subset of data points which lie on the boundary between the two
classes (the so called support vectors). rather than making a parametric
assumption on how the data can be captured (i.e., mean and covariance) the
theory shows that the data can be captured by a special subset of points. the
tools, as a result, are naturally more complex (quadratic id135
versus spectral matrix analysis)     but the advantage is that optimality is
guaranteed without making assumptions on the distribution of the data (i.e.,
distribution free). it can be shown that id166 and lda would produce the
same result if the class data is normally distributed.

5.9 canonical correlation analysis

55

5.9 canonical correlation analysis

cca is a technique for learning a mapping f(x) = y where x     rk and
y     rs using the notion of subspace similarity (an extension of the inner
product between two vectors) from a training set of (xi, yi), i = 1, ..., n. such
a mapping, where y can be any point in rk as opposed to a discrete set of
labels, is often referred to as a    regression    (as opposed to    classi   cation   ).
like in pca and lda, the approach would be to look for projection axes
such that the projection of the input and output vectors on those axes satisfy
certain requirements     and like pca and lda the tools we would be using
is matrix spectral analysis.

1 , ..., x(cid:62)

1 , ..., y(cid:62)

1 u, ..., x(cid:62)

it will be convenient to stack our vectors as rows of an input matrix a and
output matrix b. let a be an n    k matrix whose rows are x(cid:62)
n and
n . consider vectors u     rk
b is the n    s matrix whose rows are y(cid:62)
and v     rs and project the input and output data onto them producing
au = (x(cid:62)
n u) and bv. the requirement we would like to place on
the projection axes is that au     bv, or in other words that (au)(cid:62)(bv)
is maximal. the requirement therefore is that the projection of the input
points onto the u axis is similar to the projection of the output points
onto the v axis.
if we extend this notion to multiple axes u1, ..., uq (not
necessarily orthogonal) and v1, ..., vq where q     min(k, s) our requirement
becomes that the new coordinates of the input points projected onto the
subspace spanned by the u vectors are similar to the new coordinates of
the output points projected onto the subspace spanned by the v vectors.
in other words, we wish to    nd two q-dimensional subspaces one of rk and
the other of rs such that the two sets of projected points are as aligned as
possible.

cca goes a step further and makes the assumption that the input/output
relationship is solely determined by the relation (angles) between the column
spaces of a, b. in other words, the particular columns of a are not really
important, what is important is the space ua spanned by the columns.
since g = au is a point in ua (a linear combination of the columns of
a) and h = bv is a point in ub, then g(cid:62)h is the cosine angle, cos(  )
between the two axes provided that we normalize the vectors g and h. if
we continue this line of reasoning recursively, we obtain a set of angles
0       1     ...       q     (  /2), called    principal angles   , between the two
subspaces uniquely de   ned as:

cos(  j) = max
g   ua

max
h   ub

g(cid:62)h

(5.4)

56

subject to:

spectral analysis i: pca, lda, cca

g(cid:62)g = h(cid:62)h = 1, h(cid:62)hi = 0, g(cid:62)gi = 0,

i = 1, ..., j     1

as a result, we obtain the following optimization function over axes u, v:

u(cid:62)a(cid:62)bv s.t.

(cid:107)au(cid:107)2 = 1, (cid:107)bv(cid:107)2 = 1.

max
u,v

to solve this problem we    rst perform a    qr    factorization of a and b. a
   qr    factorization of a matrix a is a grahm-schmidt process resulting in
an orthonormal set of vectors arranged as the columns of a matrix qa whose
column space is equal to the column space of a, and a matrix ra which
contains the coe   cients of the linear combination of the columns of qa such
that a = qara. since orthoganilzation is not unique, the grahm-schmidt
process perfroms the orthogonalization such that ra is an upper-diagonal
matrix. likewise let b = qbrb. because the column spaces of a and qa
are the same, then for every u there exists a   u such that au = qa  u. our
optimization problem now becomes:

  u(cid:62)q(cid:62)

aqb   v s.t. (cid:107)  u(cid:107)2 = 1, (cid:107)  v(cid:107)2 = 1.

max
  u,   v

the solution of this problem is when   u and   v are the leading singular vectors
of q(cid:62)
aqb. the singular value decomposition (svd) of any matrix e is a
decomposition e = u dv (cid:62) where the columns of u are the leading eigen-
vectors of ee(cid:62), the rows of v (cid:62) are the leading eigenvectors of e(cid:62)e and
d is a diagonal matrix whose entries are the corresponding square eigen-
values (note that the eigenvalues of ee(cid:62) and e(cid:62)e are the same). the
svd decomposition has the property that if we keep only the    rst q leading
eigenvectors then u dv (cid:62) is the closest (in least squares sense) rank q matrix
to e.
therefore, let   u d   v (cid:62) be the svd of q(cid:62)
aqb using the    rst q eigenvectors.
then, our sought after axes u = [u1, ..., uq] is simply r   1
  u and likewise
and the axes v = [v1, ..., vq] is equal to r   1
  v . the axes are called    canon-
ical vectors   , and the vectors gi = aui (mutually orthogonal) are called
   variates   . the concept of principal angles is due to jordan in 1875, where
hotelling in 1936 is the    rst to introduce the recursive de   nition above.
given a new vector x     rk the resulting vector y can be found by solving
the linear system u(cid:62)x = v (cid:62)y (since our assumption is that in the new basis
the coordinates of x and y are similar).

b

a

to conclude, the relationship between a and b is captured by creating
similar variates, i.e., creating subspaces of dimension q such that the projec-
tions of the input vectors and the output vectors have similar coordinates.

5.9 canonical correlation analysis

57

the process for obtaining the two q-dimensional subspaces is by performing
a qr factorization of a and b followed by an svd. here again the spectral
analysis of the input and output data matrices plays a pivoting role in the
input/output association.

6

spectral analysis ii: id91

in the previous lecture we ended up with the formulation:

trace(g(cid:62)kg)

s.t. g(cid:62)g = i

max
gm  k

(6.1)

and showed the solution g is the leading eigenvectors of the symmetric pos-
itive semi de   nite matrix k. when k = aa(cid:62) (sample covariance matrix)
with a = [x1, ..., xm], xi     rn, those eigenvectors form a basis to a k-
dimensional subspace of rn which is the closest (in l2 norm sense) to the
sample points xi. the axes (called principal axes) g1, ..., gk preserve the
variance of the original data in the sense that the projection of the data
points on the g1 has maximum variance, projection on g2 has the maximum
variance over all vectors orthogonal to g1, etc. the spectral decomposition
of the sample covariance matrix is a way to    compress    the data by means
of linear super-position of the original coordinates y = g(cid:62)x.

we also ended with a ratio formulation:
w(cid:62)s1w
w(cid:62)s2w

max
w

where s1, s2 where scatter matrices de   ned such that w(cid:62)s1w is the variance
of class centers (which we wish to maximize) and w(cid:62)s2w is the sum of
within class variance (which we want to minimize). the solution w is the
generalized eigenvector s1w =   s2w with maximal   .

in this lecture we will show additional applications where the search for
leading eigenvectors plays a pivotal part of the solution. so far we have
seen how spectral analysis relates to pca and lda and today we will fo-
cus on the classic data id91 problem of partitioning a set of points
x1, ..., xm into k     2 classes, i.e., generating as output indicator variables
y1, ..., ym where yi     {1, ..., k}. we will begin with    id116    algorithm for
id91 and then move on to show how the optimization criteria relates

58

6.1 id116 algorithm for id91

59

to grapth-theoretic approaches (like min-cut, ratio-cut, normalized cuts)
and spectral decomposition.

6.1 id116 algorithm for id91

the id116 formulation (originally introduced by [4]) assumes that the
clusters are de   ned by the distance of the points to their class centers only.
in other words, the goal of id91 is to    nd those k mean vectors c1, ..., ck
and provide the cluster assignment yi     {1, ..., k} of each point xi in the set.
the id116 algorithm is based on an interleaving approach where the
cluster assignments yi are established given the centers and the centers are
computed given the assignments. the optimization criterion is as follows:

min

y1,...,ym,c1,...,ck

(cid:107)xi     cj(cid:107)2

(6.2)

k(cid:88)

(cid:88)

j=1

yi=j

assume that c1, ..., ck are given from the previous iteration, then

yi = argmin

j

(cid:107)xi     cj(cid:107)2,

and next assume that y1, .., ym (cluster assignments) are given, then for any
set s     {1, ..., m} we have that

(cid:88)

j   s

1
|s|

(cid:88)

j   s

xj = argmin

c

(cid:107)xj     c(cid:107)2.

in other words, given the estimated centers in the current round, the new
assignments are computed by the closest center to each point xi, and then
given the updated assignments the new centers are estimated by taking the
mean of each cluster. since each step is guaranteed to reduce the optimiza-
tion energy the process must converge     to some local optimum.

the drawback of the id116 algorithm is that the quality of the local
optimum strongly depends on the initial guess (either the centers or the
assignments). if we start with a wild guess for the centers it would be fairly
unlikely that the process would converge to a good local minimum (i.e. one
that is close to the global optimum). an alternative approach would be to
de   ne an approximate but simpler problem which has a closed form solution
(such as obtained by computing eigenvectors of some matrix). the global
optimum of the id116 is an np-complete problem (mentioned brie   y in
the next section).

next, we will rewrite the id116 optimization criterion in matrix form

and see that it relates to the spectral formulation (eqn. 6.1).

60

spectral analysis ii: id91

6.1.1 matrix formulation of id116

we rewrite eqn. 6.2 as follows [7]. instead of carrying the class variables yi

we de   ne class sets   1, ...,   k where   i     {1, ..., n} with (cid:83)   j = {1, ..., n}
(cid:84)   j =    . the id116 optimization criterion seeks for the centers

and   i
and the class sets:

min

  1,...,  k,c1,...,ck

(cid:107)xi     cj(cid:107)2.

k(cid:88)

(cid:88)

j=1

i     j

k(cid:88)

let lj = |  j| and following the expansion of the squared norm and dropping
x(cid:62)
i xi we end up with an equivalent problem:
j cj     2

(cid:88)
k(cid:88)
next we substitute cj with its de   nition: (1/lj)(cid:80)

xj and obtain a new
equivalent formulation where the centers cj are eliminated form considera-
tion:

  1,...,  k,c1,...,ck

x(cid:62)
i cj.

ljc(cid:62)

i     j

i     j

min

j=1

j=1

x(cid:62)
r xs

(cid:88)

r,s     j

1
lj

(cid:88)

    k(cid:88)
k(cid:88)

j=1

1
lj

j=1

r,s     j

min
  1,...,  k

max
  1,...,  k

which is more conveniently written as a maximization problem:

x(cid:62)
r xs.

(6.3)

since the resulting formulation involves only inner-products we could have
replaced xi with   (xi) in eqn. 6.2 where the mapping   (  ) is chosen such
that   (xi)(cid:62)  (xj) can be replaced by some non-linear function   (xi, xj)    
known as the    kernel trick    (discussed in previous lectures). having the
ability to map the input vectors onto some high-dimensional space before
id116 is applied provides more    exibility and increases our chances of
getting out a    good    id91 from the global id116 solution (again,
the local optimum depends on the initial conditions so it could be    bad   ).
the rbf kernel is quite popular in this context   (xi, xj) = e   (cid:107)xi   xj(cid:107)2/  2
with    some pre-determined parameter. note that   (xi, xj)     (0, 1] which
can be interpreted loosely as the id203 of xi and xj to be clustered
together.
let kij =   (xi, xj) making k a m    m symmetric positive-semi-de   nite
matrix often referred to as the    a   nity    matrix. let f be an n    n matrix
whose entries are fij = 1/lr if (i, j)       r for some class   r and fij = 0

6.1 id116 algorithm for id91

61

otherwise.
in other words, if we sort the points xi according to cluster
membership, then f is a block diagonal matrix with blocks f1, ..., fk where
fr = (1/lr)11(cid:62) is an lr    lr block of 1   s scaled by 1/lr. then, eqn. 6.3 can
be written in terms of k as follows:

kijfij = trace(kf )

(6.4)

n(cid:88)

i,j=1

max

f

in order to form this as an optimization problem we need to represent the
structure of f in terms of constraints. let g be an n    k column-scaled

indicator matrix: gij = (1/(cid:112)lj) if i       j (i.e., xi belongs to the j   th class)

(cid:62) = diag(0, .., fr, 0, .., 0) therefore f =(cid:80)

and gij = 0 otherwise. let g1, ..., gk be the columns of g and it can be easily
j = gg(cid:62).
veri   ed that grgr
since trace(ab) = trace(ba) we can now write eqn. 6.4 in terms of g:

j gjg(cid:62)

trace(g(cid:62)kg)

max

g

under conditions on g which we need to further spell out.

we will start with the necessary conditions. clearly g     0 (has non-
negative entries). because each point belongs to exactly one cluster we must
have g(cid:62)gij = 0 when i (cid:54)= j and g(cid:62)gii = (1/li)1(cid:62)1 = 1, thus g(cid:62)g = i.
furthermore we have that the rows and columns of f = gg(cid:62) sum up to
1, i.e., f 1 = 1, f (cid:62)1 = 1 which means that f is doubly stochastic which
translates to the constraint gg(cid:62)1 = 1 on g. we have therefore three
necessary conditions on g: (i) g     0, (ii) g(cid:62)g = i, and (iii) gg(cid:62)1 = 1.
the claim below asserts that these are also su   cient conditions:

claim 4 the feasibility set of matrices g which satisfy the three conditions
g     0, gg(cid:62)1 = 1 and g(cid:62)g = i are of the form:

(cid:40) 1   

lj
0

gij =

(cid:41)

xi       j
otherwise

proof: from g     0 and g(cid:62)
r gs = 0 we have that girgis = 0, i.e., g
has a single non-vanishing element in each row.
it will be convenient to
assume that the points are sorted according to the class membership, thus
the columns of g have the non-vanishing entries in consecutive order and
let lj be the number of non-vanishing entries in column gj. let uj the
vector of lj entries holding only the non-vanishing entries of gj. then,
the doubly stochastic constraint gg(cid:62)1 = 1 results that (1(cid:62)uj)uj = 1 for
j = 1, ..., k. multiplying 1 from both sides yields (1(cid:62)uj)2 = 1(cid:62)1 = lj,

therefore uj = (1/(cid:112)lj)1.

62

spectral analysis ii: id91

this completes the equivalence between the matrix formulation:

trace(g(cid:62)kg)

s.t. g     0, g(cid:62)g = i, gg(cid:62)1 = 1

(6.5)

max

g   rm  k

and the original id116 formulation of eqn. 6.2.

we have obtained the same optimization criteria as eqn. 6.1 with addi-
tional two constraints: g should be non-negative and gg(cid:62) should be doubly
stochastic. the constraint g(cid:62)g = i comes from the requirement that each
point is assigned to one class only. the doubly stochastic constraint comes
from a    class balancing    requirement which we will expand on below.

6.2 min-cut

we will arrive to eqn. 6.5 from a graph-theoretic perspective. we start
with representing the graph min-cut problem in matrix form, as follows.
a convenient way to represent the data to be clustered is by an undirected
graph with edge-weights where v = {1, ..., m} is the vertex set, e     v    v
is the edge set and    : e     r+ is the positive weight function. vertices
of the graph correspond to data points xi, edges represent neighborhood
relationships, and edge-weights represent the similarity (a   nity) between
pairs of linked vertices. the weight adjacency matrix k holds the weights
where kij =   (i, j) for (i, j)     e and kij = 0 otherwise.
a cut in the graph is de   ned between two disjoint sets a, b     v , a    
b = v , is the sum of edge-weights connecting the two sets: cut(a, b) =
i   a,j   b kij which is a measure of dissimilarity between the two sets. the
min-cut problem is to    nd a minimal weight cut in the graph (can be solved
in polynomial time through max network flow solution). the following
claim associates algebraic conditions on g with an indicator matrix:

(cid:80)

claim 5 the feasibility set of matrices g which satisfy the three conditions
g     0, g1 = 1 and g(cid:62)g = d for some diagonal matrix d are of the form:

(cid:26) 1

gij =

xi       j
0 otherwise

(cid:27)

proof: let g = [g1, ..., gk]. from g     0 and g(cid:62)
r gs = 0 we have that
girgis = 0, i.e., g has a single non-vanishing element in each row. from
g1 = 1 the single non-vanishing entry of each row must have the value of
1.

in the case of two classes (k = 2), the function tr(g(cid:62)kg) is equal to
kij. therefore maxg tr(g(cid:62)kg) is equivalent to
(i,j)     1

kij +(cid:80)

(cid:80)

(i,j)     2

minimizing the cut: (cid:80)

6.3 spectral id91: ratio-cuts and normalized-cuts

63

i     1,j     2

kij. as a result, the min-cut problem is

equivalent to solving the optimization problem:

tr(g(cid:62)kg) s.t g     0, g1 = 1, g(cid:62)g = diag

(6.6)

max
g   rm  2

we seem to be close to eqn. 6.5 with the di   erence that g is orthogonal
(instead of orthonormal) and the doubly-stochasitc constraint is replaced
by g1 = 1. the di   erence can be bridged by considering a    balancing   
requirement. min-cut can produce an unbalanced partition where one set
of vertices is very large and the other contains a spurious set of vertices
having a small number of edges to the larger set. this is an undesirable
outcome in the context of id91. consider a    balancing    constraint
g(cid:62)1 = (m/k)1 which makes a strict requirement that all the k clusters have
an equal number of points. we can relax the balancing constraint slightly by
combining the balancing constraint with g1 = 1 into one single constraint
gg(cid:62)1 = (m/k)1, i.e., gg(cid:62) is scaled doubly stochastic. note that the two
conditions gg(cid:62)1 = (m/k)1 and g(cid:62)g = d result in d = (m/k)i. thus we
propose the relaxed-balanced hard id91 scheme:

max

g

tr(g(cid:62)kg) s.t g     0, gg(cid:62)1 = m
k

1, g(cid:62)g = m
k

i

the scale m/k is a global scale that can be dropped without a   ecting the
resulting solution, thus the min-cut with a relaxed balancing requirement
becomes eqn. 6.5 which we saw is equivalent to id116:

tr(g(cid:62)kg) s.t g     0, gg(cid:62)1 = 1, g(cid:62)g = i.

max

g

6.3 spectral id91: ratio-cuts and normalized-cuts

we saw above that the doubly-stochastic constraint has to do with a    bal-
ancing    desire. a further relaxation of the balancing desire is to perform the
optimization in two steps: (i) replace the a   nity matrix k with the closest
(under some chosen error measure) doubly-stochastic matrix k(cid:48), (ii)    nd a
solution to the problem:

tr(g(cid:62)k(cid:48)g) s.t g     0, g(cid:62)g = i

(6.7)

max

g   rm  k

because gg(cid:62) should come out close to k(cid:48) (tr(g(cid:62)k(cid:48)g) = tr(k(cid:48)gg(cid:62)))
and k(cid:48) is doubly-stochastic, then gg(cid:62) should come out close to satisfying
a doubly-stochastic constraint     this is the motivation behind the 2-step
approach. moreover, we drop the non-negativity constraint g     0. note
that the non-negativity constraint is crucial for the physical interpretation of

64

spectral analysis ii: id91

g; nevertheless, for k = 2 clusters it is possible to make an interpretation, as
we shall next. as a result we are left with a spectral decomposition problem
of eqn. 6.1:

tr(g(cid:62)k(cid:48)g) s.t g(cid:62)g = i,

max

g   rm  k

where the columns of g are the leading eigenvectors of k(cid:48). we will refer
to the    rst step as a    id172    process and there are two popular
id172s in the literature     one leading to ratio-cuts and the other
to normalized-cuts.

6.3.1 ratio-cuts

let d = diag(k1) which is a diagonal matrix containing the row sums of
k. the ratio-cuts id172 is to look for k(cid:48) as the closest doubly-
stochastic matrix to k by minimizing the l1 norm     this turns out to be
k(cid:48) = k     d + i.

claim 6 (ratio-cut) let k be a symmetric positive-semi-de   nite whose
values are in the range [0, 1]. the closest doubly stochastic matrix k(cid:48) under
the l1 error norm is

k(cid:48) = k     d + i

proof: let r = minf (cid:107)k     f(cid:107)1 s.t. f 1 = 1, f = f (cid:62). since (cid:107)k     f(cid:107)1    
(cid:107)(k     f )1(cid:107)1 for any matrix f , we must have:

r     (cid:107)(k     f )1(cid:107)1 = (cid:107)d1     1(cid:107)1 = (cid:107)d     i(cid:107)1.

let f = k     d + i, then

(cid:107)k     (k     d + i)(cid:107)1 = (cid:107)d     i(cid:107)1.

the laplacian matrix of a graph is d     k. if v is an eigenvector of the
laplacian d     k with eigenvalue   , then v is also an eigenvector of k(cid:48) =
k     d + i with eigenvalue 1        and since (d     k)1 = 0 then the smallest
eigenvector v = 1 of the laplacian is the largest of k(cid:48), and the second
smallest eigenvector of the laplacian (the ratio-cut result) corresponds to the
second largest eigenvector of k(cid:48). because the eigenvectors are orthogonal,
the second eigenvector must have positive and negative entries (because the
inner-product with 1 is zero)     thus the sign of the entries of the second
eigenvector determines the class membership.

6.3 spectral id91: ratio-cuts and normalized-cuts

65
ratio-cuts, the second smallest eigenvector of the laplacian d     k, is
an approximation due to hall in the 70s [2] to the min-cut formulation.
let z     rm determine the class membership such that xi and xj would be
clustered together if zi and zj have similar values. this leads to the following
optimization problem:

(cid:88)

i,j

min
z

1
2

(zi     zj)2kij

s.t. z(cid:62)z = 1

the criterion function is equal to (1/2)z(cid:62)(d    k)z and the derivative of the
lagrangian (1/2)z(cid:62)(d     k)z       (z(cid:62)z     1) with respect to z gives rise to
the necessary condition (d     k)z =   z and the ratio-cut scheme follows.

6.3.2 normalized-cuts

normalized-cuts looks for the closest doubly-stochastic matrix k(cid:48) in relative
id178 error measure de   ned as:

re(x || y) =(cid:88)

+(cid:88)

yi    (cid:88)

i

i

xi.

xi ln xi
yi

i

we will encounter the relative id178 measure in more detail later in the
course. we can show that k(cid:48) must have the form   k   for some diagonal
matrix   :

claim 7 the closest doubly-stochastic matrix f under the relative-id178
error measure to a given non-negative symmetric matrix k, i.e., which min-
imizes:

re(f||k) s.t. f     0, f = f (cid:62), f 1 = 1, f (cid:62)1 = 1

min
f

has the form f =   k   for some (unique) diagonal matrix   .

proof: the lagrangian of the problem is:

+(cid:88)

kij    (cid:88)

fij    (cid:88)

  i((cid:88)

fij    1)   (cid:88)

  j((cid:88)

fij    1)

l() =(cid:88)

fij ln fij
kij

ij

ij

ij

i

j

j

i

the derivative with respect to fij is:

= ln fij + 1     ln kij     1       i       j = 0

   l
   fij

from which we obtain:

fij = e  ie  j kij

66

spectral analysis ii: id91

let d1 = diag(e  1, ..., e  n) and d2 = diag(e  1, ..., e  n), then we have:

f = d1kd2

since f = f (cid:62) and k is symmetric we must have d1 = d2.
next, we can show that the diagonal matrix    can found by an iterative
process where k is replaced by d   1/2kd   1/2 where d was de   ned above
as diag(k1):

claim 8 for any non-negative symmetric matrix k(0), iterating the process
k(t+1)     d   1/2k(t)d   1/2 with d = diag(k(t)1) converges to a doubly
stochastic matrix.

the proof is based on showing that the permanent increases monotonically,
i.e. perm(k(t+1))     perm(k(t)). because the permanent is bounded the
process must converge and if the permanent does not change (at the conver-
gence point) the resulting matrix must be doubly stochastic. the resulting
doubly stochastic matrix is the closest to k in relative-id178.

normalized-cuts takes the result of the    rst iteration by replacing k
with k(cid:48) = d   1/2kd   1/2 followed by the spectral decomposition (in case
of k = 2 classes the partitioning information is found in the second leading
eigenvector of k(cid:48)     just like ratio-cuts but with a di   erent k(cid:48)). thus, k(cid:48)
in this manner is not the closest doubly-stochastic matrix to k but is fairly
close (the    rst iteration is the dominant one in the process).

normalized-cuts, as the second leading eigenvector of k(cid:48) = d   1/2kd   1/2,
is an approximation to a    balanced    min-cut described    rst in [6]. deriving
it from    rst principles proceeds as follows:

let sum(v1, v2) = sumi   v1,j   v2kij be de   ned for any two subsets (not
necessarily disjoint) of vertices. the normalized-cuts measures the cut cost
as a fraction of the total edge connections to all the nodes in the graph:

n cuts(a, b) = cut(a, b)
sum(a, v )

+ cut(a, b)
sum(b, v ) .

a minimal ncut partition will no longer favor small isolated points since the
cut value would most likely be a large percentage of the total connections
from that small set to all the other vertices. a related measure n assoc(a, b)
de   ned as:

n assoc(a, b) = sum(a, a)
sum(a, v )

+ sum(b, b)
sum(b, v ) ,

re   ects how tightly on average nodes within the group are connected to each
other. given that cut(a, b) = sum(a, v )    sum(a, a) one can easily verify

6.3 spectral id91: ratio-cuts and normalized-cuts

67

that:

n cuts(a, b) = 2     n assoc(a, b),

therefore the optimal bi-partition can be represented as maximizing n assoc(a, v    
a). the n assoc naturally extends to k > 2 classes (partitions) as follows:
let   1, ...,   k be disjoint sets    j  j = v , then:

k(cid:88)

sum(  j,   j)
sum(  j, v ) .

n assoc(  1, ...,   k) =

eqn. 6.7. let   g = [g1, ..., gk] with gj = 1/(cid:112)sum(  j, v )(0, ..., 0, 1, ...1, 0., , , 0)

we will now rewrite n assoc in matrix form and establish equivalence to

j=1

with the 1s indicating membership to the j   th class. note that

j kgj = sum(  j,   j)
g(cid:62)
sum(  j, v ) ,

(1/sum(  i, v ))(cid:80)

therefore trace(   g(cid:62)k   g) = n assoc(  1, ...,   k). note also that g(cid:62)

i dgi =
dr = 1, therefore   g(cid:62)d   g = i. let g = d1/2   g so we
have that g(cid:62)g = i and trace(g(cid:62)d   1/2kd   1/2g) = n assoc(  1, ...,   k).
taken together we have that maximizing n assoc is equivalent to:

r     i

trace(g(cid:62)k(cid:48)g)

s.t. g     0, g(cid:62)g = i,

(6.8)

max

g   rm  k

where k(cid:48) = d   1/2kd   1/2. note that this is exactly the id116 matrix
setup of eqn. 6.5 where the doubly-stochastic constraint is relaxed into the
replacement of k by k(cid:48). the constraint g     0 is then dropped and the
resulting solution for g is the k leading eigenvectors of k(cid:48).
we have arrived via seemingly di   erent paths to eqn. 6.8 which after we
drop the constraint g     0 we end up with a closed form solution consisting
of the k leading eigenvectors of k(cid:48). when k = 2 (two classes) one can
easily verify that the partitioning information is fully contained in the second
eigenvector. let v1, v2 be the    rst leading eigenvectors of k(cid:48). clearly
v = d1/21 is an eigenvector with eigenvalue    = 1:

d   1/2kd   1/2(d1/21) = d   1/2k1 = d1/21.

in fact    = 1 is the largest eigenvalue (left as an exercise) thus v1 = d1/21 >
0. since k(cid:48) is symmetric the v(cid:62)
2 v1 = 0 thus v2 contains positive and
negative entries     those are interpreted as indicating class membership
(positive to one class and negative to the other).

the case k > 2 is treated as an embedding (also known as multi-dimensional

scaling) by re-coordinating the points xi using the rows of g.

in other

68

spectral analysis ii: id91

words, the i   th row of g is a representation of xi in rk. under ideal con-
ditions where k is block diagonal (the distance between clusters is in   nity)
the rows associated with points clustered together are identical (i.e., the n
original points are mapped to k points in rk) [5]. in practice, one performs
the iterative id116 in the embedded space.

7

the formal (pac) learning model

we have see so far algorithms that explicitly estimate the underlying dis-
tribution of the data (bayesian methods and em) and algorithms that are
in some sense optimal when the underlying distribution is gaussian (pca,
lda). we have also encountered an algorithm (id166) that made no as-
sumptions on the underlying distribution and instead tied the accuracy to
the margin of the training data.

in this lecture and in the remainder of the course we will address the
issue of    accuracy    and    generalization    in a more formal manner. because
the learner receives only a    nite training sample, the learning function can
do very well on the training set yet perform badly on new input instances.
what we would like to establish are certain guarantees on the accuracy of
the learner measured over all the instance space and not only on the training
set. we will then use those guarantees to better understand what the large-
margin principle of id166 is doing in the context of generalization.

in the remainder of this lecture we will refer to the following notations:
the class of learning functions is denoted by c. a learning functions is often
referred to as a    concept    or    hypothesis   . a target function ct     c is a
function that has zero error on all input instances (such a function may not
always exist).

7.1 the formal model

in many learning situations of interest, we would like to assume that the
learner receives m examples sampled by some    xed (yet unknown) distri-
bution d and the learner must do its best with the training set in order to
achieve the accuracy and con   dence objectives. the probably approximate
correct (pac) model, also known as the    formal model   ,    rst introduced by

69

70

the formal (pac) learning model

valient in 1984, provides a probabilistic setting which formalizes the notions
of accuracy and con   dence.
the pac model makes the following statistical assumption. we assume
the learner receives a set s of m instances x1, ..., xm     x which are sampled
randomly and independently according to a distribution d over x. in other
words, a random training set s of length m is distributed according to the
product id203 distribution dm. the distribution d is unknown, but
we will see that one can obtain useful results by simply assuming that d is
   xed     there is no need to attempt to recover d during the learning process.
to recap, we make the following three assumptions: (i) d is unkown, (ii)
d is    xed throughout the learning process, and (iii) the example instances
are sampled independently of each other (are identically and independently
distributed     i.i.d.).

we distinguish between the    realizable    case where a target concept ct(x)
is known to exist, and the unrealizable case, where there is no such guar-
antee. in the realizable case our training examples are z = {(xi, ct(xi)},
i = 1, ..., m and d is de   ned over x (since yi     y are given by ct(xi)). in
the unrealizable case, z = {(xi, yi)} and d is the distribution over x    y
(each element is a pair, one from x and the other from y ).
we next de   ne what is meant by the error induced by a concept function
h(x). in the realizable case, given a function h     c, the error of h is de   ned
with respect to the distribution d:

err(h) = probd[x : ct(x) (cid:54)= h(x)] =

ind(ct(x) (cid:54)= h(x))d(x)dx

(cid:90)

x   x

where ind(f ) is an indication function which returns    1    if the proposition
f is true and    0    otherwise. the function err(h) is the id203 that
an instance x sampled according to d will be labeled incorrectly by h(x).
let   > 0 be a parameter given to the learner specifying the    accuracy    of
the learning process, i.e. we would like to achieve err(h)      . note that
err(ct) = 0.

in addition, we de   ne a    con   dence    parameter    > 0, also given to the

learner, which de   nes the id203 that err(h) >  , namely,

or equivalently:

prob[err(h) >  ] <   ,

prob[err(h)      ]     1       .

in other words, the learner is supposed to meet some accuracy criteria but
is allowed to deviate from it by some small id203. finally, the learning

7.1 the formal model

71

algorithm is supposed to be    e   cient    if the running time is polynomial in
1/ , ln(1/  ), n and the size of the concept target function ct() (measured by
the number of bits necessary for describing it, for example).
we will say that an algorithm l learns a concept family c in the formal
sense (pac learnable) if for any ct     c and for every distribution d on the
instance space x, the algorithm l generates e   ciently a concept function
h     c such that the id203 that err(h)       is at least 1       .

the inclusion of the con   dence value    could seem at    rst unnatural.
what we desire from the learner is to demonstrate a consistent performance
regardless of the training sample z. in other words, it is not enough that
the learner produces a hypothesis h whose accuracy is above threshold, i.e.,
err(h)      , for some training sample z. we would like the accuracy per-
formance to hold under all training samples (sampled from the distribution
dm)     since this requirement could be too di   cult to satisfy, the formal
model allows for some    failures   , i.e, situations where err(h) >  , for some
training samples z, as long as those failures are rare and the frequency of
their occurrence is controlled (the parameter   ) and can be as small as we
like.
in the unrealizable case, there may be no function h     c for which
err(h) = 0, thus we need to de   ne what we mean by the best a learning
algorithm can achieve:

opt(c) = min
h   c

err(h),

which is the best that can be done on the concept class c using functions
that map between x and y . given the desired accuracy   and con   dence   
values the learner seeks a hypothesis h     c such that:
prob[err(h)     opt(c) +  ]     1       .

we are ready now to formalize the discussion above and introduce the de   -
nition of the formal learning model (anthony & bartlett [1], pp. 16):

de   nition 1 (formal model) let c be the concept class of functions that
map from a set x to y . a learning algorithm l is a function:

   (cid:91)

l :

{(xi, yi)}m

i=1     c

m=1

from the set of all training examples to c with the following property: given
any  ,        (0, 1) there is an integer m0( ,   ) such that if m     m0 then, for
any id203 distribution d on x    y , if z is a training set of length m

72

the formal (pac) learning model

drawn randomly according to the product id203 distribution dm, then
with id203 of at least 1        the hypothesis h = l(z)     c output by
l is such that err(h)     opt(c) +  . we say that c is learnable (or pac
learnable) if there is a learning algorithm for c.

there are few points to emphasize. the sample size m0( ,   ) is a suf-
   cient sample size for pac learning c by l and is allowed to vary with
 ,   . decreasing the value of either   or    makes the learning problem more
di   cult and in turn a larger sample size is required. note however that
m0( ,   ) does not depend on the distribution d! that is, a su   cient sample
size can be given that will work for any distribution d     provided that
d is    xed throughout the learning experience (both training and later for
testing). this point is a crucial property of the formal model because if the
su   cient sample size is allowed to vary with the distribution d then not
only we would need to have some information about the distribution in or-
der to set the sample complexity bounds, but also an adversary (supplying
the training set) could control the rate of convergence of l to a solution
(even if that solution can be proven to be optimal) and make it arbitrarily
slow by suitable choice of d.

what makes the formal model work in a distribution-invariant manner
is that it critically depends on the fact that in many interesting learning
scenarios the concept class c is not too complex. for example, we will show
later in the lecture that any    nite concept class |c| <     is learnable, and
the sample complexity (in the realizable case) is

m     1
 

ln

|c|
  

.

in the next lecture we will consider concept classes of in   nite size and show
that despite the fact that the class is in   nite it still can be of low complexity!
before we illustrate the concepts above with an example, there is another
useful measure which is the empirical error (also known as the sample error)
  err(h) which is de   ned as the proportion of examples from z on which h
made a mistake:

  err(h) =

1
m

|{i : h(xi) (cid:54)= ct(xi)}|

(replace ct(xi) with yi for the unrealizable case). the situation of bounding
the true error err(h) by minimizing the sample error   err(h) is very conve-
nient     we will get to that later.

7.2 the rectangle learning problem

73

7.2 the rectangle learning problem

as an illustration of learnability we will consider the problem (introduced
in kearns & vazirani [3]) of learning an axes-aligned rectangle from positive
and negative examples. we will show that the problem is pac-learnable
and    nd out m0( ,   ).

in the rectangle learning game we are given a training set consisting of
points in the 2d plane with a positive    +    or negative    -    label. the positive
examples are sampled inside the target rectangle (parallel to the main axes)
r and the negative examples are sampled outside of r. given m examples
sampled i.i.d according to some distribution d the learner is supposed to
generate an approximate rectangle r(cid:48) which is consistent with the training
set (we are assuming that r exists) and which satis   es the accuracy and
con   dence constraints.

we    rst need to decide on a learning strategy. since the solution r(cid:48)
is not uniquely de   ned given any training set z, we need to add further
constraints to guarantee a unique solution. we will choose r(cid:48) as the axes-
aligned concept which gives the tightest    t to the positive examples, i.e., the
smallest area axes-aligned rectangle which contains the positive examples.
if no positive examples are given then r(cid:48) =    . we can also assume that
z contains at least three non-collinear positive examples in order to avoid
complications associated with in   nitesimal area rectangles. note that we
could have chosen other strategies, such as the middle ground between the
tightest    t to the positive examples and the tightest    t (from below) to the
negative examples, and so forth. de   ning a strategy is necessary for the
analysis below     the type of strategy is not critical though.

we next de   ne the error err(r(cid:48)) on the concept r(cid:48) generated by our
learning strategy. we    rst note that with the strategy de   ned above we
always have r(cid:48)     r since r(cid:48) is the tightest    t solution which is consistent
with the sample data (there could be a positive example outside of r(cid:48) which
is not in the training set). we will de   ne the    weight    w(e) of a region e
in the plane as

(cid:90)

w(e) =

d(x)dx,

x   e

i.e., the id203 that a random point sampled according to the distri-
bution d will fall into the region. therefore, the error associated with the
concept r(cid:48) is

err(r(cid:48)) = w(r     r(cid:48))

74

the formal (pac) learning model

fig. 7.1. given the tightest-   t to positive examples strategy we have that r(cid:48)     r.
the strip t1 has weight  /4 and the strip t (cid:48)
1 is de   ned as the upper strip covering
the area between r and r(cid:48).

and we wish to bound the error w(r     r(cid:48))       with id203 of at least
1        after seeing m examples.

we will divide the region r     r(cid:48) into four strips t (cid:48)
4 (see fig.7.1)
which overlap at the corners. we will estimate prob(w(t (cid:48)
4) noting that
the overlaps between the regions makes our estimates more pessimistic than
they truly are (since we are counting the overlapping regions twice) thus
making us lean towards the conservative side in our estimations.

1, ..., t (cid:48)
i )      

consider the upper strip t (cid:48)
1.

4) then we are done. we are
however interested in quantifying the id203 that this is not the case.
assume w(t (cid:48)
4 and de   ne a strip t1 which starts from the upper axis
of r and stretches to the extent such that w(t1) =  
1. we
4 i    t1     t (cid:48)
have that w(t (cid:48)
claim 9 t1     t (cid:48)

4. clearly t1     t (cid:48)

1 i    x1, ..., xm (cid:54)    t1.

1. furthermore:

if w(t (cid:48)

1      

1) >  

1) >  

if xi     t1 the the label must be positive since t1     r. but if
proof:
the label is positive then given our learning strategy of    tting the tightest
rectangle over the positive examples, then xi     r(cid:48). since t1 (cid:54)    r(cid:48) it follows
that xi (cid:54)    t1.
4) i    no point in t1 appears in the sample
s = {x1, ..., xm} (otherwise t1 intersects with r(cid:48) and thus t (cid:48)
1     t1). the
id203 that a point sampled according to the distribution d will fall
outside of t1 is 1      
4. given the independence assumption (examples are

we have therefore that w(t (cid:48)

1 >  

7.3 learnability of finite concept classes

75

drawn i.i.d.), we have:

prob(x1, ..., xm (cid:54)    t1) = prob(w(t (cid:48)
2, t (cid:48)

 
4
repeating the same analysis to regions t (cid:48)
4 and using the union bound
p (a     b)     p (a) + p (b) we come to the conclusion that the id203
that any of the four strips of r     r(cid:48) has weight greater that  /4 is at most
4(1      

)) = (1      
4

1 >
3, t (cid:48)

4)m. in other words,

)m.

prob(err(l(cid:48))      )     4((1      
4

)m       .

we can make the expression more convenient for manipulation by using the
inequality e   x     1     x (recall that 1 + (1/n))n < e from which it follows
that (1 + z)1/z < e and by taking the power of rz where r     0 we obtain
(1 + z)r < erz then set r = 1, z =    x):

4(1      
4
from which we obtain the bound:

)m     4e     m

4       ,

m     4
 

ln

4
  

.

to conclude, assuming that the learner adopts the tightest-   t to positive ex-
amples strategy and is given at least m0 = 4
   training examples in order
to    nd the axes-aligned rectangle r(cid:48), we can assert that with id203
1        the error associated with r(cid:48) (i.e., the id203 that an (m + 1)   th
point will be classi   ed incorrectly) is at most  .

  ln 4

we can see form the analysis above that indeed it applies to any distri-
bution d where the only assumption we had to make is the independence
of the draw. also, the sample size m behaves well in the sense that if one
desires a higher level of accuracy (smaller  ) or a higher level of con   dence
(smaller   ) then the sample size grows accordingly. the growth of m is
linear in 1/  and linear in ln(1/  ).

7.3 learnability of finite concept classes

in the previous section we illustrated the concept of learnability with a
particular simple example. we will now focus on applying the learnability
model to a more general family of learning examples. we will consider the
family of all learning problems over    nite concept classes |c| <    . for
example, the conjunction learning problem (over boolean formulas) with n
literals contains only 3n hypotheses because each variable can appear in
the conjunction or not and if appears it could be negated or not. we have

76

the formal (pac) learning model

shown that n is the lower bound on the number of mistakes on the worst
case analysis any on-line algorithm can achieve. with the de   nitions we
have above on the formal model of learnability we can perform accuracy
and sample complexity analysis that will apply to any learning problem
over    nite concept classes. this was    rst introduced by valiant in 1984.

in the realizable case over |c| <    , we will show that any algorithm l
which returns a hypothesis h     c which is consistent with the training set
z is a learning algorithm for c. in other words, any    nite concept class
is learnable and the learning algorithms simply need to generate consistent
hypotheses. the sample complexity m0 associated with the choice of   and
   can be shown as equal to: 1

  ln |c|
   .

in the unrealizable case, any algorithm l that generates a hypothesis
h     c that minimizes the empirical error (the error obtained on z) is a
learning algorithm for c. the sample complexity can be shown as equal to:
 2 ln 2|c|
2

   . we will derive these two cases below.

7.3.1 the realizable case

let h     c be some consistent hypothesis with the training set z (we know
that such a hypothesis exists, in particular h = ct the target concept used
for generating z) and suppose that

err(h) = prob[x     d : h(x) (cid:54)= ct(x)] >  .

then, the id203 (with respect to the product distribution dm) that h
agrees with ct on a random sample of length m is at most (1      )m. using
the inequality we saw before e   x     1     x we have:

prob[err(h) >   && h(xi) = ct(xi),

i = 1, ..., m]     (1      )m < e    m.

we wish to bound the error uniformly, i.e., that err(h)       for all concepts
h     c. this requires the evaluation of:

prob[max
h   c

{err(h) >  } && h(xi) = ct(xi),

i = 1, ..., m].

there at most |c| such functions h, therefore using the union-bound the
id203 that some function in c has error larger than   and is consistent

7.3 learnability of finite concept classes

77

with ct on a random sample of length m is at most |c|e    m:

prob[   h : err(h) >   && h(xi) = ct(xi),

i = 1, ..., m]

prob[h(xi) = ct(xi),

i = 1, ..., m]

    (cid:88)

h:err(h)> 

    |h : err(h) >  |e    m
    |c|e    m

for any positive   , this id203 is less than    provided:

m     1
 

ln

|c|
  

.

this derivation can be summarized in the following theorem (anthony &
bartlett [1], pp. 25):

theorem 5 let c be a    nite set of functions from x to y . let l be
an algorithm such that for any m and for any ct     c, if z is a training
sample {(xi, ct(xi))}, i = 1, ..., m, then the hypothesis h = l(z) satis   es
h(xi) = ct(xi). then l is a learning algorithm for c in the realizable case
with sample complexity

m0 =

1
 

ln

|c|
  

.

7.3.2 the unrealizable case

in the realizable case an algorithm simply needs to generate a consistent
hypothesize to be considered a learning algorithm in the formal sense. in
the unrealizable situation (a target function ct might not exist) an algorithm
which minimizes the empirical error, i.e., an algorithm l generates h = l(z)
having minimal sample error:

  err(l(z)) = min
h   c

  err(h)

is a learning algorithm for c (assuming    nite |c|). this is a particularly
useful property given that the true errors of the functions in c are un-
known. it seems natural to use the sample errors   err(h) as estimates to the
performance of l.

the fact that given a large enough sample (training set z) then the sam-
ple error   err(h) becomes close to the true error err(h) is somewhat of a
restatement of the    law of large numbers    of id203 theory. for ex-
ample, if we toss a coin many times then the relative frequency of    heads   
approaches the true id203 of    head    at a rate determined by the law of

78

the formal (pac) learning model

large numbers. we can bound the id203 that the di   erence between
the empirical error and the true error of some h exceeds   using hoe   ding   s
inequality:
claim 10 let h be some function from x to y = {0, 1}. then

prob[|   err(h)     err(h)|      ]     2e(   2 2m),

for any id203 distribution d, any   > 0 and any positive integer m.

proof: this is a straightforward application of hoe   ding   s inequality to
bernoulli variables. hoe   ding   s inequality says: let x be a set, d a proba-
bility distribution on x, and f1, ..., fm real-valued functions fi : x     [ai, bi]
from x to an interval on the real line (ai < bi). then,

(cid:34)

m(cid:88)

i=1

| 1
m

(cid:35)
fi(xi)     ex   d[f(x)]|      

p
    2 2m2

i(bi   ai)2

    2e

(7.1)

prob

where

ex   d[f(x)] =

1
m

fi(x)d(x)dx.

(1/m)(cid:80)

in our case fi(xi) = 1 i    h(xi) (cid:54)= yi and ai = 0, bi = 1. therefore

i fi(xi) =   err(h) and err(h) = ex   d[f(x)].

the hoe   ding bound almost does what we need, but not quite so. what
we have is that for any given hypothesis h     c, the empirical error is
close to the true error with high id203. recall that our goal is to
minimize err(h) over all possible h     c but we can access only   err(h). if
we can guarantee that the two are close to each other for every h     c, then
minimizing   err(h) over all h     c will approximately minimize err(h). put
formally, in order to ensure that l learns the class c, we must show that

(cid:90)

m(cid:88)

i=1

(cid:20)

(cid:21)

prob

max
h   c

|   err(h)     err(h)| <  

> 1       

in other words, we need to show that the empirical errors converge (at high
id203) to the true errors uniformly over c as m        . if that can be
guaranteed, then with (high) id203 1       , for every h     c,

err(h)       <   err(h) < err(h) +  .

so, since the algorithm l running on training set z returns h = l(z) which
minimizes the empirical error, we have:

err(l(z))       err(l(z)) +   = min

h

  err(h) +       opt(c) + 2 ,

7.3 learnability of finite concept classes

79

which is what is needed in order that l learns c. thus, what is left is to
prove the following claim:

claim 11

prob

(cid:20)

max
h   c

(cid:21)

|   err(h)     err(h)|      

    2|c|e   2 2m

proof: we will use the union bound. finding the maximum over c is
equivalent to taking the union of all the events:

|   err(h)     err(h)|      

= prob

{z : |   err(h)     err(h)|      }

,

(cid:21)

(cid:34)(cid:91)

(cid:20)

prob

max
h   c

(cid:35)

h   c
using the union-bound and claim 2, we have:

prob [|   err(h)     err(h)|      ]     |c|2e(   2 2m).

   (cid:88)

h   c

finally, given that 2|c|e   2 2m        we obtain the sample complexity:

m0 =

2
 2 ln

2|c|
  

.

this discussion is summarized with the following theorem (anthony & bartlett
[1], pp. 21):
theorem 6 let c be a    nite set of functions from x to y = {0, 1}. let l
be an algorithm such that for any m and for any training set z = {(xi, yi)},
i = 1, ..., m, then the hypothesis l(z) satis   es:

  err(l(z)) = min
h   c

  err(h).

 2 ln 2|c|
   .
then l is a learning algorithm for c with sample complexity m0 = 2
note that the main di   erence with the realizable case (theorem 1) is the
larger 1/ 2 rather than 1/ . the realizable case requires a smaller training
set since we are estimating a random quantity so the smaller the variance
the less data we need.

8

the vc dimension

the result of the pac model (also known as the    formal    learning model)
is that if the concept class c is pac-learnable then the learning strategy
must simply consist of gathering a su   ciently large training sample s of
size m > mo( ,   ), for given accuracy   > 0 and con   dence 0 <    < 1
parameters, and    nds a hypothesis h     c which is consistent with s. the
learning algorithm is then guaranteed to have a bounded error err(h) <  
with id203 1       . the error measurement includes data not seen by
the training phase.

this state of a   air also holds (with some slight modi   cations on the sam-
ple complexity bounds) when there is no consistent hypothesis (the unreal-
izable case). in this case the learner simply needs to minimize the empirical
error   err(h) on the sample training data s, and if m is su   ciently large
then the learner is guaranteed to have err(h) < opt(c) +   with id203
1       . the measure opt(c) is de   ned as the minimal err(g) over all g     c.
note that in the realizable case opt(c) = 0.

the property of bounding the true error err(h) by minimizing the sample
error   err(h) is very convenient. the fundamental question is under what
conditions this type of generalization property applies? we saw in the previ-
ous lecture that a satisfactorily answer can be provided when the cardinality
of the concept space is bounded, i.e. |c| <    , which happens for boolean
concept space for example. in that lecture we have proven that:

mo( ,   ) = o(

1
 

ln

|c|
  

),

is su   cient for guaranteeing a learning model in the formal sense, i.e., which
has the generalization property described above.

in this lecture and the one that follows we have two goals in mind. first
is to generalize the result of    nite concept class cardinality to in   nite car-

80

8.1 the vc dimension

81
dinality     note that the bound above is not meaningful when |c| =    .
can we learn in the formal sense any non-trivial in   nite concept class? (we
already saw an example of a pac-learnable in   nite concept class which is
the class of axes aligned rectangles). in order to answer this question we will
need to a general measure of concept class complexity which will replace the
cardinality term |c| in the sample complexity bound mo( ,   ). it is tempting
to assume that the number of parameters which fully describe the concepts
of c can serve as such a measure, but we will show that in fact one needs
a more powerful measure called the vapnik-chervonenkis (vc) dimension.
our second goal is to pave the way and provide the theoretical foundation
for the large margin principle algorithm (id166) we derived in lecture 4.

8.1 the vc dimension

the basic principle behind the vc dimension measure is that although c
may have in   nite cardinality, the restriction of the application of concepts
in c to a    nite sample s has a    nite outcome. this outcome is typically
governed by an exponential growth with the size m of the sample s     but
not always. the point at which the growth stops being exponential is when
the    complexity    of the concept class c has exhausted itself, in a manner
of speaking.

we will assume c is a concept class over the instance space x     both
of which can be in   nite. we also assume that the concept class maps in-
stances in x to {0, 1}, i.e., the input instances are mapped to    positive   
or    negative    labels. a training sample s is drawn i.i.d according to some
   xed but unknown distribution d and s consists of m instances x1, ..., xm.
in our notations we will try to reserve c     c to denote the target concept
and h     c to denote some concept. we begin with the following de   nition:

de   nition 2

  c(s) = {(h(x1), ..., h(xm) : h     c}

which is a set of vectors in {0, 1}m.
  c(s) is set whose members are m-dimensional boolean vectors induced by
functions of c. these members are often called dichotomies or behaviors on
s induced or realized by c. if c makes a full realization then   c(s) will
have 2m members. an equivalent description is a collection of subsets of s:

  c(s) = {h     s : h     c}

where each h     c makes a partition of s into two sets     the positive and

82

points of s under h). a full realization will provide (cid:80)m

negative points. the set   c(s) contains therefore subsets of s (the positive

(cid:0)m
(cid:1) = 2m. we

the vc dimension

will use both descriptions of   c(s) as a collection of subsets of s and as a
set of vectors interchangeably.
de   nition 3 if |  c(s)| = 2m then s is considered shattered by c. in
other words, s is shattered by c if c realizes all possible dichotomies of s.
consider as an example a    nite concept class c = {c1, ..., c4} applied to

i=0

i

three instance vectors with the results:

x1 x2 x3
1
1
1
0
0
1
0
0

1
1
0
0

c1
c2
c3
c4

then,

  c({x1}) = {(0), (1)}
  c({x1, x3}) = {(0, 0), (0, 1), (1, 0), (1, 1)}
  c({x2, x3}) = {(0, 0), (1, 1)}

shattered
shattered
not shattered

with these de   nitions we are ready to describe the measure of concept class
complexity.

de   nition 4 (vc dimension) the vc dimension of c, noted as v cdim(c),
is the cardinality d of the largest set s shattered by c. if all sets s (arbi-
trarily large) can be shattered by c, then v cdim(c) =    .

v cdim(c) = max{d |    |s| = d, and |  c(s)| = 2d}

the vc dimension of a class of functions c is the point d at which all
samples s with cardinality |s| > d are no longer shattered by c. as long as
c shatters s it manifests its full    richness    in the sense that one can obtain
from s all possible results (dichotomies). once that ceases to hold, i.e.,
when |s| > d, it means that c has    exhausted    its richness (complexity).
an in   nite vc dimension means that c maintains full richness for all sample
sizes. therefore, the vc dimension is a combinatorial measure of a function
class complexity.

before we consider a number of examples of geometric concept classes
and their vc dimension, it is important clarify the lower and upper bounds
(existential and universal quanti   ers) in the de   nition of vc dimension.
the vc dimension is at least d if there exists some sample |s| = d which is

8.1 the vc dimension

83

shattered by c     this does not mean that all samples of size d are shattered
by c. conversely, in order to show that the vc dimension is at most d,
one must show that no sample of size d + 1 is shattered. naturally, proving
an upper bound is more di   cult than proving the lower bound on the vc
dimension. the following examples are shown in a    hand waiving    style
and are not meant to form rigorous proofs of the stated bounds     they are
shown for illustrative purposes only.

intervals of the real line: the concept class c is governed by two param-
eters   1,   2 in the closed interval [0, 1]. a concept from this class will tag an
input instance 0 < x < 1 as positive if   1     x       2 and negative otherwise.
the vc dimension is at least 2: select a sample of 2 points x1, x2 positioned
in the open interval (0, 1). we need to show that there are values of   1,   2
which realize all the possible four dichotomies (+, +), (   ,   ), (+,   ), (   , +).
this is clearly possible as one can place the interval [  1,   2] such the inter-
section with the interval [x1, x2] is null, (thus producing (   ,   )), or to fully
include [x1, x2] (thus producing (+, +)) or to partially intersect [x1, x2] such
that x1 or x2 are excluded (thus producing the remaining two dichotomies).
to show that the vc dimension is at most 2, we need to show that any
sample of three points x1, x2, x3 on the line (0, 1) cannot be shattered. it is
su   cient to show that one of the dichotomies is not realizable: the labeling
(+,   , +) cannot be realizable by any interval [  1,   2]     this is because if
x1, x3 are labeled positive then by de   nition the interval [  1,   2] must fully
include the interval [x1, x3] and since x1 < x2 < x3 then x2 must be labeled
positive as well. thus v cdim(c) = 2.

axes-aligned rectangles in the plane: we have seen this concept class
in the previous lecture     a point in the plane is labeled positive if it lies
in an axes-aligned rectangle. the concept class c is thus governed by 4
parameters. the vc dimension is at least 4: consider a con   guration of
4 input points arranged in a cross pattern (recall that we need only to
show some sample s that can be shattered). we can place the rectangles
(concepts of the class c) such that all 16 dichotomies can be realized (for
example, placing the rectangle to include the vertical pair of points and
exclude the horizontal pair of points would induce the labeling (+,   , +,   )).
it is important to note that in this case, not all con   gurations of 4 points
can be shattered     but to prove a lower bound it is su   cient to show
the existence of a single shattered set of 4 points. to show that the vc
dimension is at most 4, we need to prove that any set of 5 points cannot

84

the vc dimension

be shattered. for any set of 5 points there must be some point that is
   internal   , i.e., is neither the extreme left, right, top or bottom point of the
   ve. if we label this internal point as negative and the remaining 4 points as
positive then there is no axes-aligned rectangle (concept) which cold realize
this labeling (because if the external 4 points are labeled positive then they
must be fully within the concept rectangle, but then the internal point must
also be included in the rectangle and thus labeled positive as well).

separating hyperplanes: consider    rst linear half spaces in the plane.
the lower bound on the vc dimension is 3 since any three (non-collinear)
points in r2 can be shattered, i.e., all 8 possible labelings of the three points
can be realized by placing a separating line appropriately. by having one
of the points on one side of the line and the other two on the other side we
can realize 3 dichotomies and by placing the line such that all three points
are on the same side will realize the 4th. the remaining 4 dichotomies are
realized by a sign    ip of the four previous cases. to show that the upper
bound is also 3, we need to show that no set of 4 points can be shattered.
we consider two cases: (i) the four points form a convex region, i.e., lie on
the convex hull de   ned by the 4 points, (ii) three of the 4 points de   ne the
convex hull and the 4th point is internal. in the    rst case, the labeling which
is positive for one diagonal pair and negative to the other pair cannot be
realized by a separating line. in the second case, a labeling which is positive
for the three hull points and negative for the interior point cannot be realize.
thus, the vc dimension is 3 and in general the vc dimension for separating
hyperplanes in rn is n + 1.

union of a    nite number of intervals on the line: this is an example
of a concept class with an in   nite vc dimension. for any sample of points
on the line, one can place a su   cient number of intervals to realize any
labeling.

the examples so far were simple enough that one might get the wrong
impression that there is a correlation between the number of parameters
required to describe concepts of the class and the vc dimension. as a
counter example, consider the two parameter concept class:

c = {sign(sin(  x +   ) :   }

which has an in   nite vc dimension as one can show that for every set
of m points on the line one can realize all possible labelings by choosing

8.2 the relation between vc dimension and pac learning

85

a su   ciently large value of    (which serves as the frequency of the sync
function) and appropriate phase.

we conclude this section with the following claim:

theorem 7 the vc dimension of a    nite concept class |c| <     is bounded
from above:

v cdim(c)     log2 |c|.

if v cdim(c) = d then there exists at least 2d functions in c
proof:
because every function induces a labeling and there are at least 2d labelings.
thus, from |c|     2d follows that d     log2 |c|.

8.2 the relation between vc dimension and pac learning

we saw that the vc dimension is a combinatorial measure of concept class
complexity and we would like to have it replace the cardinality term in the
sample complexity bound. the    rst result of interest is to show that if
the vc dimension of the concept class is in   nite then the class is not pac
learnable.
theorem 8 concept class c with v cdim(c) =     is not learnable in the
formal sense.

proof: assume the contrary that c is pac learnable. let l be the learning
algorithm and m be the number of training examples required to learn the
concept class with accuracy   = 0.1 and 1        = 0.9. that is, after seeing
at least m( ,   ) training examples, the learner generates a concept h which
satis   es p(err(h)     0.1)     0.9.

since the vc dimension is in   nite there exist a sample set s with 2m
instances which is shattered by c. since the formal model (pac) applies
to any training sample we will use the set s as follows. we will de   ne a
id203 distribution on the instance space x which is uniform on s (with
id203 1

2m) and zero everywhere else.

because s is shattered, then any target concept is possible so we will

choose our target concept c in the following manner:
   xi     s,

prob(ct(xi) = 0) =

1
2

in other words, the labels ct(xi) are determined by a coin    ip. the learner
l selects an i.i.d. sample of m instances   s     which due to the structure of

86
d means that the   s     s and outputs a consistent hypothesis h     c. the
id203 of error for each xi (cid:54)      s is:

the vc dimension

prob(ct(xi) (cid:54)= h(xi)) =

1
2 .

the reason for that is because s is shattered by c, i.e., we can select any
target concept for any labeling of s (the 2m examples) therefore we could
select the labels of the m points not seen by the learner arbitrarily (by
   ipping a coin). regardless of h, the id203 of mistake is 0.5. the
expectation on the error of h is:

e[err(h)] = m    0    1
2m

+ m    1
2

   1
2m

=

1
4 .

this is because we have 2m points to sample (according to d as all other
points have zero id203) from which the error on half of them is zero
(as h is consistent on the training set   s) and the error on the remaining half
is 0.5. thus, the average error is 0.25. note that e[err(h)] = 0.25 for any
choice of  ,    as it is based on the sample size m. for any sample size m we
can follow the construction above and generate the learning problem such
that if the learner produces a consistent hypothesis the expectation of the
error will be 0.25.

the result that e[err(h)] = 0.25 is not possible for the accuracy and
con   dence values we have set: with id203 of at least 0.9 we have that
err(h)     0.1 and with id203 0.1 then err(h) =    where 0.1 <        1.
taking the worst case of    = 1 we come up with the average error:

e[err(h)]     0.9    0.1 + 0.1    1 = 0.19 < 0.25.

we have therefore arrived to a contradiction that c is pac learnable.
we next obtain a bound on the growth of |  s(c)| when the sample size
|s| = m is much larger than the vc dimension v cdim(c) = d of the
concept class. we will need few more de   nitions:

de   nition 5 (growth function)

  c(m) = max{|  s(c)|

|s| = m}

:

the measure   c(m) is the maximum number of dichotomies induced by c
for samples of size m. as long as m     d then   c(m) = 2m. the question
is what happens to the growth pattern of   c(m) when m > d. we will
see that the growth becomes polynomial     a fact which is crucial for the
learnability of c.

8.2 the relation between vc dimension and pac learning

87

de   nition 6 for any natural numbers m, d we have the following de   nition:

  d(m) =   d(m     1) +   d   1(m     1)
  d(0) =   0(m) = 1

by induction on m, d it is possible to prove the following:

theorem 9

d(cid:88)

i=0

  d(m) =

(cid:18)m

(cid:19)

i

proof: by induction on m, d. for details see [[3], pp. 56].

for m     d we have that   d(m) = 2m. for m > d we can derive a

polynomial upper bound as follows.

(cid:18) d

(cid:19)d d(cid:88)

(cid:18)m
(cid:19)

m

i

i=0

i=0
from which we obtain:

dividing both sides by(cid:0) d

(cid:19)

i

m

    d(cid:88)

(cid:19)i(cid:18)m
(cid:18) d
(cid:18) d
(cid:19)d
(cid:1)d yields:
  d(m)     ed(cid:16) m
(cid:17)d

m

m

d

(cid:18) d

(cid:19)i(cid:18)m
(cid:19)

m

i

    m(cid:88)

i=0

  d(m)     ed.

(cid:16) em

(cid:17)d

d

=

= o(md).

= (1 + d
m

)m     ed

we need one more result before we are ready to present the main result of
this lecture:

theorem 10 (sauer   s lemma) if v cdim(c) = d, then for any m,
  c(m)       d(m).
proof: by induction on both d, m. for details see [[3], pp. 55   56].

taken together, we have now a fairly interesting characterization on how
the combinatorial measure of complexity of the concept class c scales up
with the sample size m. when the vc dimension of c is in   nite the growth
is exponential, i.e.,   c(m) = 2m for all values of m. on the other hand,
when the concept class has a bounded vc dimension v cdim(c) = d <    
then the growth pattern undergoes a discontinuity from an exponential to
a polynomial growth:

(cid:40)

   (cid:0) em

2m

(cid:1)d m > d

m     d

d

(cid:41)

  c(m) =

88

the vc dimension

as a direct result of this observation, when m >> d is much larger than d
the id178 becomes much smaller than m. recall than from an informa-
tion theoretic perspective, the id178 of a random variable z with discrete
values z1, ..., zn with probabilities pi, i = 1, ..., n is de   ned as:

n(cid:88)

i=0

h(z) =

pi log2

1
pi

,

1
pi

where i(pi) = log2
is a measure of    information   , i.e., is large when
pi is small (meaning that there is much information in the occurrence of
an unlikely event) and vanishes when the event is certain pi = 1. the
id178 is therefore the expectation of information. id178 is maximal for
a uniform distribution h(z) = log2 n. the id178 in id205
context can be viewed as the number of bits required for coding z1, ..., zn. in
coding theory it can be shown that the id178 of a distribution provides the
lower bound on the average length of any possible encoding of a uniquely
decodable code fro which one symbol goes into one symbol. when the
distribution is uniform we will need the maximal number of bits, i.e., one
cannot compress the data. in the case of concept class c with vc dimension
d, we see that one when m     d all possible dichotomies are realized and
thus one will need m bits (as there are 2m dichotomies) for representing
all the outcomes of the sample. however, when m >> d only a small
fraction of the 2m dichotomies can be realized, therefore the distribution
of outcomes is highly non-uniform and thus one would need much less bits
for coding the outcomes of the sample. the technical results which follow
are therefore a formal way of expressing in a rigorous manner this simple
truth     if it is possible to compress, then it is possible to learn. the crucial
point is that learnability is a direct consequence of the    phase transition   
(from exponential to polynomial) in the growth of the number of dichotomies
realized by the concept class.

in the next lecture we will continue to prove the    double sampling    the-
orem which derives the sample size complexity as a function of the vc
dimension.

9

the double-sampling theorem

in this lecture will use the measure of vc dimension, which is a combina-
torial measure of concept class complexity, to bound the sample size com-
plexity.

9.1 a polynomial bound on the sample size m for pac learning
in this section we will follow the material presented in kearns & vazirani
[3] pp. 57   61 and prove the following:

theorem 11 (double sampling) let c be any concept class of vc di-
mension d. let l be any algorithm that when given a set s of m labeled
examples {xi, c(xi)}i, sampled i.i.d according to some    xed but unknown
distribution d over the instance space x, of some concept c     c, produces
as output a concept h     c that is consistent with s. then l is a learning
algorithm in the formal sense provided that the sample size obeys:

(cid:18)1

 

log

1
  

+ d
 

log

1
 

(cid:19)

m     c0

for some constant c0 > 0.

the idea behind the proof is to build an    approximate    concept space which
includes concepts arranged such that the distance between the approximate
concepts h and the target concept c is at least       where distance is de-
   ned as the weight of the region in x which is in con   ict with the target
concept. to formalize this story we will need few more de   nitions. unless
speci   ed otherwise, c     c denotes the target concept and h     c denotes
some concept.

89

90

de   nition 7

the double-sampling theorem

c   h = h   c = {x : c(x) (cid:54)= h(x)}

c   h is the region in instance space where both concepts do not agree    
the error region. the id203 that x     c   h is equal to (by de   nition)
err(h).

de   nition 8

   (c) = {h   c : h     c}
    (c) = {h   c : h     c and err(h)      }

   (c) is a set of error regions, one per concept h     c over all concepts. the
error regions are with respect to the target concept. the set     (c)        (c)
is the set of all error regions whose weight exceeds  . recall that weight is
de   ned as the id203 that a point sampled according to d will hit the
region.

it will be important for later to evaluate the vc dimension of    (c). unlike
c, we are not looking for the vc dimension of a class of function but the
vc dimension of a set of regions in space. recall the de   nition of   c(s)
from the previous lecture: there were two equivalent de   nitions one based
on a set of vectors each representing a labeling of the instances of s induced
by some concept. the second, yet equivalent, de   nition is based on a set
of subsets of s each induced by some concept (where the concept divides
the sample points of s into positive and negative labeled points). so far it
was convenient to work with the    rst de   nition, but for evaluating the vc
dimension of    (c) it will be useful to consider the second de   nition:

     (c)(s) = {r     s : r        (c)},

that is, the collection of subsets of s induced by intersections with regions
of    (c). an intersection between s and a region r is de   ned as the subset of
points from s that fall into r. we can easily show that the vc dimensions
of c and    (c) are equal:

lemma 1

v cdim(c) = v cdim(   (c)).

proof: we have that the elements of   c(s) and      (c)(s) are susbsets of
s, thus we need to show that for every s the cardinality of both sets is
equal |  c(s)| = |     (c)(s)|. to do that it is su   cient to show that for every
element s       c(s) there is a unique corresponding element in      (c)(s). let

9.1 a polynomial bound on the sample size m for pac learning

91
c    s be the subset of s induced by the target concept c. the set s (a subset
of s) is realized by some concept h (those points in s which were labeled
positive by h). therefore, the set s     (c     s) is the subset of s containing
the points that hit the region h   c which is an element of      (c)(s). since
this is a one-to-one mapping we have that |  c(s)| = |     (c)(s)|.

de   nition 9 ( -net) for every   > 0, a sample set s is an  -net for    (c)
if every region in     (c) is hit by at least one point of s:

   r         (c), s     r (cid:54)=    .

in other words, if s hits all the error regions in    (c) whose weight exceeds
 , then s is an  -net. consider as an example the concept class of intervals
on the line [0, 1]. a concept is de   ned by an interval [  1,   2] such that all
points inside the interval are positive and all those outside are negative.
given c     c is the target concept and h     c is some concept, then the
error region h   c is the union of two intervals: i1 consists of all points x     h
which are not in c, and i2 the interval of all points x     c but which are not
in h. assume that the distribution d is uniform (just for the sake of this
example) then, prob(x     i) = |i| which is the length of the interval i. as a
result, err(h) >   if either |i1| >  /2 or |i2| >  /2. the sample set

s = {x = k 
2

: k = 0, 1, ..., 2/ }

contains sample points from 0 to 1 with increments of  /2. therefore, every
interval larger than   must be hit by at least one point from s and by
de   nition s is an  -net.
it is important to note that if s forms an  -net then we are guaranteed
that err(h)      . let h     c be the consistent hypothesis with s (returned
by the learning algorithm l). becuase h is consistent, h   c        (c) has
not been hit by s (recall that h   c is the error region with respect to the
target concept c, thus if h is consistent then it agrees with c over s and
therefore s does not hit h   c). since s forms an  -net for    (c) we must
have h   c (cid:54)        (c) (recall that by de   nition s hits all error regions with
weight larger than  ). as a result, the error region h   c must have a weight
smaller than   which means that err(h)      .

the conclusion is that if we can bound the id203 that a random sam-
ple s does not form an  -net for    (c), then we have bounded the id203
that a concept h consistent with s has err(h) >  . this is the goal of the
proof of the double-sampling theorem which we are about to prove below:

92

the double-sampling theorem

proof (following kearns & vazirani [3] pp. 59   61): let s1 be a ran-
dom sample of size m (sampled i.i.d. according to the unknown distribution
d) and let a be the event that s1 does not form an  -net for    (c). from
the preceding discussion our goal is to upper bound the id203 for a to
occur, i.e., prob(a)       .
if a occurs, i.e., s1 is not an  -net, then by de   nition there must be some
region r         (c) which is not hit by s1, that is s1     r =    . note that
r = h   (c) for some concept h which is consistent with s1. at this point the
space of possibilities is in   nite, because the id203 that we fail to hit
h   (c) in m random examples is at most (1     )m. thus the id203 that
we fail to hit some h   c         (c) is bounded from above by |   (c)|(1      )m
    which does not help us due to the fact that |   (c)| is in   nite. the idea
of the proof is to turn this into a    nite space by using another sample, as
follows.

let s2 be another random sample of size m. we will select m (for both
s1 and s2) to guarantee a high id203 that s2 will hit r many times.
in fact we wish that s2 will hit r at least  m
2 with id203 of at least 0.5:

prob(|s2     r| >

 m
2

) = 1     prob(|s2     r|      m
2

).

we will use the cherno    bound (lower tail) to obtain a bound on the right-
hand side term. recall that if we have m bernoulli trials (coin tosses)
z1, ..., zm with expectation e(zi) = p and we consider the random variable
z = z1 + ... + zm with expectation e(z) =    (note that    = pm) then for
all 0 <    < 1 we have:

prob(z < (1       )  )     e        2
2 .

considering the sampling of m examples that form s2 as bernoulli trials,
we have that         m (since the id203 that an example will hit r is at
least  ) and    = 0.5. we obtain therefore:

prob(|s2     r|     (1     1
2
  ln 2 = o( 1

) m)     e     m

8 =

1
2

  ). to summarize what we have
which happens when m = 8
obtained so far, we have calculated the id203 that s2 will hit r many
times given that r was    xed using the previous sampling, i.e., given that s1
does not form an  -net. to formalize this, let b denote the combined event
that s1 does not form an  -event and s2 hits r at least  m/2 times. then,
we have shown that for m = o(1/ ) we have:
prob(b/a)     1
2 .

9.1 a polynomial bound on the sample size m for pac learning

93

from this we can calculate prob(b):

prob(b) = prob(b/a)prob(a)     1

2 prob(a),

which means that our original goal of bounding prob(a) is equivalent to
   nding a bound prob(b)       /2 because prob(a)     2    prob(b)       . the
crucial point with the new goal is that to analyze the id203 of the
event b, we need only to consider a    nite number of possibilities, namely to
consider the regions of

      (c)(s1     s2) = {r     {s1     s2} : r         (c)} .

this is because the occurrence of the event b is equivalent to saying that
there is some r           (c)(s1     s2) such that |r|      m/2 (i.e., the region r
is hit at least  m/2 times) and s1     r =    . this is because       (c)(s1     s2)
contains all the subsets of s1     s2 realized as intersections over all regions
in     (c). thus even though we have an in   nite number of regions we still
have a    nite number of subsets. we wish therefore to analyze the following
id203:

prob(cid:0)r           (c)(s1     s2) :

|r|      m/2 and s1     r =    (cid:1) .

let s = s1   s2 a random sample of 2m (note that since the sampling is i.i.d.
it is equivalent to sampling s1 and s2 separately) and r satisfying |r|      m/2
being    xed. consider some random partitioning of s into s1 and s2 and
consider then the problem of estimating the id203 that s1     r =    .
this problem is equivalent to the following combinatorial question: we have
2m balls, each colored red or blue, with exaclty l      m/2 red balls. we
divide the 2m balls into groups of equal size s1 and s2 and we are interested
in bounding the id203 that all of the l balls fall in s2 (that is, the
id203 that s1     r =    ). this in turn is equivalent to    rst dividing the
2m uncolored balls into s1 and s2 groups and then randomly choose l of
the balls to be colored red and analyze the id203 that all of the red
balls fall into s2. this id203 is exactly

(cid:1)(cid:0)2m
(cid:0)m
(cid:1) =

l

l

l   1(cid:89)

i=0

    l   1(cid:89)

i=0

m     i
2m     i

1
2

=

1
2l = 2    m/2.

this id203 was evaluated for a    xed s and r. thus, the id203 that
this occurs for some r           (c)(s) satisfying |r|      m/2 (which is prob(b))
can be calculated by summing over all possible    xed r and applying the

94

union bound prob((cid:80)

i zi)    (cid:80)

i prob(zi):

the double-sampling theorem

prob(b)     |      (c)(s)|2    m/2     |     (c)(s)|2    m/2
2    m/2       
2 ,

= |  c(s)|2    m/2    

d

(cid:18)2 m

from which it follows that:

m = o

(cid:18)1

 

log

1
  

+ d
 

log

1
 

(cid:19)d
(cid:19)

.

few comments are worthwhile at this point:

(i) it is possible to show that the upper bound on the sample complexity
m is tight by showing that the lower bound on m is    (d/ ) (see [[3],
pp. 62]).
(ii) the treatment above holds also for the unrealizable case (target con-
cept c (cid:54)    c) with slight modi   cations to the bound. in this context,
the learning algorithm l must simply minimize the sample (empiri-
cal) error   err(h) de   ned:

  err(h) =

1
m

|{i : h(xi) (cid:54)= yi}| xi     s.

the generalization of the double-sampling theorem (derroye   82) states
that the empirical errors converge uniformly to the true errors:

(cid:18)

(cid:19)

2   m 2/2       ,

prob

max
h   c

|
  err(h)     err(h)|      

from which it follows that

m = o

    4e(4 +4 2)

1
  

+ d

 2 log

1
 

(cid:18) 1

 2 log

(cid:19)d

(cid:18)  m2
(cid:19)

d

.

taken together, we have arrived to a fairly remarkable result. despite the
fact that the distribution d from which the training sample s is drawn from
is unknown (but is known to be    xed), the learner simply needs to minimize
the empirical error. if the sample size m is large enough the learner is guar-
anteed to have minimized the true errors for some accuracy and con   dence
parameters which de   ne the sample size complexity. equivalently,

|opt(c)       err(h)|       m       0.

not only is the convergence is independent of d but also the rate of con-
vergence is independent (namely, it does not matter where the optimal h   

9.2 optimality of id166 revisited

95

is located). the latter is very important because without it one could ar-
bitrarily slow down the convergence rate by maliciously choosing d. the
beauty of the results above is that d does not have an e   ect at all     one
simply needs to choose the sample size to be large enough for the accuracy,
con   dence and vc dimension of the concept class to be learned over.

9.2 optimality of id166 revisited

in lecture 4 we discussed the large margin principle for    nding an optimal
separating hyperplane. it is natural to ask how does the pac theory pre-
sented so far explains why a maximal margin hyperplane is optimal with
regard to the formal sense of learning (i.e. to generalization from empirical
errors to true errors)? we saw in the previous section that the sample com-
plexity m( ,   , d) depends also on the vc dimension of the concept class    
which is n + 1 for hyperplanes in rn. thus, another natural question that
may certainly arise is what is the gain in employing the    kernel trick   ? for a
   xed m, mapping the input instance space x of dimension n to some higher
(exponentially higher) feature space might simply mean that we are compro-
mising the accuracy and con   dence of the learner (since the vc dimension
is equal to the instance space dimension plus 1).

given a    xed sample size m, the best the learner can do is to minimize the
empirical error and at the same time to try to minimize the vc dimension d
of the concept class. the smaller d is, for a    xed m, the higher the accuracy
and con   dence of the learning algorithm. likewise, the smaller d is, for a
   xed accuracy and con   dence values, the smaller sample size is required.

there are two possible ways to decrease d. first is to decrease the dimen-
sion n of the instance space x. this amounts to    feature selection   , namely
   nd a subset of coordinates that are the most    relevant    to the learning
task r perform a id84 via pca, for example. a second
approach is to maximize the margin. let the margin associated with the
separating hyperplane h (i.e. consistent with the sample s) be   . let the
input vectors x     x have a bounded norm, |x|     r. it can be shown that
the vc dimension of the concept class c   of hyperplanes with margin    is:

(cid:26) r2

(cid:27)

c   = min

  2 , n

+ 1.

thus, if the margin is very small then the vc dimension remains n + 1. as
the margin gets larger, there comes a point where r2/  2 < n and as a result
the vc dimension decreases. moreover, mapping the instance space x to
some higher dimension feature space will not change the vc dimension as

96

the double-sampling theorem

long as the margin remains the same. it is expected that the margin will not
scale down or will not scale down as rapidly as the scaling up of dimension
from image space to feature space.

to conclude, maximizing the margin (while minimizing the empirical er-
ror) is advantageous as it decreases the vc dimension of the concept class
and causes the accuracy and con   dence values of the learner to be largely
immune to dimension scaling up while employing the kernel trick.

10

appendix

97

98

appendix

a0.1 variance, covariance, etc.

let x, y be two random variables and let f(x, y) be some function on x    
x, y     y , and let p(x, y) be the id203 of the event x and y occurring
together. the expectation e[f(x, y)] is de   ned:

e[f(x, y)] = (cid:88)

(cid:88)

x   x

y   y

f(x, y)p(x, y)

y

x

xp(x, y)

(cid:88)
(cid:88)

. the mean, variance and covariance are de   ned:

  x = e[x] =(cid:88)
  y = e[y ] =(cid:88)
x = v ar[x] = e[(x       x)2] =(cid:88)
(cid:88)
y = v ar[y ] = e[(y       y)2] =(cid:88)
(cid:88)
  xy = cov(xy ) = e[(x       x)(y       y)] =(cid:88)

yp(x, y)

  2

  2

x

x

x

y

y

y

(x       x)2p(x, y)

(y       y)2p(x, y)

(cid:88)

x

y

(x       x)(y       y)p(x, y)

in vector-matrix notation, let x represent the n random variables of x1, ..., xn,
i.e., x = (x1, ..., xn)(cid:62) is an instance vector and p(x) is the id203 of the
instance occurrence. then the mean is a vector    and the covariance matrix
e are de   ned:

   = (cid:88)
e = (cid:88)

x   {x1,...,xn}

x

xp(x)

(x       )(x       )(cid:62)p(x)

note that the covariance matrix e is the linear superposition of rank-1
matrices (x      )(x      )(cid:62) with coe   cients p(x). the diagonal of e containes
the variances of the variables x1, ..., xn. for a uniform distribution and
a sample data s consisting of m points, let a = [x1       , ..., xm       ] be
the matrix whose columns consist of the points centered around the mean:
   = 1
m

i xi. the (sample) covariance matrix is e = 1

m aa(cid:62).

(cid:80)

a0.2 derivatives of matrix operations: scalar functions of a vector

99

a0.2 derivatives of matrix operations: scalar functions of a

vector

the two most important examples of a scalar function of a vector x are the
linear form a(cid:62)x and the quadratic form x(cid:62)ax for some square matrix a.

d(a(cid:62)x) = a(cid:62)dx
d(x(cid:62)ax) = (dx)(cid:62)ax + x(cid:62)a(dx)

(cid:16)

(cid:17)(cid:62)

(dx)(cid:62)ax

=
= x(cid:62)(a + a(cid:62))dx

+ x(cid:62)a(dx)

where the derivative d(x(cid:62)ax) using the rule of products d(f    g) = (df)   g +
f    (dg) where g = ax and f = x(cid:62) and noting that d(ax) = adx. thus,
dx(a(cid:62)x) = a(cid:62) and d
if a is symmetric then
dx(x(cid:62)ax)) = (2ax)(cid:62).

dx(x(cid:62)ax)) = x(cid:62)(a + a(cid:62)).

d

d

a0.3 primer on constrained optimization

a0.3.1 equality constraints and lagrange multipliers

consider    rst the general optimization with equality constraints which gives
rise to the notion of lagrange multipliers.

min
x

f(x)

subject to
h(x) = 0

(0.1)

where f : rn     r and h : rn     rk where h is a vector function (h1, ..., hk)
each from rn to r. we want to derive a necessary and su   cient constraint
for a point xo to be a local minimum subject to the k equality constraints
h(x) = 0. assume that xo is a regular point, meaning that the gradient
vectors    hj(x) are linearly independent. note that    h(xo) is a k  n matrix
and the null space of this matrix:

null(   h(xo)) = {y :    h(xo)y = 0}

de   nes the tangent plane at the point xo. we have the following fundamental
theorem:

   f(xo)     null(   h(xo))

in other words, all vectors y spanning the tangent plane at the point xo are
also perpendicular to the gradient of f at xo.

100

appendix

the sketch of the proof is as follows. let x(t),    a     t < a, be a smooth
curve on the surface h(x) = 0, i.e., h(x(t)) = 0. let xo = x(0) and y =
dtx(0) the tangent to the curve at xo. from the de   nition of tangency, the
d
vector y lives in null(   h(xo)), i.e., y       hj(x(0)) = 0, j = 1, ..., k. since
xo = x(0) is a local extremum of f(x), then

f(x(t))|t=0 =(cid:88)    f

0 = d
dt

|t=0 =    f(xo)    y.

dxi
dt

   xi

as a corollary of this basic theorem, the gradient vector    f(xo)     span{   h1(xo), ...,   hk(xo)},

i.e.,

   f(xo) +

  i   hi(xo) = 0,

k(cid:88)
f(x) +(cid:88)

i=1

  ihi(x)

where the coe   cients   i are called lagrange multipliers and the expression:

is called the lagrangian of the optimization problem (0.1).

i

a0.3.2 inequality constraints and kkt conditions

consider next the general constrained optimization with inequality con-
straints (called    non-id135   ):

min
x

f(x)

subject to
h(x) = 0
g(x)     0

(0.2)

where g : rn     rs. we will assume that the optimal solution xo is a
regular point which has the following meaning: let j be the set of indices
j such that gj(xo) = 0, then xo is a regular point if the gradient vectors
   hi(xo),   gj(xo), i = 1, ..., k and j     j are linearly independent. a basic
result (we will not prove here) is the karush-kuhn-tucker (kkt) theorem:
let xo be a local minimum of the problem and suppose xo is a regular
point. then, there exist   1, ...,   k and   1     0, ...,   s     0 such that:

a0.3 primer on constrained optimization

101

fig. a0.1. geometric interpreatation of duality (see text).

k(cid:88)

i=1

   f(xo) +

  i   hi(xo) +

s(cid:88)
s(cid:88)

j=1

  j   gj(xo) = 0,

  jgj(xo) = 0.

(0.3)

(0.4)

note that the condition(cid:80)   jgj(xo) = 0 is equivalent to the condition that

  jgj(xo) = 0 (since        0 and g(xo)     0 thus there sum cannot vanish
unless each term vanishes) which in turn implies:   j = 0 when gj(xo) < 0.
the expression

j=1

k(cid:88)

s(cid:88)

l(x,   ,   ) = f(x) +

  ihi(x) +

  jgj(x)

i=1

j=1

is the lagrangian of the problem (0.2) and the associated condition   jgj(xo) =
0 is called the kkt condition.

the remaining concepts we need are the    duality    and the    lagrangian

dual    problem.

),(**zy),(zyyz!  =+yzgnrx"))(),((xfxg)(  #102

appendix

a0.3.3 the langrangian dual problem

the optimization problem (0.2) is called the    primal    problem. the la-
grangian dual problem is de   ned as:

max
  ,  

  (  ,   )

subject to
       0

{f(x) +(cid:88)

  ihi(x) +(cid:88)

i

j

  (  ,   ) = min
x

(0.5)

(0.6)

  jgj(x)}.

where

note that   (  ,   ) may assume the value        for some values of   ,    (thus
to be rigorous we should have replaced    min    with    inf   ). the    rst basic
result is the weak duality theorem:
let x be a feasible solution to the primal (i.e., h(x) = 0, g(x)     0) and let
(  ,   ) be a feasible solution to the dual problem (i.e.,        0), then f(x)    
  (  ,   )

the proof is immediate:

  (  ,   ) = min
y

{f(y) +(cid:88)

  ihi(y) +(cid:88)
  ihi(x) +(cid:88)

j

i

    f(x) +(cid:88)

  jgj(x)

  jgj(y)}

i

j

where the latter inequality follows from h(x) = 0 and (cid:80)

    f(x)

because        0 and g(x)     0. as a corollary of this theorem we have:

j   jgj(x)     0

{f(x) : h(x) = 0, g(x)     0}     max

{  (  ,   ) :        0}.

(0.7)

the next basic result is the strong duality theorem which speci   es the con-
ditions for when the inequality in (0.7) becomes equality:
let f(), g() be convex functions and let h() be a   ne, i.e., h(x) = ax     b
where a is a k    n matrix, then

{f(x) : h(x) = 0, g(x)     0} = max

{  (  ,   ) :        0}.

the strong duality theorem allows one to solve for the primal problem by
   rst dualizing it and solving for the dual problem instead (we will see exactly
how to do it when we return to solving the primal problem (4.3)). when

  ,  

  ,  

min
x

min
x

a0.3 primer on constrained optimization

103

fig. a0.2. an example of duality gap arising from non-convexity (see text).

the (convexity) conditions above do not hold we obtain

min
x

{f(x) : h(x) = 0, g(x)     0} > max

{  (  ,   ) :        0}

  ,  

which means that the optimal solution to the dual problem provides only a
lower bound to the primal problem     this situation is called a duality gap.
taken together, the    duality theorem    summarizes the discussion so far:
theorem 12 (duality theorem) in order for x    to be an optimal primal
solution and (     ,      ) to be an optimal dual solution, it is necessary and
su   cient that:

(i) x    is primal feasible,
(ii)           0 and      j = 0 for all gj(x   ) < 0,
(iii) x        argminxl(x,      ,      ).
we will end this section with a geometric interpretation of duality.

a0.3.4 geometric interpretation of duality

for clarity we will consider a primal problem with a single inequality con-
straint: min{f(x) : g(x)     0} where g : rn     r.
consider the set g = {(y, z) : y = g(x), z = f(x)} in the (y, z) plane. the
set g is the image of rn under the (g, f) map (see fig. a0.1). the primal

),(**zyyzg*  optimal primaloptimal dualappendix

104
problem is to    nd a point in g that has a y     0 with the smallest z value
    this is the point (y   , z   ) in the    gure.
in this case   (  ) = minx{f(x) +   g(x)} which is equivalent to minimize
z +   y over points in g. the equation z +   y =    represents a straight line
with slope       and intercept (on z axis)   . for a given value   , to minimize
z +   y over g we need to move the line z +   y =    parallel to itself as far
down as possible while it remains in contact with g     in other words g
is above the line and touches it. then, the intercept with the z axis gives
  (  ). the dual problem is therefore equivalent to    nding the slope of the
supporting hyperplane such that its intercept on the z axis is maximal.

consider the non-convex region g in fig. a0.2 which illustrates a duality
gap condition. the optimal primal is the point (y   , z   ) which is higher than
the greatest intercept on the z axis achieved by a line that supports g from
below. this is an example of a duality gap caused by the non-convexity of
the functions f(), g() (thereby making the set g non-convex).

bibliography

m. anthony and p.l. bartlett. neural neteowk learning: theoretical foundations.

cambridge university press, 1999.

k.m. hall. an r-dimensional quadratic placement algorithm. manag. sci., 17:219   

229, 1970.

ory. mit press, 1997.

m.j. kearns and u.v. vazirani. an introduction to computational learning the-

y. linde, a. buzo, and r.m. gray. an algorithm for vector quantizer design. ieee

transactions on communications, 1:84   95, 1980.

a.y. ng, m.i. jordan, and y. weiss. on spectral id91: analysis and an
algorithm. in proceedings of the conference on neural information processing
systems (nips), 2001.

j. shi and j. malik. normalized cuts and image segmentation. ieee transactions

on pattern analysis and machine intelligence, 22(8), 2000.

r. zass and a. shashua. a unifying approach to hard and probabilistic id91.
in proceedings of the international conference on id161, beijing,
china, oct. 2005.

105

