speech and language processing.
2018.

all rights reserved. draft of september 23, 2018.

daniel jurafsky & james h. martin.

copyright c(cid:13)

chapter

12 statistical parsing

the characters in damon runyon   s short stories are willing to bet    on any propo-
sition whatever   , as runyon says about sky masterson in the idyll of miss sarah
brown, from the id203 of getting aces back-to-back to the odds against a man
being able to throw a peanut from second base to home plate. there is a moral here
for language processing: with enough knowledge we can    gure the id203 of
just about anything. the last two chapters have introduced sophisticated models of
syntactic structure and its parsing. here, we show that it is possible to build proba-
bilistic models of syntactic knowledge and use some of this probabilistic knowledge
to build ef   cient probabilistic parsers.

one crucial use of probabilistic parsing is to solve the problem of disambigua-
tion. recall from chapter 11 that sentences on average tend to be syntactically
ambiguous because of phenomena like coordination ambiguity and attachment
ambiguity. the cky parsing algorithm can represent these ambiguities in an ef   -
cient way but is not equipped to resolve them. a probabilistic parser offers a solution
to the problem: compute the id203 of each interpretation and choose the most
probable interpretation. thus, due to the prevalence of ambiguity, most modern
parsers used for natural language understanding tasks (semantic analysis, summa-
rization, question-answering, machine translation) are of necessity probabilistic.

the most commonly used probabilistic grammar formalism is the probabilistic
context-free grammar (pid18), a probabilistic augmentation of context-free gram-
mars in which each rule is associated with a id203. we introduce pid18s in the
next section, showing how they can be trained on treebank grammars and how they
can be parsed. we present the most basic parsing algorithm for pid18s, which is the
probabilistic version of the cky algorithm that we saw in chapter 11.

we then show a number of ways that we can improve on this basic id203
model (pid18s trained on treebank grammars). one method of improving a trained
treebank grammar is to change the names of the non-terminals. by making the
non-terminals sometimes more speci   c and sometimes more general, we can come
up with a grammar with a better id203 model that leads to improved parsing
scores. another augmentation of the pid18 works by adding more sophisticated
conditioning factors, extending pid18s to handle probabilistic subcategorization
information and probabilistic lexical dependencies.

heavily lexicalized grammar formalisms such as lexical-functional grammar
(lfg) (bresnan, 1982), head-driven phrase structure grammar (hpsg) (pollard
and sag, 1994), tree-adjoining grammar (tag) (joshi, 1985), and combinatory
categorial grammar (id35) pose additional problems for probabilistic parsers. sec-
tion 12.7 introduces the task of id55 and the use of heuristic search methods
based on the a* algorithm in the context of id35 parsing.

finally, we describe the standard techniques and metrics for evaluating parsers

and discuss some relevant psychological results on human parsing.

2 chapter 12

    statistical parsing

12.1 id140

pid18
sid18

the simplest augmentation of the context-free grammar is the probabilistic context-
free grammar (pid18), also known as the stochastic context-free grammar
(sid18),    rst proposed by booth (1969). recall that a context-free grammar g is
de   ned by four parameters (n,   , r, s); a probabilistic context-free grammar is also
de   ned by four parameters, with a slight augmentation to each of the rules in r:

n a set of non-terminal symbols (or variables)
   a set of terminal symbols (disjoint from n)
r a set of rules or productions, each of the form a        [p],

where a is a non-terminal,
   is a string of symbols from the in   nite set of strings (      n)   ,
and p is a number between 0 and 1 expressing p(  |a)

s a designated start symbol

that is, a pid18 differs from a standard id18 by augmenting each rule in r with

a id155:

a        [p]

(12.1)

here p expresses the id203 that the given non-terminal a will be expanded
to the sequence    . that is, p is the id155 of a given expansion   
given the left-hand-side (lhs) non-terminal a. we can represent this id203 as

or as

or as

p(a        )

p(a       |a)

p(rhs|lhs)

thus, if we consider all the possible expansions of a non-terminal, the sum of their
probabilities must be 1:

(cid:88)

p(a        ) = 1

  

figure 12.1 shows a pid18: a probabilistic augmentation of the l1 miniature en-
glish id18 grammar and lexicon. note that the probabilities of all of the expansions
of each non-terminal sum to 1. also note that these probabilities were made up
for pedagogical purposes. a real grammar has a great many more rules for each
non-terminal; hence, the probabilities of any particular rule would tend to be much
smaller.

a pid18 is said to be consistent if the sum of the probabilities of all sentences
in the language equals 1. certain kinds of recursive rules cause a grammar to be
inconsistent by causing in   nitely looping derivations for some sentences. for ex-
ample, a rule s     s with id203 1 would lead to lost id203 mass due to
derivations that never terminate. see booth and thompson (1973) for more details
on consistent and inconsistent grammars.

consistent

12.1

    id140

3

grammar

lexicon

det     that [.10] | a [.30] | the [.60]
noun     book [.10] |    ight [.30]
| meal [.015] | money [.05]
|    ight [.40] | dinner [.10]
verb     book [.30] | include [.30]
| prefer [.40]
pronoun     i [.40] | she [.05]
| me [.15] | you [.40]
proper-noun     houston [.60]
| nwa [.40]
aux     does [.60] | can [40]
preposition     from [.30] | to [.30]

s     np vp
[.80]
s     aux np vp
[.15]
s     vp
[.05]
np     pronoun
[.35]
np     proper-noun
[.30]
np     det nominal
[.20]
np     nominal
[.15]
nominal     noun
[.75]
nominal     nominal noun [.20]
nominal     nominal pp
[.05]
vp     verb
[.35]
vp     verb np
[.20]
vp     verb np pp
[.10]
vp     verb pp
[.15]
vp     verb np np
[.05]
vp     vp pp
[.15]
pp     preposition np
[1.0]
figure 12.1 a pid18 that is a probabilistic augmentation of the l1 miniature english id18
grammar and lexicon of fig. ??. these probabilities were made up for pedagogical purposes
and are not based on a corpus (since any real corpus would have many more rules, so the true
probabilities of each rule would be much smaller).

| on [.20] | near [.15]
| through [.05]

how are pid18s used? a pid18 can be used to estimate a number of useful
probabilities concerning a sentence and its parse tree(s), including the id203 of
a particular parse tree (useful in disambiguation) and the id203 of a sentence
or a piece of a sentence (useful in id38). let   s see how this works.

12.1.1 pid18s for disambiguation
a pid18 assigns a id203 to each parse tree t (i.e., each derivation) of a sen-
tence s. this attribute is useful in disambiguation. for example, consider the two
parses of the sentence    book the dinner    ight    shown in fig. 12.2. the sensible
parse on the left means    book a    ight that serves dinner   . the nonsensical parse
on the right, however, would have to mean something like    book a    ight on behalf
of    the dinner       just as a structurally similar sentence like    can you book john a
   ight?    means something like    can you book a    ight on behalf of john?   

the id203 of a particular parse t is de   ned as the product of the probabil-
ities of all the n rules used to expand each of the n non-terminal nodes in the parse
tree t, where each rule i can be expressed as lhsi     rhsi:

p(t,s) =

p(rhsi|lhsi)

(12.2)

i=1

the resulting id203 p(t,s) is both the joint id203 of the parse and the
sentence and also the id203 of the parse p(t ). how can this be true? first, by
the de   nition of joint id203:

p(t,s) = p(t )p(s|t )

(12.3)

n(cid:89)

4 chapter 12

    statistical parsing

but since a parse tree includes all the words of the sentence, p(s|t ) is 1. thus,

p(t,s) = p(t )p(s|t ) = p(t )

(12.4)

s

vp

s

vp

verb

np

verb

np

np

book

det

nominal

book

det

nominal

nominal

the

nominal

noun

the

noun

noun

noun

   ight

dinner

   ight

dinner

rules
    vp
    verb np
    det nominal

p
.05
s
vp
.20
np
.20
nominal     nominal noun .20
nominal     noun
.75
    book
verb
    the
det
noun     dinner
noun        ight

.30
.60
.10
.40

s
vp
np
np
nominal     noun
nominal     noun
    book
verb
    the
det
noun     dinner
noun        ight

p
rules
    vp
.05
    verb np np .10
    det nominal
.20
    nominal
.15
.75
.75
.30
.60
.10
.40

figure 12.2 two parse trees for an ambiguous sentence. the parse on the left corresponds
to the sensible meaning    book a    ight that serves dinner   , while the parse on the right corre-
sponds to the nonsensical meaning    book a    ight on behalf of    the dinner       .

we can compute the id203 of each of the trees in fig. 12.2 by multiplying
the probabilities of each of the rules used in the derivation. for example, the proba-
bility of the left tree in fig. 12.2a (call it tle f t) and the right tree (fig. 12.2b or tright)
can be computed as follows:

p(tle f t ) = .05    .20    .20    .20    .75    .30    .60    .10    .40 = 2.2   10   6
p(tright ) = .05    .10    .20    .15    .75    .75    .30    .60    .10    .40 = 6.1   10   7

we can see that the left tree in fig. 12.2 has a much higher id203 than the
tree on the right. thus, this parse would correctly be chosen by a disambiguation
algorithm that selects the parse with the highest pid18 id203.

let   s formalize this intuition that picking the parse with the highest id203
is the correct way to do disambiguation. consider all the possible parse trees for a
given sentence s. the string of words s is called the yield of any parse tree over s.

yield

12.1

    id140

5

thus, out of all parse trees with a yield of s, the disambiguation algorithm picks the
parse tree that is most probable given s:

  t (s) = argmax

t s.t.s=yield(t )

p(t|s)

(12.5)

by de   nition, the id203 p(t|s) can be rewritten as p(t,s)/p(s), thus lead-

ing to

  t (s) = argmax

t s.t.s=yield(t )

p(t,s)
p(s)

(12.6)

since we are maximizing over all parse trees for the same sentence, p(s) will be

a constant for each tree, so we can eliminate it:

  t (s) = argmax

t s.t.s=yield(t )

p(t,s)

(12.7)

furthermore, since we showed above that p(t,s) = p(t ), the    nal equation
for choosing the most likely parse neatly simpli   es to choosing the parse with the
highest id203:

  t (s) = argmax

t s.t.s=yield(t )

p(t )

(12.8)

12.1.2 pid18s for id38
a second attribute of a pid18 is that it assigns a id203 to the string of words
constituting a sentence. this is important in id38, whether for use
in id103, machine translation, id147, augmentative com-
munication, or other applications. the id203 of an unambiguous sentence is
p(t,s) = p(t ) or just the id203 of the single parse tree for that sentence. the
id203 of an ambiguous sentence is the sum of the probabilities of all the parse
trees for the sentence:

p(s) =

=

t s.t.s=yield(t )

p(t,s)

p(t )

(12.9)

(12.10)

t s.t.s=yield(t )

an additional feature of pid18s that is useful for id38 is their
ability to assign a id203 to substrings of a sentence. for example, suppose we
want to know the id203 of the next word wi in a sentence given all the words
we   ve seen so far w1, ...,wi   1. the general formula for this is

p(wi|w1,w2, ...,wi   1) =

p(w1,w2, ...,wi   1,wi)
p(w1,w2, ...,wi   1)

(12.11)

we saw in chapter 3 a simple approximation of this id203 using id165s,
conditioning on only the last word or two instead of the entire context; thus, the
bigram approximation would give us

p(wi|w1,w2, ...,wi   1)     p(wi   1,wi)
p(wi   1)

(12.12)

(cid:88)
(cid:88)

6 chapter 12

    statistical parsing

but the fact that the id165 model can only make use of a couple words of
context means it is ignoring potentially useful prediction cues. consider predicting
the word after in the following sentence from chelba and jelinek (2000):
(12.13) the contract ended with a loss of 7 cents after trading as low as 9 cents
a trigram grammar must predict after from the words 7 cents, while it seems clear
that the verb ended and the subject contract would be useful predictors that a pid18-
based parser could help us make use of. indeed, it turns out that pid18s allow us to
condition on the entire previous context w1,w2, ...,wi   1 shown in eq. 12.11.

in summary, this section and the previous one have shown that pid18s can be
applied both to disambiguation in syntactic parsing and to word prediction in lan-
guage modeling. both of these applications require that we be able to compute the
id203 of parse tree t for a given sentence s. the next few sections introduce
some algorithms for computing this id203.

12.2 probabilistic cky parsing of pid18s

the parsing problem for pid18s is to produce the most-likely parse   t for a given
sentence s, that is,

  t (s) = argmax

t s.t.s=yield(t )

p(t )

(12.14)

probabilistic
cky

the algorithms for computing the most likely parse are simple extensions of the
standard algorithms for parsing; most modern probabilistic parsers are based on the
probabilistic cky algorithm,    rst described by ney (1991).

as with the cky algorithm, we assume for the probabilistic cky algorithm that
the pid18 is in chomsky normal form. recall from page ?? that grammars in cnf
are restricted to rules of the form a     b c, or a     w. that is, the right-hand side
of each rule must expand to either two non-terminals or to a single terminal.

for the cky algorithm, we represented each sentence as having indices between

the words. thus, an example sentence like
(12.15) book the    ight through houston.
would assume the following indices between each word:
(12.16)

0(cid:13) book 1(cid:13) the 2(cid:13)    ight 3(cid:13) through 4(cid:13) houston 5(cid:13)

using these indices, each constituent in the cky parse tree is encoded in a
two-dimensional matrix. speci   cally, for a sentence of length n and a grammar
that contains v non-terminals, we use the upper-triangular portion of an (n + 1)  
(n + 1) matrix. for cky, each cell table[i, j] contained a list of constituents that
could span the sequence of words from i to j. for probabilistic cky, it   s slightly
simpler to think of the constituents in each cell as constituting a third dimension of
maximum length v . this third dimension corresponds to each non-terminal that can
be placed in this cell, and the value of the cell is then a id203 for that non-
terminal/constituent rather than a list of constituents. in summary, each cell [i, j,a]
in this (n + 1)   (n + 1)  v matrix is the id203 of a constituent of type a that
spans positions i through j of the input.

figure 12.3 gives pseudocode for this probabilistic cky algorithm, extending

the basic cky algorithm from fig. ??.

12.3

    ways to learn pid18 rule probabilities

7

function probabilistic-cky(words,grammar) returns most probable parse
for j   from 1 to length(words) do

and its id203

for all { a | a     words[ j]     grammar}
for i   from j    2 downto 0 do

table[ j    1, j,a]   p(a     words[ j])
for k   i + 1 to j    1 do

for all { a | a     bc     grammar,

and table[i,k,b] > 0 and table[k, j,c] > 0 }

if (table[i,j,a] < p(a     bc)    table[i,k,b]    table[k,j,c]) then

table[i,j,a]   p(a     bc)    table[i,k,b]    table[k,j,c]
back[i,j,a]   {k,b,c}

return build tree(back[1, length(words), s]), table[1, length(words), s]

figure 12.3 the probabilistic cky algorithm for    nding the maximum id203 parse
of a string of num words words given a pid18 grammar with num rules rules in chomsky
normal form. back is an array of backpointers used to recover the best parse. the build tree
function is left as an exercise to the reader.

like the basic cky algorithm, the probabilistic cky algorithm as shown in
fig. 12.3 requires a grammar in chomsky normal form. converting a probabilistic
grammar to cnf requires that we also modify the probabilities so that the id203
of each parse remains the same under the new cnf grammar. exercise 12.2 asks
you to modify the algorithm for conversion to cnf in chapter 11 so that it correctly
handles rule probabilities.

in practice, a generalized cky algorithm that handles unit productions directly
is typically used. recall that exercise 13.3 asked you to make this change in cky;
exercise 12.3 asks you to extend this change to probabilistic cky.

let   s see an example of the probabilistic cky chart, using the following mini-

grammar, which is already in cnf:

s     np vp
.80
np     det n
.30
v p     v np
.20
v     includes .05

det     the
det     a
n     meal
n     f light

.40
.40
.01
.02

given this grammar, fig. 12.4 shows the    rst steps in the probabilistic cky

parse of the following example:
(12.17) the    ight includes a meal

12.3 ways to learn pid18 rule probabilities

where do pid18 rule probabilities come from? there are two ways to learn proba-
bilities for the rules of a grammar. the simplest way is to use a treebank, a corpus
of already parsed sentences. recall that we introduced in chapter 10 the idea of
treebanks and the commonly used id32 (marcus et al., 1993), a collec-
tion of parse trees in english, chinese, and other languages that is distributed by the
linguistic data consortium. given a treebank, we can compute the id203 of
each expansion of a non-terminal by counting the number of times that expansion

8 chapter 12

    statistical parsing

figure 12.4 the beginning of the probabilistic cky matrix. filling out the rest of the chart
is left as exercise 12.4 for the reader.

occurs and then normalizing.

p(         |  ) =

(cid:80)
count(          )
   count(         )

count(          )

count(  )

=

(12.18)

if we don   t have a treebank but we do have a (non-probabilistic) parser, we can
generate the counts we need for computing pid18 rule probabilities by    rst parsing
a corpus of sentences with the parser. if sentences were unambiguous, it would be
as simple as this: parse the corpus, increment a counter for every rule in the parse,
and then normalize to get probabilities.

but wait! since most sentences are ambiguous, that is, have multiple parses, we
don   t know which parse to count the rules in. instead, we need to keep a separate
count for each parse of a sentence and weight each of these partial counts by the
id203 of the parse it appears in. but to get these parse probabilities to weight
the rules, we need to already have a probabilistic parser.

the intuition for solving this chicken-and-egg problem is to incrementally im-
prove our estimates by beginning with a parser with equal rule probabilities, then
parse the sentence, compute a id203 for each parse, use these probabilities to

theflight[0,1][0,2][0,3][1,2][1,3][2,3]det: .40includesameal[3,4][4,5]n: .02v: .05np: .30 *.40 *.02= .0024[0,4][1,4][2,4][3,5][2,5][1,5][0,5]det: .40n: .0112.4

    problems with pid18s

9

inside-outside

expectation
step
maximization
step

weight the counts, re-estimate the rule probabilities, and so on, until our proba-
bilities converge. the standard algorithm for computing this solution is called the
inside-outside algorithm; it was proposed by baker (1979) as a generalization of the
forward-backward algorithm for id48s. like forward-backward, inside-outside is
a special case of the expectation maximization (em) algorithm, and hence has two
steps: the expectation step, and the maximization step. see lari and young (1990)
or manning and sch  utze (1999) for a complete description of the algorithm.

this use of the inside-outside algorithm to estimate the rule probabilities for
a grammar is actually a kind of limited use of inside-outside. the inside-outside
algorithm can actually be used not only to set the rule probabilities but even to induce
the grammar rules themselves. it turns out, however, that grammar induction is so
dif   cult that inside-outside by itself is not a very successful grammar inducer; see
the historical notes at the end of the chapter for pointers to other grammar induction
algorithms.

12.4 problems with pid18s

while id140 are a natural extension to context-free
grammars, they have two main problems as id203 estimators:
poor independence assumptions: id18 rules impose an independence assumption
on probabilities, resulting in poor modeling of structural dependencies across
the parse tree.

lack of lexical conditioning: id18 rules don   t model syntactic facts about speci   c
words, leading to problems with subcategorization ambiguities, preposition
attachment, and coordinate structure ambiguities.

because of these problems, most current probabilistic parsing models use some
augmented version of pid18s, or modify the treebank-based grammar in some way.
in the next few sections after discussing the problems in more detail we introduce
some of these augmentations.

12.4.1

independence assumptions miss structural dependencies
between rules

let   s look at these problems in more detail. recall that in a id18 the expansion
of a non-terminal is independent of the context, that is, of the other nearby non-
terminals in the parse tree. similarly, in a pid18, the id203 of a particular
rule like np     det n is also independent of the rest of the tree. by de   nition, the
id203 of a group of independent events is the product of their probabilities.
these two facts explain why in a pid18 we compute the id203 of a tree by just
multiplying the probabilities of each non-terminal expansion.

unfortunately, this id18 independence assumption results in poor id203
estimates. this is because in english the choice of how a node expands can after all
depend on the location of the node in the parse tree. for example, in english it turns
out that nps that are syntactic subjects are far more likely to be pronouns, and nps
that are syntactic objects are far more likely to be non-pronominal (e.g., a proper
noun or a determiner noun sequence), as shown by these statistics for nps in the

10 chapter 12

    statistical parsing

switchboard corpus (francis et al., 1999):1

pronoun non-pronoun

subject 91%
object 34%

9%
66%

unfortunately, there is no way to represent this contextual difference in the prob-
abilities in a pid18. consider two expansions of the non-terminal np as a pronoun
or as a determiner+noun. how shall we set the probabilities of these two rules? if
we set their probabilities to their overall id203 in the switchboard corpus, the
two rules have about equal id203.

np     dt nn .28
np     prp
.25

because pid18s don   t allow a rule id203 to be conditioned on surrounding
context, this equal id203 is all we get; there is no way to capture the fact that in
subject position, the id203 for np     prp should go up to .91, while in object
position, the id203 for np     dt nn should go up to .66.
these dependencies could be captured if the id203 of expanding an np as
a pronoun (e.g., np     prp) versus a lexical np (e.g., np     dt nn) were condi-
tioned on whether the np was a subject or an object. section 12.5 introduces the
technique of parent annotation for adding this kind of conditioning.

12.4.2 lack of sensitivity to lexical dependencies
a second class of problems with pid18s is their lack of sensitivity to the words in
the parse tree. words do play a role in pid18s since the parse id203 includes
the id203 of a word given a part-of-speech (i.e., from rules like v     sleep,
nn     book, etc.).

but it turns out that lexical information is useful in other places in the grammar,
such as in resolving prepositional phrase (pp) attachment ambiguities. since prepo-
sitional phrases in english can modify a noun phrase or a verb phrase, when a parser
   nds a prepositional phrase, it must decide where to attach it into the tree. consider
the following example:
(12.19) workers dumped sacks into a bin.

figure 12.5 shows two possible parse trees for this sentence; the one on the left is
the correct parse; fig. 12.6 shows another perspective on the preposition attachment
problem, demonstrating that resolving the ambiguity in fig. 12.5 is equivalent to
deciding whether to attach the prepositional phrase into the rest of the tree at the
np or vp nodes; we say that the correct parse requires vp attachment, and the
incorrect parse implies np attachment.

why doesn   t a pid18 already deal with pp attachment ambiguities? note that
the two parse trees in fig. 12.5 have almost exactly the same rules; they differ only
in that the left-hand parse has this rule:

v p     v bd np pp

1 distribution of subjects from 31,021 declarative sentences; distribution of objects from 7,489 sen-
tences. this tendency is caused by the use of subject position to realize the topic or old information
in a sentence (giv  on, 1990). pronouns are a way to talk about old information, while non-pronominal
(   lexical   ) noun-phrases are often used to introduce new referents. we talk more about new and old
information in chapter 21.

vp attachment
np attachment

12.4

    problems with pid18s

11

s

s

np

vp

np

vp

nns

vbd

np

pp

nns

vbd

np

workers

dumped

nns

p

np

workers

dumped

np

pp

sacks

into

dt

nn

nns

p

np

a

bin

sacks

into

dt

nn

figure 12.5 two possible parse trees for a prepositional phrase attachment ambiguity. the left parse is
the sensible one, in which    into a bin    describes the resulting location of the sacks. in the right incorrect parse,
the sacks to be dumped are the ones which are already    into a bin   , whatever that might mean.

a

bin

s

np

vp

nns

vbd

np

workers

dumped

nns

sacks

pp

p

np

into

dt

nn

a

bin

figure 12.6 another view of the preposition attachment problem. should the pp on the right attach to the
vp or np nodes of the partial parse tree on the left?

while the right-hand parse has these:

v p     v bd np
np     np pp

depending on how these probabilities are set, a pid18 will always either prefer
np attachment or vp attachment. as it happens, np attachment is slightly more
common in english, so if we trained these rule probabilities on a corpus, we might
always prefer np attachment, causing us to misparse this sentence.

but suppose we set the probabilities to prefer the vp attachment for this sen-
tence. now we would misparse the following sentence, which requires np attach-
ment:
(12.20)    shermen caught tons of herring

12 chapter 12

    statistical parsing

lexical
dependency

what information in the input sentence lets us know that (12.20) requires np

attachment while (12.19) requires vp attachment?

it should be clear that these preferences come from the identities of the verbs,
nouns, and prepositions. it seems that the af   nity between the verb dumped and the
preposition into is greater than the af   nity between the noun sacks and the preposi-
tion into, thus leading to vp attachment. on the other hand, in (12.20) the af   nity
between tons and of is greater than that between caught and of, leading to np attach-
ment.

thus, to get the correct parse for these kinds of examples, we need a model that
somehow augments the pid18 probabilities to deal with these lexical dependency
statistics for different verbs and prepositions.

coordination ambiguities are another case in which lexical dependencies are
the key to choosing the proper parse. figure 12.7 shows an example from collins
(1999) with two parses for the phrase dogs in houses and cats. because dogs is
semantically a better conjunct for cats than houses (and because most dogs can   t    t
inside cats), the parse [dogs in [np houses and cats]] is intuitively unnatural and
should be dispreferred. the two parses in fig. 12.7, however, have exactly the same
pid18 rules, and thus a pid18 will assign them the same id203.

np

np

np

conj

np

np

pp

np

pp

and

noun

noun

prep

np

noun

prep

np

cats

dogs

in

np

conj

np

dogs

in

noun

houses

noun

and

noun

houses

cats

figure 12.7 an instance of coordination ambiguity. although the left structure is intu-
itively the correct one, a pid18 will assign them identical probabilities since both structures
use exactly the same set of rules. after collins (1999).

in summary, we have shown in this section and the previous one that probabilistic
context-free grammars are incapable of modeling important structural and lexical
dependencies. in the next two sections we sketch current methods for augmenting
pid18s to deal with both these issues.

12.5

improving pid18s by splitting non-terminals

let   s start with the    rst of the two problems with pid18s mentioned above: their
inability to model structural dependencies, like the fact that nps in subject position
tend to be pronouns, whereas nps in object position tend to have full lexical (non-
pronominal) form. how could we augment a pid18 to correctly model this fact?
one idea would be to split the np non-terminal into two versions: one for sub-

split

12.5

   

improving pid18s by splitting non-terminals

13

parent
annotation

jects, one for objects. having two nodes (e.g., npsubject and npobject) would allow
us to correctly model their different distributional properties, since we would have
different probabilities for the rule npsubject     prp and the rule npobject     prp.
one way to implement this intuition of splits is to do parent annotation (john-
son, 1998), in which we annotate each node with its parent in the parse tree. thus,
an np node that is the subject of the sentence and hence has parent s would be anno-
tated np  s, while a direct object np whose parent is vp would be annotated np  vp.
figure 12.8 shows an example of a tree produced by a grammar that parent-annotates
the phrasal non-terminals (like np and vp).

a)

s

b)

s

np

vp

np  s

vp  s

prp

vbd

np

prp

vbd

np  vp

i

need

dt

nn

i

need

dt

nn

a

   ight

a

   ight

figure 12.8 a standard pid18 parse tree (a) and one which has parent annotation on the
nodes which aren   t pre-terminal (b). all the non-terminal nodes (except the pre-terminal
part-of-speech nodes) in parse (b) have been annotated with the identity of their parent.

in addition to splitting these phrasal nodes, we can also improve a pid18 by
splitting the pre-terminal part-of-speech nodes (klein and manning, 2003b). for ex-
ample, different kinds of adverbs (rb) tend to occur in different syntactic positions:
the most common adverbs with advp parents are also and now, with vp parents
n   t and not, and with np parents only and just. thus, adding tags like rb  advp,
rb  vp, and rb  np can be useful in improving pid18 modeling.

similarly, the id32 tag in can mark a wide variety of parts-of-speech,
including subordinating conjunctions (while, as, if), complementizers (that, for), and
prepositions (of, in, from). some of these differences can be captured by parent an-
notation (subordinating conjunctions occur under s, prepositions under pp), while
others require speci   cally splitting the pre-terminal nodes. figure 12.9 shows an ex-
ample from klein and manning (2003b) in which even a parent-annotated grammar
incorrectly parses works as a noun in to see if advertising works. splitting pre-
terminals to allow if to prefer a sentential complement results in the correct verbal
parse.

to deal with cases in which parent annotation is insuf   cient, we can also hand-
write rules that specify a particular node split based on other features of the tree. for
example, to distinguish between complementizer in and subordinating conjunction
in, both of which can have the same parent, we could write rules conditioned on
other aspects of the tree such as the lexical identity (the lexeme that is likely to be a
complementizer, as a subordinating conjunction).

node-splitting is not without problems; it increases the size of the grammar and
hence reduces the amount of training data available for each grammar rule, leading
to over   tting. thus, it is important to split to just the correct level of granularity for a
particular training set. while early models employed hand-written rules to try to    nd
an optimal number of non-terminals (klein and manning, 2003b), modern models

14 chapter 12

    statistical parsing

split and merge

automatically search for the optimal splits. the split and merge algorithm of petrov
et al. (2006), for example, starts with a simple x-bar grammar, alternately splits the
non-terminals, and merges non-terminals,    nding the set of annotated nodes that
maximizes the likelihood of the training set treebank. as of the time of this writing,
the performance of the petrov et al. (2006) algorithm was the best of any known
parsing algorithm on the id32.

12.6 probabilistic lexicalized id18s

the previous section showed that a simple probabilistic cky algorithm for pars-
ing raw pid18s can achieve extremely high parsing accuracy if the grammar rule
symbols are redesigned by automatic splits and merges.

in this section, we discuss an alternative family of models in which instead of
modifying the grammar rules, we modify the probabilistic model of the parser to
allow for lexicalized rules. the resulting family of lexicalized parsers includes the
well-known collins parser (collins, 1999) and charniak parser (charniak, 1997),
both of which are publicly available and widely used throughout natural language
processing.

we saw in section ?? that syntactic constituents could be associated with a lexi-
cal head, and we de   ned a lexicalized grammar in which each non-terminal in the
tree is annotated with its lexical head, where a rule like v p     v bd np pp would
be extended as

collins parser
charniak
parser

lexicalized
grammar

vp(dumped)     vbd(dumped) np(sacks) pp(into)

(12.21)

head tag

in the standard type of lexicalized grammar, we actually make a further exten-
sion, which is to associate the head tag, the part-of-speech tags of the headwords,
with the non-terminal symbols as well. each rule is thus lexicalized by both the

vp  s

vp  s

to

vp  vp

to  vp

vp  vp

to

vb

pp  vp

to

vb  vp

sbar  vp

see

in

np  pp

see

in  sbar

s  sbar

if

nn

nns

if

np  s

vp  s

advertising

works

nn  np

vbz  vp

figure 12.9 an incorrect parse even with a parent-annotated parse (left). the correct parse (right), was
produced by a grammar in which the pre-terminal nodes have been split, allowing the probabilistic grammar to
capture the fact that if prefers sentential complements. adapted from klein and manning (2003b).

advertising

works

12.6

    probabilistic lexicalized id18s

15

headword and the head tag of each constituent resulting in a format for lexicalized
rules like

vp(dumped,vbd)     vbd(dumped,vbd) np(sacks,nns) pp(into,p)

(12.22)

we show a lexicalized parse tree with head tags in fig. 12.10, extended from fig. ??.

top

s(dumped,vbd)

np(workers,nns)

vp(dumped,vbd)

nns(workers,nns)

vbd(dumped,vbd)

np(sacks,nns)

pp(into,p)

workers

dumped

nns(sacks,nns)

p(into,p)

np(bin,nn)

sacks

into

dt(a,dt)

nn(bin,nn)

a

bin

internal rules
    s(dumped,vbd)
top
s(dumped,vbd)     np(workers,nns)
np(workers,nns)     nns(workers,nns)
vp(dumped,vbd)     vbd(dumped, vbd) np(sacks,nns) pp(into,p) p(into,p)
dt(a,dt)
pp(into,p)
np(bin,nn)
nn(bin,nn)

    p(into,p)
    dt(a,dt)

np(bin,nn)
nn(bin,nn)

vp(dumped,vbd)

lexical rules
nns(workers,nns)     workers
vbd(dumped,vbd)     dumped
nns(sacks,nns)

    sacks
    into
    a
    bin

figure 12.10 a lexicalized tree, including head tags, for a wsj sentence, adapted from collins (1999). below
we show the pid18 rules that would be needed for this parse tree, internal rules on the left, and lexical rules on
the right.

to generate such a lexicalized tree, each pid18 rule must be augmented to iden-
tify one right-hand constituent to be the head daughter. the headword for a node is
then set to the headword of its head daughter, and the head tag to the part-of-speech
tag of the headword. recall that we gave in fig. ?? a set of hand-written rules for
identifying the heads of particular constituents.

a natural way to think of a lexicalized grammar is as a parent annotation, that
is, as a simple context-free grammar with many copies of each rule, one copy for
each possible headword/head tag for each constituent. thinking of a probabilistic
lexicalized id18 in this way would lead to the set of simple pid18 rules shown below
the tree in fig. 12.10.

note that fig. 12.10 shows two kinds of rules:

lexical rules, which express
the expansion of a pre-terminal to a word, and internal rules, which express the
other rule expansions. we need to distinguish these kinds of rules in a lexicalized
grammar because they are associated with very different kinds of probabilities. the
lexical rules are deterministic, that is, they have id203 1.0 since a lexicalized
pre-terminal like nn(bin,nn) can only expand to the word bin. but for the internal
rules, we need to estimate probabilities.

lexical rules
internal rules

16 chapter 12

    statistical parsing

suppose we were to treat a probabilistic lexicalized id18 like a really big id18
that just happened to have lots of very complex non-terminals and estimate the
probabilities for each rule from maximum likelihood estimates. thus, according
to eq. 12.18, the id113 estimate for the id203 for the rule p(vp(dumped,vbd)
    vbd(dumped, vbd) np(sacks,nns) pp(into,p)) would be

count(vp(dumped,vbd)     vbd(dumped, vbd) np(sacks,nns) pp(into,p))

count(vp(dumped,vbd))

(12.23)

but there   s no way we can get good estimates of counts like those in (12.23)
because they are so speci   c: we   re unlikely to see many (or even any) instances of a
sentence with a verb phrase headed by dumped that has one np argument headed by
sacks and a pp argument headed by into. in other words, counts of fully lexicalized
pid18 rules like this will be far too sparse, and most rule probabilities will come out
0.

the idea of lexicalized parsing is to make some further independence assump-

tions to break down each rule so that we would estimate the id203

p(vp(dumped,vbd)     vbd(dumped, vbd) np(sacks,nns) pp(into,p))

as the product of smaller independent id203 estimates for which we could
acquire reasonable counts. the next section summarizes one such method, the
collins parsing method.

12.6.1 the collins parser
modern statistical parsers differ in exactly which independence assumptions they
make. in this section we describe a simpli   ed version of collins   s worth knowing
about; see the summary at the end of the chapter.

the    rst intuition of the collins parser is to think of the right-hand side of every
(internal) id18 rule as consisting of a head non-terminal, together with the non-
terminals to the left of the head and the non-terminals to the right of the head. in the
abstract, we think about these rules as follows:

lhs     ln ln   1 ...l1 h r1 ...rn   1 rn

(12.24)

since this is a lexicalized grammar, each of the symbols like l1 or r3 or h or
lhs is actually a complex symbol representing the category and its head and head
tag, like vp(dumped,vp) or np(sacks,nns).

now, instead of computing a single id113 id203 for this rule, we are going
to break down this rule via a neat generative story, a slight simpli   cation of what is
called collins model 1. this new generative story is that given the left-hand side,
we    rst generate the head of the rule and then generate the dependents of the head,
one by one, from the inside out. each of these generation steps will have its own
id203.

we also add a special stop non-terminal at the left and right edges of the rule;
this non-terminal allows the model to know when to stop generating dependents on a
given side. we generate dependents on the left side of the head until we   ve generated
stop on the left side of the head, at which point we move to the right side of the
head and start generating dependents there until we generate stop. so it   s as if we

12.6

    probabilistic lexicalized id18s

17

are generating a rule augmented as follows:

p(vp(dumped,vbd)    

(12.25)

stop vbd(dumped, vbd) np(sacks,nns) pp(into,p) stop)

let   s see the generative story for this augmented rule. we make use of three
kinds of probabilities: ph for generating heads, pl for generating dependents on the
left, and pr for generating dependents on the right.

1. generate the head vbd(dumped,vbd) with id203
p(h|lhs) = p(vbd(dumped,vbd) | vp(dumped,vbd))

2. generate the left dependent (which is stop, since there isn   t
one) with id203
p(stop| vp(dumped,vbd) vbd(dumped,vbd))

3. generate right dependent np(sacks,nns) with id203
pr(np(sacks,nns| vp(dumped,vbd), vbd(dumped,vbd))

4. generate the right dependent pp(into,p) with id203
pr(pp(into,p) | vp(dumped,vbd), vbd(dumped,vbd))

stop

vp(dumped,vbd)

vbd(dumped,vbd)

vp(dumped,vbd)

stop

vbd(dumped,vbd)

vp(dumped,vbd)

stop

vbd(dumped,vbd)

np(sacks,nns)

vp(dumped,vbd)

vbd(dumped,vbd)

np(sacks,nns)

pp(into,p)

vp(dumped,vbd)

5) generate the right dependent stop with id203
pr(stop | vp(dumped,vbd), vbd(dumped,vbd))

stop

vbd(dumped,vbd)

np(sacks,nns)

pp(into,p)

stop

in summary, the id203 of this rule
p(vp(dumped,vbd)    

vbd(dumped, vbd) np(sacks,nns) pp(into,p))

is estimated as

ph(vbd|vp, dumped)    pl(stop|vp,vbd,dumped)

   pr(np(sacks,nns)|vp,vbd,dumped)
   pr(pp(into,p)|vp,vbd,dumped)
   pr(stop|vp,vbd,dumped)

(12.26)

(12.27)

each of these probabilities can be estimated from much smaller amounts of data
than the full id203 in (12.26). for example, the maximum likelihood estimate

18 chapter 12

    statistical parsing

for the component id203 pr(np(sacks,nns)|vp,vbd,dumped) is

count( vp(dumped,vbd) with nns(sacks)as a daughter somewhere on the right )

count( vp(dumped,vbd) )

(12.28)
these counts are much less subject to sparsity problems than are complex counts
like those in (12.26).

more generally, if h is a head with head word hw and head tag ht, lw/lt and
rw/rt are the word/tag on the left and right respectively, and p is the parent, then the
id203 of an entire rule can be expressed as follows:

1. generate the head of the phrase h(hw,ht) with id203:

ph (h(hw,ht)|p,hw,ht)

2. generate modi   ers to the left of the head with total id203

n+1(cid:89)

n+1(cid:89)

pl(li(lwi,lti)|p,h,hw,ht)

i=1

such that ln+1(lwn+1,ltn+1) =stop, and we stop generating once we   ve gen-
erated a stop token.

3. generate modi   ers to the right of the head with total id203:

pp(ri(rwi,rti)|p,h,hw,ht)

i=1

such that rn+1(rwn+1,rtn+1) = stop, and we stop generating once we   ve
generated a stop token.

12.6.2 advanced: further details of the collins parser
the actual collins parser models are more complex (in a couple of ways) than the
simple model presented in the previous section. collins model 1 includes a distance
feature. thus, instead of computing pl and pr as follows,

distance

pl(li(lwi,lti)|p,h,hw,ht)
pr(ri(rwi,rti)|p,h,hw,ht)
collins model 1 conditions also on a distance feature:

pl(li(lwi,lti)|p,h,hw,ht,distancel(i    1))
pr(ri(rwi,rti)|p,h,hw,ht,distancer(i    1))

(12.29)
(12.30)

(12.31)
(12.32)

the distance measure is a function of the sequence of words below the previous
modi   ers (i.e., the words that are the yield of each modi   er non-terminal we have
already generated on the left).

the simplest version of this distance measure is just a tuple of two binary fea-
tures based on the surface string below these previous dependencies: (1) is the string
of length zero? (i.e., were no previous words generated?) (2) does the string contain
a verb?

12.7

    probabilistic id35 parsing

19

collins model 2 adds more sophisticated features, conditioning on subcatego-

rization frames for each verb and distinguishing arguments from adjuncts.

finally, smoothing is as important for statistical parsers as it was for id165
models. this is particularly true for lexicalized parsers, since the lexicalized rules
will otherwise condition on many lexical items that may never occur in training
(even using the collins or other methods of independence assumptions).
consider the id203 pr(ri(rwi,rti)|p,hw,ht). what do we do if a particular
right-hand constituent never occurs with this head? the collins model addresses this
problem by interpolating three backed-off models: fully lexicalized (conditioning on
the headword), backing off to just the head tag, and altogether unlexicalized.
backoff pr(ri(rwi,rti|...)
1
2
3

example
pr(np(sacks,nns)|vp, vbd, dumped)
pr(np(sacks,nns)|v p,v bd)
pr(np(sacks,nns)|v p)

pr(ri(rwi,rti)|p,hw,ht)
pr(ri(rwi,rti)|p,ht)
pr(ri(rwi,rti)|p)

similar backoff models are built also for pl and ph. although we   ve used the
word    backoff   , in fact these are not backoff models but interpolated models. the
three models above are linearly interpolated, where e1, e2, and e3 are the maximum
likelihood estimates of the three backoff models above:

pr(...) =   1e1 + (1      1)(  2e2 + (1      2)e3)

(12.33)
the values of   1and  2 are set to implement witten-bell discounting (witten and

bell, 1991) following bikel et al. (1997).

the collins model deals with unknown words by replacing any unknown word
in the test set, and any word occurring less than six times in the training set, with a
special unknown word token. unknown words in the test set are assigned a part-
of-speech tag in a preprocessing step by the ratnaparkhi (1996) tagger; all other
words are tagged as part of the parsing process.

the parsing algorithm for the collins model is an extension of probabilistic
cky; see collins (2003). extending the cky algorithm to handle basic lexical-
ized probabilities is left as exercises 14.5 and 14.6 for the reader.

12.7 probabilistic id35 parsing

lexicalized grammar frameworks such as id35 pose problems for which the phrase-
based methods we   ve been discussing are not particularly well-suited. to quickly
review, id35 consists of three major parts: a set of categories, a lexicon that asso-
ciates words with categories, and a set of rules that govern how categories combine
in context. categories can be either atomic elements, such as s and np, or functions
such as (s\np)/np which speci   es the transitive verb category. rules specify how
functions, their arguments, and other functions combine. for example, the following
rule templates, forward and backward function application, specify the way that
functions apply to their arguments.

x/y y     x
y x\y     x

the    rst rule applies a function to its argument on the right, while the second
looks to the left for its argument. the result of applying either of these rules is the

20 chapter 12

    statistical parsing

category speci   ed as the value of the function being applied. for the purposes of
this discussion, we   ll rely on these two rules along with the forward and backward
composition rules and type-raising, as described in chapter 10.

12.7.1 ambiguity in id35
as is always the case in parsing, managing ambiguity is the key to successful id35
parsing. the dif   culties with id35 parsing arise from the ambiguity caused by the
large number of complex lexical categories combined with the very general nature of
the grammatical rules. to see some of the ways that ambiguity arises in a categorial
framework, consider the following example.

(12.34) united diverted the    ight to reno.

our grasp of the role of the    ight in this example depends on whether the prepo-
sitional phrase to reno is taken as a modi   er of the    ight, as a modi   er of the entire
verb phrase, or as a potential second argument to the verb divert. in a context-free
grammar approach, this ambiguity would manifest itself as a choice among the fol-
lowing rules in the grammar.

nominal     nominal pp

vp     vp pp
vp     verb np pp

in a phrase-structure approach we would simply assign the word to to the cate-
gory p allowing it to combine with reno to form a prepositional phrase. the sub-
sequent choice of grammar rules would then dictate the ultimate derivation. in the
categorial approach, we can associate to with distinct categories to re   ect the ways
in which it might interact with other elements in a sentence. the fairly abstract
combinatoric rules would then sort out which derivations are possible. therefore,
the source of ambiguity arises not from the grammar but rather from the lexicon.

let   s see how this works by considering several possible derivations for this
example. to capture the case where the prepositional phrase to reno modi   es the
   ight, we assign the preposition to the category (np\np)/np, which gives rise to
the following derivation.

united

np

diverted
reno
(s\np)/np np/n n (np\np)/np np

   ight

the

to

np\np

>

np

s\np

s

np

>

<

>

<

here, the category assigned to to expects to    nd two arguments: one to the right as
with a traditional preposition, and one to the left that corresponds to the np to be
modi   ed.
alternatively, we could assign to to the category (s\s)/np, which permits the

following derivation where to reno modi   es the preceding verb phrase.

12.7

    probabilistic id35 parsing

21

united

np

diverted
reno
(s\np)/np np/n n (s\s)/np np

   ight

the

to

s\np

np

>

>

s\np

s

s\s

>

<b

<

a third possibility is to view divert as a ditransitive verb by assigning it to the
category ((s\np)/pp)/np, while treating to reno as a simple prepositional phrase.

united

np

diverted

reno
((s\np)/pp)/np np/n n pp/np np

   ight

the

to

np

>

>

pp

(s\np)/pp

s\np

s

>

>

<

while id35 parsers are still subject to ambiguity arising from the choice of
grammar rules, including the kind of spurious ambiguity discussed in chapter 10,
it should be clear that the choice of lexical categories is the primary problem to be
addressed in id35 parsing.

12.7.2 id35 parsing frameworks
since the rules in combinatory grammars are either binary or unary, a bottom-up,
tabular approach based on the cky algorithm should be directly applicable to id35
parsing. recall from fig. 12.3 that pcky employs a table that records the location,
category and id203 of all valid constituents discovered in the input. given an
appropriate id203 model for id35 derivations, the same kind of approach can
work for id35 parsing.

unfortunately, the large number of lexical categories available for each word,
combined with the promiscuity of id35   s combinatoric rules, leads to an explosion
in the number of (mostly useless) constituents added to the parsing table. the key
to managing this explosion of zombie constituents is to accurately assess and ex-
ploit the most likely lexical categories possible for each word     a process called
id55.

the following sections describe two approaches to id35 parsing that make use of
supertags. section 12.7.4, presents an approach that structures the parsing process
as a heuristic search through the use of the a* algorithm. the following section
then brie   y describes a more traditional maximum id178 approach that manages
the search space complexity through the use of adaptive id55     a process
that iteratively considers more and more tags until a parse is found.

id55

12.7.3 id55
chapter 8 introduced the task of part-of-speech tagging, the process of assigning the
correct lexical category to each word in a sentence. id55 is the correspond-
ing task for highly lexicalized grammar frameworks, where the assigned tags often
dictate much of the derivation for a sentence.

22 chapter 12

    statistical parsing

id35 supertaggers rely on treebanks such as id35bank to provide both the over-
all set of lexical categories as well as the allowable category assignments for each
word in the lexicon. id35bank includes over 1000 lexical categories, however, in
practice, most supertaggers limit their tagsets to those tags that occur at least 10
times in the training corpus. this results in an overall total of around 425 lexical
categories available for use in the lexicon. note that even this smaller number is
large in contrast to the 45 pos types used by the id32 tagset.

as with traditional part-of-speech tagging, the standard approach to building a
id35 supertagger is to use supervised machine learning to build a sequence classi-
   er using labeled training data. a common approach is to use the maximum id178
markov model (memm), as described in chapter 8, to    nd the most likely sequence
of tags given a sentence. the features in such a model consist of the current word
wi, its surrounding words within l words wi+l
i   l, as well as the k previously assigned
supertags ti   1
i   k . this type of model is summarized in the following equation from
chapter 8. training by maximizing log-likelihood of the training corpus and decod-
ing via the viterbi algorithm are the same as described in chapter 8.

p(t|w )

  t = argmax

t

= argmax

t

= argmax

t

(cid:89)
(cid:89)

i

i

p(ti|wi+l

i   l,ti   1
i   k )

(cid:32)(cid:88)
(cid:32)(cid:88)

i

exp

i

exp

(cid:88)

t(cid:48)   tagset

(cid:33)

(cid:33)

wi fi(ti,wi+l

i   l,ti   1
i   k )

wi fi(t(cid:48),wi+l

i   l,ti   1
i   k )

(12.35)

word and tag-based features with k and l both set to 2 provides reasonable results
given suf   cient training data. additional features such as pos tags and short char-
acter suf   xes are also commonly used to improve performance.

unfortunately, even with additional features the large number of possible su-
pertags combined with high per-word ambiguity leads to error rates that are too
high for practical use in a parser. more speci   cally, the single best tag sequence
  t will typically contain too many incorrect tags for effective parsing to take place.
to overcome this, we can instead return a id203 distribution over the possible
supertags for each word in the input. the following table illustrates an example dis-
tribution for a simple example sentence. in this table, each column represents the
id203 of each supertag for a given word in the context of the input sentence.
the    ...    represent all the remaining supertags possible for each word.

serves

united
denver
n/n: 0.4 (s\np)/np: 0.8 np: 0.9
np: 0.3
n/n: 0.05
s/s: 0.1
s\s: .05

n: 0.1

...

...

...

in a memm framework, the id203 of the optimal tag sequence de   ned in
eq. 12.35 is ef   ciently computed with a suitably modi   ed version of the viterbi
algorithm. however, since viterbi only    nds the single best tag sequence it doesn   t

12.7

    probabilistic id35 parsing

23

provide exactly what we need here; we need to know the id203 of each pos-
sible word/tag pair. the id203 of any given tag for a word is the sum of the
probabilities of all the supertag sequences that contain that tag at that location. a
table representing these values can be computed ef   ciently by using a version of the
forward-backward algorithm used for id48s.

the same result can also be achieved through the use of deep learning approaches
based on recurrent neural networks (id56s). recent efforts have demonstrated con-
siderable success with id56s as alternatives to id48-based methods. these ap-
proaches differ from traditional classi   er-based methods in the following ways:

    the use of vector-based word representations (embeddings) rather than word-

    input representations that span the entire sentence, as opposed to size-limited

based feature functions.

sliding windows.

    avoiding the use of high-level features, such as part of speech tags, since

errors in tag assignment can propagate to errors in supertags.

as with the forward-backward algorithm, id56-based methods can provide a prob-
ability distribution over the lexical categories for each word in the input.

12.7.4 id35 parsing using the a* algorithm
the a* algorithm is a heuristic search method that employs an agenda to    nd an
optimal solution. search states representing partial solutions are added to an agenda
based on a cost function, with the least-cost option being selected for further ex-
ploration at each iteration. when a state representing a complete solution is    rst
selected from the agenda, it is guaranteed to be optimal and the search terminates.

the a* cost function, f (n), is used to ef   ciently guide the search to a solution.
the f -cost has two components: g(n), the exact cost of the partial solution repre-
sented by the state n, and h(n) a heuristic approximation of the cost of a solution
that makes use of n. when h(n) satis   es the criteria of not overestimating the actual
cost, a* will    nd an optimal solution. not surprisingly, the closer the heuristic can
get to the actual cost, the more effective a* is at    nding a solution without having
to explore a signi   cant portion of the solution space.

when applied to parsing, search states correspond to edges representing com-
pleted constituents. as with the pcky algorithm, edges specify a constituent   s start
and end positions, its grammatical category, and its f -cost. here, the g component
represents the current cost of an edge and the h component represents an estimate
of the cost to complete a derivation that makes use of that edge. the use of a*
for phrase structure parsing originated with (klein and manning, 2003a), while the
id35 approach presented here is based on (lewis and steedman, 2014).

using information from a supertagger, an agenda and a parse table are initial-
ized with states representing all the possible lexical categories for each word in the
input, along with their f -costs. the main loop removes the lowest cost edge from
the agenda and tests to see if it is a complete derivation. if it re   ects a complete
derivation it is selected as the best solution and the loop terminates. otherwise, new
states based on the applicable id35 rules are generated, assigned costs, and entered
into the agenda to await further processing. the loop continues until a complete
derivation is discovered, or the agenda is exhausted, indicating a failed parse. the
algorithm is given in fig. 12.11.

24 chapter 12

    statistical parsing

function id35-astar-parse(words) returns table or failure

supertags    supertagger(words)
for i   from 1 to length(words) do

for all {a | (words[i], a, score)     supertags}

edge    makeedge(i    1, i, a, score)
table    insertedge(table, edge)
agenda    insertedge(agenda, edge)

loop do

if empty?(agenda) return failure
current    pop(agenda)
if completedparse?(current) return table
table    insertedge(chart, edge)
for each rule in applicablerules(edge) do
successor    apply(rule, edge)
if successor not     in agenda or chart
else if successor     agenda with higher cost

agenda    insertedge(agenda, successor)
agenda    replaceedge(agenda, successor)

figure 12.11 a*-based id35 parsing.

heuristic functions
before we can de   ne a heuristic function for our id67, we need to decide how
to assess the quality of id35 derivations. for the generic pid18 model, we de   ned
the id203 of a tree as the product of the id203 of the rules that made up
the tree. given id35   s lexical nature, we   ll make the simplifying assumption that the
id203 of a id35 derivation is just the product of the id203 of the supertags
assigned to the words in the derivation, ignoring the rules used in the derivation.
more formally, given a sentence s and derivation d that contains suptertag sequence
t , we have:

p(d,s) = p(t,s)

n(cid:89)

=

p(ti|si)

(12.36)

(12.37)

i=1

to better    t with the traditional a* approach, we   d prefer to have states scored
by a cost function where lower is better (i.e., we   re trying to minimize the cost of
a derivation). to achieve this, we   ll use negative log probabilities to score deriva-
tions; this results in the following equation, which we   ll use to score completed id35
derivations.

p(d,s) = p(t,s)

n(cid:88)

=

   logp(ti|si)

(12.38)

(12.39)

given this model, we can de   ne our f -cost as follows. the f -cost of an edge is
the sum of two components: g(n), the cost of the span represented by the edge, and

i=1

12.7

    probabilistic id35 parsing

25

h(n), the estimate of the cost to complete a derivation containing that edge (these
are often referred to as the inside and outside costs). we   ll de   ne g(n) for an edge
using equation 12.39. that is, it is just the sum of the costs of the supertags that
comprise the span.

for h(n), we need a score that approximates but never overestimates the actual
cost of the    nal derivation. a simple heuristic that meets this requirement assumes
that each of the words in the outside span will be assigned its most probable su-
pertag. if these are the tags used in the    nal derivation, then its score will equal
the heuristic. if any other tags are used in the    nal derivation the f -cost will be
higher since the new tags must have higher costs, thus guaranteeing that we will not
overestimate.

putting this all together, we arrive at the following de   nition of a suitable f -cost

for an edge.

f (wi, j,ti, j) = g(wi, j) + h(wi, j)

(12.40)

=

j(cid:88)
i   1(cid:88)

k=i

k=1

   logp(tk|wk) +

(   logp(t|wk)) +

max
t   tags

n(cid:88)

k= j+1

(   logp(t|wk))

max
t   tags

as an example, consider an edge representing the word serves with the supertag

n in the following example.
(12.41) united serves denver.

the g-cost for this edge is just the negative log id203 of the tag, or x. the
outside h-cost consists of the most optimistic supertag assignments for united and
denver. the resulting f -cost for this edge is therefore x+y+z = 1.494.

an example
fig. 12.12 shows the initial agenda and the progress of a complete parse for this
example. after initializing the agenda and the parse table with information from the
supertagger, it selects the best edge from the agenda     the entry for united with
the tag n/n and f -cost 0.591. this edge does not constitute a complete parse and is
therefore used to generate new states by applying all the relevant grammar rules. in
this case, applying forward application to united: n/n and serves: n results in the
creation of the edge united serves: n[0,2], 1.795 to the agenda.

skipping ahead, at the the third iteration an edge representing the complete
derivation united serves denver, s[0,3], .716 is added to the agenda. however,
the algorithm does not terminate at this point since the cost of this edge (.716) does
not place it at the top of the agenda. instead, the edge representing denver with the
category np is popped. this leads to the addition of another edge to the agenda
(type-raising denver). only after this edge is popped and dealt with does the ear-
lier state representing a complete derivation rise to the top of the agenda where it is
popped, goal tested, and returned as a solution.

the effectiveness of the a* approach is re   ected in the coloring of the states
in fig. 12.12 as well as the    nal parsing table. the edges shown in blue (includ-
ing all the initial lexical category assignments not explicitly shown) re   ect states in
the search space that never made it to the top of the agenda and, therefore, never

26 chapter 12

    statistical parsing

figure 12.12 example of an id67 for the example    united serves denver   . the circled numbers on the
white boxes indicate the order in which the states are popped from the agenda. the costs in each state are based
on f-costs using negative log10 probabilities.

contributed any edges to the    nal table. this is in contrast to the pcky approach
where the parser systematically    lls the parse table with all possible constituents for
all possible spans in the input,    lling the table with myriad constituents that do not
contribute to the    nal analysis.

united serves: n[0,2]1.795united: n/n.591denver: n/n2.494denver: n1.795serves: n1.494united: s\s1.494united: s/s1.1938united: np.716denver: np.591serves: (s\np)/np.591serves denver: s\np[1,3].591united serves denver: s[0,3].716denver: s/(s\np)[0,1].591123456initial agendagoal state   s: 0.716s/np: 0.591unitedserves[0,1][0,2][0,3][1,2][1,3][2,3]n/n: 0.591np: 0.716s/s: 1.1938s\s: 1.494   denver(s\np)/np: 0.591n: 1.494   np: 0.591n: 1.795n/n: 2.494   n: 1.79512.8 evaluating parsers

12.8

    evaluating parsers

27

the standard techniques for evaluating parsers and grammars are called the par-
seval measures; they were proposed by black et al. (1991) and were based on
the same ideas from signal-detection theory that we saw in earlier chapters. the
intuition of the parseval metric is to measure how much the constituents in the
hypothesis parse tree look like the constituents in a hand-labeled, gold-reference
parse. parseval thus assumes we have a human-labeled    gold standard    parse
tree for each sentence in the test set; we generally draw these gold-standard parses
from a treebank like the id32.

given these gold-standard reference parses for a test set, a given constituent in
a hypothesis parse ch of a sentence s is labeled    correct    if there is a constituent in
the reference parse cr with the same starting point, ending point, and non-terminal
symbol.

we can then measure the precision and recall just as we did for chunking in the

previous chapter.

labeled recall: =

# of correct constituents in hypothesis parse of s
# of correct constituents in reference parse of s

labeled precision: =

# of correct constituents in hypothesis parse of s
# of total constituents in hypothesis parse of s

f-measure

as with other uses of precision and recall, instead of reporting them separately,
we often report a single number, the f-measure (van rijsbergen, 1975): the f-
measure is de   ned as

f   =

(   2 + 1)pr
   2p + r

the    parameter differentially weights the importance of recall and precision,
based perhaps on the needs of an application. values of    > 1 favor recall and values
of    < 1 favor precision. when    = 1, precision and recall are equally balanced;
this is sometimes called f   =1 or just f1:

f1 =

2pr
p + r

(12.42)

the f-measure derives from a weighted harmonic mean of precision and recall.
remember that the harmonic mean of a set of numbers is the reciprocal of the arith-
metic mean of the reciprocals:

harmonicmean(a1,a2,a3,a4, ...,an) =

and hence the f-measure is

f =

1

p + (1      ) 1
   1

r

(cid:18)

or

with    2 =

1      
  

1
a1

+ 1
a2

(cid:19)

n
+ 1
a3

+ ... + 1
an

(12.43)

f =

(   2 + 1)pr
   2p + r

(12.44)

we additionally use a new metric, crossing brackets, for each sentence s:

cross-brackets: the number of constituents for which the reference parse has a
bracketing such as ((a b) c) but the hypothesis parse has a bracketing such
as (a (b c)).

28 chapter 12

    statistical parsing

evalb

as of the time of this writing, the performance of modern parsers that are trained
and tested on the wall street journal treebank was somewhat higher than 90% recall,
90% precision, and about 1% cross-bracketed constituents per sentence.

for comparing parsers that use different grammars, the parseval metric in-
cludes a canonicalization algorithm for removing information likely to be grammar-
speci   c (auxiliaries, pre-in   nitival    to   , etc.) and for computing a simpli   ed score
(black et al., 1991). the canonical implementation of the parseval metrics is
called evalb (sekine and collins, 1997).

nonetheless, phrasal constituents are not always an appropriate unit for parser
evaluation. in lexically-oriented grammars, such as id35 and lfg, the ultimate goal
is to extract the appropriate predicate-argument relations or grammatical dependen-
cies, rather than a speci   c derivation. such relations are also more directly relevant
to further semantic processing. for these purposes, we can use alternative evaluation
metrics based on measuring the precision and recall of labeled dependencies, where
the labels indicate the grammatical relations (lin 1995, carroll et al. 1998, collins
et al. 1999).

finally, you might wonder why we don   t evaluate parsers by measuring how
many sentences are parsed correctly instead of measuring component accuracy in
the form of constituents or dependencies. the reason we use components is that it
gives us a more    ne-grained metric. this is especially true for long sentences, where
most parsers don   t get a perfect parse. if we just measured sentence accuracy, we
wouldn   t be able to distinguish between a parse that got most of the parts wrong and
one that just got one part wrong.

12.9 human parsing

human
sentence
processing

reading time

are the kinds of probabilistic parsing models we have been discussing also used by
humans when they are parsing? the answer to this question lies in a    eld called
human sentence processing. recent studies suggest that there are at least two
ways in which humans apply probabilistic parsing algorithms, although there is still
disagreement on the details.

one family of studies has shown that when humans read, the predictability of a
word seems to in   uence the reading time; more predictable words are read more
quickly. one way of de   ning predictability is from simple bigram measures. for
example, scott and shillcock (2003) used an eye-tracker to monitor the gaze of
participants reading sentences. they constructed the sentences so that some would
have a verb-noun pair with a high bigram id203 (such as (12.45a)) and others
a verb-noun pair with a low bigram id203 (such as (12.45b)).
(12.45)

a) high prob: one way to avoid confusion is to make the changes

during vacation

b) low prob: one way to avoid discovery is to make the changes

during vacation

they found that the higher the bigram predictability of a word, the shorter the

time that participants looked at the word (the initial-   xation duration).

while this result provides evidence only for id165 probabilities, more recent
experiments have suggested that the id203 of an upcoming word given the
syntactic parse of the preceding sentence pre   x also predicts word reading time
(hale 2001, levy 2008).

12.9

    human parsing

29

garden-path

the second family of studies has examined how humans disambiguate sentences
that have multiple possible parses, suggesting that humans prefer whichever parse
is more probable. these studies often rely on a speci   c class of temporarily am-
biguous sentences called garden-path sentences. these sentences,    rst described
by bever (1970), are sentences that are cleverly constructed to have three properties
that combine to make them very dif   cult for people to parse:

1. they are temporarily ambiguous: the sentence is unambiguous, but its ini-

tial portion is ambiguous.

2. one of the two or more parses in the initial portion is somehow preferable to

the human parsing mechanism.

3. but the dispreferred parse is the correct one for the sentence.

the result of these three properties is that people are    led down the garden path   
toward the incorrect parse and then are confused when they realize it   s the wrong
one. sometimes this confusion is quite conscious, as in bever   s example (12.46);
in fact, this sentence is so hard to parse that readers often need to be shown the
correct structure. in the correct structure, raced is part of a reduced relative clause
modifying the horse, and means    the horse [which was raced past the barn] fell   ;
this structure is also present in the sentence    students taught by the berlitz method
do worse when they get to france   .

(12.46) the horse raced past the barn fell.

(a)

s

np

vp

det

n

v

pp

?

v

fell

(b)

s

np

np

vp

the

horse

raced

p

np

det

n

v

pp

vp

v

fell

past

det

n

the

horse

raced

p

np

the

barn

past

det

n

the

barn

other times, the confusion caused by a garden-path sentence is so subtle that it
can only be measured by a slight increase in reading time. thus, in (12.47) readers
often misparse the solution as the direct object of forgot rather than as the subject
of an embedded sentence. this misparse is subtle, and is only noticeable because
experimental participants take longer to read the word was than in control sentences.
this    mini garden path    effect at the word was suggests that subjects had chosen the
direct object parse and had to reanalyze or rearrange their parse now that they realize
they are in a sentential complement.

(12.47) the student forgot the solution was in the back of the book.

30 chapter 12

    statistical parsing

s

s

np

vp

np

vp

det

n

v

np

det

n

v

s

the

students

forgot

det

n

the

students

forgot

np

vp

the

solution

det

n

v

the

solution

was
while many factors seem to play a role in these preferences for a particular (in-
correct) parse, at least one factor seems to be syntactic probabilities, especially lex-
icalized (subcategorization) probabilities. for example, the id203 of the verb
forgot taking a direct object (vp     v np) is higher than the id203 of it taking a
sentential complement (vp     v s); this difference causes readers to expect a direct
object after forget and be surprised (longer reading times) when they encounter a
sentential complement. by contrast, a verb which prefers a sentential complement
(like hope) didn   t cause extra reading time at was. the garden path in (12.46) is at
least partially caused by the low id203 of the reduced relative clause construc-
tion.

12.10 summary

this chapter has sketched the basics of probabilistic parsing, concentrating on
id140 and probabilistic lexicalized context-free
grammars.

    probabilistic grammars assign a id203 to a sentence or string of words
while attempting to capture more sophisticated syntactic information than the
id165 grammars of chapter 3.

    a probabilistic

a

is

(pid18)

context-free grammar

context-free
grammar in which every rule is annotated with the id203 of that rule
being chosen. each pid18 rule is treated as if it were conditionally inde-
pendent; thus, the id203 of a sentence is computed by multiplying the
probabilities of each rule in the parse of the sentence.
    the probabilistic cky (cocke-kasami-younger) algorithm is a probabilistic
version of the cky parsing algorithm. there are also probabilistic versions
of other parsers like the earley algorithm.
    pid18 probabilities can be learned by counting in a parsed corpus or by pars-
ing a corpus. the inside-outside algorithm is a way of dealing with the fact
that the sentences being parsed are ambiguous.
    raw pid18s suffer from poor independence assumptions among rules and lack
    one way to deal with this problem is to split and merge non-terminals (auto-

of sensitivity to lexical dependencies.

matically or by hand).

bibliographical and historical notes

31

    probabilistic lexicalized id18s are another solution to this problem in which
the basic pid18 model is augmented with a lexical head for each rule. the
id203 of a rule can then be conditioned on the lexical head or nearby
heads.
    parsers for lexicalized pid18s (like the charniak and collins parsers) are
    parsers are evaluated with three metrics: labeled recall, labeled precision,
    evidence from garden-path sentences and other on-line sentence-processing
experiments suggest that the human parser uses some kinds of probabilistic
information about grammar.

based on extensions to probabilistic cky parsing.

and cross-brackets.

bibliographical and historical notes

many of the formal properties of id140 were    rst
worked out by booth (1969) and salomaa (1969). baker (1979) proposed the inside-
outside algorithm for unsupervised training of pid18 probabilities, and used a cky-
style parsing algorithm to compute inside probabilities. jelinek and lafferty (1991)
extended the cky algorithm to compute probabilities for pre   xes. stolcke (1995)
drew on both of these algorithms in adapting the earley algorithm to use with
pid18s.

a number of researchers starting in the early 1990s worked on adding lexical de-
pendencies to pid18s and on making pid18 rule probabilities more sensitive to sur-
rounding syntactic structure. for example, schabes et al. (1988) and schabes (1990)
presented early work on the use of heads. many papers on the use of lexical depen-
dencies were    rst presented at the darpa speech and natural language workshop
in june 1990. a paper by hindle and rooth (1990) applied lexical dependencies
to the problem of attaching prepositional phrases; in the question session to a later
paper, ken church suggested applying this method to full parsing (marcus, 1990).
early work on such probabilistic id18 parsing augmented with probabilistic depen-
dency information includes magerman and marcus (1991), black et al. (1992), bod
(1993), and jelinek et al. (1994), in addition to collins (1996), charniak (1997), and
collins (1999) discussed above. other recent pid18 parsing models include klein
and manning (2003a) and petrov et al. (2006).

this early lexical probabilistic work led initially to work focused on solving
speci   c parsing problems like preposition-phrase attachment by using methods in-
cluding transformation-based learning (tbl) (brill and resnik, 1994), maximum
id178 (ratnaparkhi et al., 1994), memory-based learning (zavrel and daelemans,
1997), id148 (franz, 1997), id90 that used semantic distance
between heads (computed from id138) (stetina and nagao, 1997), and boosting
(abney et al., 1999).

another direction extended the lexical probabilistic parsing work to build prob-
abilistic formulations of grammars other than pid18s, such as probabilistic tag
grammar (resnik 1992, schabes 1992), based on the tag grammars discussed in
chapter 10, probabilistic lr parsing (briscoe and carroll, 1993), and probabilistic
link grammar (lafferty et al., 1992). an approach to probabilistic parsing called
id55 extends the part-of-speech tagging metaphor to parsing by using very
complex tags that are, in fact, fragments of lexicalized parse trees (bangalore and

id55

32 chapter 12

    statistical parsing

joshi 1999, joshi and srinivas 1994), based on the lexicalized tag grammars of
schabes et al. (1988). for example, the noun purchase would have a different tag
as the    rst noun in a noun compound (where it might be on the left of a small tree
dominated by nominal) than as the second noun (where it might be on the right).

goodman (1997), abney (1997), and johnson et al. (1999) gave early discus-
sions of probabilistic treatments of feature-based grammars. other recent work
on building statistical models of feature-based grammar formalisms like hpsg and
lfg includes (riezler et al. 2002, kaplan et al. 2004), and toutanova et al. (2005).
we mentioned earlier that discriminative approaches to parsing fall into the two
broad categories of id145 methods and discriminative reranking
methods. recall that discriminative reranking approaches require n-best parses.
parsers based on id67 can easily be modi   ed to generate n-best lists just by
continuing the search past the    rst-best parse (roark, 2001). id145
algorithms like the ones described in this chapter can be modi   ed by the elimina-
tion of the id145 with heavy pruning (collins 2000, collins and
koo 2005, bikel 2004), or through new algorithms (jim  enez and marzal 2000,char-
niak and johnson 2005,huang and chiang 2005), some adapted from speech recog-
nition algorithms such as those of schwartz and chow (1990) (see section ??).

in id145 methods, instead of outputting and then reranking an
n-best list, the parses are represented compactly in a chart, and log-linear and other
methods are applied for decoding directly from the chart. such modern methods
include (johnson 2001, clark and curran 2004), and taskar et al. (2004). other
reranking developments include changing the optimization criterion (titov and hen-
derson, 2006).

collins    (1999) dissertation includes a very readable survey of the    eld and an
introduction to his parser. manning and sch  utze (1999) extensively cover proba-
bilistic parsing.

the    eld of grammar induction is closely related to statistical parsing, and a
parser is often used as part of a grammar induction algorithm. one of the earliest
statistical works in grammar induction was horning (1969), who showed that pid18s
could be induced without negative evidence. early modern probabilistic grammar
work showed that simply using em was insuf   cient (lari and young 1990, carroll
and charniak 1992). recent probabilistic work, such as yuret (1998), clark (2001),
klein and manning (2002), and klein and manning (2004), are summarized in klein
(2005) and adriaans and van zaanen (2004). work since that summary includes
smith and eisner (2005), haghighi and klein (2006), and smith and eisner (2007).

exercises

12.1 implement the cky algorithm.
12.2 modify the algorithm for conversion to cnf from chapter 11 to correctly
handle rule probabilities. make sure that the resulting cnf assigns the same
total id203 to each parse tree.

12.3 recall that exercise 13.3 asked you to update the cky algorithm to han-
dle unit productions directly rather than converting them to cnf. extend this
change to probabilistic cky.

12.4 fill out the rest of the probabilistic cky chart in fig. 12.4.

exercises

33

12.5 sketch how the cky algorithm would have to be augmented to handle lexi-

calized probabilities.

12.6 implement your lexicalized extension of the cky algorithm.
12.7 implement the parseval metrics described in section 12.8. next, either
use a treebank or create your own hand-checked parsed test set. now use your
id18 (or other) parser and grammar, parse the test set and compute labeled
recall, labeled precision, and cross-brackets.

34 chapter 12     statistical parsing

abney, s. p. (1997). stochastic attribute-value grammars.

computational linguistics, 23(4), 597   618.

abney, s. p., schapire, r. e., and singer, y. (1999). boosting
applied to tagging and pp attachment. in emnlp/vlc-99,
college park, md, pp. 38   45.

adriaans, p. and van zaanen, m. (2004). computational
grammar induction for linguists. grammars; special issue
with the theme    grammar induction   , 7, 57   68.

baker, j. k. (1979). trainable grammars for speech recog-
nition. in klatt, d. h. and wolf, j. j. (eds.), speech com-
munication papers for the 97th meeting of the acoustical
society of america, pp. 547   550.

bangalore, s. and joshi, a. k. (1999). id55: an
approach to almost parsing. computational linguistics,
25(2), 237   265.

bever, t. g. (1970). the cognitive basis for linguistic struc-
tures. in hayes, j. r. (ed.), cognition and the development
of language, pp. 279   352. wiley.

bikel, d. m. (2004). intricacies of collins    parsing model.

computational linguistics, 30(4), 479   511.

bikel, d. m., miller, s., schwartz, r., and weischedel,
r. (1997). nymble: a high-performance learning name-
   nder. in anlp 1997, pp. 194   201.

black, e., abney, s. p., flickinger, d., gdaniec, c., grish-
man, r., harrison, p., hindle, d., ingria, r., jelinek, f.,
klavans, j. l., liberman, m. y., marcus, m. p., roukos,
s., santorini, b., and strzalkowski, t. (1991). a procedure
for quantitatively comparing the syntactic coverage of en-
glish grammars. in proceedings darpa speech and natu-
ral language workshop, paci   c grove, ca, pp. 306   311.
black, e., jelinek, f., lafferty, j. d., magerman, d. m.,
mercer, r. l., and roukos, s. (1992). towards history-
based grammars: using richer models for probabilistic
parsing. in proceedings darpa speech and natural lan-
guage workshop, harriman, ny, pp. 134   139.

bod, r. (1993). using an annotated corpus as a stochastic

grammar. in eacl-93, pp. 37   44.

booth, t. l. (1969). probabilistic representation of formal
languages. in ieee conference record of the 1969 tenth
annual symposium on switching and automata theory, pp.
74   81.

booth, t. l. and thompson, r. a. (1973). applying prob-
ability measures to abstract languages. ieee transactions
on computers, c-22(5), 442   450.

bresnan, j. (ed.). (1982). the mental representation of

grammatical relations. mit press.

brill, e. and resnik, p. (1994). a rule-based approach
in

to prepositional phrase attachment disambiguation.
coling-94, kyoto, pp. 1198   1204.

briscoe, t. and carroll, j. (1993). generalized probabilistic
lr parsing of natural language (corpora) with uni   cation-
based grammars. computational linguistics, 19(1), 25   59.
carroll, g. and charniak, e. (1992). two experiments on
learning probabilistic dependency grammars from corpora.
tech. rep. cs-92-16, brown university.

carroll, j., briscoe, t., and san   lippo, a. (1998). parser
in lrec-98,

evaluation: a survey and a new proposal.
granada, spain, pp. 447   454.

charniak, e. (1997). statistical parsing with a context-free
in aaai-97, pp. 598   603.

grammar and word statistics.
aaai press.

charniak, e. and johnson, m. (2005). coarse-to-   ne n-best
parsing and maxent discriminative reranking. in acl-05,
ann arbor.

chelba, c. and jelinek, f. (2000). structured language mod-

eling. computer speech and language, 14, 283   332.

clark, a. (2001). the unsupervised induction of stochastic
in

context-free grammars using distributional id91.
conll-01.

clark, s. and curran, j. r. (2004). parsing the wsj using

id35 and id148. in acl-04, pp. 104   111.

collins, m. (1996). a new statistical parser based on bi-
in acl-96, santa cruz, ca,

gram lexical dependencies.
pp. 184   191.

collins, m. (1999). head-driven statistical models for nat-
ural language parsing. ph.d. thesis, university of penn-
sylvania, philadelphia.

collins, m. (2000). discriminative reranking for natural lan-
guage parsing. in icml 2000, stanford, ca, pp. 175   182.
collins, m. (2003). head-driven statistical models for nat-
ural language parsing. computational linguistics, 29(4),
589   637.

collins, m., haji  c, j., ramshaw, l. a., and tillmann, c.
(1999). a statistical parser for czech. in acl-99, college
park, ma, pp. 505   512.

collins, m. and koo, t. (2005). discriminative reranking
for natural language parsing. computational linguistics,
31(1), 25   69.

francis, h. s., gregory, m. l., and michaelis, l. a. (1999).
in cls-99. university of

are lexical subjects deviant?.
chicago.

franz, a. (1997).

independence assumptions considered

harmful. in acl/eacl-97, madrid, spain, pp. 182   189.

giv  on, t. (1990). syntax: a functional typological intro-

duction. john benjamins.

goodman, j. (1997). probabilistic feature grammars.

iwpt-97.

in

haghighi, a. and klein, d. (2006). prototype-driven gram-

mar induction. in coling/acl 2006, pp. 881   888.

hale, j. (2001). a probabilistic earley parser as a psycholin-

guistic model. in naacl 2001, pp. 159   166.

hindle, d. and rooth, m. (1990). structural ambiguity and
lexical relations. in proceedings darpa speech and natu-
ral language workshop, hidden valley, pa, pp. 257   262.
hindle, d. and rooth, m. (1991). structural ambiguity and

lexical relations. in acl-91, berkeley, ca, pp. 229   236.

horning, j. j. (1969). a study of grammatical id136.

ph.d. thesis, stanford university.

huang, l. and chiang, d. (2005). better k-best parsing. in

iwpt-05, pp. 53   64.

jelinek, f. and lafferty, j. d. (1991). computation of
the id203 of initial substring generation by stochastic
context-free grammars. computational linguistics, 17(3),
315   323.

jelinek, f., lafferty, j. d., magerman, d. m., mercer, r. l.,
ratnaparkhi, a., and roukos, s. (1994). decision tree pars-
ing using a hidden derivation model. in arpa human lan-
guage technologies workshop, plainsboro, n.j., pp. 272   
277.

jim  enez, v. m. and marzal, a. (2000). computation of the
n best parse trees for weighted and stochastic context-free
grammars. in advances in pattern recognition: proceed-
ings of the joint iapr international workshops, sspr 2000
and spr 2000, alicante, spain, pp. 183   192. springer.

johnson, m. (1998). pid18 models of linguistic tree repre-

sentations. computational linguistics, 24(4), 613   632.

johnson, m. (2001). joint and conditional estimation of tag-

ging and parsing models. in acl-01, pp. 314   321.

johnson, m., geman, s., canon, s., chi, z., and riezler, s.
(1999). estimators for stochastic    uni   cation-based    gram-
mars. in acl-99, pp. 535   541.

joshi, a. k. (1985). id34s: how much
context-sensitivity is required to provide reasonable struc-
tural descriptions?.
in dowty, d. r., karttunen, l., and
zwicky, a. (eds.), natural language parsing, pp. 206   
250. cambridge university press.

joshi, a. k. and srinivas, b. (1994). disambiguation of
in

super parts of speech (or supertags): almost parsing.
coling-94, kyoto, pp. 154   160.

kaplan, r. m., riezler, s., king, t. h., maxwell iii, j. t.,
vasserman, a., and crouch, r. (2004). speed and accuracy
in shallow and deep stochastic parsing. in hlt-naacl-04.
klein, d. (2005). the unsupervised learning of natural

language structure. ph.d. thesis, stanford university.

klein, d. and manning, c. d. (2001). parsing and hyper-

graphs. in iwpt-01, pp. 123   134.

klein, d. and manning, c. d. (2002). a generative
constituent-context model for improved grammar induc-
tion. in acl-02.

klein, d. and manning, c. d. (2003a). a* parsing: fast

exact viterbi parse selection. in hlt-naacl-03.

klein, d. and manning, c. d. (2003b). accurate unlexical-

ized parsing. in hlt-naacl-03.

klein, d. and manning, c. d. (2004). corpus-based induc-
tion of syntactic structure: models of dependency and con-
stituency. in acl-04, pp. 479   486.

lafferty, j. d., sleator, d., and temperley, d. (1992). gram-
matical trigrams: a probabilistic model of link grammar.
in proceedings of the 1992 aaai fall symposium on prob-
abilistic approaches to natural language.

lari, k. and young, s. j. (1990). the estimation of stochastic
context-free grammars using the inside-outside algorithm.
computer speech and language, 4, 35   56.

levy, r. (2008). expectation-based syntactic comprehen-

sion. cognition, 106(3), 1126   1177.

lewis, m. and steedman, m. (2014). a* id35 parsing with a

supertag-factored model.. in emnlp, pp. 990   1000.

lin, d. (1995). a dependency-based method for evaluating
broad-coverage parsers. in ijcai-95, montreal, pp. 1420   
1425.

magerman, d. m. and marcus, m. p. (1991). pearl: a prob-

abilistic chart parser. in eacl-91, berlin.

exercises

35

manning, c. d. and sch  utze, h. (1999). foundations of sta-

tistical natural language processing. mit press.

marcus, m. p. (1990). summary of session 9: automatic
acquisition of linguistic structure. in proceedings darpa
speech and natural language workshop, hidden valley,
pa, pp. 249   250.

marcus, m. p., santorini, b., and marcinkiewicz, m. a.
(1993). building a large annotated corpus of english: the
id32. computational linguistics, 19(2), 313   
330.

ney, h. (1991). id145 parsing for context-
ieee

free grammars in continuous id103.
transactions on signal processing, 39(2), 336   340.

petrov, s., barrett, l., thibaux, r., and klein, d. (2006).
learning accurate, compact, and interpretable tree annota-
tion. in coling/acl 2006, sydney, australia, pp. 433   
440.

pollard, c. and sag, i. a. (1994). head-driven phrase struc-

ture grammar. university of chicago press.

ratnaparkhi, a. (1996). a maximum id178 part-of-speech

tagger. in emnlp 1996, philadelphia, pa, pp. 133   142.

ratnaparkhi, a., reynar, j. c., and roukos, s. (1994). a
maximum id178 model for prepositional phrase attach-
ment. in arpa human language technologies workshop,
plainsboro, n.j., pp. 250   255.

resnik, p. (1992). probabilistic tree-adjoining grammar as
a framework for statistical natural language processing. in
coling-92, nantes, france, pp. 418   424.

riezler, s., king, t. h., kaplan, r. m., crouch, r.,
maxwell iii, j. t., and johnson, m. (2002).
parsing
the wall street journal using a lexical-functional gram-
mar and discriminative estimation techniques. in acl-02,
philadelphia, pa.

roark, b. (2001). probabilistic top-down parsing and lan-
guage modeling. computational linguistics, 27(2), 249   
276.

salomaa, a. (1969). probabilistic and weighted grammars.

information and control, 15, 529   544.

schabes, y. (1990). mathematical and computational as-
pects of lexicalized grammars. ph.d. thesis, university of
pennsylvania, philadelphia, pa.

schabes, y. (1992). stochastic lexicalized tree-adjoining
grammars. in coling-92, nantes, france, pp. 426   433.
schabes, y., abeill  e, a., and joshi, a. k. (1988). pars-
ing strategies with    lexicalized    grammars: applications to
id34s. in coling-88, budapest, pp.
578   583.

schwartz, r. and chow, y.-l. (1990). the n-best algorithm:
an ef   cient and exact procedure for    nding the n most
likely sentence hypotheses. in icassp-90, vol. 1, pp. 81   
84.

scott, m. and shillcock, r. (2003). eye movements re-
veal the on-line computation of lexical probabilities during
reading. psychological science, 14(6), 648   652.

sekine, s. and collins, m.

the evalb
http://cs.nyu.edu/cs/projects/

(1997).

software.
proteus/evalb.

smith, d. a. and eisner,

j.

(2007).

feature-rich dependency parsers with entropic priors.
emnlp/conll 2007, prague, pp. 667   677.

id64
in

36 chapter 12     statistical parsing

smith, n. a. and eisner, j. (2005). guiding unsupervised
grammar induction using contrastive estimation. in ijcai
workshop on grammatical id136 applications, edin-
burgh, pp. 73   82.

stetina, j. and nagao, m. (1997). corpus based pp attach-
ment ambiguity resolution with a semantic dictionary. in
zhou, j. and church, k. w. (eds.), proceedings of the fifth
workshop on very large corpora, beijing, china, pp. 66   
80.

stolcke, a. (1995). an ef   cient probabilistic context-free
parsing algorithm that computes pre   x probabilities. com-
putational linguistics, 21(2), 165   202.

taskar, b., klein, d., collins, m., koller, d., and manning,
c. d. (2004). max-margin parsing. in emnlp 2004, pp.
1   8.

titov, i. and henderson, j. (2006). loss minimization in

parse reranking. in emnlp 2006.

toutanova, k., manning, c. d., flickinger, d., and oepen,
s. (2005). stochastic hpsg parse disambiguation using
the redwoods corpus. research on language & compu-
tation, 3(1), 83   105.

van rijsbergen, c. j. (1975). information retrieval. butter-

worths.

witten, i. h. and bell, t. c. (1991). the zero-frequency
problem: estimating the probabilities of novel events in
adaptive text compression. ieee transactions on informa-
tion theory, 37(4), 1085   1094.

yuret, d. (1998). discovery of linguistic relations using

lexical attraction. ph.d. thesis, mit.

zavrel, j. and daelemans, w. (1997). memory-based learn-
in acl/eacl-97,

ing: using similarity for smoothing.
madrid, spain, pp. 436   443.

