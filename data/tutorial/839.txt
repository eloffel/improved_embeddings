advanced id145 in cl:

theory,  algorithms,  and applications

(s, 0, n)

w0  w1           ...           wn-1 

liang huang

university of pennsylvania

a little bit of history...

liang huang (penn)

2

id145

a little bit of history...

    who invented id145? 

and when was it invented?

liang huang (penn)

2

id145

a little bit of history...

and when was it invented?

    who invented id145? 
    r. bellman (1940s-50s)
    a. viterbi (1967)
    e. dijkstra (1959)
    hart, nilsson, and raphael (1968)
    dijkstra => a* algorithm
    d. knuth (1977)
    dijkstra on grammar (hypergraph)

liang huang (penn)

2

richard bellman

andrew viterbi
id145

a little bit of history...

and when was it invented?

    who invented id145? 
    r. bellman (1940s-50s)
    a. viterbi (1967)
    e. dijkstra (1959)
    hart, nilsson, and raphael (1968)
    dijkstra => a* algorithm
    d. knuth (1977)
    dijkstra on grammar (hypergraph)

a. turing

liang huang (penn)

2

richard bellman

andrew viterbi
id145

id145
    id145 is everywhere in nlp
    viterbi algorithm for id48
    cky algorithm for parsing and machine translation
    forward-backward and inside-outside algorithms
    also everywhere in ai/ml
    id23, planning (pomdp)
    ai search: uniform-cost, a*, etc.
    this tutorial:   a uni   ed theoretical view of dp
    focusing on optimization problems

liang huang (penn)

3

id145

review: dp basics

    dp = divide-and-conquer + two principles:
    [required] optimal subproblem property
    [recommended] sharing of common subproblems
    structure of the search space
    incremental
    graph
    knapsack, edit dist., sequence alignment
    branching
    hypergraph
    matrix-chain, polygon triangulation, optimal bst

liang huang (penn)

4

id145

two dimensional survey
traversing order

topological

(acyclic)

best-   rst
(superior)

graphs with 
semirings

viterbi

dijkstra

hypergraphs with 
weight functions

generalized 

viterbi

knuth

e
c
a
p
s
 
h
c
r
a
e
s

liang huang (penn)

5

id145

graphs in nlp

part-of-speech tagging

lattice in speech

liang huang (penn)

6

id145

semirings on graphs
    in a weighted graph, we need two operators:
    extension (multiplicative) and summary (additive)
    the weight of a path is the product of edge weights
    the weight of a vertex is the summary of path weights

d(  1) = !

w(ei) = w(e1)     w(e2)     w(e3)

e1

u

s

liang huang (penn)

ei     1

e3

e2

...

v

...

7

t

d(t) = !

w(  i)

  i

= w(p1)     w(p2)             

id145

semiring de   nitions

a monoid is a triple (a,    , 1) where

1.     is a closed associative binary operator on the set a,

2. 1 is the identity element for    , i.e., for all a     a, a     1 = 1     a = a.

a monoid is commutative if     is commutative.

liang huang (penn)

8

id145

semiring de   nitions

a monoid is a triple (a,    , 1) where

1.     is a closed associative binary operator on the set a,

2. 1 is the identity element for    , i.e., for all a     a, a     1 = 1     a = a.

a monoid is commutative if     is commutative.

([0, 1], +, 0)
([0, 1],   , 1)
([0, 1], max, 0)

liang huang (penn)

8

id145

semiring de   nitions

a monoid is a triple (a,    , 1) where

1.     is a closed associative binary operator on the set a,

2. 1 is the identity element for    , i.e., for all a     a, a     1 = 1     a = a.

a monoid is commutative if     is commutative.

a semiring is a 5-tuple r = (a,    ,    , 0, 1) such that

([0, 1], +, 0)
([0, 1],   , 1)
([0, 1], max, 0)

1. (a,    , 0) is a commutative monoid.

2. (a,    , 1) is a monoid.

3.     distributes over    : for all a, b, c in a,

(a     b)     c = (a     c)     (b     c),

c     (a     b) = (c     a)     (c     b).

4. 0 is an annihilator for    : for all a in a, 0     a = a     0 = 0.

liang huang (penn)

8

id145

semiring de   nitions

a monoid is a triple (a,    , 1) where

1.     is a closed associative binary operator on the set a,

2. 1 is the identity element for    , i.e., for all a     a, a     1 = 1     a = a.

a monoid is commutative if     is commutative.

a semiring is a 5-tuple r = (a,    ,    , 0, 1) such that

([0, 1], +, 0)
([0, 1],   , 1)
([0, 1], max, 0)

1. (a,    , 0) is a commutative monoid.

2. (a,    , 1) is a monoid.

3.     distributes over    : for all a, b, c in a,

(a     b)     c = (a     c)     (b     c),

c     (a     b) = (c     a)     (c     b).

([0, 1], max,   , 0, 1)
([0, 1], +,   , 0, 1)

4. 0 is an annihilator for    : for all a in a, 0     a = a     0 = 0.

liang huang (penn)

8

id145

semiring de   nitions

a monoid is a triple (a,    , 1) where

1.     is a closed associative binary operator on the set a,

2. 1 is the identity element for    , i.e., for all a     a, a     1 = 1     a = a.

a monoid is commutative if     is commutative.

a semiring is a 5-tuple r = (a,    ,    , 0, 1) such that

([0, 1], +, 0)
([0, 1],   , 1)
([0, 1], max, 0)

1. (a,    , 0) is a commutative monoid.

2. (a,    , 1) is a monoid.

3.     distributes over    : for all a, b, c in a,

(a     b)     c = (a     c)     (b     c),

c     (a     b) = (c     a)     (c     b).

([0, 1], max,   , 0, 1)
([0, 1], +,   , 0, 1)

4. 0 is an annihilator for    : for all a in a, 0     a = a     0 = 0.

liang huang (penn)

8

id145

examples

semiring
boolean

set
{0, 1}

   
   

   
   

viterbi

[0, 1]

max   

inside

r+    { +   }

+

  

0
0

0

0

1
1

1

1

intuition/application
logical deduction, recognition

prob. of the best derivation

prob. of a string

real

r    { +   } min + +    0

shortest-distance

tropical

r+    { +   } min + +    0

with non-negative weights

counting

n

+

  

0

1

number of paths

liang huang (penn)

9

id145

ordering

liang huang (penn)

10

id145

ordering

    idempotent

a semiring (a,    ,    , 0, 1) is idempotent if for all a in a, a     a = a.

liang huang (penn)

10

id145

ordering

a semiring (a,    ,    , 0, 1) is idempotent if for all a in a, a     a = a.

    idempotent
    comparison
    examples: boolean, viterbi, tropical, real, ...

(a     b)     (a     b = a) de   nes a partial ordering.

({0, 1},    ,    , 0, 1)

(r+    { +   },

min

, +, +   , 0)

([0, 1], max,    , 0, 1)

(r    { +   },

min

, +, +   , 0)

liang huang (penn)

10

id145

ordering

a semiring (a,    ,    , 0, 1) is idempotent if for all a in a, a     a = a.

    idempotent
    comparison
    examples: boolean, viterbi, tropical, real, ...

(a     b)     (a     b = a) de   nes a partial ordering.

({0, 1},    ,    , 0, 1)

(r+    { +   },

min

, +, +   , 0)

([0, 1], max,    , 0, 1)

(r    { +   },

min

, +, +   , 0)

    total-order for optimization problems
    examples: all of the above

a semiring is totally-ordered if     de   nes a total ordering.

liang huang (penn)

10

id145

monotonicity

liang huang (penn)

11

id145

monotonicity

    monotonicity

liang huang (penn)

11

id145

monotonicity

    monotonicity

let k = (a,    ,    , 0, 1) be a semiring, and     a partial ordering over a.

we say k is monotonic if for all a, b, c     a

(a     b)     (a     c     b     c)

(a     b)     (c     a     c     b)

liang huang (penn)

11

id145

monotonicity

    monotonicity

let k = (a,    ,    , 0, 1) be a semiring, and     a partial ordering over a.

we say k is monotonic if for all a, b, c     a

(a     b)     (a     c     b     c)

(a     b)     (c     a     c     b)

    optimal substructure in id145

liang huang (penn)

11

id145

monotonicity

    monotonicity

let k = (a,    ,    , 0, 1) be a semiring, and     a partial ordering over a.

we say k is monotonic if for all a, b, c     a

(a     b)     (a     c     b     c)

(a     b)     (c     a     c     b)

    optimal substructure in id145

a: b     c

b: b

c: c

liang huang (penn)

11

id145

monotonicity

    monotonicity

let k = (a,    ,    , 0, 1) be a semiring, and     a partial ordering over a.

we say k is monotonic if for all a, b, c     a

(a     b)     (a     c     b     c)

(a     b)     (c     a     c     b)

    optimal substructure in id145

a: b     c

b: b

c: c

a: b        c
    b     c 

b: b        b

c: c

liang huang (penn)

11

id145

monotonicity

    monotonicity

let k = (a,    ,    , 0, 1) be a semiring, and     a partial ordering over a.

we say k is monotonic if for all a, b, c     a

(a     b)     (a     c     b     c)

(a     b)     (c     a     c     b)

    optimal substructure in id145

a: b     c

b: b

c: c

a: b        c
    b     c 

b: b        b

c: c

    idempotent => monotone (from distributivity)

liang huang (penn)

11

id145

monotonicity

    monotonicity

let k = (a,    ,    , 0, 1) be a semiring, and     a partial ordering over a.

we say k is monotonic if for all a, b, c     a

(a     b)     (a     c     b     c)

(a     b)     (c     a     c     b)

    optimal substructure in id145

a: b     c

b: b

c: c

a: b        c
    b     c 

b: b        b

c: c

    idempotent => monotone (from distributivity)
    (a+b)   c = (a   c)+(b   c);  if a   b,  (a   c)=(a   c)+(b   c)

liang huang (penn)

11

id145

monotonicity

    monotonicity

let k = (a,    ,    , 0, 1) be a semiring, and     a partial ordering over a.

we say k is monotonic if for all a, b, c     a

(a     b)     (a     c     b     c)

(a     b)     (c     a     c     b)

    optimal substructure in id145

a: b     c

b: b

c: c

a: b        c
    b     c 

b: b        b

c: c

    idempotent => monotone (from distributivity)
    (a+b)   c = (a   c)+(b   c);  if a   b,  (a   c)=(a   c)+(b   c)
    by def. of comparison,   a   c     b   c

id145

11

liang huang (penn)

dp on graphs

    optimization problems on graphs
=> generic shortest-path problem
    weighted directed graph g=(v, e) with a function w 
that assigns each edge a weight from a semiring
    compute the best weight of the target vertex t
    generic update along edge (u, v)

d(v)     = d(u)     w(u, v)

u

w(u, v)

v

    how to avoid cyclic updates?
    only update when d(u) is    xed

d(v)     d(v)     (d(u)     w(u, v))

liang huang (penn)

12

id145

two dimensional survey
traversing order

topological

(acyclic)

best-   rst
(superior)

viterbi

dijkstra

generalized 

viterbi

knuth

e
c
a
p
s
 
h
c
r
a
e
s

graphs with 
semirings
(e.g., id122s)

hypergraphs with 
weight functions

(e.g., id18s)

liang huang (penn)

13

id145

viterbi algorithm for dags

1. topological sort
2. visit each vertex v in sorted order and do updates
    for each incoming edge (u, v) in e
    use d(u) to update d(v):
    key observation: d(u) is    xed to optimal at this time

d(v)     = d(u)     w(u, v)

u

w(u, v)

v

    time complexity: o( v + e )

liang huang (penn)

14

id145

variant 1: forward-update

1. topological sort
2. visit each vertex v in sorted order and do updates
    for each outgoing edge (v, u) in e
    use d(v) to update d(u):
    key observation: d(v) is    xed to optimal at this time

d(u)     = d(v)     w(v, u)

w(v, u)

u

v

    time complexity: o( v + e )

liang huang (penn)

15

id145

examples

liang huang (penn)

16

id145

examples

    [number of paths in a dag]

liang huang (penn)

16

id145

examples

    [number of paths in a dag]
    just use the counting semiring (n, +,   , 0, 1)
    note: this is not an optimization problem!

liang huang (penn)

16

id145

examples

    [number of paths in a dag]
    just use the counting semiring (n, +,   , 0, 1)
    note: this is not an optimization problem!
    [longest path in a dag] 

liang huang (penn)

16

id145

examples

    [number of paths in a dag]
    just use the counting semiring (n, +,   , 0, 1)
    note: this is not an optimization problem!
    [longest path in a dag] 
    just use the semiring 

(r     {      }, max, +,       , 0)

liang huang (penn)

16

id145

examples

    [number of paths in a dag]
    just use the counting semiring (n, +,   , 0, 1)
    note: this is not an optimization problem!
    [longest path in a dag] 
    just use the semiring 
    [part-of-speech tagging with a hidden markov model]

(r     {      }, max, +,       , 0)

liang huang (penn)

16

id145

examples

    [number of paths in a dag]
    just use the counting semiring (n, +,   , 0, 1)
    note: this is not an optimization problem!
    [longest path in a dag] 
    just use the semiring 
    [part-of-speech tagging with a hidden markov model]

(r     {      }, max, +,       , 0)

liang huang (penn)

16

id145

example: speech alignment

time complexity: 

o(n2)

also used in:
id153

biological sequence 

alignment

liang huang (penn)

17

id145

example: word alignment

i

love you

.

je

t   

aime

.

i-1

i

k

j

    key difference
    reorderings in translation!
    sequence/speech alignment 
is always monotonic
    complexity under id48
    word alignment is o(n3)
    for every (i, j)

    enumerate all (i-1, k)

    sequence alignment o(n2)

liang huang (penn)

18

id145

chinese id40

                                 

   xia  yu  tian  di  mian  ji  shui  

liang huang (penn)

19

id145

chinese id40

      
min-zhu

    people-dominate
    democracy   

                                 

   xia  yu  tian  di  mian  ji  shui  

liang huang (penn)

19

id145

chinese id40

      
min-zhu

    people-dominate
    democracy   

                    
jiang-ze-min   zhu-xi

               ... - ... - people   dominate-podium

             president   jiang zemin   

                                 

   xia  yu  tian  di  mian  ji  shui  

liang huang (penn)

19

id145

chinese id40

      
min-zhu

    people-dominate
    democracy   

                    
jiang-ze-min   zhu-xi

this was 5 years ago.

               ... - ... - people   dominate-podium

now google is

             president   jiang zemin   

good at segmentation!

                                 

   xia  yu  tian  di  mian  ji  shui  

liang huang (penn)

19

id145

chinese id40

      
min-zhu

    people-dominate
    democracy   

                    
jiang-ze-min   zhu-xi

this was 5 years ago.

               ... - ... - people   dominate-podium

now google is

             president   jiang zemin   

good at segmentation!

                                 

   xia  yu  tian  di  mian  ji  shui  

liang huang (penn)

19

id145

chinese id40

      
min-zhu

    people-dominate
    democracy   

                    
jiang-ze-min   zhu-xi

this was 5 years ago.

               ... - ... - people   dominate-podium

now google is

             president   jiang zemin   

good at segmentation!

                                 

   xia  yu  tian  di  mian  ji  shui  

liang huang (penn)

19

id145

graph search

phrase-based decoding

             
yu shalong

                     
juxing le huitan

held a talk

with sharon

with

sharon held

talks

with sharon
yu   shalong   juxing  le   huitan

held a talk

huang and chiang

forest rescoring

20

phrase-based decoding

             
yu shalong

                     
juxing le huitan

held a talk

with sharon

_ _ _ _ _

with

sharon held

talks

with sharon
yu   shalong   juxing  le   huitan

held a talk

huang and chiang

forest rescoring

20

phrase-based decoding

             
yu shalong

                     
juxing le huitan

held a talk

with sharon

_ _ _ _ _

_ _         

with

sharon held

talks

with sharon
yu   shalong   juxing  le   huitan

held a talk

huang and chiang

forest rescoring

20

phrase-based decoding

             
yu shalong

                     
juxing le huitan

held a talk

with sharon

_ _ _ _ _

_ _         

               

with

sharon held

talks

with sharon
yu   shalong   juxing  le   huitan

held a talk

huang and chiang

forest rescoring

20

phrase-based decoding

             
yu shalong

                     
juxing le huitan

held a talk

with sharon

_ _ _ _ _

_ _         

with

sharon held

talks

with sharon
yu   shalong   juxing  le   huitan

held a talk

huang and chiang

forest rescoring

21

               phrase-based decoding

             
yu shalong

                     
juxing le huitan

held a talk

with sharon

_ _ _ _ _

_ _         

   _         

with

sharon held

talks

with sharon
yu   shalong   juxing  le   huitan

held a talk

huang and chiang

forest rescoring

21

               phrase-based decoding

             
yu shalong

                     
juxing le huitan

source-side: coverage vector

_ _         
held a talk

held a talk

with sharon

target-side: grow hypotheses
               strictly left-to-right

_ _ _ _ _

...

_ _         
held a talk

...

...

               

held a talk with sharon

...

space: o(2n), time: o(2n n2) -- cf. traveling salesman problem
forest rescoring

huang and chiang

22

traveling salesman problem & mt
    a classical np-hard problem
    goal: visit each city once and only once
    exponential-time id145
    state: cities visited so far (bit-vector)
    search in this o(2n) transformed graph
    mt: each city is a source-language word
    restrictions in reordering can reduce 
    => syntax-based mt

complexity => distortion limit

huang and chiang

(held and karp, 1962; knight, 1999)

forest rescoring

23

traveling salesman problem & mt
    a classical np-hard problem
    goal: visit each city once and only once
    exponential-time id145
    state: cities visited so far (bit-vector)
    search in this o(2n) transformed graph
    mt: each city is a source-language word
    restrictions in reordering can reduce 
    => syntax-based mt

complexity => distortion limit

huang and chiang

(held and karp, 1962; knight, 1999)

forest rescoring

23

adding a bigram model

       re   ned    graph: annotated with language model words
    still id145, just larger search space
                 ... shalong
                 ... sharon

_ _                          

_ _             ... meeting

... talk

_ _ _ _ _

_ _                       
... talks

huang and chiang

forest rescoring

24

adding a bigram model

       re   ned    graph: annotated with language model words
    still id145, just larger search space
                 ... shalong
                 ... sharon

_ _                          

_ _             ... meeting

with   sharon

... talk

_ _ _ _ _

_ _                       
... talks

huang and chiang

forest rescoring

24

adding a bigram model

       re   ned    graph: annotated with language model words
    still id145, just larger search space
                 ... shalong
                 ... sharon

_ _                          

_ _             ... meeting

with   sharon

... talk

_ _ _ _ _

bigram

_ _                       
... talks

huang and chiang

forest rescoring

24

adding a bigram model

       re   ned    graph: annotated with language model words
    still id145, just larger search space
                 ... shalong
                 ... sharon

_ _                          

_ _             ... meeting

with   sharon

... talk

_ _ _ _ _

bigram

_ _                       
... talks

   space: o(2n),        time: o(2n n2) 

 =>  space: o(2n vm-1),  time: o(2n vm-1 n2)

huang and chiang

for m-gram language models

forest rescoring

24

two dimensional survey
traversing order

topological

(acyclic)

best-   rst
(superior)

viterbi

dijkstra

generalized 

viterbi

knuth

e
c
a
p
s
 
h
c
r
a
e
s

graphs with 
semirings
(e.g., id122s)

hypergraphs with 
weight functions

(e.g., id18s)

liang huang (penn)

25

id145

dijkstra algorithm

d(u)

w(e)

liang huang (penn)

d(u)     w(e)

26

id145

dijkstra algorithm

    dijkstra does not require acyclicity
    instead of topological order, we use best-   rst order
    but this requires superiority of the semiring

let k = (a,    ,    , 0, 1) be a semiring, and     a partial ordering over a.

we say k is superior if for all a, b     a

a     a     b,

b     a     b.

    intuition: combination always gets worse

d(u)

w(e)

liang huang (penn)

d(u)     w(e)

26

id145

dijkstra algorithm

    dijkstra does not require acyclicity
    instead of topological order, we use best-   rst order
    but this requires superiority of the semiring

let k = (a,    ,    , 0, 1) be a semiring, and     a partial ordering over a.

we say k is superior if for all a, b     a

a     a     b,

b     a     b.

    intuition: combination always gets worse
    contrast: monotonicity: combination preserves order

d(u)

w(e)

liang huang (penn)

d(u)     w(e)

26

id145

dijkstra algorithm

    dijkstra does not require acyclicity
    instead of topological order, we use best-   rst order
    but this requires superiority of the semiring

let k = (a,    ,    , 0, 1) be a semiring, and     a partial ordering over a.

we say k is superior if for all a, b     a

a     a     b,

b     a     b.

    intuition: combination always gets worse
    contrast: monotonicity: combination preserves order

d(u)

w(e)

liang huang (penn)

d(u)     w(e)

26

(r+    { +   },
(r    { +   },

({0, 1},    ,    , 0, 1)
([0, 1], max,   , 0, 1)
, +, +   , 0)
, +, +   , 0)
id145

min

min

dijkstra algorithm

    dijkstra does not require acyclicity
    instead of topological order, we use best-   rst order
    but this requires superiority of the semiring

let k = (a,    ,    , 0, 1) be a semiring, and     a partial ordering over a.

we say k is superior if for all a, b     a

a     a     b,

b     a     b.

    intuition: combination always gets worse
    contrast: monotonicity: combination preserves order

d(u)

w(e)

liang huang (penn)

d(u)     w(e)

26

(r+    { +   },
(r    { +   },

({0, 1},    ,    , 0, 1)
([0, 1], max,   , 0, 1)
, +, +   , 0)
, +, +   , 0)
id145

min

min

dijkstra algorithm

    keep a cut (s : v - s) where s vertices are    xed
    maintain a priority queue q of  v - s vertices
    each iteration choose the best vertex v from q
    move v to s, and use d(v) to forward-update others

d(u)     = d(v)     w(v, u)

s

...

v

s

liang huang (penn)

v - s

27

time complexity:

o((v+e) lgv) (binary heap)

o(v lgv + e) (   b. heap)

id145

dijkstra algorithm

    keep a cut (s : v - s) where s vertices are    xed
    maintain a priority queue q of  v - s vertices
    each iteration choose the best vertex v from q
    move v to s, and use d(v) to forward-update others

d(u)     = d(v)     w(v, u)

s

...

v

s

liang huang (penn)

v - s

27

time complexity:

o((v+e) lgv) (binary heap)

o(v lgv + e) (   b. heap)

id145

dijkstra algorithm

    keep a cut (s : v - s) where s vertices are    xed
    maintain a priority queue q of  v - s vertices
    each iteration choose the best vertex v from q
    move v to s, and use d(v) to forward-update others

w(v, u)

u

d(u)     = d(v)     w(v, u)

s

...

v

s

liang huang (penn)

v - s

27

time complexity:

o((v+e) lgv) (binary heap)

o(v lgv + e) (   b. heap)

id145

viterbi vs. dijkstra

    structural vs. algebraic constraints
    dijkstra only applicable to optimization problems
monotonic optimization problems

liang huang (penn)

28

id145

viterbi vs. dijkstra

    structural vs. algebraic constraints
    dijkstra only applicable to optimization problems
monotonic optimization problems

liang huang (penn)

28

id145

  acyclic:  viterbiviterbi vs. dijkstra

    structural vs. algebraic constraints
    dijkstra only applicable to optimization problems
monotonic optimization problems

liang huang (penn)

28

id145

  acyclic:  viterbi             superior:            dijkstra   viterbi vs. dijkstra

    structural vs. algebraic constraints
    dijkstra only applicable to optimization problems
monotonic optimization problems

many 
nlp 

problems

liang huang (penn)

28

id145

  acyclic:  viterbi             superior:            dijkstra   viterbi vs. dijkstra

    structural vs. algebraic constraints
    dijkstra only applicable to optimization problems
monotonic optimization problems

many 
nlp 

problems

forward-backward
(inside semiring)

liang huang (penn)

28

id145

  acyclic:  viterbi             superior:            dijkstra   viterbi vs. dijkstra

    structural vs. algebraic constraints
    dijkstra only applicable to optimization problems
monotonic optimization problems

many 
nlp 

problems

forward-backward
(inside semiring) non-probabilistic 

models

liang huang (penn)

28

id145

  acyclic:  viterbi             superior:            dijkstra   viterbi vs. dijkstra

    structural vs. algebraic constraints
    dijkstra only applicable to optimization problems
monotonic optimization problems

many 
nlp 

problems

forward-backward
(inside semiring) non-probabilistic 

models

cyclic id122s/
grammars

liang huang (penn)

28

id145

  acyclic:  viterbi             superior:            dijkstra   what if both fail?

monotonic optimization problems

many 
nlp 

problems

generalized bellman-ford

(clr, 1990; mohri, 2002)

or,    rst do strongly-connected components (scc)

which gives a dag; use viterbi globally on this scc-dag;

use bellman-ford locally within each scc

liang huang (penn)

29

id145

  acyclic:  viterbi             superior:            dijkstra   what if both work?

monotonic optimization problems

many 
nlp 

problems

full dijkstra is slower than viterbi
o((v + e) lgv)      vs.        o(v + e)

but it can    nish as early as the target vertex is popped

a (v + e) lgv      vs.            v + e

q: how to (magically) reduce a?

liang huang (penn)

30

id145

  acyclic:  viterbi             superior:            dijkstra   id67: intuition

    dijkstra is    blind    about how far the target is
    may get    trapped    by obstacles
    can we be more intelligent about the future?
    idea: prioritize by s-v distance + v-t estimate

v

u

s

t

liang huang (penn)

31

id145

id67: intuition

    dijkstra is    blind    about how far the target is
    may get    trapped    by obstacles
    can we be more intelligent about the future?
    idea: prioritize by s-v distance + v-t estimate

v

u

s

t

liang huang (penn)

31

id145

id67: intuition

    dijkstra is    blind    about how far the target is
    may get    trapped    by obstacles
    can we be more intelligent about the future?
    idea: prioritize by s-v distance + v-t estimate

v

u

s

t

 

liang huang (penn)

31

id145

a* heuristic
h(v)
d(v)

s

v

  (v)

t

    h(v): the distance from v to target t
      (v) must be an optimistic estimate of h(v):   (v)    h(v)
    dijkstra is a special case where   (v) =      (0 for dist.)
    now, prioritize the queue by d(v)       (v)
    can stop when target gets popped -- why?
    optimal subpaths should pop earlier than non-optimal
    d(v)       (v)     d(v)     h(v)     d(t)     non-optimal paths of t

liang huang (penn)

32

id145

how to design a heuristic?

    more of an art than science
    basic idea: projection into coarser space
    cluster:    w   (u, v) = min { w(u, v) | u     u, v     v }
    exact cost in coarser graph is estimate of    ner graph

liang huang (penn)

33  (raphael, 2001)

id145

how to design a heuristic?

    more of an art than science
    basic idea: projection into coarser space
    cluster:    w   (u, v) = min { w(u, v) | u     u, v     v }
    exact cost in coarser graph is estimate of    ner graph

u

v

u

v

liang huang (penn)

 (raphael, 2001)

33

id145

viterbi or a*?

    a* intuition: d(t)       (t) ranks higher among d(v)       (v)
    can    nish early if lucky
    actually, d(t)       (t) = d(t)     h(t) = d(t)        = d(t)
    with the price of maintaining priority queue - o(log v)
    q: how early? worth the price?
    if the rank is r,   then a* is better when   r/v log v < 1

d(v) pool

d(v)       (v) pool
1

 

d(t)

r

liang huang (penn)

dijkstra

d(t)

34

v

id145

a*

viterbi or a*?

    a* intuition: d(t)       (t) ranks higher among d(v)       (v)
    can    nish early if lucky
    actually, d(t)       (t) = d(t)     h(t) = d(t)        = d(t)
    with the price of maintaining priority queue - o(log v)
    q: how early? worth the price?
    if the rank is r,   then a* is better when   r/v log v < 1

d(v) pool

d(v)       (v) pool
1

 

d(t)

r

r < v / log v

liang huang (penn)

dijkstra

d(t)

34

v

id145

a*

two dimensional survey
traversing order

topological

(acyclic)

best-   rst
(superior)

viterbi

dijkstra

generalized 

viterbi

knuth

e
c
a
p
s
 
h
c
r
a
e
s

graphs with 
semirings
(e.g., id122s)

hypergraphs with 
weight functions

(e.g., id18s)

liang huang (penn)

35

id145

two dimensional survey
traversing order

topological

(acyclic)

best-   rst
(superior)

viterbi

dijkstra

generalized 

viterbi

knuth

e
c
a
p
s
 
h
c
r
a
e
s

graphs with 
semirings
(e.g., id122s)

hypergraphs with 
weight functions

(e.g., id18s)

liang huang (penn)

35

id145

background: id18 and parsing

(s, 0, n)

liang huang (penn)

w0  w1           ...           wn-1 
36

id145

background: id18 and parsing

(s, 0, n)

liang huang (penn)

w0  w1           ...           wn-1 
36

id145

background: id18 and parsing

(s, 0, n)

liang huang (penn)

w0  w1           ...           wn-1 
37

id145

background: id18 and parsing

(s, 0, n)

liang huang (penn)

w0  w1           ...           wn-1 
37

id145

(directed) hypergraphs

    a generalization of graphs
    edge => hyperedge: several vertices to one vertex
    e = (t(e), h(e), fe).    arity |e| = |t(e)|
e
    a totally-ordered weight set r
    we borrow the     operator to be the comparison
    weight function fe : r|e| to r
    generalizes the     operator in semirings 

zj,k

yi,j

xi,k

s
l
i
a
t

u1

u2

liang huang (penn)

fe

v

head

simple case:  fe(a, b) = a     b     w(e)

d(v)     = fe(d(u1), d(u2))

38

id145

hypergraphs and deduction

(b, i, k)
: a

u1

fe

(c, k, j)
: b

u2

(b, i, k)        (c, k, j) 

a   b c

(a, i, j)

: a    b    pr(a     b c)

v

(a, i, j)

(nederhof, 2003)

liang huang (penn)

39

id145

hypergraphs and deduction

(b, i, k)
: a

u1

fe

(c, k, j)
: b

u2

(b, i, k)        (c, k, j) 

a   b c

(a, i, j)

: a    b    pr(a     b c)

v

(a, i, j)

tails

u1

: a

fe

: b

u2

: a

u1

(nederhof, 2003)

antecedents

u2

: b
fe

v

: fe (a,b)

v

: fe (a,b)

head

consequent

liang huang (penn)

39

id145

related formalisms

v

e

v

e

or-node

and-node

u1

u2

u1

u2

or-nodes

liang huang (penn)

40

id145

packed forests

    a compact representation of many parses
    by sharing common sub-derivations
    polynomial-space encoding of exponentially large set

0  i 1 saw  2  him  3  with 4 a 5 mirror 6

liang huang (penn)

41

id145

(klein and manning, 2001; huang and chiang, 2005)

packed forests

    a compact representation of many parses
    by sharing common sub-derivations
    polynomial-space encoding of exponentially large set

nodes

hyperedges

a hypergraph

0  i 1 saw  2  him  3  with 4 a 5 mirror 6

liang huang (penn)

41

id145

(klein and manning, 2001; huang and chiang, 2005)

weight functions and semirings

fe

fe(a1, ..., ak) 

v

head

s
l
i
a
t

u1

u2
...
uk

liang huang (penn)

42

id145

weight functions and semirings

fe

fe(a1, ..., ak)  = a1     ...     ak     w(e)
head

special case

v

s
l
i
a
t

u1

u2
...
uk

liang huang (penn)

42

id145

weight functions and semirings

w(e)

fe

d(u)     w(e)

fe(a) = a     w(e)

fe(d(u))

fe

fe(a1, ..., ak)  = a1     ...     ak     w(e)
head

special case

v

d(u)

d(u)

s
l
i
a
t

u1

u2
...
uk

liang huang (penn)

42

id145

weight functions and semirings

d(u)     w(e)

fe(a) = a     w(e)

fe(d(u))

semiring-
composed

fe

fe(a1, ..., ak) 

= a1     ...     ak     w(e)

v

head

special case

w(e)

fe

d(u)

d(u)

s
l
i
a
t

u1

u2
...
uk

liang huang (penn)

42

id145

weight functions and semirings

w(e)

fe

d(u)

d(u)

s
l
i
a
t

u1

u2
...
uk

d(u)     w(e)

fe(a) = a     w(e)

fe(d(u))

semiring-
composed

fe

fe(a1, ..., ak) 

= a1     ...     ak     w(e)

v

head

special case

can also extend monotonicity and 

superiority to general weight functions

liang huang (penn)

42

id145

generalizing semiring properties
    monotonicity
    semiring:   a     b => a x c     b x c
    for all weight function f,   for all a1... ak,   for all i, 
if  a   i     ai    then   f(a1... a   i ... ak)     f(a1... ai ... ak)
    superiority
    semiring:   a     a x b,   b     a x b
    for all f,   for all a1... ak,   for all i,     ai     f(a1, ..., ak)
    acyclicity
    degenerate a hypergraph back into a graph

liang huang (penn)

43

id145

two dimensional survey
traversing order

topological

(acyclic)

best-   rst
(superior)

viterbi

dijkstra

generalized 

viterbi

knuth

e
c
a
p
s
 
h
c
r
a
e
s

graphs with 
semirings
(e.g., id122s)

hypergraphs with 
weight functions

(e.g., id18s)

liang huang (penn)

44

id145

viterbi algorithm for dags

1. topological sort
2. visit each vertex v in sorted order and do updates
    for each incoming edge (u, v) in e
    use d(u) to update d(v):
    key observation: d(u) is    xed to optimal at this time

u

w(u, v)

v

d(v)     = d(u)     w(u, v)

    time complexity: o( v + e )

liang huang (penn)

45

id145

viterbi algorithm for dahs

1. topological sort
2. visit each vertex v in sorted order and do updates
    for each incoming hyperedge e = ((u1, .., u|e|), v, fe)
    use d(ui)   s to update d(v)
    key observation: d(ui)   s are    xed to optimal at this time
d(v)     = fe(d(u1),          , d(u|e|))

fe

u1

v

u2

    time complexity: o( v + e )    (assuming constant arity)

liang huang (penn)

46

id145

example: cky parsing

    parsing with id18s in chomsky normal form (cnf)
    typical instance of the generalized viterbi for dahs
    many variants of cky ~ various topological ordering

(s, 0, n)

(s, 0, n)

o(n3|p|)

liang huang (penn)

47

id145

example: cky parsing

    parsing with id18s in chomsky normal form (cnf)
    typical instance of the generalized viterbi for dahs
    many variants of cky ~ various topological ordering

(s, 0, n)

(s, 0, n)

bottom-up

o(n3|p|)

liang huang (penn)

47

id145

example: cky parsing

    parsing with id18s in chomsky normal form (cnf)
    typical instance of the generalized viterbi for dahs
    many variants of cky ~ various topological ordering

(s, 0, n)

(s, 0, n)

bottom-up

left-to-right

o(n3|p|)

liang huang (penn)

47

id145

example: cky parsing

    parsing with id18s in chomsky normal form (cnf)
    typical instance of the generalized viterbi for dahs
    many variants of cky ~ various topological ordering

(s, 0, n)

(s, 0, n)

(s, 0, n)

bottom-up

left-to-right

o(n3|p|)

liang huang (penn)

48

id145

example: cky parsing

    parsing with id18s in chomsky normal form (cnf)
    typical instance of the generalized viterbi for dahs
    many variants of cky ~ various topological ordering

(s, 0, n)

(s, 0, n)

(s, 0, n)

bottom-up

left-to-right

right-to-left

o(n3|p|)

liang huang (penn)

48

id145

example: syntax-based mt
    synchronous context-free grammars (sid18s)
    context-free grammar in two dimensions
    generating pairs of strings/trees simultaneously
    co-indexed nonterminal further rewritten as a unit

vp     pp(1) vp(2)
vp     juxing le huitan, held a meeting
pp     yu shalong,

vp(2) pp(1)

with sharon

,

vp

vp

pp

vp

vp

pp

yu shalong

juxing le huitan

held a meeting

with sharon

liang huang (penn)

49

id145

translation as parsing
    translation with sid18s => monolingual parsing
    parse the source input with the source projection
    build the corresponding target sub-strings in parallel

vp     pp(1) vp(2)
vp     juxing le huitan, held a meeting
pp     yu shalong,

vp(2) pp(1)

with sharon

,

vp1, 6

pp1, 3

vp3, 6

yu  shalong

juxing  le  huitan

liang huang (penn)

50

id145

translation as parsing
    translation with sid18s => monolingual parsing
    parse the source input with the source projection
    build the corresponding target sub-strings in parallel

vp     pp(1) vp(2)
vp     juxing le huitan, held a meeting
pp     yu shalong,

vp(2) pp(1)

with sharon

,

vp1, 6

pp1, 3

vp3, 6

yu  shalong

juxing  le  huitan

liang huang (penn)

50

id145

translation as parsing
    translation with sid18s => monolingual parsing
    parse the source input with the source projection
    build the corresponding target sub-strings in parallel

vp     pp(1) vp(2)
vp     juxing le huitan, held a meeting
pp     yu shalong,

vp(2) pp(1)

with sharon

,

held a talk  with sharon

vp1, 6

with sharon

held a talk

pp1, 3

vp3, 6

yu  shalong

juxing  le  huitan

liang huang (penn)

50

id145

translation as parsing
    translation with sid18s => monolingual parsing
    parse the source input with the source projection
    build the corresponding target sub-strings in parallel

vp     pp(1) vp(2)
vp     juxing le huitan, held a meeting
pp     yu shalong,

vp(2) pp(1)

with sharon

,

held a talk  with sharon

vp1, 6

complexity: same as 
cky parsing -- o(n3)

with sharon

held a talk

pp1, 3

vp3, 6

yu  shalong

juxing  le  huitan

liang huang (penn)

50

id145

adding a bigram model

_ _             ... meeting

_ _ _ _ _

_ _                          

... talk

with   sharon

bigram

_ _                       
... talks

vp1, 6

                 ... shalong
                 ... sharon

bigram

held  ...   talk

with ...  sharon

vp3, 6

pp1, 3

liang huang (penn)

pp1, 3

with ... sharon
along ... sharon
with ... shalong

51

vp3, 6

held ... talk

held ... meeting

hold ... talks
id145

adding a bigram model

_ _             ... meeting

_ _ _ _ _

_ _                          

... talk

with   sharon

bigram

_ _                       
... talks

vp1, 6

                 ... shalong
                 ... sharon

held               ...             sharon

vp1, 6
bigram

held  ...   talk

with ...  sharon

vp3, 6

pp1, 3

liang huang (penn)

pp1, 3

with ... sharon
along ... sharon
with ... shalong

51

vp3, 6

held ... talk

held ... meeting

hold ... talks
id145

adding a bigram model

_ _             ... meeting

_ _ _ _ _

_ _                          

... talk

with   sharon

bigram

_ _                       
... talks

vp1, 6

                 ... shalong
                 ... sharon

held               ...             sharon

vp1, 6
bigram

held  ...   talk

with ...  sharon

vp3, 6

pp1, 3

complexity: o(n3 v4(m-1) )

liang huang (penn)

pp1, 3

with ... sharon
along ... sharon
with ... shalong

51

vp3, 6

held ... talk

held ... meeting

hold ... talks
id145

two dimensional survey
traversing order

topological

(acyclic)

best-   rst
(superior)

viterbi

dijkstra

generalized 

viterbi

knuth

e
c
a
p
s
 
h
c
r
a
e
s

graphs with 
semirings
(e.g., id122s)

hypergraphs with 
weight functions

(e.g., id18s)

liang huang (penn)

52

id145

viterbi algorithm for dahs

1. topological sort
2. visit each vertex v in sorted order and do updates
    for each incoming hyperedge e = ((u1, .., u|e|), v, fe)
    use d(ui)   s to update d(v)
    key observation: d(ui)   s are    xed to optimal at this time
d(v)     = fe(d(u1),          , d(u|e|))

fe

u1

v

u2

    time complexity: o( v + e )    (assuming constant arity)

liang huang (penn)

53

id145

forward  variant for dahs

1. topological sort
2. visit each vertex v in sorted order and do updates
    for each outgoing hyperedge e = ((u1, .., u|e|), h(e), fe)
    if d(ui)   s have all been    xed to optimal 
    use d(ui)   s to update d(h(e))

v = ui

u1

u2 = 

v

fe
fe

h(e)
h(e)

    time complexity: o( v + e )

liang huang (penn)

54

id145

forward  variant for dahs

1. topological sort
2. visit each vertex v in sorted order and do updates
    for each outgoing hyperedge e = ((u1, .., u|e|), h(e), fe)
    if d(ui)   s have all been    xed to optimal 
    use d(ui)   s to update d(h(e))

v = ui

u1

u2 = 

v

fe
fe

h(e)
h(e)

    time complexity: o( v + e )

liang huang (penn)

54

id145

forward  variant for dahs

1. topological sort
2. visit each vertex v in sorted order and do updates
    for each outgoing hyperedge e = ((u1, .., u|e|), h(e), fe)
    if d(ui)   s have all been    xed to optimal 
    use d(ui)   s to update d(h(e))

v = ui

u1

u2 = 

v

fe
fe

h(e)
h(e)

q: how to avoid repeated checking?
maintain a counter r[e] for each e:
   how many tails yet to be    xed?
   re this hyperedge only if r[e]=0

    time complexity: o( v + e )

liang huang (penn)

54

id145

dijkstra algorithm

    keep a cut (s : v - s) where s vertices are    xed
    maintain a priority queue q of  v - s vertices
    each iteration choose the best vertex v from q
    move v to s, and use d(v) to forward-update others

d(u)     = d(v)     w(v, u)

s

...

v

s

liang huang (penn)

v - s

55

time complexity:

o((v+e) lgv) (binary heap)

o(v lgv + e) (   b. heap)

id145

dijkstra algorithm

    keep a cut (s : v - s) where s vertices are    xed
    maintain a priority queue q of  v - s vertices
    each iteration choose the best vertex v from q
    move v to s, and use d(v) to forward-update others

d(u)     = d(v)     w(v, u)

s

...

v

s

liang huang (penn)

v - s

55

time complexity:

o((v+e) lgv) (binary heap)

o(v lgv + e) (   b. heap)

id145

dijkstra algorithm

    keep a cut (s : v - s) where s vertices are    xed
    maintain a priority queue q of  v - s vertices
    each iteration choose the best vertex v from q
    move v to s, and use d(v) to forward-update others

w(v, u)

u

d(u)     = d(v)     w(v, u)

s

...

v

s

liang huang (penn)

v - s

55

time complexity:

o((v+e) lgv) (binary heap)

o(v lgv + e) (   b. heap)

id145

knuth (1977) algorithm
    keep a cut (s : v - s) where s vertices are    xed
    maintain a priority queue q of  v - s vertices
    each iteration choose the best vertex v from q
    move v to s, and use d(v) to forward-update others

s

...

u1

v
v

s

liang huang (penn)

v - s

56

time complexity:

o((v+e) lgv) (binary heap)

o(v lgv + e) (   b. heap)

id145

knuth (1977) algorithm
    keep a cut (s : v - s) where s vertices are    xed
    maintain a priority queue q of  v - s vertices
    each iteration choose the best vertex v from q
    move v to s, and use d(v) to forward-update others

s

...

u1

v
v

s

liang huang (penn)

v - s

56

time complexity:

o((v+e) lgv) (binary heap)

o(v lgv + e) (   b. heap)

id145

knuth (1977) algorithm
    keep a cut (s : v - s) where s vertices are    xed
    maintain a priority queue q of  v - s vertices
    each iteration choose the best vertex v from q
    move v to s, and use d(v) to forward-update others

s

...

u1

v
v

fe

h(e)

s

liang huang (penn)

v - s

56

time complexity:

o((v+e) lgv) (binary heap)

o(v lgv + e) (   b. heap)

id145

knuth (1977) algorithm
    keep a cut (s : v - s) where s vertices are    xed
    maintain a priority queue q of  v - s vertices
    each iteration choose the best vertex v from q
    move v to s, and use d(v) to forward-update others

s

...

u1

v
v

fe

h(e)

s

liang huang (penn)

v - s

56

time complexity:

o((v+e) lgv) (binary heap)

o(v lgv + e) (   b. heap)

id145

example: best-first/a* parsing
    knuth for parsing:  best-   rst  (caraballo & charniak, 1998)
    further speed-up: use a* heuristics
    showed signi   cant speed up with carefully designed 
    heuristic function: an estimate of outside cost

heuristic functions (klein and manning, 2003)

(s, 0, n)

liang huang (penn)

57

id145

example: best-first/a* parsing
    knuth for parsing:  best-   rst  (caraballo & charniak, 1998)
    further speed-up: use a* heuristics
    showed signi   cant speed up with carefully designed 
    heuristic function: an estimate of outside cost

heuristic functions (klein and manning, 2003)

(s, 0, n)

liang huang (penn)

57

id145

outside cost in hypergraph
    outside cost:  yet to pay to reach goal
    let   s only consider semiring-composed case
    and only acyclic hypergraphs
    after computing d(v) for all v from bottom-up
    backwards viterbi from top-down (outside-in)

d(v)

h(v)

v

s

t

s0,n

h(v)

d(v)

liang huang (penn)

...

...

u

e

v   

v

58

h(s0,n) =   
h(v)    = h(u)   w(e)   d(v   ) 

id145

d(v)outside cost in hypergraph
    outside cost:  yet to pay to reach goal
    let   s only consider semiring-composed case
    and only acyclic hypergraphs
    after computing d(v) for all v from bottom-up
    backwards viterbi from top-down (outside-in)

d(v)

h(v)

v

s

t

s0,n

h(v)

d(v)

liang huang (penn)

...

...

u

e

v   

v

58

h(s0,n) =   
h(v)    = h(u)   w(e)   d(v   ) 

q: d(v)   h(v) = ?

id145

d(v)projection-based heuristics

    how to guess? project onto a coarser-grained space
    and parse with the coarser grammar
    outside cost of of the coarser item as heuristics

liang huang (penn)

 (klein and manning, 2003)
59

id145

projection-based heuristics

    how to guess? project onto a coarser-grained space
    and parse with the coarser grammar
    outside cost of of the coarser item as heuristics

liang huang (penn)

 (klein and manning, 2003)
59

id145

projection-based heuristics

    how to guess? project onto a coarser-grained space
    and parse with the coarser grammar
    outside cost of of the coarser item as heuristics

liang huang (penn)

 (klein and manning, 2003)
60

id145

projection-based heuristics

    how to guess? project onto a coarser-grained space
    and parse with the coarser grammar
    outside cost of of the coarser item as heuristics

liang huang (penn)

 (klein and manning, 2003)
61

id145

projection-based heuristics

    how to guess? project onto a coarser-grained space
    and parse with the coarser grammar
    outside cost of of the coarser item as heuristics

liang huang (penn)

 (klein and manning, 2003)
61

id145

projection-based heuristics

    how to guess? project onto a coarser-grained space
    and parse with the coarser grammar
    outside cost of of the coarser item as heuristics

   (vbd2,3) = h    (v2,3)

liang huang (penn)

 (klein and manning, 2003)
61

id145

analogy with graphs

liang huang (penn)

62

id145

analogy with graphs

liang huang (penn)

62

id145

more on coarse-to-fine

    multilevel coarse-to-   ne a*
    heuristic = exact outside cost in previous stage
      i (v) = hi-1 (proj i-1(v))
    vbd>v>x.    i (vbd1,5) = hi-1 (v1,5);   i-1 (v1,5) = hi-2 (x1,5)
    multilevel coarse-to-   ne viterbi w/ beam-search
    viterbi + beam pruning in each stage
    prune according to merit:  d(v)   h(v)     d(top)
    hard to derive a provably correct threshold
    in practice: use a preset threshold (but works well!)

liang huang (penn)

63

id145

more on coarse-to-fine

    multilevel coarse-to-   ne a*
    heuristic = exact outside cost in previous stage
      i (v) = hi-1 (proj i-1(v))
    vbd>v>x.    i (vbd1,5) = hi-1 (v1,5);   i-1 (v1,5) = hi-2 (x1,5)
    multilevel coarse-to-   ne viterbi w/ beam-search
    viterbi + beam pruning in each stage
    prune according to merit:  d(v)   h(v)     d(top)
    hard to derive a provably correct threshold
    in practice: use a preset threshold (but works well!)

liang huang (penn)

63

id145

more on coarse-to-fine

    multilevel coarse-to-   ne a*
    heuristic = exact outside cost in previous stage
      i (v) = hi-1 (proj i-1(v))
    vbd>v>x.    i (vbd1,5) = hi-1 (v1,5);   i-1 (v1,5) = hi-2 (x1,5)
    multilevel coarse-to-   ne viterbi w/ beam-search
    viterbi + beam pruning in each stage
    prune according to merit:  d(v)   h(v)     d(top)
    hard to derive a provably correct threshold
    in practice: use a preset threshold (but works well!)

liang huang (penn)

63

id145

same picture again

monotonic optimization problems

many 
nlp 

problems

liang huang (penn)

64

id145

  acyclic:  viterbi             superior:            knuth   same picture again

monotonic optimization problems

many 
nlp 

problems

pid18 parsing 

with cnf

liang huang (penn)

64

id145

  acyclic:  viterbi             superior:            knuth   same picture again

monotonic optimization problems

many 
nlp 

problems

inside-outside alg.
(inside semiring)

pid18 parsing 

with cnf

liang huang (penn)

64

id145

  acyclic:  viterbi             superior:            knuth   same picture again

monotonic optimization problems

many 
nlp 

problems

inside-outside alg.
(inside semiring)

pid18 parsing 

with cnf

non-prob. 

(discriminative) 

parsing

liang huang (penn)

64

id145

  acyclic:  viterbi             superior:            knuth   same picture again

monotonic optimization problems

many 
nlp 

problems

inside-outside alg.
(inside semiring)

pid18 parsing 

with cnf

cyclic 

grammars

non-prob. 

(discriminative) 

parsing

liang huang (penn)

64

id145

  acyclic:  viterbi             superior:            knuth   same picture again

monotonic optimization problems

many 
nlp 

problems

inside-outside alg.
(inside semiring)

pid18 parsing 

with cnf

cyclic 

grammars

non-prob. 

(discriminative) 

parsing

generalized 
generalized
bellman-ford 

(open)

liang huang (penn)

64

id145

  acyclic:  viterbi             superior:            knuth   take home message

    id145 is cool, easy, and universal!
    two frameworks and two types of algorithms
    monotonicity;   acyclicity and/or superiority
    topological (viterbi) vs. best-   rst style (dijkstra/knuth/a*)
    when to choose which:  a* can    nish early if lucky
    graph (lattice) vs. hypergraph (forest)
    incremental,    nite-state vs. branching, context-free

    covered many typical nlp applications
    a better understanding of theory helps in practice

liang huang (penn)

65

id145

the end - thanks!

thanks!

questions?
comments?

(s, 0, n)

w0  w1           ...           wn-1 

   nal slides will be available on my website.

66

