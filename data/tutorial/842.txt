information extraction
a survey

katharina kaiser and silvia miksch

vienna university of technology
institute of software technology & interactive systems

asgaard-tr-2005-6

may 2005

authors: katharina kaiser and silvia miksch

{kaiser, silvia}@asgaard.tuwien.ac.at
http://ieg.ifs.tuwien.ac.at

contact: vienna university of technology

institute of software technology & interactive systems
favoritenstra  e 9-11/188
a-1040 vienna
austria, europe
telephone: +43 1 58801 18839
telefax:
+43 1 58801 18899
web
http://ieg.ifs.tuwien.ac.at

contents

abstract

1

2

introduction

parsing .

. . . . . .

. . . . . .
. . . . . .

. . . . .
2.1.1
. . . . .
2.1.2 considerations for an approach . . . .

information extraction systems: aspects and characteristics
2.1 design approaches . . . .
. . . . . .
. . . . . .
pattern discovery .
. . . . . .
2.2 components of an information extraction system . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .

2.2.1 id121 . . .
. . . . .
2.2.2 lexical and morphological processing .
. . . . . .
. . . . .
2.2.3
. . . . .
. . . . . .
2.2.4 coreference . . . .
. . . . .
. . . . .
2.2.5 domain-speci   c analysis
. .
. . . . .
2.2.6 merging partial results . . . .
. . . . .
. . . . . .
. .
. . . . .
format uniqueness and completeness .
. . . . .
. . . . .

2.3 types of data . .
2.4 evaluating information extraction systems
2.5 wrapper . . . . .

2.5.1
2.5.2 html-quality level . . . . .
2.5.3 wrapper generation . . . . .

. . . . . .

. . . . .

. . . . .

3 prior work

3.2.1

3.2 automatic pattern discovery in ie systems

fastus . . . . .
. . . . . .
ge nltoolset . . . . . .
. . . . . .
plum .
. . . . .
proteus . . . .
. . . . . .

3.1 manual pattern discovery in ie systems . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .

supervised . . . .
autoslog . . . . .
palka .
. . . . .
crystal . . . .
. . . . .
liep . .
whisk .
. . . . .
rapier . . . . .
gate . .
. . . . .
discussion . . . .
3.2.2 unsupervised . . .

. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .

. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .

1

1

1

2
2
2
3
3
3
5
5
5
6
6
7
7
8
8
9
9

10
10
10
10
11
11
12
12
12
13
13
13
14
14
14
15
15

. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .

. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .

. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .

. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .

. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .

. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .

. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .
. . . . .

. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .
. . . .

15
16
16
16
17
17
17
17
18
18
18
18
20
20
21
21

22

24

. . . . . .
autoslog-ts . . .
mutual id64 . . . .
. . . . . .
exdisco . . . .
. . . . . .
snowball
. . . . .
qdie . .
. . . . .
. . . . . .
. . . . . .
discussion . . . .
3.3 semi-automatic wrapper generation .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
. . . . . .
3.4 automatic wrapper generation . . . .
. . . . . .
. . . . . .
. . . . . .

. . . . .
wien . .
softmealy . . . . .
stalker . . . .
. . . . .
lixto . .
xwrap .
. . . . .

shopbot
roadrunner
iepad .

. . . . .
. . .
. . . . .

4 conclusions

bibliography

2

abstract

information extraction is a technique used to detect relevant information in larger docu-
ments and present it in a structured format. information extraction is not text understand-
ing. it is used to analyze the text and locate speci   c pieces of information in the text.

information extraction techniques can be applied to structured, semi-structured, and
unstructured texts. for the latter one, natural language processing is necessary which
is implemented in traditional information extraction systems. to process structured and
semi-structured texts often no nlp techniques are necessary as they do not offer such a rich
grammatical structure. for this reason, so called wrappers are developed that incorporate
the different structures of documents.

in this paper we will describe the requirements and components of information extrac-
tion systems as well as present various approaches for building such systems. we then will
represent important methodologies and systems for both traditional information extraction
systems and wrapper generation systems.

chapter 1

introduction

unstructured data, most of it in the form of text    les, typically accounts for over 80 % of
an organization   s knowledge stores, but it is not always easy to    nd, access, analyze, or
use. therefore, we need tools and methods to locate the information and synthesize it into
knowledge in order to make it useful. a common approach to accomplish this task is text
mining.

id111 (tm) is about looking for patterns in natural language text and has been
de   ned as    the discovery by computer of new, previously unknown information, by auto-
matically extracting information from different written resources    [16]. it recognizes that
complete understanding of natural language text is not attainable and focuses on extracting
a small amount of information from text with high reliability. tm uses recall and precision
scores to measure the effectiveness of different information extraction techniques to allow
quantitative comparisons to be made.

information extraction (ie) is one of the most prominent techniques currently used in
tm. it is a starting point to analyze unstructured text. in particular, by combining natu-
ral language processing tools, lexical resources, and semantic constraints, it can provide
effective modules for mining documents of various domains.

ie is an emerging nlp technology, whose function is to process unstructured, natural
language text, to locate speci   c pieces of information, or facts, in the text, and to use these
facts to    ll a database. peshkin and pfeffer [31] de   ne ie as the task of    lling template
information from previously unseen text which belongs to a pre-de   ned domain.

its goal is to extract from documents salient facts about pre-speci   ed types of events,
entities, or relationships. these facts are then usually entered automatically into a database,
which may then be used for further processing.

today, ie systems are commonly based on pattern matching. each pattern consists of a

regular expression and an associated mapping from syntactic to logical form.

1

chapter 2

information extraction systems:
aspects and characteristics

2.1 design approaches

numerous ie systems have been designed and implemented.
in principal, the used ap-
proaches can be categorized into two groups: (1) the learning approach, and (2) the knowl-
edge engineering approach.

for systems or modules using learning techniques an annotated corpus of domain-
relevant texts is necessary. therefore, there is no need for system expertise. this approach
calls only for someone who has enough knowledge about the domain and the tasks of the
system to annotate the texts appropriately. the annotated texts are the input of the system
or module, which runs a training algorithm on them. thus, the system obtains knowledge
from the annotated texts and can use it to gain desired information from new texts of the
same domain.

the knowledge engineering (ke) approach asks for a system developer, who is familiar
with both the requirements of the application domain and the function of the designed ie
system. the developer is concerned with the de   nition of rules used to extract the relevant
information. therefore, a corpus of domain-relevant texts will be available for this task.
furthermore, she or he is free to apply any general knowledge or intuitions in the design
of rules. thus, the performance of the ie system depends on the skill of the knowledge
engineer.

the ke approach uses an iterative process, whereas within each iteration the rules are
modi   ed as a result of the system   s output on a training corpus. thus, the ke approach
demands a lot of effort.

2.1.1 pattern discovery

pattern discovery is a major part of ie. it is the task of identifying the extraction patterns
that are relevant for the user   s need, speci   ed by the user   s query. patterns can be discovered
automatically, semi-automatically, and manually.

at the beginning of developing ie systems the systems were customized manually
to a given task [4, 17, 21]. due to the very high costs for computational linguists ap-
proaches were demanded to automate this task. thus, within the proteus project [40] a
semi-automatic creation of patterns was developed. thereby, a discovery procedure of ex-
traction patterns aims to help the user create the knowledge-bases, such as lexicons and

2

patterns. the methodology includes showing a pattern candidate and incorporating an ex-
isting ontology and pattern set.

the automatic approach takes a set of documents and outputs a set of extraction patterns
by using machine learning techniques. automatic learning systems can be categorized in
three groups: (1) supervised learning systems [32, 37, 20, 19, 36], (2) semi-supervised
learning systems [35, 1, 41], and (3) unsupervised learning systems [34, 11, 38].

2.1.2 considerations for an approach

appelt [2] de   ned a number of considerations that in   uence the decision to utilize a par-
ticular approach for a particular module (see section 2.2: components of an information
extraction system):

1. the availability of training data. if the required training data is available or cheaply
and easily obtainable, the learning approach should be chosen. for complex domain-
level tasks, where the annotation task is much slower, more dif   cult, more expensive,
or requires extensive domain expertise from annotators, the ke approach may be
favored.

2. the availability of linguistic resources.

if linguistic resources like lexicons and
dictionaries are available developing rules by a knowledge engineer may be possible.
otherwise, it may be necessary to rely on training from the annotated corpus.

3. the availability of knowledge engineers. if there is no skilled knowledge engineer,

the learning approach should be chosen.

4. the stability of the    nal speci   cations. if speci   cations change, it is often easier
to make minor changes to a set of rules than to reannotate and retrain the system.
however, other changes in speci   cations may be easier to accomplish with a trainable
system.

5. the level of performance required. human skills count for a lot. the best per-
forming systems for various ie tasks have been hand crafted. the performance of
automatically trained systems depend on the quantity of available training data. eval-
uations at mucs show that with enough data the automatically training approach can
achieve equivalent results to the knowledge engineering approach.

2.2 components of an information extraction system

a typical information extraction system has phases for input id121, lexical and mor-
phological processing, some basic syntactic analysis, and identifying the information being
sought in the particular application (cf. figure 2.1) [2]. depending on what one is interested
in some phases may not be necessary. in addition to the modules in the left-hand column,
ie systems may include modules from the right-hand column, depending on the particular
requirements of the application.

2.2.1 id121

the id121 module is responsible for splitting the input text into sentences and to-
kens. id121 is a trivial problem for european languages with clear word borders.
however, in processing some languages like chinese or japanese, it is not evident from the

3

a

l

a

o

t

o

i

n

g

n

d

y

t

e

p

o

e

t

l

m

o

m

x

k

p

o

a

a

i

a

e

r

n

n

c

n

a

p
i

o

h

r

s

i

z

n

o
s

y

 

l

d

i

n

p

s

g
i

e

s

c

i

f

i

c

x
a

a
c

e

t

n

r

o

r

s

d

t

t

g

r

o
a

e

r

f
g

f

e

f

i

n

e

t
r

c

i

e
g

s

t

l

s
g

u

i

e

i

p

o

p
e

n

l

t

i

n

g

r

e
n

a

s

c

g
e

i

z

n

e
c

r

g

i

n

h

t

i

a

l

m

figure 2.1: modules of an information extraction system.

4

orthography where the word boundaries are. therefore, systems for these languages must
necessarily be expanded by a id40 module.

2.2.2 lexical and morphological processing

morphology is a sub discipline of linguistics and is interested in the structure of word forms.
many ie systems for languages with simple in   ectional morphology, like english, do not
have a morphological analysis component at all. in english, it is easy to simply list all
in   ectional variants of a word explicitly in the lexicon. for languages like french, with
more complex in   ectional morphology, a morphological analysis component makes more
sense, but for a language like german, where compound nouns are agglutinated into a single
word, morphological analysis is essential.

in the lexical analysis the tokens determined by the id121 module are looked
up in the dictionary to determine their possible parts-of-speech and other lexical features
that are required for subsequent processing. the most important job of this module is the
handling of proper names. recognizing names can thereby be done with either handcrafted
rules under the knowledge engineering approach or automatically trained rules derived
from an annotated corpus.

in addition to name recognition, this module must assign lexical features to words re-
quired for subsequent processing. this can be accomplished by either a lookup in a lexicon,
or by automatic taggers, like a parts-of-speech tagger. a parts of speech tagger annotates
each word of a sentence with its parts of speech tag, such as noun, verb, adjective, and so
on. it can avoid incorrect analysis based on disambiguation caused by rare word senses in
comprehensive lexicons.

2.2.3 parsing

syntactic analysis has the aim to identify the syntactic structure of the analyzed document.
most ie systems only accomplish a shallow, fragment analysis of the texts. but there have
been even ie systems which totally skip the phase of syntactic analysis.

ie systems are only interested in speci   c types of information in a text and ignore por-
tions of text, which are not relevant for their task. therefore, parsing these portions and
   nding irrelevant grammatical relationships will be unnecessary.

2.2.4 coreference

the reason for this module is simply that application relevant entities will be referred to in
many different ways throughout a given text and thus, success on the ie task was, to a least
some extent, conditional on success at determining when one noun phrase referred to the
very same entity as another noun phrase. thus, a coreference module should handle the
following coreference problems:

    name-alias coreference. names and their common variants must be recognized as

coreferring, e.g.,    silvia miksch    and    prof. miksch   .

    pronoun-antecedent coreference. pronouns like    she   ,    he   ,    they   , and so on must be
associated with their antecedents, resolving them to a domain relevant named entity
if possible.

    de   nite description coreference. handling this problem requires arbitrary world
knowledge to make the connection among descriptors. when building an ie sys-
tem, it is reasonable to include ontological information for domain-relevant entities

5

that enable such resolution in restricted cases, but doing it in general is unrealistic.
examples are    apple computer    and    the company    or    apple    and    the cupertino
computer manufacturer   .

as with other ie modules, it is possible to build coreference modules by both knowledge
engineering and automatic learning approach. the knowledge engineering approach is, for
instance, applied by fastus [3]. for accomplishing the coreference task with the learning
approach id90 can be applied [27].

2.2.5 domain-speci   c analysis

the domain analysis is the core of most ie systems. the preceding modules prepare the
text for the domain analysis by adding semantic and syntactic features to it.

this module    lls the templates, which are in general constructed as attribute-value pairs.
templates consist of a collection of slots (i.e., attributes), each of which may be    lled by
one or more values. these values can consist of the original text, one or more of a    nite
set of prede   ned alternatives, or pointers to other template objects. typically, slot    llers
representing dates, times, job titles, and so on are standardized by id172 rules.

for extracting facts and events, the system needs domain speci   c extraction patterns
(i.e., extraction rules or case frames). these patterns can be generated manually (by means
of knowledge engineering) or automatically (by means of automatic learning). the por-
tion of text that matches a de   ned linguistic pattern is memorized and the information is
extracted by the guidance of the extraction rule from this portion of text to    ll the template.
for designing the domain-relevant pattern rules there exist two approaches, which can

be characterized as (1) the atomic approach and (2) the molecular approach.

the molecular approach is the most common one. it involves matching all or most
of the arguments in an event in a single pattern. the development cycle of this approach
starts with a small number of highly reliable rules that capture the common core cases
of the domain, but ignoring a broad class of less frequently occurring relevant patterns.
further development is characterized by capturing ever-larger numbers of increasingly rare
and problematic cases with increasingly general and possibly overgenerating rules. thus,
the system starts with high precision and low recall scores and evolves in increasing recall
and progressively lower precision.

the atomic approach builds a domain module that recognizes the arguments to an event
and combines them into template structures strictly on the basis of intelligent guesses rather
than syntactic relationships. the development cycle can be characterized by assuming
domain-relevant events for any recognized entities, leading to high recall, but much over-
generation, and thus low precision. further development would result improving    lters and
heuristics for combining the atomic elements, improving precision

the atomic approach make sense at tasks characterized by the following features: (1)
entities in the domain have easily determined types and (2) the templates are structured so
that there is only one or a very small number of possible slots that an entity of a given type
can    ll and only entities of a given type can    ll those slots.

2.2.6 merging partial results

usually, the sought-after information is spread among different sentences. in these cases
information should be combined before creating the    nal templates. for this purpose some
ie systems use a merging module. this module uses an algorithm to decide which templates
can be merged.

6

again, there are two merging strategies: (1) the knowledge engineering approach,
where one performs data analyses to identify good merging principles, de   nes rules, and
tests the results; and (2) using some training mechanism to acquire the merging strategies
automatically by the system.

2.3 types of data

we can differentiate the various ie systems by the type of data that are used as origin:
structured data, semi-structured data, and unstructured data.

1. structured data:

this is relational data (e.g., from databases). by means of the structure of the database
a meaning of the particular data is assigned. thus, detecting relevant information and
the assignment of a meaning can be eased.

2. semi-structured data:

no semantic is applied to these data, but for extracting the relevant information no
natural language understanding (nlu), like analysis of words or sentences, is re-
quired. examples are advertisements in newspapers and job postings or highly struc-
tured html pages.
according to [5, 26] both xml-encoded and html-encoded pages contain semi-
structured data, but html is rather more    human-oriented    or    presentation-oriented   .
it lacks the separation of data structure from layout, which xml provides.

3. unstructured data:

this can be, for example, plain text. for extracting the relevant information we must
understand the text. therefore, methods of nlu are applied. examples are newspa-
per articles.

2.4 evaluating information extraction systems

over the course of several message understanding conferences (mucs) organizers and
participants agreed how ie systems should be evaluated [25]. thereby, the extracted output
is presented as hierarchical attribute-value structures. human annotators provide a set of
key templates for the training data and the test data that is compared to the system   s output.
values that correctly match the key values are counted as correct, whereas values that do
not match are incorrect. attributes with non-empty values not aligning with a key attribute
are considered overgeneration. thus, it is possible to de   ne recall and precision scores for
the output of an ie system given the total possible correct responses (p ), number of correct
values (c), number of incorrect values (i), and overgenerated values (o) as follows:

recall =

c

p

c

precision =

c + i + o

thereby, recall measures the ratio of correct information extracted from the texts against
all the available information present in the text. precision measures the ratio of correct
information that was extracted against all the information that was extracted. it is dif   cult
to optimize both parameters at the same time. is a system optimized for high precision the

7

feasibility of not detecting all relevant information improves. but if recall is optimized it is
possible that the system classi   es irrelevant information as relevant.

besides, there can be de   ned the f measure to have a metric that can be used to compare
various ie systems by only one value. this metric uses weighted recall and precision scores
depending which value is given more importance.

f =

(   2 + 1)p r

   2p + r

the f measure is a geometric mean between recall and precision. by means of the param-
eter    it can be determined whether the recall (r) or the precision (p ) score is weighted
more heavily.

recall, precision, and f measure are the most frequently used metrics when referring to

an ie system   s performance.

2.5 wrapper

a wrapper is a program carrying out retrieving information from different repositories,
merging, and unifying them. but often wrappers are only applied to the latter two activ-
ities. the aim of a wrapper is to locate relevant information in semi-structured data and to
put it into a self-described representation for further processing [24]. it seems, as if ie sys-
tems and wrappers do just the same, but the application areas are different. besides, many
information resources do not exhibit the rich grammatical structure nlp techniques applied
in ie systems are designed to exploit.

the most widespread application area of wrappers is the world wide web with its
unlimited amount of web sites that are mostly semi-structured. the differences between the
structure of each document in the web and the fact that sites are changed periodically makes
it obvious that building such programs by hand is not a feasible task. this facts lead to two
main problems in this    eld:    wrapper generation    and    wrapper maintenance    [9].

rule-based methods have been especially popular in recent years. some techniques
for generating rules in the realm of text extraction are called    wrapper induction    methods.
these techniques have proved to be rather successful for ie tasks in their intended domains,
which are collections of documents such as web pages generated from a template script
[29, 23, 26, 5]. however, wrapper induction methods do only extend well to documents
speci   c to the induced rules.

concerning the result pages in html format we have to consider the following aspects
that are important for the wrapper generation [10]: format uniqueness and completeness as
well as the html-quality level.

2.5.1 format uniqueness and completeness

it provides the most obvious classi   cation of html-pages returned by the different backends.
completeness is hereby de   ned to be homogeneity, that is, a search request always returns
the same set of elements within the resulting html-page. the following classi   cation can be
given:

    rigorous structure, i.e., unique format and complete information: for example, al-
tavista always returns a    name    and a    body    element (even though with rather un-
structured, raw information).

8

    semi-rigorous structure, i.e., unique format and incomplete information: for exam-
ple, library of congress always provides a list of attributes for each returned item but
not all of the attributes are common for all the items.

    semi-relaxed structure, i.e., no unique format and complete information: semi-
relaxed structures result from data sets put together from different legacy collections.

    relaxed structure, i.e., no unique format and incomplete information: most home

pages on the web have relaxed structures.

2.5.2 html-quality level

another aspect that has to be mentioned is the html-quality level. the classi   cation
ranges from high level to low level. in existing information repositories, almost all variation
between these two extreme classi   cations can be found.

    high level:

each item in the result page is surrounded by a couple of html-tags, such as <b>   
</b>. each of these    tagged    items corresponds to exactly one attribute of the orig-
inal data (e.g., each skill requirement is stated within a single tag).

    low level:

a string between two html-tags corresponds to more than one output attributes. in this
case, some additional plain-text separators like    .   ,    ,   ,    ;    are used for separating the
different attributes of the original data (e.g., a set of requirements for a job position is
stated within one tag). here, the analysis of the html-structure of the result pages is
not enough, and a plain text analysis must be done!

2.5.3 wrapper generation

for generating wrappers similar methods can be applied like for ie systems: (1) manual
wrapper generation based on specialized languages to express extraction rules written by a
human expert, (2) semi-automatic wrapper generation using machine learning approaches
[24, 5, 30, 26], and (3) automatic wrapper generation applying unsupervised learning [15,
8, 13].

9

chapter 3

prior work

this chapter introduces prior work on both manual and automatic learning of extraction
patterns for ie systems and wrappers.

3.1 manual pattern discovery in ie systems

in earlier mucs1, many ie systems were customized manually to a given task.

fastus

fastus [17] is a (slightly permuted) acronym for finite state automaton text under-
standing system, although it does not deal with text understanding but ie. it is a cascaded,
nondeterministic    nite state automaton.

fastus, as used for muc-4, is based on a 4-step processing: (1) triggering, (2) rec-
ognizing phrases, (3) recognizing patterns, and (4) merging of incidents. in the    rst pass,
trigger words are searched for in every sentence. additionally, person   s names identi   ed
in previous sentences are also treated as trigger words for the remainder of the text. in the
second step, noun groups, verb groups, and several critical word classes (e.g., prepositions,
conjunctions, relative pronouns) are recognized by a nondeterministic    nite state automa-
ton. in this phase no parts-of-speech tagger is necessary as it was shown to not improve the
results, but decreases the system   s performance. in the third step, patterns are recognized.
pattern generation was done completely hand-coded. for muc-4 95 patterns were imple-
mented to extract incidents detected in the documents. in the last step incidents are merged.
the application area of muc-4 have been news articles about terrorist activities. merging
is accomplished for incidents of the same sentence and for incidents remaining at the end
of the processing which are merged with incidents found in previous sentences. in case of
incompatible incident   s types, dates, or locations, merging is blocked.

the basic system is relatively small, although the dictionary used is very large. the
manually developed rules were very effective and performed very well. due to the fast run
time and the simple concepts the development time was also very fast.

ge nltoolset

the ge nltoolset [21] is an ie system using a knowledge-based, domain-independent
core of text processing tool. the processing of the toolset is divided into three stages: (1)
pre-processing, (2) linguistic analysis, and (3) post-processing.

1message understanding conferences

10

in the pre-processing phase the text is segmented and irrelevant parts are    ltered out,
phrases that are template activators are identi   ed, and portions of text are marked that could
describe discrete events. in the analysis phase parsing and semantic interpretation is per-
formed. the post-processing module selects the templates and maps semantic categories
and roles into those templates.

the system   s knowledge base consists of a core sense-based lexicon and a feature and
function grammar. the core lexicon contains over 10,000 entries, of which a small set is
restricted to the application domain. the core grammar consists of 170 rules, again with a
small set of muc-speci   c rules.

plum

plum (probabilistic language understanding model) [4] as used in muc-4 applied a
manually generated rules. the system architecture contains a preprocessing module, a mor-
phological analysis module, a parsing module, a semantic interpreter, a discourse processing
module, and a template generation module.

within the preprocessing module message boundaries were determined, the header is
identi   ed, and paragraph and sentence boundaries are determined. the morphologic anal-
ysis module assigns parts-of-speech (pos) information, whereby the id52 is aug-
mented by (automatically trained) probabilistic models for recognizing words of spanish
and english origin. the parsing module generates one or more non-overlapping parse frag-
ments spanning the input sentence. these fragments are then processed by the semantic
interpreter. this module uses semantic components, such as lexical semantics and seman-
tic rules. lexical semantics are constructed by an automatic case frame induction procedure.
they indicate the word   s semantic type and predicates pertaining to it. semantic rules are
general syntactic patterns. their basic elements are    semantic forms   , which can be either
entities of the domain, events, or states of affairs. entities correspond to people, places,
things, and time intervals of the domain and arise from noun phrases. events (who did what
to whom) and states of affairs (properties of entities) may be described in clauses. the
discourse module constructs event objects corresponding to relevant events in the message.
thereby, it must infer indirect relations not explicitly found by the interpreter and resolve
any references in the text. the template generator then uses the structures created by the
discourse module to generate the    nal templates.

proteus

proteus [40] is a core extraction engine consisting of seven modules (see figure 3.1): (1)
lexical analysis, (2) name recognition, (3) partial syntactical analysis, (4) scenario pattern
analysis, (5) reference resolution, (6) discourse analysis, and (7) output generation.

the lexical analysis module splits the document into sentences and tokens. each to-
ken is assigned a reading using dictionaries. optionally, a parts-of-speech tagger can be
invoked to eliminate unlikely readings from tokens. the name recognition, partial syn-
tax, and scenario patterns modules use deterministic, bottom-up, partial parsing, or pattern
matching. patterns are id157. patterns for name recognition identify proper
names. the partial syntax module    nds noun phrases and verb phrases. the scenario pat-
terns module    nds higher-level syntactic constructions. the reference resolution module
links anaphoric pronouns o their antecedents and merges other co-referring expressions.
the discourse analysis module builds more complex event structures using higher-level in-
ference rules. thereby, several clauses contain information about a single complex fact. the

11

figure 3.1: proteus system architecture.

template generation module performs a transformation of the gathered information into the
   nal template structure.

the pattern acquisition consists of several steps. first, the user enters a sentence con-
taining an event and selects an event template from a list of events. then, the system applies
applies current patterns to the example to obtain an initial analysis. thereby, it identi   es
noun/verb groups and their semantic types and applies a minimal generalization. the sys-
tem presents the result to the user, who can modify each pattern element (e.g., choose the
appropriate level of generalization, make the element optional, remove it). the user has then
to specify how pattern elements are used to    ll slots in the event template. now the system
builds a new pattern to match the example and compiles the associated action, which will
   re when the pattern matches and will    ll the slots of the event template. the new pattern
is added to the pattern base.

3.2 automatic pattern discovery in ie systems

due to the cumbersome and time-consuming manual generation of extraction rules accom-
plished by knowledge engineers, research has been directed towards automating this task.
therefore, two approaches can be applied: (1) supervised learning, where a large set of
training data is required to learn the rules using machine learning techniques, and (2) un-
supervised learning, where rules are learned by a small set of seed rules and an annotated
corpus using id64 methods.

3.2.1 supervised

supervised learning uses training data to induce extraction rules. thereby, almost no knowl-
edge about the domain is necessary, but a large set of training data has to be annotated
according to the underlying structure of information to be extracted.

autoslog

autoslog [32] was the    rst system to learn text extraction rules from training examples.
it extracts a domain-speci   c dictionary of concept nodes for extracting information from

12

table 3.1: sample of autoslog heuristics.

linguistic pattern
<subject>passive-verb
<subject>active-verb
<subject>verb in   nitive
<subject>auxiliary noun

passive-verb <direct-object>
active-verb <direct-object>
in   nitive <direct-object>
...

text. a concept node is a rules which includes a    trigger    word or words and a semantic
constraint. if the system    nds the trigger in the text and the concept node   s conditions are
satis   ed, the concept node is activated and the concept node de   nition is extracted from the
context.

the system identi   es a sentence annotated with a slot    ller and semantic tag. then, it
looks up its list of heuristics (for samples see table 3.1) and sees if any of the heuristics
match the part of the sentence containing the slot    ller.

each heuristic handles only a single-slot extraction. autoslog also uses a semantic
tagger and semantic constraints in the extraction rule; it does not merge similar concept
nodes and handles only free text.

palka

the palka system [20] uses an induction method similar to mitchell   s candidate elim-
ination algorithm [28]. it produces the extraction rule as a pair of a meaning frame and
a phrasal pattern, called frame-phrasal pattern structure (fp-structure). if existing rules
cannot be applied, palka creates a new rule and tries to generalize it with existing ones to
include a new positive instance. it specializes existing rules to avoid a negative instance if
it generates the wrong interpretation when applying existing rules.

crystal

the crystal system [37] takes texts, which are processed by a syntactic parser. it needs
training documents annotated by a domain expert, as well as a semantic hierarchy. crys-
tal starts learning by creating the extraction rules for each instance of the target event in
the training data. using inductive learning it    nds the most similar pair or rules and merges
them together by    nding the most restrictive constraints that cover both rules.

liep

the liep system [19] uses heuristics in a manner similar to autoslog, but learns multi-
slot rules and cannot handle single slot extraction. it allows a user to interactively identify

13

events in text, based on the assumption that a large annotated training corpus is hard to
obtain. for each potential training sentence, entities of interest (e.g., people, companies,
etc.) are identi   ed.

liep tries to choose extraction patterns that will maximize the number of extractions of
positive examples and minimize spurious extractions. if a new example cannot be matched
by a known pattern, liep attempts to generalize a known pattern to cover the example. if
the generalization is not possible or the resulting pattern decreases the quality, a new pattern
is constructed.

whisk

the whisk system [36] uses machine learning algorithms known as covering algorithms.
whisk uses a covering algorithm to induce id157 in a top-down induc-
tion. it begins with the most general rule and continues by progressively specializing the
available rules. the process stops when a set of rules is generated covering all positive
training examples. afterwards, post-pruning is achieved to remove rules that generate over-
   tting.

rapier

the rapier2 system [7] uses pairs of sample documents and    lled templates to induce
pattern-match rules that directly extract    llers for the slots of the template. it employes
a bottom-up learning algorithm in order to limit search without imposing arti   cial limits
on the constants to be considered, and in order to prefer high precision by preferring more
speci   c rules. pairs of rules are randomly chosen and a id125 is achieved to    nd
the best generalization of the two rules, taking a least general generalization (lgg), then
adding constraints until the proposed rule operates correctly on the training data. rapier
can only handle single-slot extraction on semi-structured text.

gate

gate [14] is a framework and graphical development environment which enables users to
develop and deploy language engineering components and resources. a set of reusable pro-
cessing resources is packed together to annie, a nearly-new ie system. these processing
resources can be used individually or coupled together with new modules.

annie consists of a tokeniser, a sentence splitter, a pos tagger, a gazetteer, a    nite
state transducer, an orthomatcher, and a coreferencer. the tokeniser splits text into tokens
(i.e., numbers, punctuation, symbols, and words of different types). the sentence splitter
segments the text into sentences, which are the input of the tagger. it produces a parts-
of-speech tag as an annotation on each word or symbol. the gazetteer consists of lists of
cities, organizations, days of the week, and so on. the semantic tagger consists of hand-
crafted rules, which describe patterns to match and annotations to be created as a result. the
orthomatcher performs co-reference, or entity tracking, by recognizing relations between
entities. the coreferencer    nds identity relations between entities in the text.

gate provides easy-to-use and extendable facilities for text annotation to annotate re-
quired training data for nlp algorithms. the annotation can be done manually by the
user or semi-automatically by running some processing resources over the corpus and then

2robust automated production of information extraction rules

14

correcting and adding new annotations manually. depending on the information to be an-
notated, some annie modules can be used or adapted to bootstrap the corpus annotation
task.

gate addresses the complete range of issues in nlp application development in a

   exible and extensible way. it promotes robustness, re-usability, and scalability.

discussion

the main bottleneck of supervised ie systems is the preparation of the training data. most
systems need a large amount of annotated documents for a particular extraction task, which
also leads to the lack of portability of an ie system.

3.2.2 unsupervised

unsupervised learning systems reduce the burden of the user to require only a statement of
the required information. no extraction patterns are given in advance by the user. the main
challenge is to realize the user   s need into a set of the extraction patterns. the systems are
based on id64 methods, expanding an initial small set of extraction patterns.

autoslog-ts

autoslog-ts [33] is an extension of autoslog [32]. autoslog-ts (cp. figure 3.2) needs
only a corpus pre-classi   ed with respect to each document   s relevance to the task of inter-
est. it generates extraction patterns for every noun phrase in the training corpus by means of
heuristics. a major extension to autoslog is that it allows multiple rules to    re if more than
one matches the context and thus multiple extraction patterns may be generated. statistics
will reveal which pattern is needed to be reliable for the domain. in a second stage these pat-
terns are evaluated. thereby, it processes the corpus a second time and generates relevance
statistics for each pattern by which the extraction patterns are ranked.

figure 3.2: autoslog-ts    owchart.

15

mutual id64

riloff and jones [35] propose a co-training algorithm using mutual id64 for lexical
discovery. lexicons and extraction patterns are thereby used as separate features. mutual
id64 is used due to the assumption that a good pattern can    nd a good lexicon and
a good lexicon can    nd a good pattern.

given a handful of lexical entries as initial data, patterns are discovered that extract the
initial lexicon. the extracted patterns are ranked and the most reliable are used to extract
more lexical items.

a strong limitation of mutual id64 is that a minor error can cause a large
amount of errors during the following iteration. a touching up was introduced by meta-
id64. thereby, each iteration takes only the    ve best noun phrases for adding to
the extracted lexicons.

exdisco

exdisco [41] also applies a mutual id64 strategy. it is based on the assumption
that the presence of relevant documents indicates good patterns and good patterns can    nd
relevant documents.

given an unannotated corpus and a handful of seed patterns, the document set is divided
into a relevant document set containing at least one instance of patterns and a non-relevant
document set not containing any seed patterns. now candidate patterns are generated from
the clauses in the documents and ranked in correlation with the relevant documents. the
highest pattern is added to the pattern set and each document is re-ranked using the newly
obtained pattern set. again, the entire document set is split into relevant and non-relevant
and the system keeps iterating.

snowball

the snowball [1] system is based on dual iterative pattern expansion (dipre) algorithm
[6]. dipre is similar to co-training and works well on data with two distinct features, each
of which can independently distinguish the class of instances from the other.

figure 3.3: main components of snowball.

figure 3.3 shows the main components of the snowball system. given a handful of
initial relation instances and a general regular expression that the entities must match,
snowball generates patterns from text documents. a key improvement from dipre is that
snowball   s patterns include named-entity tags (e.g., <location>-based <organiza-
tion> instead of <string1>-based <string2>). snowball patterns are generated by
id91 similar tuples using a simple single-pass id91 algorithm.

16

after generating patterns, the system discovers new tuples that match the patterns in
a certain degree. each candidate tuple will then have a number of patterns that helped
generate it associated with a degree of match. this information helps snowball to decide
what candidate tuples to add to the    nal template.

qdie

the query-driven information extraction (qdie) framework [38] tries to minimize human
intervention by using a set of keywords as input. it parses the documents by a dependency
parser and a named entity tagger and retrieves relevant documents speci   ed by the user   s
query. dependency trees of the sentences are used for pattern extraction. each dependency
subtree of a sentence that con   rms to the pattern model becomes a pattern candidate. qdie
calculates the relevance score for each pattern candidate using tf/idf scoring in ir literature.
a pattern is more relevant the more it appears in the relevant document set and less across
the entire document set.

qdie uses the subtree model, a generalization of the predicate-argument model [41]
and the chain model [39], such that any subtree of a dependency tree in a source sentence
can be regarded as an extraction pattern candidate.

discussion

the development of unsupervised ie systems arose from the high costs for annotating train-
ing documents for supervised learning. autoslog-ts [33] only takes a corpus pre-classi   ed
for relevancy as initial input, as the classi   cation of documents is a far easier task than
annotating a large amount of training data.

a drawback of id64-based systems is that a minor error can cause a large
amount of errors during iteration, often caused by polysemous words and phrases. to reduce
the degree of polysemous patterns an named-entity constraint can be implemented, which
will increase the amount of pattern.

3.3 semi-automatic wrapper generation

in semi-automatic wrapper generation machine learning approaches are applied. tools
may support the design of the wrapper. some approaches offer a declarative interface where
the user shows the system what information to extract.

wien

wien (wrapper induction environment) [24, 22] is designed for automatically learning of
web pages and is strongly in   uenced by shopbot. it works on structured text containing
tabular information.

wien looks for uniform delimiters that identify the beginning and end of each slot and

for delimiters separating the tabular information from the surrounding text.

in order to automate wrapper construction as much as possible and thereby avoiding to
manually labeling training data, a set of techniques for automatic labeling has been devel-
oped. the labeling algorithm takes a set of heuristics for recognizing instances of attributes
to be extracted as input, whereas it is not concerned in the way they are obtained.

wrapper induction uses a bottom-up induction algorithm, which takes a set of labeled
pages as input. wien uses only delimiters immediately preceding and following the data

17

to be extracted. it cannot wrap sources in which some items are missing or sources where
items may appear in a varying order.

softmealy

softmealy [18] is based on non-deterministic    nite state automata (ndfa). it uses a bottom-
up inductive learning algorithm to produce extraction rules using labeled training pages. it
can deal with missing values and is able to handle permutations of values if the training set
includes all possible permutations.

stalker

stalker [30] is a hierarchical wrapper induction algorithm. it transforms complex docu-
ments into a series of simpler extraction tasks handling both missing data and permutations
of values.

web documents are described by embedded catalog (ec) trees. given the ec and a
set of extraction rules stalker is able to extract the data. to induce the extraction rules a
user marks up relevant data on sample pages and stalker applies a sequential covering
algorithm for rule induction. thereby, stalker starts generating a rule that covers as
many positive examples as possible. then it tries to create another rule for the remaining
examples, and so on. this procedure is accomplished until all examples are covered. after
having a list of rules it re   nes the rules and creates a disjunctive rule to cover all examples.
stalker handles only single-slot extraction, but requires a fewer set of training ex-

amples than other algorithms.

lixto

lixto [5] (figure 3.4) is a declarative wrapper program for supervised wrapper gener-
ation and automated web information extraction. the system assists the user to semi-
automatically create wrappers by providing a visual and interactive user interface. it pro-
vides a    exible hierarchical extraction pattern de   nition and deals with various kinds of
conditions, such as contextual, internal, and range conditions, prede   ned concepts, refer-
ences to other user-de   ned patterns, or comparison conditions.

the generated wrappers are relatively stable and easy to update. the de   nition of ex-
traction patterns works on both the tree structure of the document and    at strings (i.e.,
id157). the rules are presented in an internal rule language named elog,
whereas the wrapper designer does not deal with elog. the wrapper designer can label
instances directly on the web page and no working inside the html source or the tree
representation is necessary.

xwrap

xwrap [26] is a semi-automatic wrapper generation framework. it consists of four com-
ponents (figure 3.5) for data wrapping: syntactical structure id172, information
extraction, code generation, and testing and packing.

the information extraction component derives extraction rules using declarative spec-
i   cation to describe how to extract information content of interest from its html format-
ting.
it performs this task in three steps: (1) identifying interesting regions in retrieved
documents, (2) identifying important semantic tokens and their logical paths and node po-
sitions in the parse tree, and (3) identifying useful hierarchical structures of the retrieved

18

figure 3.4: overview of the lixto system.

figure 3.5: the xwrap system architecture.

19

document. each step results in a set of extraction rules speci   ed in declarative languages
which are used by the code generation component to generate the wrapper program code.

3.4 automatic wrapper generation

automatic wrapper generation tools use unsupervised learning techniques. therefore, no
training sets are necessary, but a post-generation tuning.

shopbot

shopbot [15] is a domain-independent comparison-shopping agent. shopbot autonomously
learns how to shop at vendors given the home pages of several on-line stores. it relies on
a combination of heuristic search, pattern matching, and inductive learning techniques and
does not need to apply sophisticated natural language processing.

shopbot operates in two phases: the learning phase, which is performed off   ine, and
the online comparison-shopping phase. during the learning phase the learner module (see
figure 3.6) automatically generates symbolic vendor descriptions of each site. together
with the domain description this is all the knowledge required by the comparison-shopping
phase for    nding products at this vendor.

figure 3.6: shopbot learner module.

to learn the vendor description three components, which strongly interdepend, have to
be considered: (1) identifying an appropriate search form, (2) determining how to    ll in the
form, and (3) distinguish the format of product descriptions from the resulting page.

first, the module searches for a set of candidate forms and computes an estimate for
each form of how successful the comparison-shopping phase would be if the particular form
were chosen by the learner. the estimation is done by    lling the form and making several
test queries using the form to search for several popular products. the test queries    results
provide training examples from which the learner induces the format of product descriptions
in the result pages from the used form as well as to compute the estimate measure for the
form. after obtaining estimates for all forms, the learner picks up the form with the best

20

estimate and records the vendor description, how to    ll the form, and the result pages of the
form.

roadrunner

roadrunner [13, 12] is based on an unsupervised learning algorithm. its goal is to auto-
matically extract data from web sources by exploiting similarities in page structure across
multiple pages. roadrunner works by inducing the grammar of web pages by comparing
several pages containing long lists of data. its grammar is expressed at the html tag level.
roadrunner works well on data-intensive sites.

given a set of sample html pages belonging to the same class, the nested type of the
source dataset is found. the system compares the html codes of the pages and infers a
common structure and a wrapper. these are used to extract the source dataset.

iepad

iepad (information extraction based on pattern discovery) [8] processes semi-structured
texts by means of unsupervised inductive learning. it is more expressive than wien (cp.
section 3.3) and discovers extraction patterns from web pages without user-labeled exam-
ples. iepad applies several pattern discovery techniques such as pat trees, multiple string
alignments, and pattern matching algorithms. its extraction rules are pattern-based instead
of delimiter-based and it can handle exceptions such as missing attributes, multiple attribute
values, and variant attribute permutations.

21

chapter 4

conclusions

research and development concerning information extraction started emerging in the late
1980ies. research has been focused through the muc conferences, which have also fo-
cused on the evaluation of ie systems and the de   nition of id74.

documents on which ie is applied can be structured, semi-structured, or unstructured.
unstructured documents (i.e., free text) require natural language processing techniques.
documents containing semi-structured and structured data, which hardly contain full gram-
matical sentences, require delimiter-based techniques that can better analyze the document   s
structure.

constructing ie systems or wrappers, which are tailored to extract information from
web pages, is often cumbersome and labor-intensive. both ie systems and wrappers can
be generated manually, semi-automatically, or automatically. manual pattern discovery and
rule generation demand for a skilled knowledge engineer who is familiar with both the
requirements of the application domain and the function of the ie system. semi-automatic
rule generation requires a large set of training data. this is used to derive the extraction
rules by machine learning algorithms. as the costs for obtaining the training data sets
are very high research has been directed towards automatic rule generation by means of
unsupervised learning methods. these are based on id64 methods that need only
an initial small set of extraction patterns to learn the required rules.

application areas for ie and wrapper generation systems are manifold and diversi   ed.
in the area of commercial systems comparison-shopping is vitally important. there, prod-
uct information pages from different online vendors are fetched, relevant information is
extracted and presented in a uni   ed list to the user.

in the future, research will strongly focus on automatic learning to handle a large amount

of dynamic documents, whereby the systems need to be    exible and scalable.

22

acknowledgements

this work is supported by    fonds zur f  orderung der wissenschaftlichen forschung fwf   
(austrian science fund), grant p15467-inf.

23

bibliography

[1] e. agichtein and l. gravano. snowball: extracting relations from large plaintext
collections. in proceedings of the 5th acm international conference on digital li-
braries, 2000.

[2] d. e. appelt. introduction to information extraction. ai communications, 12:161   

172, 1999.

[3] d. e. appelt, j. hobbs, j. bear, d. israel, and m. tyson. fastus: a    nite-state
processor for information extraction from real world text. in proceedings of the 13th
international joint conference on arti   cial intelligence, pages 1172   1178, 1993.

[4] d. ayuso, s. boisen, h. fox, h. gish, r. ingria, and r. weischedel. bbn: description
in proceedings of the fourth message

of the plum system as used for muc-4.
understanding conference (muc-4), pages 169   176, 1992.

[5] r. baumgartner, s. flesca, and g. gottlob. visual web information extraction with

lixto. in proceedings of the conference on very large databases (vldb), 2001.

[6] s. brin. extracting patterns and relations from the world wide web. in webdb work-
shop at 6th international conference on extended database technology, edbt   98,
1998.

[7] m. e. califf and r. j. mooney. relational learning of pattern-match rules for in-
in proceedings of the 16th national conference on arti   cial

formation extraction.
intelligence (aaai-99), pages 328   334, orlando, fl, july 1999.

[8] c.-h. chang, c.-n. hsu, and s.-c. lui. automatic information extraction from semi-
structured web pages by pattern discovery. decision support systems, special issue
on web retrieval and mining, 35(1):129   147, april 2003.

[9] b. chidlovskii. automatic repairing of web wrappers.

in proceeding of the third
international workshop on web information and data management, pages 24   30,
atlanta, georgia, usa, 2001.

[10] b. chidlovskii, u. borghoff, and p. chevalier. towards sophisticated wrapping of
web-based information repositories. in proceedings of the conference of computer-
assisted information retrieval, pages 123   135, 1997.

[11] m. collins and y. singer. unsupervised models for named entity classi   cation. in pro-
ceedings of the joint sigdat conference on empirical methods in natural language
processing, pages 100   110, 1999.

24

[12] v. crescenzi, g. mecca, and p. merialdo. automatic web information extraction in
the roadrunner system. in international workshop on data semantics in web infor-
mation systems (daswis-2001) in conjunction with 20th international conference on
conceptual modeling (er 2001), 2001.

[13] v. crescenzi, g. mecca, and p. merialdo. roadrunner: towards automatic data extrac-
tion from large web sites. in proceedings of the conference on very large databases
(vldb   01), pages 109   118, 2001.

[14] h. cunningham, d. maynard, k. bontcheva, and v. tablan. gate: a framework
and graphical development environment for robust nlp tools and applications.
in
proceedings of the 40th anniversary meeting of the association for computational
linguistics (acl   02), philadelphia, july 2002.

[15] r. b. doorenbos, o. etzioni, and d. s. weld. a scalable comparison-shopping agent
for the world-wide web. in w. l. johnson and b. hayes-roth, editors, proceedings of
the first international conference on autonomous agents (agents   97), pages 39   48,
marina del rey, ca, usa, 1997. acm press.

[16] m. hearst. what

is id111.

http://www.sims.berkeley.edu/  hearst/text-

mining.html, 2004.

[17] j. r. hobbs, d. appelt, m. tyson, j. bear, and d. islael. sri international: descrip-
in proceedings fo the 4th message

tion of the fastus system used for muc-4.
understanding conference (muc-4), pages 268   275, 1992.

[18] c. n. hsu and m. t. dung. wrapping semistructured web pages with    nite-state
transducers. in proceedings of the conference on automatic learning and discovery,
1998.

[19] s. b. huffman. learning information extraction patterns from examples. in lecture
notes in computer science. connectionist, statistical, and symbolic approaches to
learning for natural language processing, volume 1040, pages 246   260, london,
uk, 1996. springer verlag.

[20] j.-t. kim and d. i. moldovan. acquisition of linguistic patterns for knowledge-based
ieee transactions on knowledge and data engineering,

information extraction.
7(5):713   724, october 1995.

[21] g. krupka, p. jacobs, l. rau, l. childs, and i. sider. ge nltoolset: description
of the system as used for muc-4. in proceedings of the 4th message understanding
conference (muc-4), pages 177   185, 1992.

[22] n. kushmerick. wrapper induction for information extraction. phd thesis, university

of washington, 1997.

[23] n. kushmerick. wrapper induction: ef   ciency and expressiveness. arti   cial intelli-

gence, 118(1-2):15   68, 2000.

[24] n. kushmerick, d. s. weld, and r. doorenbos. wrapper induction for information
extraction. in proceedings of international joint conference on arti   cial intelligence
(ijcai-97), nagoya, 1997.

25

[25] w. lehnert, c. cardie, d. fisher, j. mccarthy, e. riloff, and s. soderland. evaluating
an information extraction system. journal of integrated computer-aided engineer-
ing, 1(6), 1994.

[26] l. liu, c. pu, and w. han. xwrap: an xml-enabled wrapper construction system
in intern. conference on data engineering (icde),

for web information sources.
pages 611   621, 2000.

[27] j. mccarthy and w. lehnert. using id90 for coreference resolution. in pro-
ceedings of the 14th international joint conference on arti   cial intelligence, pages
1050   1055, 1995.

[28] t. m. mitchell. version spaces: a candidate elimination approach to rule learning.
in proceedings of the 5th international joint conference on arti   cial intelligence
(ijcai-77), pages 305   310, cambridge, ma, august 1977.

[29] i. muslea, s. minton, and c. knoblock. a hierarchical approach to wrapper induction.
in o. etzioni, j. p. m  uller, and j. m. bradshaw, editors, proceedings of the third
international conference on autonomous agents (agents   99), pages 190   197, seattle,
wa, usa, 1999. acm press.

[30] i. muslea, s. minton, and c. a. knoblock. hierarchical wrapper induction for
semistructured information sources. autonomous agents and multi-agent systems,
4(1/2):93   114, 2001.

[31] l. peshkin and a. pfeffer. bayesian information extraction network. in proc. of the

18th international joint conference on arti   cial intelligence (ijcai), 2003.

[32] e. riloff. automatically constructing a dictionary for information extraction tasks. in
proc. of the 11th national conference on arti   cial intelligence, pages 811   816, 1993.

[33] e. riloff. automatically generating extraction patterns from untagged text. in pro-
ceedings of the thirteenth national conference on arti   cial intelligende (aaai-96),
pages 1044   1049, 1996.

[34] e. riloff. an empirical study of automated dictionary construction for information

extraction in three domains. arti   cial intelligence, 85(1-2):101   134, 1996.

[35] e. riloff and r. jones. learning dictionaries for information extraction by multi-
in proceedings of the 16th national conference on arti   cial

level id64.
intelligence, pages 474   479. aaai press/mit press, 1999.

[36] s. soderland. learning information extraction rules for semi-structured and free

text. machine learning, 34(1-3):233   272, 1999.

[37] s. soderland, d. fisher, j. aseltine, and w. lehnert. crystal: inducing a concep-
tual dictionary. in proceedings of the fourteenth international joint conference on
arti   cial intelligence (ijcai   95), pages 1314   1319, 1995.

[38] k. sudo. unsupervised discovery of extraction patterns for information extraction.

phd thesis, new york university, new york, september 2004.

[39] k. sudo, s. sekine, and r. grishman. automatic pattern acquisition for japanese
information extraction. in proceedings of human language technology conference
(hlt2001), san diego, ca, 2001.

26

[40] r. yangarber and r. grishman. nyu: description of the proteus/pet system as used
for muc-7 st. in proceedings of the 7th message understanding conference: muc-
7, washington, dc, 1998.

[41] r. yangarber, r. grishman, p. tapanainen, and s. huttunen. automatic acquisition
of domain knowledge for information extraction. in proceedings of the 18th interna-
tional conference on computational linguistics (coling 2000), saarbr  ucken, ger-
many, august 2000.

27

